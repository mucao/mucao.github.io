<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhongZhenGang&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-04T11:50:41.058Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhongzhengang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Math For Programmers</title>
    <link href="http://yoursite.com/2018/06/24/Math%20For%20Programmers/"/>
    <id>http://yoursite.com/2018/06/24/Math For Programmers/</id>
    <published>2018-06-24T12:02:36.000Z</published>
    <updated>2018-07-04T11:50:41.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Math-For-Programmers"><a href="#Math-For-Programmers" class="headerlink" title="Math For Programmers"></a><center>Math For Programmers</center></h1><p>I’ve been working for the past 15 months on repairing my rusty math skills, ever since I read a <a href="http://www.amazon.com/o/asin/0262011212" target="_blank" rel="noopener">biography</a> of <a href="http://en.wikipedia.org/wiki/Von_Neumann" target="_blank" rel="noopener">Johnny von Neumann</a>. I’ve read a huge stack of math books, and I have an even bigger stack of unread math books. And it’s starting to come together.  </p><p>Let me tell you about it. </p><h3 id="Conventional-Wisdom-Doesn’t-Add-Up"><a href="#Conventional-Wisdom-Doesn’t-Add-Up" class="headerlink" title="Conventional Wisdom Doesn’t Add Up"></a>Conventional Wisdom Doesn’t Add Up</h3><p>First: programmers don’t think they need to know math. I hear that so often; I hardly know anyone who disagrees. Even programmers who were math majors tell me they don’t really use math all that much! They say it’s better to know about design patterns, object-oriented methodologies, software tools, interface design, stuff like that. </p><p>And you know what? They’re absolutely right. You can be a good, solid, professional programmer without knowing much math. </p><p>But hey, you don’t really need to know how to program, either. Let’s face it: there are a lot of professional programmers out there who realize they’re not very good at it, and they still find ways to contribute. </p><p>If you’re suddenly feeling out of your depth, and everyone appears to be running circles around you, what are your options? Well, you might discover you’re good at project management, or people management, or UI design, or technical writing, or system administration, any number of other important things that “programmers” aren’t necessarily any good at. You’ll start filling those niches (because there’s always more work to do), and as soon as you find something you’re good at, you’ll probably migrate towards doing it full-time. </p><p>In fact, I don’t think you need to know <em>anything</em>, as long as you can stay alive somehow.   </p><p>So they’re right: you don’t need to know math, and you can get by for your entire life just fine without it.   </p><p>But a few things I’ve learned recently might surprise you: </p><ol><li>Math is a lot easier to pick up after you know how to program. In fact, if you’re a halfway decent programmer, you’ll find it’s almost a snap. </li><li>They teach math all wrong in school. Way, WAY wrong. If you teach yourself math the right way, you’ll learn faster, remember it longer, and it’ll be much more valuable to you as a programmer. </li><li>Knowing even a little of the right kinds of math can enable you do write some pretty interesting programs that would otherwise be too hard. In other words, math is something you can pick up a little at a time, whenever you have free time. </li><li>Nobody knows all of math, not even the best mathematicians. The field is constantly expanding, as people invent new formalisms to solve their own problems. And with any given math problem, just like in programming, there’s more than one way to do it. You can pick the one you like best. </li><li>Math is… ummm, please don’t tell anyone I said this; I’ll never get invited to another party as long as I live. But math, well… I’d better whisper this, so listen up: (it’s actually kinda fun.)</li></ol><h3 id="The-Math-You-Learned-And-Forgot"><a href="#The-Math-You-Learned-And-Forgot" class="headerlink" title="The Math You Learned (And Forgot)"></a>The Math You Learned (And Forgot)</h3><p>Here’s the math I learned in school, as far as I can remember:</p><p>Grade School: Numbers, Counting, Arithmetic, Pre-Algebra (“story problems”)</p><p>High School: Algebra, Geometry, Advanced Algebra, Trigonometry, Pre-Calculus (conics and limits)</p><p>College: Differential and Integral Calculus, Differential Equations, Linear Algebra, Probability and Statistics, Discrete Math</p><p>How’d they come up with that particular list for high school, anyway? It’s more or less the same courses in most U.S. high schools. I think it’s very similar in other countries, too, except that their students have finished the list by the time they’re nine years old. (Americans really kick butt at monster-truck competitions, though, so it’s not a total loss.)</p><p>Algebra? Sure. No question. You need that. And a basic understanding of Cartesian geometry, too. Those are useful, and you can learn everything you need to know in a few months, give or take. But the rest of them? I think an introduction to the basics might be useful, but spending a whole semester or year on them seems ridiculous.</p><p>I’m guessing the list was designed to prepare students for science and engineering professions. The math courses they teach in and high school don’t help ready you for a career in programming, and the simple fact is that the number of programming jobs is rapidly outpacing the demand for all other engineering roles.</p><p>And even if you’re planning on being a scientist or an engineer, I’ve found it’s much easier to learn and appreciate geometry and trig after you understand what exactly math is — where it came from, where it’s going, what it’s for. No need to dive right into memorizing geometric proofs and trigonometric identities. But that’s exactly what high schools have you do. </p><p>So the list’s no good anymore. Schools are teaching us the wrong math, and they’re teaching it the wrong way. It’s no wonder programmers think they don’t need any math: most of the math we learned isn’t helping us.</p><h3 id="The-Math-They-Didn’t-Teach-You"><a href="#The-Math-They-Didn’t-Teach-You" class="headerlink" title="The Math They Didn’t Teach You"></a>The Math They Didn’t Teach You</h3><p>The math computer scientists use regularly, in real life, has very little overlap with the list above. For one thing, most of the math you learn in grade school and high school is continuous: that is, math on the real numbers. For computer scientists, 95% or more of the interesting math is discrete: i.e., math on the integers. </p><p>I’m going to talk in a future blog about some key differences between computer science, software engineering, programming, hacking, and other oft-confused disciplines. I got the basic framework for these (upcoming) insights in no small part from Richard Gabriel’s <a href="http://www.amazon.com/o/asin/0195121236" target="_blank" rel="noopener">Patterns Of Software</a>, so if you absolutely can’t wait, go read that. It’s a good book.   </p><p>For now, though, don’t let the term “computer scientist” worry you. It sounds intimidating, but math isn’t the exclusive purview of computer scientists; you can learn it all by yourself as a closet hacker, and be just as good (or better) at it than they are. Your background as a programmer will help keep you focused on the practical side of things. </p><p>The math we use for modeling computational problems is, by and large, math on discrete integers. This is a generalization. If you’re with me on today’s blog, you’ll be studying a little more math from now on than you were planning to before today, and you’ll discover places where the generalization isn’t true. But by then, a short time from now, you’ll be confident enough to ignore all this and teach yourself math the way you want to learn it. </p><p>For programmers, the most useful branch of discrete math is probability theory. It’s the first thing they should teach you after arithmetic, in grade school. What’s probability theory, you ask? Why, it’s counting. How many ways are there to make a Full House in poker? Or a Royal Flush? Whenever you think of a question that starts with “how many ways…” or “what are the odds…”, it’s a probability question. And as it happens (what are the odds?), it all just turns out to be “simple” counting. It starts with flipping a coin and goes from there. It’s definitely the first thing they should teach you in grade school after you learn Basic Calculator Usage. </p><p>I still have my <a href="http://www.amazon.com/o/asin/0072930330" target="_blank" rel="noopener">discrete math textbook</a> from college. It’s a bit heavyweight for a third-grader (maybe), but it does cover a <em>lot</em> of the math we use in “everyday” computer science and computer engineering.  </p><p>Oddly enough, my professor didn’t tell me what it was for. Or I didn’t hear. Or something. So I didn’t pay very close attention: just enough to pass the course and forget this hateful topic forever, because I didn’t think it had anything to do with programming. That happened in quite a few of my comp sci courses in college, maybe as many as 25% of them. Poor me! I had to figure out what was important on my own, later, the hard way.</p><p>I think it would be nice if every math course spent a full week just introducing you to the subject, in the most fun way possible, so you know why the heck you’re learning it. Heck, that’s probably true for every course.</p><p>Aside from probability and discrete math, there are a few other branches of mathematics that are potentially quite useful to programmers, and they usually don’t teach them in school, unless you’re a math minor. This list includes: </p><ul><li><strong>Statistics</strong>, some of which is covered in my discrete math book, but it’s really a discipline of its own. A pretty important one, too, but hopefully it needs no introduction. </li><li><strong>Algebra</strong> and <strong>Linear Algebra</strong> (i.e., matrices). They should teach Linear Algebra immediately after algebra. It’s pretty easy, and it’s amazingly useful in all sorts of domains, including machine learning. </li><li><strong>Mathematical Logic</strong>. I have a really cool <a href="http://www.amazon.com/o/asin/0486425339" target="_blank" rel="noopener">totally unreadable book</a> on the subject by Stephen Kleene, the inventor of the Kleene closure and, as far as I know, Kleenex. Don’t read that one. I swear I’ve tried 20 times, and never made it past chapter 2. If anyone has a recommendation for a better introduction to this field, <em>please</em> post a comment. It’s obviously important stuff, though. </li><li><strong>Information Theory</strong> and <strong>Kolmogorov Complexity</strong>. Weird, eh? I bet <em>none</em> of your high schools taught either of those. They’re both pretty new. Information theory is (veeery roughly) about data compression, and Kolmogorov Complexity is (also roughly) about algorithmic complexity. I.e., how small you can you make it, how long will it take, how elegant can the program or data structure be, things like that. They’re both fun, interesting and useful.</li></ul><p>There are others, of course, and some of the fields overlap. But it just goes to show: the math that you’ll find useful is pretty different from the math your school thought would be useful. </p><p>What about calculus? Everyone teaches it, so it must be important, right? </p><p>Well, calculus is actually pretty easy. Before I learned it, it sounded like one of the hardest things in the universe, right up there with quantum mechanics. Quantum mechanics is still beyond me, but calculus is nothing. After I realized programmers can learn math quickly, I picked up my <a href="http://www.amazon.com/o/asin/0471381578" target="_blank" rel="noopener">Calculus textbook</a> and got through the entire thing in about a month, reading for an hour an evening.  </p><p>Calculus is all about continuums — rates of change, areas under curves, volumes of solids. Useful stuff, but the exact details involve a lot of memorization and a lot of tedium that you don’t normally need as a programmer. It’s better to know the overall concepts and techniques, and go look up the details when you need them.</p><p>Geometry, trigonometry, differentiation, integration, conic sections, differential equations, and their multidimensional and multivariate versions — these all have important applications. It’s just that you don’t need to know them right this second. So it probably wasn’t a great idea to make you spend years and years doing proofs and exercises with them, was it? If you’re going to spend that much time studying math, it ought to be on topics that will remain relevant to you for life. </p><h3 id="The-Right-Way-To-Learn-Math"><a href="#The-Right-Way-To-Learn-Math" class="headerlink" title="The Right Way To Learn Math"></a>The Right Way To Learn Math</h3><p>The right way to learn math is breadth-first, not depth-first. You need to survey the space, learn the names of things, figure out what’s what. </p><p>To put this in perspective, think about long division. Raise your hand if you can do long division on paper, right now. Hands? Anyone? I didn’t think so. </p><p>I went back and looked at the long-division algorithm they teach in grade school, and damn if it isn’t annoyingly complicated. It’s deterministic, sure, but you never have to do it by hand, because it’s easier to find a calculator, even if you’re stuck on a desert island without electricity. You’ll still have a calculator in your watch, or your dental filling, or something. </p><p>Why do they even teach it to you? Why do we feel vaguely guilty if we can’t remember how to do it? It’s not as if we need to know it anymore. And besides, if your life were on the line, you know you could perform long division of any arbitrarily large numbers. Imagine you’re imprisoned in some slimy 3rd-world dungeon, and the dictator there won’t let you out until you’ve computed 219308862/103503391. How would you do it? Well, easy. You’d start subtracting the denominator from the numerator, keeping a counter, until you couldn’t subtract it anymore, and that’d be the remainder. If pressed, you could figure out a way to continue using repeated subtraction to estimate the remainder as decimal number (in this case, 0.1185678219, or so my Emacs ==M-x calc== tells me. Close enough!) </p><p>You could figure it out because you know that division is just repeated subtraction. The intuitive notion of division is deeply ingrained now. </p><p>The right way to learn math is to ignore the actual algorithms and proofs, for the most part, and to start by learning a little bit about all the techniques: their names, what they’re useful for, approximately how they’re computed, how long they’ve been around, (sometimes) who invented them, what their limitations are, and what they’re related to. Think of it as a Liberal Arts degree in mathematics. </p><p>Why? Because the first step to applying mathematics is problem identification. If you have a problem to solve, and you have no idea where to start, it could take you a long time to figure it out. But if you know it’s a differentiation problem, or a convex optimization problem, or a boolean logic problem, then you at least know where to start looking for the solution. </p><p>There are lots and lots of mathematical techniques and entire sub-disciplines out there now. If you don’t know what combinatorics is, not even the first clue, then you’re not very likely to be able to recognize problems for which the solution is found in combinatorics, are you? </p><p>But that’s actually great news, because it’s easier to read about the field and learn the names of everything than it is to learn the actual algorithms and methods for modeling and computing the results. In school they teach you the Chain Rule, and you can memorize the formula and apply it on exams, but how many students really know what it “means”? So they’re not going to be able to know to apply the formula when they run across a chain-rule problem in the wild. Ironically, it’s easier to know what it is than to memorize and apply the formula. The chain rule is just how to take the derivative of “chained” functions — meaning, function x() calls function g(), and you want the derivative of x(g()). Well, programmers know all about functions; we use them every day, so it’s much easier to imagine the problem now than it was back in school. </p><p>Which is why I think they’re teaching math wrong. They’re doing it wrong in several ways. They’re focusing on specializations that aren’t proving empirically to be useful to most high-school graduates, and they’re teaching those specializations backwards. You should learn how to count, and how to program, before you learn how to take derivatives and perform integration. </p><p>I think the best way to start learning math is to spend 15 to 30 minutes a day surfing in Wikipedia. It’s filled with articles about thousands of little branches of mathematics. You start with pretty much any article that seems interesting (e.g. <a href="http://en.wikipedia.org/wiki/String_theory" target="_blank" rel="noopener">String theory</a>, say, or the <a href="http://en.wikipedia.org/wiki/Fourier_transform" target="_blank" rel="noopener">Fourier transform</a>, or <a href="http://en.wikipedia.org/wiki/Tensor" target="_blank" rel="noopener">Tensors</a>, anything that strikes your fancy. Start reading. If there’s something you don’t understand, click the link and read about it. Do this recursively until you get bored or tired.  </p><p>Doing this will give you amazing perspective on mathematics, after a few months. You’ll start seeing patterns — for instance, it seems that just about every branch of mathematics that involves a single variable has a more complicated multivariate version, and the multivariate version is almost always represented by matrices of linear equations. At least for applied math. So Linear Algebra will gradually bump its way up your list, until you feel compelled to learn how it actually works, and you’ll download a PDF or buy a book, and you’ll figure out enough to make you happy for a while. </p><p>With the Wikipedia approach, you’ll also quickly find your way to the <a href="http://en.wikipedia.org/wiki/Foundations_of_mathematics" target="_blank" rel="noopener">Foundations of Mathematics</a>, the Rome to which all math roads lead. Math is almost always about formalizing our “common sense” about some domain, so that we can deduce and/or prove new things about that domain. Metamathematics is the fascinating study of what the limits are on math itself: the intrinsic capabilities of our formal models, proofs, axiomatic systems, and representations of rules, information, and computation.   </p><p>One great thing that soon falls by the wayside is notation. Mathematical notation is the biggest turn-off to outsiders. Even if you’re familiar with summations, integrals, polynomials, exponents, etc., if you see a thick nest of them your inclination is probably to skip right over that sucker as one atomic operation. </p><p>However, by surveying math, trying to figure out what problems people have been trying to solve (and which of these might actually prove useful to you someday), you’ll start seeing patterns in the notation, and it’ll stop being so alien-looking. For instance, a summation sign (capital-sigma) or product sign (capital-pi) will look scary at first, even if you know the basics. But if you’re a programmer, you’ll soon realize it’s just a loop: one that sums values, one that multiplies them. Integration is just a summation over a continuous section of a curve, so that won’t stay scary for very long, either. </p><p>Once you’re comfortable with the many branches of math, and the many different forms of notation, you’re well on your way to knowing a lot of useful math. Because it won’t be scary anymore, and next time you see a math problem, it’ll jump right out at you. “Hey,” you’ll think, “I recognize that. That’s a multiplication sign!”</p><p>And then you should pull out the calculator. It might be a very fancy calculator such as R, Matlab, Mathematica, or a even C library for support vector machines. But almost all useful math is heavily automatable, so you might as well get some automated servants to help you with it. </p><h3 id="When-Are-Exercises-Useful"><a href="#When-Are-Exercises-Useful" class="headerlink" title="When Are Exercises Useful?"></a>When Are Exercises Useful?</h3><p>After a year of doing part-time hobbyist catch-up math, you’re going to be able to do a lot more math in your head, even if you never touch a pencil to a paper. For instance, you’ll see polynomials all the time, so eventually you’ll pick up on the arithmetic of polynomials by osmosis. Same with logarithms, roots, transcendentals, and other fundamental mathematical representations that appear nearly everywhere. </p><p>I’m still getting a feel for how many exercises I want to work through by hand. I’m finding that I like to be able to follow explanations (proofs) using a kind of “plausibility test” — for instance, if I see someone dividing two polynomials, I kinda know what form the result should take, and if their result looks more or less right, then I’ll take their word for it. But if I see the explanation doing something that I’ve never heard of, or that seems wrong or impossible, then I’ll dig in some more. </p><p>That’s a lot like reading programming-language source code, isn’t it? You don’t need to hand-simulate the entire program state as you read someone’s code; if you know what approximate shape the computation will take, you can simply check that their result makes sense. E.g. if the result should be a list, and they’re returning a scalar, maybe you should dig in a little more. But normally you can scan source code almost at the speed you’d read English text (sometimes just as fast), and you’ll feel confident that you understand the overall shape and that you’ll probably spot any truly egregious errors. </p><p>I think that’s how mathematically-inclined people (mathematicians and hobbyists) read math papers, or any old papers containing a lot of math. They do the same sort of sanity checks you’d do when reading code, but no more, unless they’re intent on shooting the author down. </p><p>With that said, I still occasionally do math exercises. If something comes up again and again (like algebra and linear algebra), then I’ll start doing some exercises to make sure I really understand it. </p><p>But I’d stress this: don’t let exercises put you off the math. If an exercise (or even a particular article or chapter) is starting to bore you, move on. Jump around as much as you need to. Let your intuition guide you. You’ll learn much, much faster doing it that way, and your confidence will grow almost every day. </p><h3 id="How-Will-This-Help-Me"><a href="#How-Will-This-Help-Me" class="headerlink" title="How Will This Help Me?"></a>How Will This Help Me?</h3><p>Well, it might not — not right away. Certainly it will improve your logical reasoning ability; it’s a bit like doing exercise at the gym, and your overall mental fitness will get better if you’re pushing yourself a little every day. </p><p>For me, I’ve noticed that a few domains I’ve always been interested in (including artificial intelligence, machine learning, natural language processing, and pattern recognition) use a lot of math. And as I’ve dug in more deeply, I’ve found that the math they use is no more difficult than the sum total of the math I learned in high school; it’s just different math, for the most part. It’s not harder. And learning it is enabling me to code (or use in my own code) neural networks, genetic algorithms, bayesian classifiers, clustering algorithms, image matching, and other nifty things that will result in cool applications I can show off to my friends. </p><p>And I’ve gradually gotten to the point where I no longer break out in a cold sweat when someone presents me with an article containing math notation: n-choose-k, differentials, matrices, determinants, infinite series, etc. The notation is actually there to make it easier, but (like programming-language syntax) notation is always a bit tricky and daunting on first contact. Nowadays I can follow it better, and it no longer makes me feel like a plebian when I don’t know it. Because I know I can figure it out.</p><p>And that’s a good thing. </p><p>And I’ll keep getting better at this. I have lots of years left, and lots of books, and articles. Sometimes I’ll spend a whole weekend reading a math book, and sometimes I’ll go for weeks without thinking about it even once. But like any hobby, if you simply trust that it will be interesting, and that it’ll get easier with time, you can apply it as often or as little as you like and still get value out of it. </p><p><a href="http://www.cabochon.com/~stevey/blog-rants/blog-math-every-day.html" target="_blank" rel="noopener">Math every day</a>. What a great idea that turned out to be! </p><p>转载自：<a href="https://blog.csdn.net/rideronstorm/article/details/629178" target="_blank" rel="noopener">https://blog.csdn.net/rideronstorm/article/details/629178</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Math-For-Programmers&quot;&gt;&lt;a href=&quot;#Math-For-Programmers&quot; class=&quot;headerlink&quot; title=&quot;Math For Programmers&quot;&gt;&lt;/a&gt;&lt;center&gt;Math For Programme
      
    
    </summary>
    
      <category term="编程知识扩展" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95/"/>
    
      <category term="文章摘抄" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%89%A9%E5%B1%95/%E6%96%87%E7%AB%A0%E6%91%98%E6%8A%84/"/>
    
    
      <category term="数学知识" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="编程知识" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java多线程</title>
    <link href="http://yoursite.com/2018/05/23/1_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/23/1_Java多线程/</id>
    <published>2018-05-23T02:20:31.000Z</published>
    <updated>2018-07-03T12:13:54.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h2><h3 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h3><p>1、进程</p><p>　　进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是<a href="http://baike.baidu.com/view/880.htm" target="_blank" rel="noopener">操作系统</a>结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>　　进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的<a href="http://baike.baidu.com/view/41.htm" target="_blank" rel="noopener">代码</a>，还包括当前的活动，通过<a href="http://baike.baidu.com/view/178145.htm" target="_blank" rel="noopener">程序计数器</a>的值和处理<a href="http://baike.baidu.com/view/6159.htm" target="_blank" rel="noopener">寄存器</a>的内容来表示。</p><p>　　进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括<a href="http://baike.baidu.com/view/300107.htm" target="_blank" rel="noopener">文本</a>区域（text region）、数据区域（data region）和<a href="http://baike.baidu.com/view/93201.htm" target="_blank" rel="noopener">堆栈</a>（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有<a href="http://baike.baidu.com/view/989420.htm" target="_blank" rel="noopener">处理</a>器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为<a href="http://baike.baidu.com/view/19746.htm" target="_blank" rel="noopener">进程</a>。</p><p>2、线程</p><p>　　线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令<a href="http://baike.baidu.com/view/159417.htm" target="_blank" rel="noopener">指针</a>(PC），<a href="http://baike.baidu.com/view/6159.htm" target="_blank" rel="noopener">寄存器</a>集合和<a href="http://baike.baidu.com/view/93201.htm" target="_blank" rel="noopener">堆栈</a>组 成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个 进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程 在运行中呈现出间断性。线程也有<a href="http://baike.baidu.com/view/654230.htm" target="_blank" rel="noopener">就绪</a>、<a href="http://baike.baidu.com/view/497285.htm" target="_blank" rel="noopener">阻塞</a>和<a href="http://baike.baidu.com/view/1026025.htm" target="_blank" rel="noopener">运行</a>三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p><p>​    线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位，是<a href="http://baike.baidu.com/view/1026025.htm" target="_blank" rel="noopener">运行</a>中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为<a href="http://baike.baidu.com/view/65706.htm" target="_blank" rel="noopener">多线程</a>。</p><p>参考资料：<a href="https://www.cnblogs.com/work115/p/5620272.html" target="_blank" rel="noopener">进程、线程、协程之概念理解</a></p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>​    写在前面的话：此文只能说是java多线程的一个入门，其实Java里头线程完全可以写一本书了，但是如果最基本的你都学掌握好，又怎么能更上一个台阶呢？如果觉得此文很简单，可以看看Java并发包的的线程池（<a href="http://blog.csdn.net/evankaka/article/details/51489322" target="_blank" rel="noopener">Java并发编程与技术内幕:线程池深入理解</a>），或者看这个专栏：<a href="http://blog.csdn.net/column/details/javahhighconcurrence.html" target="_blank" rel="noopener">Java并发编程与技术内幕</a>。将会对Java里头的高并发场景下的线程有更加深刻的理解。</p><p>​    本文主要讲了java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别：</p><p>​    <strong>进程：</strong> 每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（<strong>进程是资源分配的最小单位</strong>）</p><p>​    <strong>线程：</strong> 同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（<strong>线程是cpu调度的最小单位</strong> ）</p><p>　　线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p><p>　　多进程是指操作系统能同时运行多个任务（程序）。</p><p>　　多线程是指在同一程序中有多个顺序流在执行。</p><p>​    在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(<strong>其实准确来讲，应该有三种，还有一种是实现Callable接口</strong>，并与Future、线程池结合使用，此文这里不讲这个，有兴趣看这里<a href="http://blog.csdn.net/evankaka/article/details/51610635" target="_blank" rel="noopener">Java并发编程与技术内幕:Callable、Future、FutureTask、CompletionService</a> )</p><h4 id="一、扩展java-lang-Thread类"><a href="#一、扩展java-lang-Thread类" class="headerlink" title="一、扩展java.lang.Thread类"></a>一、扩展java.lang.Thread类</h4><p>​    这里继承Thread类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用Thread.（<strong>推荐使用Runable，后头会说明为什么</strong>）。下面来看一个简单的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.multithread.learning;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">*<span class="doctag">@functon</span> 多线程学习 </span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> 林炳文 </span></span><br><span class="line"><span class="comment">*<span class="doctag">@time</span> 2015.3.9 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> String name;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">this</span>.name=name;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">             System.out.println(name + <span class="string">"运行  :  "</span> + i);  </span><br><span class="line">             <span class="keyword">try</span> &#123;  </span><br><span class="line">                 sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);  </span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                 e.printStackTrace();  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);  </span><br><span class="line">        Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);  </span><br><span class="line">        mTh1.start();  </span><br><span class="line">        mTh2.start();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>A运行  :  0<br>B运行  :  0<br>A运行  :  1<br>A运行  :  2<br>A运行  :  3<br>A运行  :  4<br>B运行  :  1<br>B运行  :  2<br>B运行  :  3<br>B运行  :  4</p><p>再运行一下：</p><p>A运行  :  0</p><p>B运行  :  0</p><p>B运行  :  1</p><p>B运行  :  2</p><p>B运行  :  3</p><p>B运行  :  4</p><p>A运行  :  1</p><p>A运行  :  2</p><p>A运行  :  3</p><p>A运行  :  4</p><p><strong>说明：</strong><br>​    程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。</p><p><strong>注意：</strong>start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p><p>​    从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。</p><p>​    Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</p><p>​    实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。</p><p>​    但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);</span><br><span class="line">Thread1 mTh2=mTh1;</span><br><span class="line">mTh1.start();</span><br><span class="line">mTh2.start();</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalThreadStateException</span><br><span class="line">at java.lang.Thread.start(Unknown Source)</span><br><span class="line">at com.multithread.learning.Main.main(Main.java:<span class="number">31</span>)</span><br></pre></td></tr></table></figure></p><p>A运行  :  0<br>A运行  :  1<br>A运行  :  2<br>A运行  :  3<br>A运行  :  4</p><h4 id="二、实现java-lang-Runnable接口"><a href="#二、实现java-lang-Runnable接口" class="headerlink" title="二、实现java.lang.Runnable接口"></a>二、实现java.lang.Runnable接口</h4><p>​    采用Runnable也是非常常见的一种，我们只需要重写run方法即可。下面也来看个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习 </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文 </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">package</span> com.multithread.runnable;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name=name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">                System.out.println(name + <span class="string">"运行  :  "</span> + i);  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(<span class="string">"C"</span>)).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(<span class="string">"D"</span>)).start();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>C运行  :  0<br>D运行  :  0<br>D运行  :  1<br>C运行  :  1<br>D运行  :  2<br>C运行  :  2<br>D运行  :  3<br>C运行  :  3<br>D运行  :  4<br>C运行  :  4</p><p><strong>说明：</strong></p><p>​    Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p><p>​    在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p><p>​    实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><h4 id="三、Thread和Runnable的区别"><a href="#三、Thread和Runnable的区别" class="headerlink" title="三、Thread和Runnable的区别"></a>三、Thread和Runnable的区别</h4><p>​    如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p><p><strong>总结：</strong></p><p>​    实现Runnable接口比继承Thread类所具有的优势：</p><p>​    1）：适合多个相同的程序代码的线程去处理同一个资源</p><p>​    2）：可以避免java中的单继承的限制</p><p>​    3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</p><p>​    4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</p><p>​    提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。</p><p>​    在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实习在就是在操作系统中启动了一个进程。</p><h4 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a>四、线程状态转换</h4><p>​    下面的这个图非常重要！你如果看懂了这个图，那么对于多线程的理解将会更加深刻！</p><p><img src="\image\Java多线程\线程状态转换图.png" alt="线程状态转换图"></p><p>1、新建状态（New）：新创建了一个线程对象。</p><p>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</p><p>3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</p><p>4、<strong>阻塞状态（Blocked）</strong>：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p><p>（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</p><p>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</p><p>（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</p><p>5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><h4 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a>五、线程调度</h4><p>线程的调度</p><p>1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。</p><p>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY  </span><br><span class="line">          线程可以具有的最高优先级，取值为<span class="number">10</span>。  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY  </span><br><span class="line">          线程可以具有的最低优先级，取值为<span class="number">1</span>。  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY  </span><br><span class="line">          分配给线程的默认优先级，取值为<span class="number">5</span>。</span><br></pre></td></tr></table></figure><p>​    Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</p><p>​    每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。</p><p>​    线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</p><p>​    JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p><p>2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p><p>3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p><p>4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p><p>5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><p>6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p><p><strong>注意：</strong>Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p><h4 id="六、常用函数说明"><a href="#六、常用函数说明" class="headerlink" title="六、常用函数说明"></a>六、常用函数说明</h4><p>①<strong>sleep(long millis)</strong>: 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）<br>②<strong>join()</strong>:指等待t线程终止。</p><p><strong>使用方式。</strong></p><p>​    join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p><p>​    <code>Thread t = new AThread(); t.start(); t.join();</code>  </p><p><strong>为什么要用join()方法</strong></p><p>​    在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p>不加join。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习,join </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文 </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">package</span> com.multithread.join;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name);  </span><br><span class="line">       <span class="keyword">this</span>.name=name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 线程运行开始!"</span>);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"子线程"</span>+name + <span class="string">"运行 : "</span> + i);  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                sleep((<span class="keyword">int</span>) Math.random() * <span class="number">10</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 线程运行结束!"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"主线程运行开始!"</span>);  </span><br><span class="line">        Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);  </span><br><span class="line">        Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);  </span><br><span class="line">        mTh1.start();  </span><br><span class="line">        mTh2.start();  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">"主线程运行结束!"</span>);  </span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>main主线程运行开始!<br>main主线程运行结束!<br>B 线程运行开始!<br>子线程B运行 : 0<br>A 线程运行开始!<br>子线程A运行 : 0<br>子线程B运行 : 1<br>子线程A运行 : 1<br>子线程A运行 : 2<br>子线程A运行 : 3<br>子线程A运行 : 4<br>A 线程运行结束!<br>子线程B运行 : 2<br>子线程B运行 : 3<br>子线程B运行 : 4<br>B 线程运行结束!</p><p>发现主线程比子线程早结束</p><p>加join<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"主线程运行开始!"</span>);  </span><br><span class="line">        Thread1 mTh1=<span class="keyword">new</span> Thread1(<span class="string">"A"</span>);  </span><br><span class="line">        Thread1 mTh2=<span class="keyword">new</span> Thread1(<span class="string">"B"</span>);  </span><br><span class="line">        mTh1.start();  </span><br><span class="line">        mTh2.start();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            mTh1.join();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            mTh2.join();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">"主线程运行结束!"</span>);  </span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>main主线程运行开始!<br>A 线程运行开始!<br>子线程A运行 : 0<br>B 线程运行开始!<br>子线程B运行 : 0<br>子线程A运行 : 1<br>子线程B运行 : 1<br>子线程A运行 : 2<br>子线程B运行 : 2<br>子线程A运行 : 3<br>子线程B运行 : 3<br>子线程A运行 : 4<br>子线程B运行 : 4<br>A 线程运行结束!<br>主线程一定会等子线程都结束了才结束</p><p>③<strong>yield()</strong>:暂停当前正在执行的线程对象，并执行其他线程。</p><p>​        Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p><p>​        <strong>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。</strong>因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p>​    <strong>结论：</strong>yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习 yield </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文 </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">package</span> com.multithread.yield;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadYield</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;  </span><br><span class="line">            System.out.println(<span class="string">""</span> + <span class="keyword">this</span>.getName() + <span class="string">"-----"</span> + i);  </span><br><span class="line">            <span class="comment">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）  </span></span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">30</span>) &#123;  </span><br><span class="line">                <span class="keyword">this</span>.yield();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        ThreadYield yt1 = <span class="keyword">new</span> ThreadYield(<span class="string">"张三"</span>);  </span><br><span class="line">        ThreadYield yt2 = <span class="keyword">new</span> ThreadYield(<span class="string">"李四"</span>);  </span><br><span class="line">        yt1.start();  </span><br><span class="line">        yt2.start();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>第一种情况：李四（线程）当执行到30时会CPU时间让掉，这时张三（线程）抢到CPU时间并执行。</p><p>第二种情况：李四（线程）当执行到30时会CPU时间让掉，这时李四（线程）抢到CPU时间并执行。</p><p><strong>sleep()和yield()的区别</strong></p><pre><code>sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</code></pre><p>​    sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程</p><p>​    另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 </p><p>④<strong>setPriority():</strong> 更改线程的优先级。</p><p>　　　MIN_PRIORITY = 1<br>  　　  NORM_PRIORITY = 5<br>​            MAX_PRIORITY = 10</p><p> <strong>用法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread4 t1 = <span class="keyword">new</span> Thread4(<span class="string">"t1"</span>);</span><br><span class="line">Thread4 t2 = <span class="keyword">new</span> Thread4(<span class="string">"t2"</span>);</span><br><span class="line">t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">t2.setPriority(Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure><p>⑤<strong>interrupt():</strong>不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！</p><p>⑥<strong>wait()</strong></p><p>​    Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p><p>​        单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对Object.wait()、Object.notify()的应用最经典的例子，应该是三线程打印ABC的问题了吧，这是一道比较经典的面试题，题目要求如下：</p><p>​        建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * wait用法 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DreamSea  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2015.3.9  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">package</span> com.multithread.wait;  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPrinter2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;     </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> String name;     </span><br><span class="line">    <span class="keyword">private</span> Object prev;     </span><br><span class="line">    <span class="keyword">private</span> Object self;     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadPrinter2</span><span class="params">(String name, Object prev, Object self)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">this</span>.name = name;     </span><br><span class="line">        <span class="keyword">this</span>.prev = prev;     </span><br><span class="line">        <span class="keyword">this</span>.self = self;     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;     </span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;     </span><br><span class="line">            <span class="keyword">synchronized</span> (prev) &#123;     </span><br><span class="line">                <span class="keyword">synchronized</span> (self) &#123;     </span><br><span class="line">                    System.out.print(name);     </span><br><span class="line">                    count--;    </span><br><span class="line">                      </span><br><span class="line">                    self.notify();     </span><br><span class="line">                &#125;     </span><br><span class="line">                <span class="keyword">try</span> &#123;     </span><br><span class="line">                    prev.wait();     </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;     </span><br><span class="line">                    e.printStackTrace();     </span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;     </span><br><span class="line">        </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;     </span><br><span class="line">        Object a = <span class="keyword">new</span> Object();     </span><br><span class="line">        Object b = <span class="keyword">new</span> Object();     </span><br><span class="line">        Object c = <span class="keyword">new</span> Object();     </span><br><span class="line">        MyThreadPrinter2 pa = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"A"</span>, c, a);     </span><br><span class="line">        MyThreadPrinter2 pb = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"B"</span>, a, b);     </span><br><span class="line">        MyThreadPrinter2 pc = <span class="keyword">new</span> MyThreadPrinter2(<span class="string">"C"</span>, b, c);     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(pa).start();  </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  <span class="comment">//确保按顺序A、B、C执行  </span></span><br><span class="line">        <span class="keyword">new</span> Thread(pb).start();  </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);    </span><br><span class="line">        <span class="keyword">new</span> Thread(pc).start();     </span><br><span class="line">        Thread.sleep(<span class="number">100</span>);    </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>ABCABCABCABCABCABCABCABCABCABC</p><p>​    先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。</p><p><strong>wait和sleep区别</strong></p><p><strong>共同点： </strong></p><p>1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 </p><p>2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 </p><pre><code>如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。</code></pre><p>​    需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 </p><p><strong>不同点： </strong></p><p>1. Thread类的方法：sleep(),yield()等<br>   Object的方法：wait()和notify()等 </p><p>2. 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 </p><p>3. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用，所以sleep()和wait()方法的最大区别是：</p><p>​    sleep()睡眠时，保持对象锁，仍然占有该锁；</p><p>​    而wait()睡眠时，释放对象锁。</p><p>​    但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。</p><p><strong>sleep（）方法</strong></p><p>​    sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p><p>​    sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。</p><p>​    在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 </p><p><strong>wait（）方法</strong></p><p>​    wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；</p><p>​    wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。</p><p>​    wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitor StateException“异常。</p><h4 id="七、常见线程名词解释"><a href="#七、常见线程名词解释" class="headerlink" title="七、常见线程名词解释"></a>七、常见线程名词解释</h4><p>​    主线程：JVM调用程序main()所产生的线程。</p><p>​    当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。</p><p>​    后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。<strong>用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</strong></p><p>​    前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</p><p>​    线程类的一些常用方法：</p><p>　    <strong>sleep():</strong> 强迫一个线程睡眠Ｎ毫秒。<br>　　<strong>isAlive():</strong> 判断一个线程是否存活。<br>　　<strong>join():</strong> 等待线程终止。<br>　　<strong>activeCount():</strong> 程序中活跃的线程数。<br>　　<strong>enumerate():</strong> 枚举程序中的线程。 </p><p>​       <strong>currentThread():</strong> 得到当前线程。 </p><p>　　<strong>isDaemon():</strong> 一个线程是否为守护线程。<br>　　<strong>setDaemon():</strong> 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)<br>　　<strong>setName():</strong> 为线程设置一个名称。<br>　　<strong>wait():</strong> 强迫一个线程等待。<br>　　<strong>notify():</strong> 通知一个线程继续运行。<br>　　<strong>setPriority():</strong> 设置一个线程的优先级。</p><h4 id="八、线程同步"><a href="#八、线程同步" class="headerlink" title="八、线程同步"></a>八、线程同步</h4><p>1、synchronized关键字的作用域有二种： </p><p>1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法； </p><p>2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 </p><p>2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/<em>区块</em>/}，它的作用域是当前对象； </p><p>3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法； </p><p>​    Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如何？――还得对synchronized关键字的作用进行深入了解才可定论。</p><p>​    总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。</p><p>​    在进一步阐述之前，我们需要明确几点：</p><p>​    A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</p><p>​    B．每个对象只有一个锁（lock）与之相关联。</p><p>​    C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p><p>接着来讨论synchronized用到不同地方对代码产生的影响：</p><p>​    假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。</p><p>1．  把synchronized当作函数修饰符时，示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">//….  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    在上面的这个同步方法中，其实锁定的对象是调用这个方法的对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。</p><p>​    上边的示例代码等同于如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)  &#123;   <span class="comment">//  (1)  </span></span><br><span class="line"><span class="comment">//…..  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>(1) 处的this指的是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱。</code></pre><p>2．同步块，示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(SomeObject so)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">synchronized</span>(so)&#123;  </span><br><span class="line">       <span class="comment">//…..  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">Runnable</span>  </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] lock = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];  <span class="comment">// 特殊的instance变量  </span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Public <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;  </span><br><span class="line">       <span class="keyword">synchronized</span>(lock)&#123; <span class="comment">//… &#125;  </span></span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//…..  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    <strong>注：</strong>零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</p><p>3．将synchronized作用于static 函数，示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Foo  &#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodAAA</span><span class="params">()</span></span>&#123; <span class="comment">// 同步的static 函数 </span></span><br><span class="line"><span class="comment">//….  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodBBB</span><span class="params">()</span></span>&#123;  </span><br><span class="line"><span class="keyword">synchronized</span>(Foo.class)   <span class="comment">//  class literal(类名称字面常量)  </span></span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    代码中的methodBBB()方法是把Foo类的字节码class对象作为锁，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。</p><p>​    记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。</p><p>​    可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。</p><p><strong>总结一下：</strong></p><p>1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。</p><p>2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法</p><p>3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。</p><p>4、对于同步，要时刻清醒在哪个对象上同步，这是关键。</p><p>5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。</p><p>6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。</p><p>7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使。但是，一旦程序发生死锁，程序将死掉。</p><h4 id="九、线程数据传递"><a href="#九、线程数据传递" class="headerlink" title="九、线程数据传递"></a>九、线程数据传递</h4><p>​    在传统的同步开发模式下，当我们调用一个函数时，通过这个函数的参数将数据传入，并通过这个函数的返回值来返回最终的计算结果。但在多线程的异步开发模式下，数据的传递和返回和同步开发模式有很大的区别。由于线程的运行和结束是不可预料的，因此，在传递和返回数据时就无法象函数一样通过函数参数和return语句来返回数据。</p><p><strong>9.1、通过构造方法传递数据 </strong></p><p>​    在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用(其实就是在run方法中使用)。下面的代码演示了如何通过构造方法来传递数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;   </span><br><span class="line"><span class="keyword">private</span> String name;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(String name)</span></span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.name = name;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   </span><br><span class="line">System.out.println(<span class="string">"hello "</span> + name);   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">Thread thread = <span class="keyword">new</span> MyThread1(<span class="string">"world"</span>);   </span><br><span class="line">thread.start();   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 </p><p><strong>9.2、通过变量和方法传递数据 </strong></p><p>​    向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对MyThread1类的改版，使用了一个setName方法来设置 name变量： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span>   </span>&#123;   </span><br><span class="line"><span class="keyword">private</span> String name;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span>   </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.name = name;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   </span>&#123;   </span><br><span class="line">System.out.println(<span class="string">"hello "</span> + name);   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>   </span>&#123;  </span><br><span class="line">        MyThread2 myThread = <span class="keyword">new</span> MyThread2();   </span><br><span class="line">myThread.setName(<span class="string">"world"</span>);   </span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread);   </span><br><span class="line">thread.start();   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9.3、通过回调函数传递数据 </strong></p><p>​    上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个 value是无法事先就传入线程类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread;   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>   </span>&#123;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> value = <span class="number">0</span>;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Work</span>   </span>&#123;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Data data, Integer numbers)</span>   </span>&#123;   </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : numbers)   &#123;   </span><br><span class="line">data.value += n;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">extends</span> <span class="title">Thread</span>   </span>&#123;   </span><br><span class="line"><span class="keyword">private</span> Work work;   </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread3</span><span class="params">(Work work)</span>   </span>&#123;   </span><br><span class="line"><span class="keyword">this</span>.work = work;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>   </span>&#123;   </span><br><span class="line">java.util.Random random = <span class="keyword">new</span> java.util.Random();   </span><br><span class="line">Data data = <span class="keyword">new</span> Data();   </span><br><span class="line"><span class="keyword">int</span> n1 = random.nextInt(<span class="number">1000</span>);   </span><br><span class="line"><span class="keyword">int</span> n2 = random.nextInt(<span class="number">2000</span>);   </span><br><span class="line"><span class="keyword">int</span> n3 = random.nextInt(<span class="number">3000</span>);   </span><br><span class="line">work.process(data, n1, n2, n3); <span class="comment">// 使用回调函数   </span></span><br><span class="line">System.out.println(String.valueOf(n1) + <span class="string">"+"</span> + String.valueOf(n2) + <span class="string">"+"</span> + String.valueOf(n3) + <span class="string">"="</span> + data.value);   </span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>   </span>&#123;  </span><br><span class="line">  Thread thread = <span class="keyword">new</span> MyThread3(<span class="keyword">new</span> Work());   </span><br><span class="line">  thread.start();   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，Java多线程的基础知识就讲到这里了，有兴趣研究多线程的推荐直接看java的源码，你将会得到很大的提升！</p><p>参考资料: <a href="http://blog.csdn.net/evankaka/article/details/44153709#t9" target="_blank" rel="noopener">Java多线程学习（吐血超详细总结）</a></p><h3 id="并行与并发的概念"><a href="#并行与并发的概念" class="headerlink" title="并行与并发的概念"></a>并行与并发的概念</h3><ul><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li></ul><p><img src="\image\Java多线程\并行与并发示意图.png" alt="并行与并发示意图"></p><h3 id="高级多线程"><a href="#高级多线程" class="headerlink" title="高级多线程"></a>高级多线程</h3><h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><p>synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们</p><p><img src="\image\Java多线程\Java_Monitor示意图.png" alt="Java_Monitor示意图"></p><p><strong>monitor</strong></p><p>​    他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。</p><p>​    wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。</p><p>​    当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。</p><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>​    多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。</p><p><img src="\image\Java多线程\main-memory模型.png" alt="main-memory模型"></p><p>​    多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。</p><h4 id="关于中断"><a href="#关于中断" class="headerlink" title="关于中断"></a>关于中断</h4><p>​    它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。</p><p>​    Thread.interrupted()检查当前线程是否发生中断，返回boolean</p><p>​    synchronized在获锁的过程中是不能被中断的。</p><p>​    中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体</p><h4 id="Thread类最佳实践"><a href="#Thread类最佳实践" class="headerlink" title="Thread类最佳实践"></a>Thread类最佳实践</h4><p>​    写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。</p><h4 id="高级多线程控制类"><a href="#高级多线程控制类" class="headerlink" title="高级多线程控制类"></a>高级多线程控制类</h4><p>​    Java1.5提供了一个非常高效实用的多线程包:<em>java.util.concurrent</em>, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。</p><h5 id="1-ThreadLocal类"><a href="#1-ThreadLocal类" class="headerlink" title="1.ThreadLocal类"></a>1.ThreadLocal类</h5><p>​    用处：保存线程的独立变量。对一个线程类（继承自Thread)。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。</p><p>​    实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。</p><p>​    主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。</p><h5 id="2-原子类（AtomicInteger、AtomicBoolean……）"><a href="#2-原子类（AtomicInteger、AtomicBoolean……）" class="headerlink" title="2.原子类（AtomicInteger、AtomicBoolean……）"></a>2.原子类（AtomicInteger、AtomicBoolean……）</h5><p>​    如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值为boolean</span></span><br><span class="line">AtomicInteger.compareAndSet(<span class="keyword">int</span> expect,<span class="keyword">int</span> update)</span><br></pre></td></tr></table></figure><p>​    该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b.value.compareAndSet(old, value))&#123;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//try again</span></span><br><span class="line">   <span class="comment">// if that fails, rollback and log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AtomicReference</strong></p><p>​    对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。</p><p>​    这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号。</p><h5 id="3-Lock类"><a href="#3-Lock类" class="headerlink" title="3.Lock类　"></a>3.Lock类　</h5><p>​    lock: 在java.util.concurrent包内。共有三个实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock</span><br><span class="line">ReentrantReadWriteLock.ReadLock</span><br><span class="line">ReentrantReadWriteLock.WriteLock</span><br></pre></td></tr></table></figure><p>​    主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。</p><p>​    区别如下：</p><p>​    lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序），提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。</p><p>​    本质上和监视器锁（即synchronized是一样的），能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。和Condition类的结合，性能更高，对比如下图：</p><p><strong>ReentrantLock</strong>　　　　</p><p>可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。</p><p>使用方法是：</p><p>1.先new一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ReentrantLock r=<span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure><p>2.加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.lock()或r.lockInterruptibly();</span><br></pre></td></tr></table></figure><p>​    此处也是个不同，后者可被打断。当a线程lock后，b线程阻塞，此时如果是lockInterruptibly，那么在调用b.interrupt()之后，b线程退出阻塞，并放弃对资源的争抢，进入catch块。（如果使用后者，必须throw interruptable exception 或catch）　</p><p>3.释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.unlock()</span><br></pre></td></tr></table></figure><p>​    必须做！何为必须做呢，要放在finally里面。以防止异常跳出了正常流程，导致灾难。这里补充一个小知识点，finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。</p><p><strong>ReentrantReadWriteLock</strong></p><p>​    可重入读写锁（读写锁的一个实现):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock()</span><br><span class="line">　　ReadLock r = lock.readLock();</span><br><span class="line">　　WriteLock w = lock.writeLock();</span><br></pre></td></tr></table></figure><p>​    两者都有lock,unlock方法。写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码</p><h5 id="4-容器类"><a href="#4-容器类" class="headerlink" title="4.容器类"></a>4.容器类</h5><p>​    这里就讨论比较常用的两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue</span><br><span class="line">ConcurrentHashMap</span><br></pre></td></tr></table></figure><p><strong>BlockingQueue</strong></p><p>​    阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管　　道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列），有兴趣可以研究</p><p>​    BlockingQueue在队列的基础上添加了多线程协作的功能：</p><p><img src="\image\Java多线程\BlockingQueue操作总结图.png" alt="BlockingQueue操作总结图"></p><p>​    除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队　列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。</p><p>常见的阻塞队列有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayListBlockingQueue</span><br><span class="line">LinkedListBlockingQueue</span><br><span class="line">DelayQueue</span><br><span class="line">SynchronousQueue</span><br></pre></td></tr></table></figure><p><strong>ConcurrentHashMap</strong>  </p><p>高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap</p><h3 id="线程池深入理解"><a href="#线程池深入理解" class="headerlink" title="线程池深入理解"></a>线程池深入理解</h3><p>参考资料：<a href="http://blog.csdn.net/evankaka/article/details/51489322" target="_blank" rel="noopener">Java并发编程与技术内幕:线程池深入理解</a></p><p>​    摘要： 本文主要讲了Java当中的线程池的使用方法、注意事项及其实现源码实现原理，并辅以实例加以说明,对加深Java线程池的理解有很大的帮助。</p><p>​         首先，讲讲什么是线程池？照笔者的简单理解，其实就是一组线程实时处理休眠状态，等待唤醒执行。那么为什么要有线程池这个东西呢？可以从以下几个方面来考虑：其一、减少在创建和销毁线程上所花的时间以及系统资源的开销 。其二、2将当前任务与主线程隔离，能实现和主线程的异步执行，特别是很多可以分开重复执行的任务。但是，一味的开线程也不一定能带来性能上的，线池休眠也是要占用一定的内存空间，所以合理的选择线程池的大小也是有一定的依据。</p><h4 id="一、Executors的API介绍"><a href="#一、Executors的API介绍" class="headerlink" title="一、Executors的API介绍"></a>一、Executors的API介绍</h4><p>Java类库提供了许多静态方法来创建一个线程池：</p><p>a、newFixedThreadPool 创建一个固定长度的线程池，当到达线程最大数量时，线程池的规模将不再变化。</p><p>b、newCachedThreadPool 创建一个可缓存的线程池，如果当前线程池的规模超出了处理需求，将回收空的线程；当需求增加时，会增加线程数量；线程池规模无限制。</p><p>c、newSingleThreadPoolExecutor 创建一个单线程的Executor，确保任务对了，串行执行</p><p>d、newScheduledThreadPool 创建一个固定长度的线程池，而且以延迟或者定时的方式来执行，类似Timer；</p><p>小结一下：在线程池中执行任务比为每个任务分配一个线程优势更多，通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊线程创建和销毁产生的巨大的开销。当请求到达时，通常工作线程已经存在，提高了响应性；通过配置线程池的大小，可以创建足够多的线程使CPU达到忙碌状态，还可以防止线程太多耗尽计算机的资源。</p><p>创建线程池基本方法：</p><p>(1)定义线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)建立ExecutorService线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cpuNums = Runtime.getRuntime().availableProcessors();  <span class="comment">//获取当前系统的CPU 数目  </span></span><br><span class="line">ExecutorService executorService =Executors.newFixedThreadPool(cpuNums * POOL_SIZE); <span class="comment">//ExecutorService通常根据系统资源情况灵活定义线程池大小</span></span><br></pre></td></tr></table></figure><p>(3)调用线程池操作<br>循环操作，成为daemon,把新实例放入Executor池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">executorService.execute(<span class="keyword">new</span> Handler(socket)); </span><br><span class="line">           <span class="comment">// class Handler implements Runnable&#123;</span></span><br><span class="line">        或者</span><br><span class="line">        executorService.execute(createTask(i));</span><br><span class="line">            <span class="comment">//private static Runnable createTask(final int taskID)</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>execute(Runnable对象)方法其实就是对Runnable对象调用start()方法（当然还有一些其他后台动作，比如队列，优先级，IDLE timeout，active激活等）</p><h4 id="二、几种不同的ExecutorService线程池对象"><a href="#二、几种不同的ExecutorService线程池对象" class="headerlink" title="二、几种不同的ExecutorService线程池对象"></a>二、几种不同的ExecutorService线程池对象</h4><table><thead><tr><th>不同线程池对象</th><th>线程池对象的特点</th></tr></thead><tbody><tr><td>1.newCachedThreadPool()</td><td>-缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中<br>-缓存型池子通常用于执行一些生存期很短的异步型任务 因此在一些面向连接的daemon型SERVER中用得不多。<br>-能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</td></tr><tr><td>2.newFixedThreadPool</td><td>-newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程<br>-其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子<br>-和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器<br>-从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同:<strong>fixed池线程数固定，并且是0秒IDLE（无IDLE）</strong><br>cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE</td></tr><tr><td>3.ScheduledThreadPool</td><td>-调度型线程池-这个池子里的线程可以按schedule依次delay执行，或周期执行</td></tr><tr><td>4.SingleThreadExecutor</td><td>-单例线程，任意时间池中只能有一个线程<br>-<strong>用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）</strong></td></tr></tbody></table><p><strong>应用实例：</strong></p><p><strong>1.CachedThreadPool</strong></p><p>​    CachedThreadPool首先会按照需要创建足够多的线程来执行任务(Task)。随着程序执行的过程，有的线程执行完了任务，可以被重新循环使用时，才不再创建新的线程来执行任务。我们采用《Thinking In Java》中的例子来分析。客户端线程和线程池之间会有一个任务队列。当程序要关闭时，你需要注意两件事情：入队的这些任务的情况怎么样了以及正在运行的这个任务执行得如 何了。令人惊讶的是很多开发人员并没能正确地或者有意识地去关闭线程池。正确的方法有两种：一个是让所有的入队任务都执行完毕（shutdown()）， 再就是舍弃这些任务（shutdownNow())——这完全取决于你。比如说如果我们提交了N多任务并且希望等它们都执行完后才返回的话，那么就使用 shutdown()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 功能概要：缓冲线程池实例-execute运行 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linbingwen </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  2016年5月24日  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handle</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">"thread"</span>+name;  </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println( name +<span class="string">" Start. Time = "</span>+<span class="keyword">new</span> Date());  </span><br><span class="line">            processCommand();  </span><br><span class="line">            System.out.println( name +<span class="string">" End. Time = "</span>+<span class="keyword">new</span> Date());  </span><br><span class="line">        &#125;  </span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">         <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.name;  </span><br><span class="line">            &#125;     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>验证实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCachedThreadPool</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     System.out.println(<span class="string">"Main: Starting at: "</span>+ <span class="keyword">new</span> Date());    </span><br><span class="line">     ExecutorService exec = Executors.newCachedThreadPool();   <span class="comment">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;     </span><br><span class="line">            exec.execute(<span class="keyword">new</span> Handle(String.valueOf(i)));     </span><br><span class="line">     &#125;     </span><br><span class="line">     exec.shutdown();  <span class="comment">//执行到此处并不会马上关闭线程池,但之后不能再往线程池中加线程，否则会报错  </span></span><br><span class="line">     System.out.println(<span class="string">"Main: Finished all threads at"</span>+ <span class="keyword">new</span> Date());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：</p><p><img src="\image\Java多线程\演示线程池的关闭.png" alt="演示线程池的关闭"></p><p>从上面的结果可以看出：<br>1、主线程的执行与线程池里的线程分开，有可能主线程结束了，但是线程池还在运行<br>2、放入线程池的线程并不一定会按其放入的先后而顺序执行</p><p><strong>2.FixedThreadPool</strong><br>​     FixedThreadPool模式会使用一个优先固定数目的线程来处理若干数目的任务。规定数目的线程处理所有任务，一旦有线程处理完了任务就会被用来处理新的任务(如果有的话)。这种模式与上面的CachedThreadPool是不同的，CachedThreadPool模式下处理一定数量的任务的线程数目是不确定的。而FixedThreadPool模式下最多 的线程数目是一定的。</p><p>应用实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFixThreadPool</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"Main Thread: Starting at: "</span>+ <span class="keyword">new</span> Date());    </span><br><span class="line">     ExecutorService exec = Executors.newFixedThreadPool(<span class="number">5</span>);     </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;     </span><br><span class="line">            exec.execute(<span class="keyword">new</span> Handle(String.valueOf(i)));     </span><br><span class="line">     &#125;     </span><br><span class="line">     exec.shutdown();  <span class="comment">//执行到此处并不会马上关闭线程池  </span></span><br><span class="line">     System.out.println(<span class="string">"Main Thread: Finished at:"</span>+ <span class="keyword">new</span> Date());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="\image\Java多线程\FixedThreadPool演示图.jpg" alt="FixedThreadPool演示图"></p><p>上面创建了一个固定大小的线程池，大小为5.也就说同一时刻最多只有5个线程能运行。并且线程执行完成后就从线程池中移出。它也不能保证放入的线程能按顺序执行。这要看在等待运行的线程的竞争状态了。</p><p><strong>3、newSingleThreadExecutor</strong></p><p>其实这个就是创建只能运行一条线程的线程池。它能保证线程的先后顺序执行，并且能保证一条线程执行完成后才开启另一条新的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSingleThreadPool</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     System.out.println(<span class="string">"Main Thread: Starting at: "</span>+ <span class="keyword">new</span> Date());    </span><br><span class="line">     ExecutorService exec = Executors.newSingleThreadExecutor();   <span class="comment">//创建大小为1的固定线程池  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;     ![SingleThreadPool运行示意图]( \image\Java多线程\SingleThreadPool运行示意图.jpg)</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Handle(String.valueOf(i)));     </span><br><span class="line">     &#125;     </span><br><span class="line">     exec.shutdown();  <span class="comment">//执行到此处并不会马上关闭线程池  </span></span><br><span class="line">     System.out.println(<span class="string">"Main Thread: Finished at:"</span>+ <span class="keyword">new</span> Date());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="\image\Java多线程\SingleThreadPool运行示意图.jpg" alt="SingleThreadPool运行示意图"></p><p>其实它也等价于以下：</p><p><code>ExecutorService exec = Executors.newFixedThreadPool(1);</code></p><p><strong>4、newScheduledThreadPool</strong></p><p>这是一个计划线程池类，它能设置线程执行的先后间隔及执行时间等，功能比上面的三个强大了一些。</p><p>以下实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testScheduledThreadPool</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Main Thread: Starting at: "</span>+ <span class="keyword">new</span> Date());    </span><br><span class="line">    ScheduledThreadPoolExecutor  exec = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(<span class="number">10</span>);   <span class="comment">//创建大小为10的线程池  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;     </span><br><span class="line">            exec.schedule(<span class="keyword">new</span> Handle(String.valueOf(i)), <span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//延迟10秒执行  </span></span><br><span class="line">     &#125;     </span><br><span class="line">     exec.shutdown();  <span class="comment">//执行到此处并不会马上关闭线程池  </span></span><br><span class="line">     <span class="keyword">while</span>(!exec.isTerminated())&#123;  </span><br><span class="line">            <span class="comment">//wait for all tasks to finish  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     System.out.println(<span class="string">"Main Thread: Finished at:"</span>+ <span class="keyword">new</span> Date());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现每个放入的线程延迟10秒执行。<br>结果：</p><p><img src="\image\Java多线程\ScheduledThreadPool.jpg" alt="ScheduledThreadPool"></p><p>ScheduledThreadPoolExecutor的定时方法主要有以下四种：</p><p><img src="\image\Java多线程\ScheduledThreadPoolExecutor的四种定时方法.jpg" alt="ScheduledThreadPoolExecutor的四种定时方法"></p><p>下面将主要来具体讲讲scheduleAtFixedRate和scheduleWithFixedDelay</p><p><strong>scheduleAtFixedRate 按指定频率周期执行某个任务</strong></p><p>解释：启动第一个任务后，间隔指定的时间，立马启动第二个任务。</p><p>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, </p><p>long initialDelay, </p><p>long period, </p><p>TimeUnit unit); </p><p>command：执行线程</p><p>initialDelay：初始化延时</p><p>period：两次开始执行最小间隔时间</p><p>unit：计时单位</p><p><strong>scheduleWithFixedDelay 周期定时执行某个任务/按指定频率间隔执行某个任务(注意)</strong></p><p>解释：启动第一个任务，等到第一个任务结束后，再间隔指定的时间，才启动第二个任务。</p><p>public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, </p><p>long initialDelay, </p><p>long delay, </p><p>TimeUnit unit); </p><p>command：执行线程</p><p>initialDelay：初始化延时</p><p>period：前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间）</p><p>unit：计时单位</p><p>使用实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(System.currentTimeMillis());  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>1.按指定频率周期执行某个任务</strong></p><p>下面实现每隔2秒执行一次，注意，如果上次的线程还没有执行完成，那么会阻塞下一个线程的执行。即使线程池设置得足够大。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 初始化延迟0ms开始执行，每隔2000ms重新执行一次任务 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linbingwen </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  2016年6月6日 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeFixedRate</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">10</span>);    </span><br><span class="line">        executor.scheduleAtFixedRate(    </span><br><span class="line">                <span class="keyword">new</span> MyHandle(),    </span><br><span class="line">                <span class="number">0</span>,    </span><br><span class="line">                <span class="number">2000</span>,    </span><br><span class="line">                TimeUnit.MILLISECONDS);    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>间隔指的是连续两次任务开始执行的间隔。对于scheduleAtFixedRate方法，当执行任务的时间大于我们指定的间隔时间时，它并不会在指定间隔时开辟一个新的线程并发执行这个任务。而是等待该线程执行完毕。</p><p><strong>2、按指定频率间隔执行某个任务</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 以固定延迟时间进行执行  </span></span><br><span class="line"><span class="comment"> * 本次任务执行完成后，需要延迟设定的延迟时间，才会执行新的任务  </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeFixedDelay</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">10</span>);    </span><br><span class="line">        executor.scheduleWithFixedDelay(    </span><br><span class="line">                <span class="keyword">new</span> MyHandle(),    </span><br><span class="line">                <span class="number">0</span>,    </span><br><span class="line">                <span class="number">2000</span>,    </span><br><span class="line">                TimeUnit.MILLISECONDS);    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>间隔指的是连续上次执行完成和下次开始执行之间的间隔。</p><p><strong>3.周期定时执行某个任务</strong></p><p>周期性的执行一个任务，可以使用下面方法设定每天在固定时间执行一次任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 每天晚上9点执行一次  </span></span><br><span class="line"><span class="comment"> * 每天定时安排任务进行执行  </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeEightAtNightPerDay</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);    </span><br><span class="line">        <span class="keyword">long</span> oneDay = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;    </span><br><span class="line">        <span class="keyword">long</span> initDelay  = getTimeMillis(<span class="string">"21:00:00"</span>) - System.currentTimeMillis();    </span><br><span class="line">        initDelay = initDelay &gt; <span class="number">0</span> ? initDelay : oneDay + initDelay;    </span><br><span class="line"></span><br><span class="line">    executor.scheduleAtFixedRate(    </span><br><span class="line">            <span class="keyword">new</span> MyHandle(),    </span><br><span class="line">            initDelay,    </span><br><span class="line">            oneDay,    </span><br><span class="line">            TimeUnit.MILLISECONDS);    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 获取指定时间对应的毫秒数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time "HH:mm:ss"  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getTimeMillis</span><span class="params">(String time)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">            DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yy-MM-dd HH:mm:ss"</span>);    </span><br><span class="line">            DateFormat dayFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yy-MM-dd"</span>);    </span><br><span class="line">            Date curDate = dateFormat.parse(dayFormat.format(<span class="keyword">new</span> Date()) + <span class="string">" "</span> + time);    </span><br><span class="line">            <span class="keyword">return</span> curDate.getTime();    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;    </span><br><span class="line">            e.printStackTrace();    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="三、线程池一些常用方法"><a href="#三、线程池一些常用方法" class="headerlink" title="三、线程池一些常用方法"></a>三、线程池一些常用方法</h4><p><strong>1、submit()</strong></p><p>​       将线程放入线程池中，除了使用execute，也可以使用submit，它们两个的区别是一个使用有返回值，一个没有返回值。submit的方法很适应于生产者-消费者模式，通过和Future结合一起使用，可以起到如果线程没有返回结果，就阻塞当前线程等待线程 池结果返回。</p><p>它主要有三种方法：</p><p>一般用第一种比较多</p><p><img src="\image\Java多线程\线程池的submit方法.jpg" alt="线程池的submit方法"></p><p>如下实例。注意，submit中的线程要实现接口Callable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.func.axc.executors;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 功能概要：缓冲线程池实例-submit运行 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linbingwen </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  2016年5月25日  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">this</span>.id = id;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 任务的具体过程，一旦任务传给ExecutorService的submit方法，则该方法自动在一个线程上执行。  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line">            System.out.println(<span class="string">"call()方法被自动调用,干活！！！             "</span> + Thread.currentThread().getName());   </span><br><span class="line">            <span class="comment">//一个模拟耗时的操作  </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">999999</span>; i &gt; <span class="number">0</span>; i--) ;   </span><br><span class="line">            <span class="keyword">return</span><span class="string">"call()方法被自动调用，任务的结果是："</span> + id + <span class="string">"    "</span> + Thread.currentThread().getName();   </span><br><span class="line">        &#125;   </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool2</span> </span>&#123;  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">          ExecutorService executorService = Executors.newCachedThreadPool();   </span><br><span class="line">          List&lt;Future&lt;String&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();   </span><br><span class="line">      </span><br><span class="line">          <span class="comment">//创建10个任务并执行  </span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">                  <span class="comment">//使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中  </span></span><br><span class="line">                  Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> TaskWithResult(i));   </span><br><span class="line">                  <span class="comment">//将任务执行结果存储到List中  </span></span><br><span class="line">                  resultList.add(future);   </span><br><span class="line">          &#125;   </span><br><span class="line">        <span class="comment">//启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。  </span></span><br><span class="line">          executorService.shutdown();   </span><br><span class="line">            </span><br><span class="line">          <span class="comment">//遍历任务的结果  </span></span><br><span class="line">          <span class="keyword">for</span> (Future&lt;String&gt; fs : resultList) &#123;   </span><br><span class="line">                  <span class="keyword">try</span> &#123;   </span><br><span class="line">                          System.out.println(fs.get());     <span class="comment">//打印各个线程（任务）执行的结果  </span></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line">                          e.printStackTrace();   </span><br><span class="line">                  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;   </span><br><span class="line">                          e.printStackTrace();   </span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;   </span><br><span class="line">                            </span><br><span class="line">                  &#125;   </span><br><span class="line">          &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：</p><p><img src="\image\Java多线程\submit(" alt="submit()方法调用示意图">方法调用示意图.jpg)</p><p>从上面可以看到，输出结果的依次的。说明每次get都 阻塞了的。</p><p>看了下它的源码，其实它最终还是调用 了execute方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);  </span><br><span class="line">    execute(ftask);  </span><br><span class="line">    <span class="keyword">return</span> ftask;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、execute()</strong></p><p>表示往线程池添加线程，有可能会立即运行，也有可能不会。无法预知线程何时开始，何时线束。</p><p>主要源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)  </span><br><span class="line">                ensureQueuedTaskHandled(command);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))  </span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3、shutdown()</strong></p><p>通常放在execute后面。如果调用 了这个方法，一方面，表明当前线程池已不再接收新添加的线程，新添加的线程会被拒绝执行。另一方面，表明当所有线程执行完毕时，回收线程池的资源。注意，它不会马上关闭线程池！</p><p><strong>4、shutdownNow()</strong></p><p>不管当前有没有线程在执行，马上关闭线程池！这个方法要小心使用，要不可能会引起系统数据异常！</p><h4 id="四、ThreadPoolExecutor技术内幕"><a href="#四、ThreadPoolExecutor技术内幕" class="headerlink" title="四、ThreadPoolExecutor技术内幕"></a>四、ThreadPoolExecutor技术内幕</h4><p>经过上面的过程，基本上可以掌握线程池的一些基本用法。下面再来看看JAVA中线程池的源码实现。</p><p>首先是其继承关系如下：</p><p><img src="\image\Java多线程\线程池继承层次关系.jpg" alt="线程池继承层次关系"></p><p>通过观察上面四种线程池的源码：</p><p>如：newFixedThreadPool<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,  </span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,  </span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如：newCachedThreadPool<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  </span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,  </span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如：newSingleThreadExecutor<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService  </span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,  </span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,  </span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    可以发现，其实它们调用的都是同一个接口ThreadPoolExecutor方法，只不过传入参数不一样而已。下面就来看看这个神秘的ThreadPoolExecutor。</p><p>​    首先来看看它的一些基本参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行状态标志位  </span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> runState;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       = <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//线程缓冲队列，当线程池线程运行超过一定线程时并满足一定的条件，待运行的线程会放入到这个队列  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;  </span><br><span class="line">    <span class="comment">//重入锁，更新核心线程池大小、最大线程池大小时要加锁  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();  </span><br><span class="line">    <span class="comment">//重入锁状态  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();  </span><br><span class="line">    <span class="comment">//工作都set集合  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  </span><br><span class="line">    <span class="comment">//线程执行完成后在线程池中的缓存时间  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;  </span><br><span class="line">    <span class="comment">//核心线程池大小   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;  </span><br><span class="line">    <span class="comment">//最大线程池大小   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;  </span><br><span class="line">    <span class="comment">//当前线程池在运行线程大小   </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;  </span><br><span class="line">    <span class="comment">//当缓冲队列也放不下线程时的拒绝策略  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;  </span><br><span class="line">    <span class="comment">//线程工厂，用来创建线程  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;     </span><br><span class="line">    <span class="comment">//用来记录线程池中曾经出现过的最大线程数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;     </span><br><span class="line">   <span class="comment">//用来记录已经执行完毕的任务个数  </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;     </span><br><span class="line"></span><br><span class="line">    ................  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化线程池大小 有以下四种方法：</p><p><img src="\image\Java多线程\初始化线程池大小的四种方法.jpg" alt="初始化线程池大小的四种方法"></p><p>从源码中可以看到其实最终都是调用了以下的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,  </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,  </span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||  </span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||  </span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||  </span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();  </span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;  </span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;  </span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;  </span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);  </span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;  </span><br><span class="line">    <span class="keyword">this</span>.handler = handler;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里很简单，就是设置一下各个参数，并校验参数是否正确，然后抛出对应的异常。</p><p>接下来我们来看看最重要的方法execute，其源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; <span class="comment">//  判断1  </span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 判断2  </span></span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)  <span class="comment">//  判断3  </span></span><br><span class="line">                ensureQueuedTaskHandled(command);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command)) <span class="comment">//  判断4  </span></span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>笔者在上面加了点注释。下面我们一个一个判断来看</p><p>首先判断1</p><p> if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) </p><p>（1）当poolSize &gt;= corePoolSize 不成立时，表明当前线程数小于核心线程数目，左边返回fasle.接着执行右边判断!addIfUnderCorePoolSize(command)</p><p>它做了如下操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;<span class="comment">//加锁  </span></span><br><span class="line">    mainLock.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)<span class="comment">//线程池在运行且当前线程小于核心线程（外面已做了一次相同的判断，确保和外面的一样）  </span></span><br><span class="line">            t = addThread(firstTask);<span class="comment">//加入线程  </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        mainLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> t != <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现它又调用addTread<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">addThread</span><span class="params">(Runnable firstTask)</span> </span>&#123; <span class="comment">//调用这个方法之前加锁  </span></span><br><span class="line"></span><br><span class="line">    Worker w = <span class="keyword">new</span> Worker(firstTask);<span class="comment">//线程包装成一个work  </span></span><br><span class="line">    Thread t = threadFactory.newThread(w);<span class="comment">//线程工厂从work创建线程  </span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 线程应该是未激活状态  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();  </span><br><span class="line">        w.thread = t;  </span><br><span class="line">        workers.add(w);<span class="comment">//全局set添加一个work  </span></span><br><span class="line">        <span class="keyword">int</span> nt = ++poolSize;<span class="comment">//当前运行线程数目加1  </span></span><br><span class="line">        <span class="keyword">if</span> (nt &gt; largestPoolSize)  </span><br><span class="line">            largestPoolSize = nt;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            t.start();<span class="comment">//注意，这里线程执行了，但是其实真正调用的是&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;Worker类的run方法！！！！！！！！！&lt;/span&gt;  </span></span><br><span class="line">            workerStarted = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!workerStarted)  </span><br><span class="line">                workers.remove(w);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> t;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>其实Work是真实去调用线程方法的地方,它是对Thread类的一个包装，每次Thread类调用其start方法时，就会调用到work的run方法。</strong>其代码如下，</p><p>private void runTask(Runnable task) { //真正发起线程方法的地方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">this</span>.runLock;  </span><br><span class="line">    runLock.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line"> <span class="keyword">if</span> ((runState &gt;= STOP || <span class="comment">//判断的判断  </span></span><br><span class="line"></span><br><span class="line">            (Thread.interrupted() &amp;&amp; runState &gt;= STOP)) &amp;&amp;  </span><br><span class="line">            hasRun)  </span><br><span class="line">            thread.interrupt();  </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;  </span><br><span class="line">        beforeExecute(thread, task);<span class="comment">//处理前  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            task.run();<span class="comment">//执行真正的原始线程的run方法  </span></span><br><span class="line">            ran = <span class="keyword">true</span>;  </span><br><span class="line">            afterExecute(task, <span class="keyword">null</span>);<span class="comment">//处理后  </span></span><br><span class="line">            ++completedTasks;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!ran)  </span><br><span class="line">                afterExecute(task, ex);  </span><br><span class="line">            <span class="keyword">throw</span> ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        runLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//这里执行线程的方法  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        hasRun = <span class="keyword">true</span>;  </span><br><span class="line">        Runnable task = firstTask;  </span><br><span class="line">        firstTask = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            runTask(task);  </span><br><span class="line">            task = <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        workerDone(<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现要执行一个线程真的很不容易，如果addIfUnderCorePoolSize返回true，刚表明成功添加一条线程，并调用了其start方法，那么整个调用到此结束。<strong>如果返回fasle.那么就进入判断2.</strong><br>（2）当<strong>poolSize &gt;= corePoolSize成立时，整个判断返回true。接着执行判断2</strong></p><p>判断2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 判断2</span></span><br></pre></td></tr></table></figure></p><p>如果当前线程池在运行状态，并且将当前线程加入到缓冲队列中。workQueue的offer是一个非阻塞方法。如查缓冲队列满了的话，返回为false.否则返回true;<br>如果上面两个都 为true，表明线程被成功添加到缓冲队列中，并且当前线程池在运行。进入判断3</p><p>判断3<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)  </span><br><span class="line">  ensureQueuedTaskHandled(command);</span><br></pre></td></tr></table></figure></p><p>​    当线程被加入到线程池中，进入判断3.如果这时线程池没有在运行或者运行的线程为为0。那么就调用ensureQueuedTaskHandled，它做的其实是判断下是否在拒绝这个线程的执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureQueuedTaskHandled</span><span class="params">(Runnable command)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;  </span><br><span class="line">    mainLock.lock();  </span><br><span class="line">    <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;  </span><br><span class="line">    Thread t = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">int</span> state = runState;  </span><br><span class="line">        <span class="keyword">if</span> (state != RUNNING &amp;&amp; workQueue.remove(command)) <span class="comment">//线程池没有在运行，且缓冲队列中有这个线程  </span></span><br><span class="line">            reject = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state &lt; STOP &amp;&amp;  </span><br><span class="line">                 poolSize &lt; Math.max(corePoolSize, <span class="number">1</span>) &amp;&amp;  </span><br><span class="line">                 !workQueue.isEmpty())  </span><br><span class="line">            t = addThread(<span class="keyword">null</span>);  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        mainLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (reject)  </span><br><span class="line">        reject(command); <span class="comment">//根据拒绝策略处理线程  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断4<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))  </span><br><span class="line">               reject(command); <span class="comment">// is shutdown or saturated</span></span><br></pre></td></tr></table></figure></p><p><strong>在判断2为false时执行，表明当前线程池没有在运行或者该线程加入缓冲队列中失败，那么就会尝试再启动下该线程，如果还是失败，那就根据拒绝策略来处理这个线程。其源码如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderMaximumPoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;  </span><br><span class="line">    mainLock.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING) <span class="comment">//如果当前运行线程数目 小于最大线程池大小 并且 线程池在运行，那么启动该线程  </span></span><br><span class="line">            t = addThread(firstTask);  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        mainLock.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> t != <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    一般调用这个方法是发生在缓冲队列已满了，那么线程池会尝试直接启动该线程。当然，它要保存当前运行的poolSize一定要小于maximumPoolSize。否则，最后。还是会拒绝这个线程！<br>以上大概就是整个线程池启动一条线程的整体过程。</p><p><strong>总结：</strong></p><p>​    ThreadPoolExecutor中，包含了一个任务缓存队列和若干个执行线程，任务缓存队列是一个大小固定的缓冲区队列，用来缓存待执行的任务，执行线程用来处理待执行的任务。每个待执行的任务，都必须实现Runnable接口，执行线程调用其run()方法，完成相应任务。ThreadPoolExecutor对象初始化时，不创建任何执行线程，当有新任务进来时，才会创建执行线程。</p><p>​    构造ThreadPoolExecutor对象时，需要配置该对象的核心线程池大小和最大线程池大小：当目前执行线程的总数小于核心线程大小时，所有新加入的任务，都在新线程中处理当目前执行线程的总数大于或等于核心线程时，所有新加入的任务，都放入任务缓存队列中当目前执行线程的总数大于或等于核心线程，并且缓存队列已满，同时此时线程总数小于线程池的最大大小，那么创建新线程，加入线程池中，协助处理新的任务。</p><p>​    当所有线程都在执行，    线程池大小已经达到上限，并且缓存队列已满时，就rejectHandler拒绝新的任务。</p><h4 id="五、自定义线程池"><a href="#五、自定义线程池" class="headerlink" title="五、自定义线程池"></a>五、自定义线程池</h4><p>再来看看它的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程大小  </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//最大线程大小   </span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//线程缓存时间  </span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//前面keepAlive  </span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//缓存队列  </span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//线程工大  </span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span><span class="comment">//拒绝策略</span></span></span><br></pre></td></tr></table></figure></p><p>block queue有以下几种实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue : 有界的数组队列  </span><br><span class="line">LinkedBlockingQueue : 可支持有界/无界的队列，使用链表实现  </span><br><span class="line">PriorityBlockingQueue : 优先队列，可以针对任务排序  </span><br><span class="line">SynchronousQueue : 队列长度为<span class="number">1</span>的队列，和Array有点区别就是：client thread提交  到block queue会是一个阻塞过程，直到有一个worker thread连接上来poll task。当线</span><br></pre></td></tr></table></figure></p><p>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。  </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。  </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）  </span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></p><p>比如定义如下一个线程池：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>,TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),Executors.defaultThreadFactory(),<span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br></pre></td></tr></table></figure></p><p>这里核心线程数为2，最大线程数为4，线程缓存时间为3秒，缓冲队列的容量设置为3。线程工厂设置为默认</p><p>下面是一个具体实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.func.axc.executors;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 功能概要： </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linbingwen </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2016年6月7日 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolTest</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> produceTaskSleepTime = <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> produceTaskMaxNumber = <span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 构造一个线程池  </span></span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>,TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),Executors.defaultThreadFactory(),<span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= produceTaskMaxNumber; i++) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// 产生一个任务，并将其加入到线程池  </span></span><br><span class="line">                String task = <span class="string">"task@ "</span> + i;  </span><br><span class="line">                System.out.println(<span class="string">"put "</span> + task);  </span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> ThreadPoolTask(task));  </span><br><span class="line">                <span class="comment">// 便于观察，等待一段时间  </span></span><br><span class="line">                Thread.sleep(produceTaskSleepTime);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 线程池执行的任务 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> consumeTaskSleepTime = <span class="number">2000</span>;  </span><br><span class="line">    <span class="comment">// 保存任务所需要的数据  </span></span><br><span class="line">    <span class="keyword">private</span> Object threadPoolTaskData;  </span><br><span class="line"></span><br><span class="line">    ThreadPoolTask(Object tasks) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.threadPoolTaskData = tasks;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 处理一个任务，这里的处理方式太简单了，仅仅是一个打印语句  </span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        System.out.println(<span class="string">"start .."</span> + threadPoolTaskData);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// //便于观察，等待一段时间  </span></span><br><span class="line">            Thread.sleep(consumeTaskSleepTime);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        threadPoolTaskData = <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTask</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.threadPoolTaskData;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="\image\Java多线程\自定义线程池执行任务示意图.jpg" alt="自定义线程池执行任务示意图"></p><p>线程池今天就说到这里，下一节我们再来讨论技术细节吧~~</p><p>参考资料：<a href="http://blog.csdn.net/evankaka/article/details/51489322" target="_blank" rel="noopener">Java并发编程与技术内幕:线程池深入理解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java多线程&quot;&gt;&lt;a href=&quot;#java多线程&quot; class=&quot;headerlink&quot; title=&quot;java多线程&quot;&gt;&lt;/a&gt;java多线程&lt;/h2&gt;&lt;h3 id=&quot;进程与线程的概念&quot;&gt;&lt;a href=&quot;#进程与线程的概念&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Java高级知识" scheme="http://yoursite.com/categories/Java%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/2018/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/05/18/数据结构/</id>
    <published>2018-05-18T14:01:58.000Z</published>
    <updated>2018-07-04T12:18:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><center>数据结构</center></h1><p>[TOC]</p><h2 id="0-常见数据结构"><a href="#0-常见数据结构" class="headerlink" title="0. 常见数据结构"></a>0. 常见数据结构</h2><p><strong>线性：</strong>数组，链表，队列，堆栈，hash表，双端队列，==位图(bitmap)==</p><p><strong>树：</strong>堆（大顶堆、小顶堆），trie树（字母树or字典树），后缀树，后缀树组，二叉排序/查找树，B+/B-树，AVL树，Treap，红黑树，splay树，线段树，树状数组</p><p><strong>图：</strong>图</p><p><strong>其他：</strong>并查表</p><p>参考资料：<a href="http://dongxicheng.org/structure/structure-algorithm-summary/" target="_blank" rel="noopener">数据结构与算法汇总</a></p><h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><p>​    数据结构中最基本的一个结构就是线性结构，而线性结构又分为连续存储结构和离散存储结构。所谓的连续存储结构其实就是数组。</p><p>​    在内存中，数组中的数据是以一组连续的数据集合的形式存在于内存中。当我们访问存在于内存中的数组时，我们应该找到其在内存中的地址，当我们找到数据的地址后我们就可以找到对应的数据。</p><p>​    数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</p><p>​    数组的特点是：<br>        元素类型是固定的、长度是固定的、通过下标查询，查询快，增删慢。</p><p><img src="\image\数据结构\数组存储空间示意图.png" alt="组存储空间示意"></p><h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><p>​    线性表的定义：一个线性表是n个数据元素的==有限==序列。（注意：线性表中元素的个数是有限的）。</p><p>​    线性表中元素的个数是n(n&gt;=0)称作线性表的长度。线性表中的元素可以是各种各样的，如数字，符号，一页书等。但同一个线性表中的元素类型必须是相同的。n=0时称线性表为空表。</p><p>​           在稍复杂的线性表中，一个数据元素可以由若干个数据项（item）组成，此时称数据元素为记录，含有大量记录的线性表称作文件。</p><h3 id="1-线性表的顺序表示和实现"><a href="#1-线性表的顺序表示和实现" class="headerlink" title="1. 线性表的顺序表示和实现"></a>1. 线性表的顺序表示和实现</h3><p>​    顺序表指的是用一组地址连续的存储单元依次存储线性表的数据元素，按照这种存储结构存储的机制称作线性表的顺序存储结构或顺序映像。</p><p>​    顺序表的特点、优点和缺点如下表1所示：</p><p>​                        表1：顺序表的特点、优点和缺点表</p><table><thead><tr><th style="text-align:center">项目</th><th>内容</th></tr></thead><tbody><tr><td style="text-align:center">特点</td><td>⑴ 线性表中相邻的元素在物理上存储位置相邻。即以元素在计算机内物理位置相邻来表示线性表中数据元素之间的逻辑关系。<br>⑵ 随机存取<br>⑶ 通常对应高级程序语言中的一维数组</td></tr><tr><td style="text-align:center">优点</td><td>⑴ 不需要额外的存储空间来表示元素间的逻辑关系<br>⑵ 可随机存取</td></tr><tr><td style="text-align:center">缺点</td><td>⑴ 插入和删除元素时需要移动大量的元素<br>⑵ 必须先进行空间分配，而且还需要考虑空间的扩充</td></tr></tbody></table><h3 id="2-线性表的链式表示和实现"><a href="#2-线性表的链式表示和实现" class="headerlink" title="2. 线性表的链式表示和实现"></a>2. 线性表的链式表示和实现</h3><p>​    线性表的链式表示主要有三种：单链表、循环链表和双向链表。</p><p><em>2.1  单链表</em></p><p>​    单链表指的是用一组任意的存储单元存储线性表的数据元素。使用单链表的时候，关心的只是它所表示的线性表中数据元素之间的逻辑顺序，而不是它所表示的线性表中数据元素之间的物理顺序。</p><p>​    单链表的特点、优点和缺点表如下表2所示：</p><p>​                        表2：单链表的特点、优点和缺点表</p><table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>特点</td><td>⑴ 存储单链表的存储单元地址可以连续也可以不连续。<br>⑵ 建立链表的过程就是一个动态生成链表的过程。</td></tr><tr><td>优点</td><td>(1) 在单链表中插入或删除一个节点时，仅需修改指针而不需要移动元素。<br>⑵ 根据需要申请空间，且不要求连续的存储空间。</td></tr><tr><td>缺点</td><td>⑴ 用指针指示元素之间的逻辑关系，存储空间利用率低。<br>⑵ 对表中元素只能按照顺序存取，不可随机访问。</td></tr></tbody></table><p>​    单链表中关键字解释表如表3所示：</p><p>​                            表3：单链表中名词解释表</p><table><thead><tr><th style="text-align:center">名词</th><th>解释</th></tr></thead><tbody><tr><td style="text-align:center">结点(node)</td><td>单链表中存储的每个元素ai。每个节点都包括两个域，数据域和指针域。</td></tr><tr><td style="text-align:center">数据域</td><td>存储的内容是数据信息</td></tr><tr><td style="text-align:center">指针域</td><td>存储的是直接后继存储位置</td></tr><tr><td style="text-align:center">头指针</td><td>头指针指示链表中第一个结点（即第一个数据元素的存储映像）的存储位置。</td></tr><tr><td style="text-align:center">头结点</td><td>在单链表的第一个结点之前附设的结点</td></tr></tbody></table><p><em>2.2 循环链表</em></p><p>​    单链表中最后一个结点的指针域指向头结点。整个链表形成一个环，从表中任一点出发均可找到表中其他节点。</p><p><em>2.3 双向链表</em></p><p>​    双向链表中的节点都有两个指针域，其一指向该结点的直接前趋，另一个指针域指向该结点的直接后继结点。<br>    与单链表的循环链表类似，双向链表也可以有循环双向链表。<br>    在双向链表中插入和删除节点时，需要同时修改两个方向上的指针。</p><p><img src="\image\数据结构\双向链表插入与删除节点过程.png" alt="向链表插入与删除节点过"></p><h2 id="三、栈和队列"><a href="#三、栈和队列" class="headerlink" title="三、栈和队列"></a>三、栈和队列</h2><p>​    从数据结构角度看，栈和队列是操作受限的线性表。<br>    从数据类型角度看，栈和队列与线性表又有所不同。</p><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p>​    栈是限定仅在表尾进行插入和删除操作的线性表。所以栈的最大特点是先进后出（last in first out）。<br>    栈的表示形式有两种：顺序栈和链栈。     </p><p>​    栈的引用举例：数制转换、括号匹配的检验、行编辑程序、迷宫求解和表达式求值。</p><p>​    一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作是递归函数。</p><p><img src="\image\数据结构\栈数据结构.png" alt="数据结"></p><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><p>​    队列是一种先进先出的线性表，只允许在表的一端进行插入，而在另外一端删除元素。</p><p>​    允许插入的一端叫做队尾（rear），允许删除的一端则叫做队头(front)。</p><h3 id="3-双端队列"><a href="#3-双端队列" class="headerlink" title="3. 双端队列"></a>3. 双端队列</h3><p>​    除了栈和队列之外，还有一种限定性数据结构是双端队列，尽管双端队列看起来比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用。</p><h3 id="4-链队列"><a href="#4-链队列" class="headerlink" title="4. 链队列"></a>4. 链队列</h3><p>​    用链表表示的队列。</p><h3 id="5-循环队列"><a href="#5-循环队列" class="headerlink" title="5. 循环队列"></a>5. 循环队列</h3><p>​    循环队列是用顺序表表示的队列，在非空队列中，头指针指向队列元素，而尾指针始终指向队列尾元素的下一个位置。如果用户程序中设有循环队列，则必须为它设定一个最大队列长度，若用户无法预估所用队列的最大长度，则宜采用链队列。</p><h2 id="四、串"><a href="#四、串" class="headerlink" title="四、串"></a>四、串</h2><p>1. 串(string)(或字符串)是由零个或多个字符组成的有限序列。</p><p>2. 字符串有3种机内表示方法：①定长顺序存储表示；②堆存储表示；③串的块链存储表示。</p><p>3. 串的模式匹配算法<br>    子串的定位操作通常称做串的模式匹配，是各种串处理系统中最重要的操作之一。</p><p>4. 字符串模式匹配<br>    给定字符串S(匹配串)和T(模式串)，求字符串T在S中首次出现的下标。<br>    注意：对于字符串S来说，其S[0]存放的是字符串的长度。如S=”abcd”,则S[0]=4.<br>    <strong>KMP算法：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index_KMP</span><span class="params">(String S, String T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; j &lt;=T[<span class="number">0</span>])&#123;<span class="comment">//注意：字符串的T[0]存储的是字符串长度</span></span><br><span class="line">        <span class="comment">/*如果j == 0 || S[i] == T[j]，则向后移动继续比较*/</span></span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">0</span> || S[i] == T[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则j回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    如何得到模式串T的next数组。此时T即是匹配串，也是模式串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_next</span><span class="params">(SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//注意这个地方j初始化为0</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">0</span> || S[i] == T[j])&#123;<span class="comment">//由S[i] == T[j]是否相等，来得出next[i+1]</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则j回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    如何得到模式串T的nextval数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nextval</span><span class="params">(SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//注意这个地方j初始化为0</span></span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">0</span> || S[i] == T[j])&#123;<span class="comment">//由S[i] == T[j]是否相等，来得出next[i+1]</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(T[i] == T[j])&#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则j回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、树和二叉树"><a href="#四、树和二叉树" class="headerlink" title="四、树和二叉树"></a>四、树和二叉树</h2><p><strong>1.  树(Tree)</strong>是n(n&gt;=0)个结点的有限集。</p><p><strong>2.  森林(Forest)</strong>是m(m&gt;=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。</p><p><strong>3. </strong> 结点拥有的子树数称为该<strong>结点的度</strong>(Degree).</p><p><strong>4.  二叉树(BinaryTree)</strong>是另一种树型结构，它的特点是每个结点至多只有两颗子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p><p><strong>5.  二叉树的性质</strong></p><p>​    ① 在二叉树的第i层上至多有2i-1个结点(i&gt;=1)；</p><p>​    ② 深度为k的二叉树至多有2k-1个结点；</p><p>​    证明：深度为k，说明是有k层，结点个数最多为2k-1个</p><p>​    ③ 对任何一棵二叉树T，如果终端结点数为n0，度为2的结点数为n2，则n0 = n2+1.</p><p>​    ④ 具有N个结点的完全二叉树的深度为log2N+1。(log2N是向下取整)</p><p><strong>6.  二叉树的存储结构</strong></p><p>​    <strong>① 顺序存储结构</strong></p><p>​    用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在如上定义的一维数组中下标为i-1的分量中。</p><p>​    <strong>② 链式存储结构</strong></p><p>​    二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表的节点至少包含3个域：数据域和左右指针域。</p><p>​    在有n个结点的二叉链表中必定存在n+1个空链域。(原因是，对于n个结点共有2n个链域，root结点不需要有指针指向，其他n-1个指针需要n-1个链域，所以还剩下2n-(n-1)=n+1)</p><p>​    有时为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。</p><p>​    利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表。</p><p>​    在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需要进行何种操作。</p><p><strong>7.  树的存储结构</strong></p><p>①    双亲表示法</p><p>​    以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置。</p><p>​    这种存储结构利用了每个结点(根结点除外)只有唯一的双亲的性质。可以利用O(1)的时间复杂度找到每个结点的父亲结点，但是如果要找结点的孩子结点则需要遍历整个结构。</p><p><img src="\image\数据结构\树的双亲表示法.png" alt="的双亲表示"></p><p>​           ②孩子表示法<br>      把每个结点的孩子排列起来，看成一个线性表，且以单链表作为存储结构，则n个结点有n个孩子链表。n个头指针又组成一个线性表，为了便于查找，可以采用顺序存储结构。<br>       与双亲表示法相反，孩子表示法方便找到孩子结点，但是不方便找到双亲结点。不过可以把双亲表示法和孩子表示法结合起来。                             </p><p><img src="\image\数据结构\树的孩子表示法.png" alt="的孩子表示"></p><p>③ 孩子兄弟表示法</p><p>​    又称二叉树表示法，或二叉链表表示法，即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点(左孩子右兄弟)，分别命名为firstchild和nextsibling域。</p><p>​    从firstchild域找到第一个孩子结点，然后沿着孩子结点的nextsibling域连续走i-1步，便可找到x的第i个孩子。此外，也可以为每一个结点增设一个PARENT域，则同样能方便地实现找某个结点的双亲结点。</p><p><img src="\image\数据结构\树的孩子兄弟表示法.png" alt="的孩子兄弟表示"></p><p><strong>8. 森林与二叉树的转换</strong></p><p>​    ==给定一棵树，可以找到唯一的一棵二叉树与之对应。==</p><p>​    可以把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可以导出森林与二叉树的对应关系。</p><p>​    先序遍历森林，相当于其对应二叉树的先序遍历，相当于依次对森林中的每棵树的先序遍历。</p><p>​    中序遍历森林，相当于其对应二叉树的中序遍历，相当于依次对森林中的每棵树做后续遍历。</p><h2 id="六、哈希表"><a href="#六、哈希表" class="headerlink" title="六、哈希表"></a>六、哈希表</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.  定义"></a>1.  定义</h3><p>​    根据设定的哈希函数H(key)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（空间）上，并以关键字在地址集中的“像”作为记录在表中存储位置。这种表则称为hash表。这个映射过程称为哈希造表或散列，所得存储位置称为哈希地址或散列地址。     </p><p>​    一般情况下，冲突只可能尽量少，但是不能避免。所以，在建造hash表的时候，选择好的hash构造函数和解决冲突的办法至关重要。</p><h3 id="2-哈希函数的构造函数。"><a href="#2-哈希函数的构造函数。" class="headerlink" title="2.  哈希函数的构造函数。"></a>2.  哈希函数的构造函数。</h3><pre><code>若对于关键字集合中的任意一个关键字，经哈希函数映像到地址集合中的任意一个位置的概率是相等的，则称此类哈希函数是均匀的。也就是说可以使任意一个关键字可被随机地映射到地址中，以便使一组关键字均匀地散列到地址集合中，以便减少冲突。</code></pre><p>​    散列函数有一个共同性质，即函数值应按==同等概率==取其值域的每一个值。</p><p>​    常见的构造hash函数有：</p><table><thead><tr><th>编号</th><th style="text-align:left">名称</th><th style="text-align:left">定义</th><th style="text-align:left">冲突</th><th>备注</th><th style="text-align:left">适用场景</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left">直接定义法</td><td style="text-align:left">取关键字或关键字的某个线性函数值为hash地址。H(key)=key或者H(key) = a*key+b</td><td style="text-align:left">不会</td><td>实际中使用很少。该方法关键字集合和地址集合大小相等 ，不会发生冲突。</td><td style="text-align:left">适合查找表较小且连续的情况。</td></tr><tr><td>2</td><td style="text-align:left">数字分析法</td><td style="text-align:left">假设关键字是以r为基的数（如以10为基的十进制数），并且hash表中可能出现的关键字都是事先知道的，则可以取关键字的若干数位组成哈希地址</td><td style="text-align:left">会</td><td>不常用</td><td style="text-align:left">关键字位数比较大，就需要事先知道关键字的分布且关键字的若干位分布较均匀</td></tr><tr><td>3</td><td style="text-align:left">平方取中法</td><td style="text-align:left">取关键字平方之后的中间几位为哈希地址。取的位数由表长决定。</td><td style="text-align:left">会</td><td>较常用</td><td style="text-align:left">不知道关键字的分布，而位数又不是很大的情况</td></tr><tr><td>4</td><td style="text-align:left">折叠法</td><td style="text-align:left">将关键字分割成位数相同的几部分（最后一部分的位数可不同），然后取这几部分的叠加和（舍去最高进位）作为hash地址。  如04 4220 5864 可做04+4220+5864=0088，舍弃最高进位</td><td style="text-align:left">会</td><td>一般常用，</td><td style="text-align:left">事先不需要知道关键字的分布，适合关键字位数较多的情况。</td></tr><tr><td>5</td><td style="text-align:left">除留余数法</td><td style="text-align:left">取关键字被某个不大于hash表表长m的数p除后所得余数为哈希地址。H(key)=key mod p;p&lt;=m  一般取p为小于m的质数或不包含小于20的质因数的合数。</td><td style="text-align:left">会</td><td>最简单，最常用的构造hash函数的方法。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模</td><td style="text-align:left">关键在于p的选择，选择较好的p则有效减少冲突。一般取p为小于m的质数或不包含小于20的质因数的合数。</td></tr><tr><td>6</td><td style="text-align:left">随机数法</td><td style="text-align:left">选择一个随机函数，取关键字的随机函数值作为它的哈希地址 ，H(key)=random(key)</td><td style="text-align:left">会</td><td>通常当关键字长度不等时采用此法，构造哈希函数较恰当</td><td style="text-align:left">当关键字的长度不等时</td></tr><tr><td>7</td><td style="text-align:left">相乘取整法</td><td style="text-align:left">首先用关键字key乘上某个常数A(0&lt;A&lt;1)，并抽取出key.A的小数部分；然后用m乘以该小数后取整</td><td style="text-align:left"></td><td></td></tr></tbody></table><p>​    实际中根据不同情况采用不同哈希方法，考虑的因素主要有：</p><p>​    1) 计算hash方法所需时间；2）关键字长度；3）哈希表的大小；4）关键字的分布情况；5）记录的查找频率。</p><p>​    总之，设计哈希构造函数的时候主要要考虑计算简单和散列地址分布均匀这两个特点。</p><h3 id="3-处理冲突的方法"><a href="#3-处理冲突的方法" class="headerlink" title="3.  处理冲突的方法"></a>3.  处理冲突的方法</h3><p>​           既然在构造hash表的过程中出现冲突不可避免，那么就需要有处理冲突的方法。下面介绍几种常用的处理冲突的方法。</p><table><thead><tr><th>类别</th><th>详细方法</th></tr></thead><tbody><tr><td>开放地址法</td><td>线性探测再散列<br>  线性补偿探测法<br>  二次探测再散列<br>  伪随机探测再散列</td></tr><tr><td>再哈希法</td><td></td></tr><tr><td>链地址法（拉链法）</td><td></td></tr><tr><td>建立公共溢出区</td></tr></tbody></table><p><strong>3.1 开放地址法</strong></p><p>​    开放地址法主要包括线性探测再散列、线性补偿探测法、二次探测再散列和伪随机探测再散列。</p><p>​    Hi = (H(key)+di)%m</p><p>​    其中H(key)为哈希函数，m为哈希表表长，di为增量序列。</p><p>​    (1) di = 1,2,3..m-1称线性探测再散列；</p><p>​    (2) 将线性探测的步长从1 改为 Q ，即将上述算法中的 j ＝ (j ＋ 1) % m 改为： j ＝ (j ＋ Q) % m ，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。（线性补偿探测法）</p><p>​    (3) di = 12,-12,22,-22….k2,-k2称作二次探测再散列。</p><p>​    (4) di = 伪随机序列，称作伪随机探测再散列。</p><p>​          在处理冲突的过程中，两个hash地址不同的关键字争夺同一个后继哈希地址的现象称作是“二次聚集”，即在处理同义词的冲突过程中又添加了非同义词的冲突。</p><p>​       对于线性探测再查找，在哈希表未填满的状态下总能找到一个不发生冲突的地址。对于二次探测再散列，只有哈希表的长度m为形如$4*j+3$($j$是整数)的素数时，才可以保证哈希表未满情况下总能找到一个不发生冲突的地址。随机探测再散列，则取决于伪随机数列。</p><p><strong>3.2 再哈希法</strong></p><p>​        $$ Hi = RH_i (key)    i=1,2,3…k $$</p><p>​    $RH_i$均是不同的hash函数，即在同义词产生冲突时计算另一个哈希函数地址，直到不产生冲突为止。该方法虽然不容易产生聚集，但是会增加计算的时间。</p><p><strong>3.3 链地址法（拉链法）</strong></p><p>​       将关键字为同义词的记录存储在同一线性表中，在链表的插入为可以在表头或表尾，也可以在中间，以保持同义词在同一线性链表中按关键字有序。</p><p><strong>3.4 建立公共溢出区</strong></p><p>​       所有关键字和哈希表中已有的记录发生冲突的，就把这个关键字填入到溢出表中。（溢出表是另建立的一张新表，专门放那些在确定其hash地址的时候产生冲突的记录）</p><p><strong>3.5 拉链法和开放地址法比较</strong></p><p><strong>与开放定址法相比，拉链法有如下几个优点：</strong></p><p>① 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p><p>② 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</p><p>③ 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p><p>④ 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</p><p><strong>拉链法的缺点</strong><br>    　==拉链法的缺点是：指针需要额外的空间==。故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p><h3 id="4-哈希表的查找及分析"><a href="#4-哈希表的查找及分析" class="headerlink" title="4.  哈希表的查找及分析"></a>4.  哈希表的查找及分析</h3><p>​    哈希表的查找过程与哈希表的构造过程一致，给定k值，根据哈希函数计算得到哈希地址，若此位置上为空，则查找不成功；否则与关键字进行比较，若相等，则查找成功，否则根据处理冲突的方法查找下一个槽位上的记录。直到找到查找成功或者哈希表中某个位置为空。</p><p>​       哈希表的平均查找长度与哈希表的装载因子有关，与关键字集合包含元素个数无关 。因此，不管n多大，我们总可以选择一个合适的装载因子，以便将平均查找长度限定在一个范围内。</p><h3 id="5-哈希表的适用"><a href="#5-哈希表的适用" class="headerlink" title="5.  哈希表的适用"></a>5.  哈希表的适用</h3><p>​       散列技术既是一种存储方法，也是一种查找方法。<strong>散列技术最适合的求解问题是查找与给定值相等的记录。</strong></p><p>​    <strong>散列表不适合范围查找；散列表也不能获得表中记录的顺序，如获得表中最大值和最小值是不可行的。</strong></p><h2 id="七、图"><a href="#七、图" class="headerlink" title="七、图"></a>七、图</h2><h3 id="1-图的深度遍历DFS"><a href="#1-图的深度遍历DFS" class="headerlink" title="1.  图的深度遍历DFS"></a>1.  图的深度遍历DFS</h3><p>可采用递归和循环两种方式实现。</p><p>​    <strong>方法一：</strong>采用递归的方式。<br>    定义一个标志数组表示某个结点是否已经被访问过。以邻接矩阵的形式表示图。依次对深度遍历图中的每个未被遍历过的结点，然后针对该结点未被遍历过的邻接点再进行深度遍历，每个结点被遍历后加入到结果中，并且设定该结点已经被访问过。</p><p>​    <strong>方法二：</strong>不采用递归的方式而是采用栈保存已经遍历过并且还有其孩子结点可能还没有遍历过的结点。与递归方式中一样，也是定义一个标志数组表示某个结点是否已经被访问过。始化栈内存放第一个结点。判断栈顶元素的第一个还未被访问邻接点，把它压入到栈中，每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。循环直到栈空。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一：采用递归的方式。</span></span><br><span class="line"><span class="comment"> * 定义一个标志数组表示某个结点是否已经被访问过。</span></span><br><span class="line"><span class="comment"> * 以邻接矩阵的形式表示图。</span></span><br><span class="line"><span class="comment"> * 依次对深度遍历图中的每个未被遍历过的结点，针对该结点未被遍历过的邻接点再进行深度遍历，每个结点被遍历后加入到结果中，并且设定该结点已经被访问过。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS_Graph1</span><span class="params">(<span class="keyword">int</span> graph[][])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;<span class="comment">//求得结点的个数</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">    <span class="comment">/*Step1：依次遍历树中还未被遍历的结点*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="keyword">false</span>)&#123;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            list.add(i);</span><br><span class="line">            <span class="comment">/*Step2:深度遍历以结点i为开始的路径上的结点*/</span>          DFS(graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度递归遍历以图中node结点为起点的结点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> graph[][],<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">        <span class="comment">/*这个当前结点可达且未被访问的结点j才可以*/</span></span><br><span class="line">        <span class="keyword">if</span>(graph[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="keyword">false</span>)&#123;</span><br><span class="line">            visited[j] = <span class="keyword">true</span>;</span><br><span class="line">            list.add(j);</span><br><span class="line">            DFS(graph,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法二：不采用递归的方式而是采用栈保存已经遍历过并且还有其孩子结点可能还没有遍历过的结点。</span></span><br><span class="line"><span class="comment"> * 与递归方式中一样，也是定义一个标志数组表示某个结点是否已经被访问过。</span></span><br><span class="line"><span class="comment"> * 初始化栈内存放第一个结点。</span></span><br><span class="line"><span class="comment"> * 判断栈顶元素的第一个还未被访问邻接点，把它压入到栈中，每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。</span></span><br><span class="line"><span class="comment"> * 如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。</span></span><br><span class="line"><span class="comment"> * 一直循环直到栈空。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS_Graph2</span><span class="params">(<span class="keyword">int</span> graph[][])</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">    <span class="comment">/*Step1:把初始第一个结点放到栈内*/</span></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Step2:找栈顶元素的第一个还未被访问邻接点，把它压入到栈中，</span></span><br><span class="line"><span class="comment"> * 每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。 </span></span><br><span class="line"><span class="comment"> * 如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。</span></span><br><span class="line"><span class="comment"> * 循环结束的条件是栈为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> i = stack.peek();<span class="comment">//读栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*找栈顶元素的第一个未被访问的邻接点*/</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;size;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="keyword">false</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;size)&#123;<span class="comment">//说明找到了</span></span><br><span class="line">            visited[j] = <span class="keyword">true</span>;</span><br><span class="line">            list.add(j);</span><br><span class="line">            stack.push(j);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//只有当前栈顶元素不存在未被访问的邻接点时才弹出栈顶元素</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-图的广度优先遍历BFS"><a href="#2-图的广度优先遍历BFS" class="headerlink" title="2.  图的广度优先遍历BFS"></a>2.  图的广度优先遍历BFS</h3><p>​    借助队列实现，同时设置一个包含结点个数的visited数组表示某个结点是否已经被遍历过。<br>    初始化时把第一个结点加入到结果list中，并且把visited[0]设置为true。<br>    循环开始时队列中存储的是图中的第一个结点，循环结束的条件是队列变成空。<br>    循环体内取出队列的第一个元素，并且把这个元素的所有未被访问过的邻接点都加入到队列中、加入到结果list中、设置其对应的状态为已访问。</p><p>​    类似于树的层次遍历.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的广度优先遍历。</span></span><br><span class="line"><span class="comment"> * 借助队列实现，同时设置一个包含结点个数的visited数组表示某个结点是否已经被遍历过。</span></span><br><span class="line"><span class="comment"> * 初始化时把第一个结点加入到结果list中，并且把visited[0]设置为true。</span></span><br><span class="line"><span class="comment"> * 循环开始时队列中存储的是图中的第一个结点，循环结束的条件是队列变成空。</span></span><br><span class="line"><span class="comment"> * 循环体内取出队列的第一个元素，并且把这个元素的所有未被访问过的邻接点都加入到队列中、加入到结果list中、设置其对应的状态为已访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BFS_Graph</span><span class="params">(<span class="keyword">int</span> graph[][])</span></span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> size = graph.length;</span><br><span class="line">visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line"><span class="comment">/*Step1:把初始第一个结点放到栈内。*/</span></span><br><span class="line">queue.add(<span class="number">0</span>);</span><br><span class="line">visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">list.add(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="comment">/*Step2:循环队列中的元素直到队列为空。*/</span></span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">i = queue.poll();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;size;j++)&#123;<span class="comment">//找刚刚被弹出队列的队头元素可达的点</span></span><br><span class="line"><span class="keyword">if</span>(graph[i][j] ==<span class="number">1</span> &amp;&amp; visited[j] == <span class="keyword">false</span>)&#123;</span><br><span class="line">visited[j] = <span class="keyword">true</span>;</span><br><span class="line">list.add(j);</span><br><span class="line">queue.add(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="八、海量数据处理"><a href="#八、海量数据处理" class="headerlink" title="八、海量数据处理"></a>八、海量数据处理</h2><p>​    通过对海量数据的挖掘能有效地揭示用户的行为模式，加深对用户需求的理解，提取用户的集体智慧，从而为研发人员决策提供依据，提升产品用户体验，进而占领市场。</p><p>​    海量处理的基本方法：</p><p><strong>1.  Hash法</strong><br>    构造hash表和处理冲突的方法和上面介绍的一样。<br>    在处理海量数据的过程中，使用Hash方法一般可以快速存取、统计某些数据，将大量数据进行分类，例如提取某日访问网站次数最多的ip。</p><p><strong>2.  BitMap法</strong><br>    BitMap(位图)法的基本原理是使用数组来表示某些元素是否存在。<br>    BitMap(位图)法的时间复杂度为O(n)，比一般的排序都快，但它是以空间换时间，而且又一些限制，即数据状态不是很多，例如排序前集合大小最好已知，而且集合中元素的最大重复次数必须已知。</p><p><strong>3.  Bloom Filter 法（适用于对低错误率可以容忍的场合）</strong><br>    Bloom Filter是一种空间效率和时间效率都很高的随机数据结构，可用来检测一个元素是否属于一个集合。其基本原理是位数组与Hash函数的联合使用。首先，Bloom Filter是一个包含m位的位数组，数组的每一位都初始化为0；其次定义k个不同的hash函数，每个函数都可以将集合中的元素映射到位数组中的某一位，这样k个hash函数就将某个元素映射到了位数组中的k个位。查询的时候，根据k个hash函数可以得到数组中的k个位，判断这个k个位是否全为1，若是则说明该元素可不存在。插入的时候，把k个hash函数就将某个元素映射到了位数组中的k个位全部置为1。<br>    Bloom Filter的难点是如何根据输入元素个数n确定m和hash函数。<br>    <strong>特点：</strong>确定不存在的元素一定不存在，确定存在的数据不一定存在。Bloom Filter只能插入不能删除元素。<br>    <strong>优点：</strong>具有很好的空间效率和时间效率，它的插入和查询时间都是常数，另外它不保存元素本身，具有良好的安全性。<br>    <strong>缺点：</strong>牺牲了正确率，当它判断一个元素已存在于集合中时可能不正确。因为可能该元素对应的k个1位可能是被其他多个元素导致的。</p><p><strong>4.  数据库优化法</strong><br>    互联网上的数据一般都是被存储到数据库中，如何从数据库中存储的海量信息中提取对自己有用的信息就涉及到了数据的查询技术等相关内容。<br>    常见的数据库优化方法有数据分区、索引、缓存机制、分批处理、优化查询语句、使用采样数据进行数据挖掘等。</p><p><strong>5.  倒排索引法</strong><br>    倒排索引是目前搜索引擎公司对搜索引擎最常用的存储方式，也是搜索引擎的核心内容。按照关键字建立索引，关键字指向了包含它的文档。优点是在处理复杂的多关键字时，可在倒排表中完成查询的并、交等逻辑运算，得到结果后再对结果进行存取，这样把记录的查询转换为地址集合的运算，不必对每个记录随机存取，从而提高查找速度。</p><p><strong>6.  外排序法</strong><br>    外排序是相对于内部排序而言的，它是大文件的排序，由于内存限制，不能一下子把所有的待排内容都读到内存中进行排序，需要在内存和外部存储器之间进行多次数据交换才能达到对整个文件进行排序的目的。<br>    一般采用归并排序等方式进行外部排序，首先生成若干个子文件，分别对这些子文件进行排序，然后对这些子文件进行多次归并，使得有序的归并段主键扩大，最后在外存上形成整个文件的单一归并段。<br>    外排序适用于大数据的排序以及去重，但外排序的缺陷是会消耗大量的IO，效率不高。</p><p><strong>7.  Trie树</strong><br>    Trie树是一种用于快速字符串检索的多叉树结果 ，原理是利用字符串的公共前缀来减少空间开销。经常被搜索引擎系统用于文件词频统计。优点是：最大限度地减少无谓的字符串比较，查询效率比散列表高。适合用于数据量大，重复多，但是数据种类小可以放入内存的情况。<br>    但是当系统中存在大量字符串且字符串基本没有公共前缀，则相应的Trie树会非常消耗内存。</p><p><strong>8.  堆</strong></p><table><thead><tr><th>堆类别</th><th>作用</th></tr></thead><tbody><tr><td>最大堆</td><td>求前k小</td></tr><tr><td>最小堆</td><td>求前k大</td></tr><tr><td>双堆</td><td>中位数</td></tr></tbody></table><p>​    比如用最小堆求前k个最大的元素：<br>    先从待找的n个数字中找出前k个建成小顶堆，然后依次读后面的元素并与小顶堆的堆顶进行比较，如果当前元素小或相等（这个相等是自己加的，需要进一步验证，应该是正确的，因为此时的堆顶元素是前k个里面最小的。如果遇到相等的即使该元素在最后前k个里面，也可以不要那个元素因为之前的已经够k个了，不需要再进行替换了），则继续读后面的元素；如果当前的元素大，则用当前元素替换堆顶元素，然后调整小顶堆。</p><p><strong>9.  双层桶法</strong><br>    双层桶不是一种数据结构 ，而是一种算法思想，类似于分治思想。因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。<br>    桶排序一般适用于寻找第k个大的数，寻找中位数、寻找不重复或重复的数字。<br>    如：1）在一个文件中有10G个整数，乱序排列，要求找出中位数，内存限制是2GB；<br>    2）现在有一个0~30000的随机数生成器。请根据这个随机数生成器，设计一个抽奖范围是0~350000彩票中奖号码列表，其中要包含20000个中奖号码</p><p><strong>10.  MapReduce法</strong></p><p>​    MapReduce是云计算的核心技术之一，是一种简化并行计算的分布式编程模型，主要目的是为了大型集群的系统能在大数据集上进行并行工作，并用于大规模数据的并行运算。<br>    海量数据处理的最大难题在于数据规模巨大，使得传统处理方式面临计算能力不和存储能力不足的瓶颈问题，而基于Hadoop可以非常轻松和方便完成处理海量数据的分布式并行程序，并运行在大规模集群上。</p><h2 id="九、红黑树"><a href="#九、红黑树" class="headerlink" title="九、红黑树"></a>九、红黑树</h2><p><strong>1.  性质</strong><br>    红黑树是一棵二叉搜索树，它在每个结点上增加了一个存储位来表示结点的颜色，是黑色还是红色。<br>    通过任何一条从根到叶子的简单路径上各个结点的颜色进行约束，==红黑树确保没有一条路径会比其他路径长出两倍==，因此也是近似于平衡的。<br>一棵红黑树是确保满足下面红黑性质的<strong>二叉搜索树</strong>。<br>    ① 每个节点要么是红色的要么是黑色的；<br>    ② 根节点是黑色的；<br>    ③ 每个叶节点(NIL)是黑色的；<br>    ④ 若一个结点是红色的，则它的两个孩子结点都是黑色的；<br>    ⑤ 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。</p><p><strong>2.  黑高</strong><br>    从某个结点x(不包含该结点)出发到达一个叶结点的任意一条简单路径的黑色结点个数称为该结点的黑高(black-height)，记为bh(x)。<br>    定义红黑树的黑高为其根结点的黑高。<br>    对于给定的黑色高度为n的红黑树，从根到叶结点的简单路径的最短长度为(n-1)，从根到叶结点的简单路径的最大长度为2(n-1).</p><p><strong>3.  定理</strong><br>一个有n个内部结点的红黑树的高度至多为2lg(n+1).</p><p><strong>4.  操作</strong><br>    默认插入的节点颜色都是红色，因为插入黑色节点会破坏根路径上的黑色节点总数，但即使如此，也会出现连续红色节点的情况。因此在一般的插入操作之后，出现红黑树约束条件不满足的情况（称为失去平衡）时，就必须要根据当前的红黑树的情况做相应的调整其他。</p><p><strong>5.  其他</strong><br>    红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求。降低了对旋转的要求，从而提高了性能。<br>    红黑树能够以O(lgn)的时间复杂度进行搜索，插入和删除操作，此外，由于红黑树的设计，任何不平衡都会要求在三次旋转之间解决。<br>    红黑树并不应用所有应用树的领域。如果数据基本上是静态的，那么让数据待在能够插入，并且不影响平衡的地方具有更好的性能。如果数据是完全静态的，例如，做一个hash表，性能可能会更好一点。<br>    在实际的系统中，需要使用动态规划的防火墙系统，使用红黑树而不是散列表，被实践证明具有更好的伸缩性。</p><p>参考资料：<a href="http://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">最容易懂得红黑树</a></p><p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md</a></p><h2 id="十、数据结构——位图（bitmap）"><a href="#十、数据结构——位图（bitmap）" class="headerlink" title="十、数据结构——位图（bitmap）"></a>十、数据结构——位图（bitmap）</h2><p><strong>定义</strong></p><p>​    位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。</p><p><strong>先了解一下位运算的基础知识：</strong></p><p>​    所有比特的编号方法是：从低字节的低位比特位开始，第一个bit为0，最后一个bit为 n-1。</p><p>​    比如，给出一个数组：int[] array = new int[4]。那么：</p><p>​        a[0] – a[4] 的比特位分别为：0–31,32–63,64–95,96–127</p><p>​    下面我们依据一个程序探究数组比特位的编号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = array[i] &gt;&gt; <span class="number">4</span>;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    结果是输出了4个1，也就是说刚开始比特位编排为：0000 0000 0001 0000，使用位运算，使其右移了4位，变为：0000 0000 0000 0001.</p><p><strong>利用位运算&amp; 进行取模</strong></p><p>​    位运算跟取模运算之间联系微妙，具体可从下面的例子中看出来：</p><p>​    100%32；100&amp;31</p><p>​    上述公式的结果是一样的，让我们探究一下他们的原理：</p><p>​    100%32 的取余运算，将取到一百减去3个32之后的余数为4。 100&amp;31是进行按位与运算，31=0001 1111；100=0110 0100，当他们进行按位与时，大于等于32的那部分将给消去，留下的便是余数。</p><p>​    当然上述运算成立的条件便是做取模运算的后一个数字必须是2的N次幂，也就是32对应位置的数必须是2的N次幂。</p><p><strong>特定位的设置与清除</strong></p><p>​    假如现在 int a = 0; 现在a的编码全部为0，现在要将其从右往左第5个位置设置为1，然后再清除上述操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    a |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);     <span class="comment">// | 按位或操作 ,双目运算符 a = a|(1&lt;&lt;5);</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">    a &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);    <span class="comment">// &amp; 按位与操作，双目运算符， ~ 按位非操作，单目运算符</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    上述运算的结果分别为32 0.</p><p><strong>字节位置与位位置</strong></p><pre><code>一个int是4个字节，每个字节有32bit，我们可以将数据存储在这些位内。比如我们要存储100这个数，我们只需在位置100存储一个1。将第100位置为1，也就是说最少需要有100个位置，每个位置1bit，100个位置需要12.5字节，因为一个int型是4字节，所以我们需要定义一个数组 int[4]。</code></pre><p>​    现在我们要对这个数组的100位进行操作，首先要知道100在这个数组中的第几个元素，每个数组元素都是32位，那么100所在的位置就是100/32，也就是 100&gt;&gt;5。然后在元素中的位置也就是：100%32，也就是100&amp;31，也就是100&amp;0x1F。</p><p><strong>给一个例子：</strong></p><p>​    给40亿个不重复的unsigned int的整数，没有排过序，然后再给一个数，如果快速判断这个数是否在那40亿个数当中。</p><p>​    因为unsigned int数据的最大范围在在40亿左右（需要40亿bit），40<em>10^8/1024</em>1024*8=476，因此只需申请512M的内存空间，每个bit位表示一个unsigned int。读入40亿个数，并设置相应的bit位为1.然后读取要查询的数，查看该bit是否为1，是1则存在，否则不存在。</p><p><strong>优缺点</strong></p><p>(1) 可读性差</p><p>(2) 位图存储的元素个数虽然比一般做法多，但是存储的元素大小受限于存储空间的大小。位图存储性质：存储的元素个数等于元素的最大值。比如， 1K 字节内存，能存储 8K 个值大小上限为 8K 的元素。（元素值上限为 8K ，这个局限性很大！）比如，要存储值为 65535 的数，就必须要 65535/8=8K 字节的内存。要就导致了位图法根本不适合存 unsigned int 类型的数（大约需要 2^32/8=5 亿字节的内存）。</p><p>(3 )位图对有符号类型数据的存储，需要 2 位来表示一个有符号元素。这会让位图能存储的元素个数，元素值大小上限减半。 比如 8K 字节内存空间存储 short 类型数据只能存 8K*4=32K 个，元素值大小范围为 -32K~32K 。</p><p><strong>总结</strong></p><p>​    Bitmap是一种非常简洁快速的数据结构，他能同使证存储空间和速度最优化（而不必空间换时间）。</p><p>参考资料：<a href="http://blog.csdn.net/lx18792732127/article/details/70545028" target="_blank" rel="noopener">【数据结构】中的位图详解</a></p><p>​            <a href="http://www.cnblogs.com/tf-Y/p/5284560.html" target="_blank" rel="noopener">数据结构–位图</a></p><p>​                    <a href="http://blog.163.com/xb_stone_yinyang/blog/static/2118160372013625112558579/" target="_blank" rel="noopener">编程珠玑——位图数据结构</a></p><h2 id="十二、二叉排序-查找树"><a href="#十二、二叉排序-查找树" class="headerlink" title="十二、二叉排序/查找树"></a>十二、二叉排序/查找树</h2><p><strong>定义</strong>:</p><p>​    二叉排序树（Binary Sort Tree）又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树：<br>    若它的左子树不为空，则左子树上所有结点的值均小于它的根结构的值；<br>    若它的右子树不为空，则右子树上所有结点的值均大于它的根结构的值；<br>    它的左、右子树也分别为二叉排序树（递归）。</p><p>​    zhg 口诀： 左小右大</p><p>​    说的直白一点，就是具有左子树上的值&lt;根节点的值&lt;右子树上的值的二叉树，我们称之为二叉排序树。</p><p>​    基于二叉排序树的特点，又结合着中序遍历的特点（中序遍历是先遍历左子树，再遍历根节点，然后遍历右子树），我们不难发现，<strong>二叉排序树的中序遍历的结果是从小到大有序的</strong>。下方我们会先给出二叉排序树的创建，然后给出二叉排序树的节点删除的代码。</p><h3 id="1-二叉排序树的创建"><a href="#1-二叉排序树的创建" class="headerlink" title="1. 二叉排序树的创建"></a>1. 二叉排序树的创建</h3><p>​    上面也简单的提了一下，二叉排序树的创建无非就是不断查找和插入的过程，当我们查找某个值没有找到时，我们就会将该值插入到二叉排序树中。因为再查找的过程中可以确定该结点要插入的合适位置，所以插入就显得比较简单了。</p><p><strong>(1) 二叉排序树的查找与插入的示意图</strong></p><p>​    我们要将集合{62, 88, 58, 47, 35, 73, 51, 99, 37, 93}中的元素放入到我们的二叉排序树中去存储，如果对我们创建好的二叉排序树进行中序搜索的话，输出的结果就是上面集合的有序序列。下方就是我们二叉排序树从无到有的完整创建过程。</p><p>​    （1）、在初始化状态下我们二叉排序树的根节点为空，我们依次将集合中的元素通过搜索插入到二叉排序树中合适的位置。</p><p>​    （2）、首先在二叉排序中进行搜索62的位置，树为空，所以将62存入到二叉排序树的根节点中，及root=(62)。</p><p>​    （3）、从集合中取出88，然后查找我们的二叉排序树，发现88大于我们的根节点62，所以将88插入到62节点的右子树中，即(62)-&gt;rightChild=(88)。</p><p>​    （4）、从集合中取出58，然后从根节点开始查找我们现有的二叉排序树，发现55\&lt;62，将55作为62的左结点，即(62)-&gt;leftChild=(55)。</p><p>​    （5）、从集合中取出47，然后对二叉排序树进行搜索，发现47\&lt;55, 所以(55)-&gt;leftChild=(47)。</p><p>​    （6）、从集合中取出35，再次对二叉排序树进行搜索，发现35又小于47，所以(47)-&gt;leftChild=(35)</p><p>​    （7）、从集合中取出73，再次对二叉排序树进行搜索，发现62\&lt;73\&lt;88, 所以有(88)-&gt;leftChild=(73)。</p><p>​    以此类推，要做的事情就是不断从集合中取值，然后对二叉排序树进行查找，找到合适的插入点，然后将相应的节点进行插入，具体步骤就不做过多赘述了。</p><p><img src="\image\数据结构\二叉排序树的创建过程.png" alt="叉排序树的创建过"></p><p><img src="\image\数据结构\二叉排序树的创建过程-2.png" alt="叉排序树的创建过程-"></p><p><strong>(2) 二叉排序树的查找</strong></p><p>​    查找过程中要保存当前节点的父节点，如果查找失败，即在二叉排序树中没有查找到给定的元素，那么就要返回插入的位置。要注意父节点为空的情况，那表明现在二叉排序树为空树。插入的时候在和父节点的数据比较一下大小，给定元素小，那么就插入到左孩子，否则就插入到右孩子。<img src="\image\数据结构\二叉排序树-查找.png" alt="叉排序树-查"></p><p><strong>(3) 二叉排序树的插入</strong></p><p>​    插入操作比较简单，只要通过查找操作找到元素的插入位置，那么就可以根据插入位置进行插入操作了。</p><p><img src="\image\数据结构\二叉排序树-插入.png" alt="叉排序树-插"></p><p><img src="\image\数据结构\二叉排序树-插入-2.png" alt="叉排序树-插入-"></p><h3 id="2-二叉排序树结点的删除"><a href="#2-二叉排序树结点的删除" class="headerlink" title="2. 二叉排序树结点的删除"></a>2. 二叉排序树结点的删除</h3><p>​    二叉排序树的结点删除要比二叉排序树结点的插入要复杂一些，不过也并不难，要分为几种情况进行讨论。二叉排序树结点的插入与删除都是在查找的基础上来做的。</p><p>​    下面分为3种情况进行讨论：</p><p>​    (1) 若*p结点为叶子节点，即$P_L$和$P_R$均为空树。由于删除叶子节点不会破坏整棵树的结构，则只需要修改其双亲节点的指针即可。</p><p>​    (2) 若<em>P结点只有左子树$P_L$或者只有右子树$P_R$，此时只要令$P_L$或$P_R$直接成为双亲节点\</em>f的左子树即可。显然，做此修改也不破坏二叉排序树的特性。</p><p>​    (3) 若<em>p结点的左子树和右子树均不为空。显然此时不能像上面一样简单处理。因为二叉排序树的中序遍历是从小到大有序的，所以我们只需要让\</em>P的前驱或者后继来替代*P就可以了。</p><p><img src="\image\数据结构\二叉排序树删除节点-示意图.png" alt="叉排序树删除节点-示意"></p><p><img src="\image\数据结构\二叉树排序树-删除节点-算法1.png" alt="叉树排序树-删除节点-算法"></p><p><img src="\image\数据结构\二叉树排序树-删除节点-算法2.png" alt="叉树排序树-删除节点-算法"></p><p><img src="\image\数据结构\二叉树排序树-删除节点-算法2-1.png" alt="叉树排序树-删除节点-算法2-"></p><p>​    在随机的情况下，二叉排序树的平均查找长度和$\log_2 n$是等数量级的。然而，在某些情况下（有人研究证明，这种情况出现的概率约为46.5%），尚需要在构成二叉排序树的过程中进行“平衡化”处理，成为二叉平衡树。</p><p>​    参考资料：<a href="http://blog.fishc.com/3077.html" target="_blank" rel="noopener">二叉排序树（二叉查找树）- 数据结构和算法73</a></p><p>​                <a href="http://www.cnblogs.com/ludashi/p/6004024.html" target="_blank" rel="noopener">算法与数据结构(十) 二叉排序树的查找、插入与删除(Swift版)</a></p><h2 id="十三、平衡二叉树-AVL"><a href="#十三、平衡二叉树-AVL" class="headerlink" title="十三、平衡二叉树(AVL)"></a>十三、平衡二叉树(AVL)</h2><p>​    在平衡树上进行查找的时间复杂度为$O(\log n)$。  </p><p>​    <strong>平衡二叉树</strong>（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。若将二叉树上节点的平衡因子BF（Balance Factor）定义为该结点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。如图9.11(a)所示为两颗平衡二叉树，而图9.11（b）所示为两颗不平衡的二叉树，结点中的值为该结点的平衡因子。</p><p><img src="\image\数据结构\平衡与不平衡的二叉树.png" alt="衡与不平衡的二叉"></p><p>​    对于序列（13，24, 37，90，53 ）插入过程如下图所示：</p><p><img src="\image\数据结构\平衡树的生成过程.png" alt="衡树的生成过"></p><p>​                        </p><p>​    一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指 针为a(即a是离插入结点最近，且平衡因子绝对值超过1的祖先结点），则失去平衡后进 行调整的规律可归纳为下列4种情况：</p><p>​    (1)    单向右旋平衡处理：由于在<em> a的左子树根结点的左子树上插入结点，</em> a的平 衡因子由1增至2，致使以* a为根的子树失去平衡，则需进行一次向右的顺时针旋转操 作，如图9. 13(a)所示。</p><p>​    (2)    单向左旋平衡处理：由于在<em> a的右子树根结点的右子树上插入结点，</em> a的平 衡因子由-1变为-2,致使以*a为根结点的子树失去平衡，则需进行一次向左的逆时针旋转操作。如图9. 13(c)所示。</p><p>​    (3)    双向旋转（先左后右）平衡处理：由于在<em> a的左子树根结点的右子树上插入结点，</em> a的平衡因子由1增至2，致使以*a为根结点的子树失去平衡，则需进行两次旋转(先左旋后右旋)操作。如图9. 13(b)所示。</p><p>​    (4)    双向旋转（先右后左）平衡处理：由于在<em> a的右子树根结点的左子树上插人结点，</em> a的平衡因子由-1变为-2，致使以* a为根结点的子树失去平衡，则需进行两次 旋转（先右旋后左旋)操作。如图9. 13(d)所示。</p><p><img src="\image\数据结构\二叉排序树的平衡旋转图例.png" alt="叉排序树的平衡旋转图">    </p><p>​                图9.13  二叉排序树的平衡旋转图例</p><p>​            (a) LL型；     (b) LR型；     (c) RR型 ；    (d) RL型；    </p><p>​    上述4种情况中，（1）和（2）对称，（3)和（4）对称。旋转操作的正确性容易由“保持二叉排序树的特性：中序遍历所得关键字序列自小至大有序”证明之。同时，从图9. 13可 见，无论哪一种情况，在经过平衡旋转处理之后，以*b或*C为根的新子树为平衡二叉 树，而且它的深度和插人之前以* a为根的子树相同。因此，当平衡的二叉排序树因插人结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。因为经过旋转处理之后的子树深度和插入之前相同，因而不影响插人路径上所有祖先结点的平衡度。     </p><p>参考资料：<u>数据结构-C语言版（P233  平衡二叉树）</u>  </p><h2 id="十四、并查集-Disjoint-Set-Union-DSU-data-structure"><a href="#十四、并查集-Disjoint-Set-Union-DSU-data-structure" class="headerlink" title="十四、并查集 (Disjoint Set Union (DSU) data structure)"></a>十四、并查集 (Disjoint Set Union (DSU) data structure)</h2><p> <strong>Disjoint Set Union (DSU) data structure    </strong></p><p>​    这个是摘自LeetCode上684题的题解，对于并查集描述的很清晰。</p><p>A DSU data structure can be used to maintain knowledge of the connected components of a graph, and query for them quickly.  In particular, we would like to support two operations:</p><ul><li><code>dsu.find(node x)</code>, which outputs a unique id so that two nodes have the same id if and only if they are in the same connected component, and:</li><li><code>dsu.union(node x, node y)</code>, which draws an edge <code>(x, y)</code> in the graph, connecting the components with id <code>find(x)</code> and <code>find(y)</code> together.</li></ul><p>To achieve this, we keep track of <code>parent</code>, which remembers the <code>id</code> of a smaller node in the same connected component.  If the node is it’s own parent, we call this the <em>leader</em> of that connected component.</p><p>A naive implementation of a DSU structure would look something like this:</p><p><em>Psuedocode</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent initialized as (x -&gt; x)</span></span><br><span class="line">function find(x):</span><br><span class="line">    <span class="keyword">while</span> parent[x] != x: <span class="comment">#While x isn't the leader</span></span><br><span class="line">        x = parent[x]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">function union(x, y):</span><br><span class="line">    parent[find(x)] = find(y)</span><br></pre></td></tr></table></figure></p><p>We use two techniques to improve the run-time complexity: <em>path compression</em>, and <em>union-by-rank</em>.</p><ul><li>Path compression involves changing the <code>x = parent[x]</code> in the <code>find</code> function to <code>parent[x] = find(parent[x])</code>.  Basically, as we compute the correct leader for x, we should remember our calculation.</li><li>Union-by-rank involves distributing the workload of <code>find</code> across leaders evenly.  Whenever we <code>dsu.union(x, y)</code>, we have two leaders <code>xr, yr</code> and we have to choose whether we want <code>parent[x] = yr</code> or <code>parent[y] = xr</code>.  We choose the leader that has a higher following to pick up a new follower.<br>Specifically, the meaning of <code>rank</code> is that there are less than <code>2 ^ rank[x]</code> followers of <code>x</code>.  This strategy can be shown to give us better bounds for how long the recursive loop in <code>dsu.find</code> could run for.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = range(<span class="number">1001</span>)</span><br><span class="line">        self.rnk = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        xr, yr = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> xr == yr:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> self.rnk[xr] &lt; self.rnk[yr]:</span><br><span class="line">            self.par[xr] = yr</span><br><span class="line">        <span class="keyword">elif</span> self.rnk[xr] &gt; self.rnk[yr]:</span><br><span class="line">            self.par[yr] = xr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.par[yr] = xr</span><br><span class="line">            self.rnk[xr] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>   <span class="comment">#求解的题目是leetCode的684题</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges)</span>:</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dsu.union(*edge):</span><br><span class="line">                <span class="keyword">return</span> edge</span><br></pre></td></tr></table></figure></li></ul><p><em>Alternate Implementation of DSU without Union-By-Rank</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = range(<span class="number">1001</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.par[self.find(x)] = self.find(y)</span><br></pre></td></tr></table></figure></p><p>Java语言实现的求解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MAX_EDGE_VAL = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        DSU dsu = <span class="keyword">new</span> DSU(MAX_EDGE_VAL + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dsu.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DSU</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) parent[i] = i;</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xr = find(x), yr = find(y);</span><br><span class="line">        <span class="keyword">if</span> (xr == yr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[xr] &lt; rank[yr]) &#123;</span><br><span class="line">            parent[xr] = yr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[xr] &gt; rank[yr]) &#123;</span><br><span class="line">            parent[yr] = xr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[yr] = xr;</span><br><span class="line">            rank[xr]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Complexity Analysis</strong></p><ul><li>Time Complexity:  $O(Nα(N))≈O(N)$, where $N$ is the number of vertices (and also the number of edges) in the graph, and α\alphaα is the <em>Inverse-Ackermann</em> function.  We make up to $N$ queries of <code>dsu.union</code>, which takes (amortized) $O(\alpha(N))$ time.  Outside the scope of this article, it can be shown why <code>dsu.union</code> has $O(\alpha(N))$ complexity, what the Inverse-Ackermann function is, and why $O(\alpha(N))$ is approximately $O(1)$.</li><li>Space Complexity:  $O(N)$.  The current construction of the graph (embedded in our <code>dsu</code> structure) has at most $N$ nodes.</li></ul><p><strong>一个生动的例子讲解</strong></p><p>例子就是杭电上的畅通工程：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1232</a></p><p>​    首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。</p><p>​    如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……</p><p>​    以下面这组数据输入数据来说明</p><p>​    4 2 1 3 4 3</p><p>​    第一行告诉你，一共有4个点，2条路。下面两行告诉你，1、3之间有条路，4、3之间有条路。那么整幅图就被分成了1-3-4和2两部分。只要再加一条路，把2和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。 这可如何是好？</p><p>​    我以前也不会呀，自从用了并查集之后，嗨，效果还真好！我们全家都用它！</p><p>​    并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1010</span>]; <span class="comment">//存放第i个元素的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span> <span class="comment">//查找根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> son, tmp;</span><br><span class="line">son = root;</span><br><span class="line"><span class="keyword">while</span>(root != pre[root]) <span class="comment">//寻找根结点</span></span><br><span class="line">root = pre[root];</span><br><span class="line"><span class="keyword">while</span>(son != root) <span class="comment">//路径压缩</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = pre[son];</span><br><span class="line">pre[son] = root;</span><br><span class="line">son = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1, <span class="keyword">int</span> root2)</span> <span class="comment">//判断是否连通，不连通就合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">x = unionsearch(root1);</span><br><span class="line">y = unionsearch(root2);</span><br><span class="line"><span class="keyword">if</span>(x != y) <span class="comment">//如果不连通，就把它们所在的连通分支合并</span></span><br><span class="line">pre[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    为了解释并查集的原理，我将举一个更有爱的例子。</p><pre><code>话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</code></pre><p>​    我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p><p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/crazy.gif" alt="抓狂">要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p><p><img src="\image\数据结构\并查集-武林帮派举例.gif" alt="查集-武林帮派举"></p><p>​    下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 </p><p>​    find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span> <span class="comment">//查找根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> son, tmp;</span><br><span class="line">son = root;</span><br><span class="line"><span class="keyword">while</span>(root != pre[root]) <span class="comment">//我的上级不是掌门</span></span><br><span class="line">root = pre[root];</span><br><span class="line"><span class="keyword">while</span>(son != root) <span class="comment">//我就找他的上级，直到掌门出现</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = pre[son];</span><br><span class="line">pre[son] = root;</span><br><span class="line">son = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root; <span class="comment">//掌门驾到~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/laugh.gif" alt="大笑">反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1, <span class="keyword">int</span> root2)</span> <span class="comment">//虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">x = unionsearch(root1);<span class="comment">//我老大是玄慈</span></span><br><span class="line">y = unionsearch(root2);<span class="comment">//我老大是灭绝</span></span><br><span class="line"><span class="keyword">if</span>(x != y) </span><br><span class="line">pre[x] = y; <span class="comment">//打一仗，谁赢就当对方老大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。</p><pre><code>设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低，以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。</code></pre><p><img src="\image\数据结构\并查集-路径压缩示意.gif" alt="查集-路径压缩示"></p><p>​    于是，问题圆满解决。。。。。。。。。</p><p>​    代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1010</span>]; <span class="comment">//里面全是掌门</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> son, tmp;</span><br><span class="line">son = root;</span><br><span class="line"><span class="keyword">while</span>(root != pre[root]) <span class="comment">//寻找掌门ing……</span></span><br><span class="line">root = pre[root];</span><br><span class="line"><span class="keyword">while</span>(son != root) <span class="comment">//路径压缩</span></span><br><span class="line">&#123;</span><br><span class="line">tmp = pre[son];</span><br><span class="line">pre[son] = root;</span><br><span class="line">son = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root; <span class="comment">//掌门驾到~</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num, road, total, i, start, end, root1, root2;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;num, &amp;road) &amp;&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">total = num - <span class="number">1</span>; <span class="comment">//共num-1个门派</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= num; ++i) <span class="comment">//每条路都是掌门</span></span><br><span class="line">pre[i] = i;</span><br><span class="line"><span class="keyword">while</span>(road--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;start, &amp;end); <span class="comment">//他俩要结拜</span></span><br><span class="line">root1 = unionsearch(start);</span><br><span class="line">root2 = unionsearch(end);</span><br><span class="line"><span class="keyword">if</span>(root1 != root2) <span class="comment">//掌门不同？踢馆！~</span></span><br><span class="line">&#123;</span><br><span class="line">pre[root1] = root2;</span><br><span class="line">total--; <span class="comment">//门派少一个，敌人（要建的路）就少一个</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, total);<span class="comment">//天下局势：还剩几个门派</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考资料：<a href="http://blog.csdn.net/niushuai666/article/details/6662911" target="_blank" rel="noopener">超有爱的并查集~</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;&lt;center&gt;数据结构&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;0-常见数据结构&quot;&gt;&lt;a href=&quot;#0-常见数据结
      
    
    </summary>
    
      <category term="编程基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Bash Shell学习</title>
    <link href="http://yoursite.com/2018/05/16/2_Bash%20Shell%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/05/16/2_Bash Shell学习/</id>
    <published>2018-05-16T04:05:41.000Z</published>
    <updated>2018-07-04T10:27:59.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bash-Shell学习"><a href="#Bash-Shell学习" class="headerlink" title="Bash Shell学习"></a>Bash Shell学习</h1><h2 id="bash-shell-小知识点"><a href="#bash-shell-小知识点" class="headerlink" title="bash shell 小知识点"></a>bash shell 小知识点</h2><p><strong>数组取值</strong></p><p>对于一个数组，在直接使用数组变量名取值得时候，其实是取得第一个元素值，如果想要取所有的元素值，要用符号@。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAMES=(Joe Jenny Sara Tony)</span><br><span class="line">echo $&#123;NAMES&#125;  #输出：Joe</span><br><span class="line">echo $&#123;NAMES[0]&#125;  #输出：Joe</span><br><span class="line">echo $&#123;NAMES[1]&#125;  #输出：Jenny</span><br><span class="line">echo $&#123;NAMES[@]  #输出：Joe Jenny Sara Tony</span><br></pre></td></tr></table></figure><p><strong>表达式求值</strong></p><p>在bash shell中，表达式求值的方式是：$$((数学表达式))，例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count=4</span><br><span class="line">count=$(($count - 1))</span><br></pre></td></tr></table></figure></p><p><strong>条件判断式中的中括号[]问题</strong></p><p>注意，在条件判断式中，中括号和后面的内容要有空格，否则可能shell识别不了。</p><p>例如 if [78 &gt; 45 ]; then 可能就会报”[78  识别不了这个命令”，正确的写法是 if [ 78 &gt; 45 ]; then。</p><p><strong>在单引号中解析变量值</strong></p><p>本来在单引号中的字符串中是不会解析变量值的，比如echo ‘\$2 is “\$2” ‘，输出结果就是”\$2 is “\$2” “ ，要想在单引号中解析变量值，需要在变量周围<strong>再使用单引号括起来</strong>，比如 echo ‘\$2 is ‘\$2’  ‘ </p><p>学习参考网址：<a href="https://www.learnshell.org/en/Hello%2C_World%21" target="_blank" rel="noopener">https://www.learnshell.org/en/Hello%2C_World%21</a></p><h2 id="基本了解"><a href="#基本了解" class="headerlink" title="基本了解"></a>基本了解</h2><p>对于Shell 脚本，其中第一行的”#!”不是一个注释，后面要跟上一个Shell解释器的全路径。这个路径可以告诉操作系统，这么文件中的内容是由解释器中的许多命令组成的。</p><p>一般Shell脚本都是”.sh”结尾。第一行的示例如下：</p><p><strong>#!/bin/bash</strong></p><p>“#”后面的跟的内容被认为是注释。</p><p>想查看当前活跃的Shell，并且查看它路径是什么，可以在命令行键入下面的命令：</p><p><strong>ps | grep $$</strong></p><blockquote><p>987 tty1 00:00:00 bash</p></blockquote><p>上面展示了你正在使用的是哪种类型的’bash’，下面的操作会找出Shell 脚本的全路径</p><p><strong>which bash</strong></p><blockquote><p>/bin/bash</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在bash中定义变量就直接使用“=”赋值，要注意一点就是”=”号两边是不能有空格的。</p><p>使用反斜杠”\”可以逃脱特殊字符。</p><p>使用单引号括起来的字符串，不会保留中间的任意空白字符，但是使用双引号括起来的字符串，是会保留任意的空白字符的。</p><p>可以使用命令的执行结果给变量赋值，但是执行的命令要使用反引号括起来，或者使用$()。</p><h2 id="传递参数到脚本"><a href="#传递参数到脚本" class="headerlink" title="传递参数到脚本"></a>传递参数到脚本</h2><p>可以给脚本传递参数，通过在执行脚本的时候，在脚本名字后面使用空格分隔参数，形成一个参数列表。</p><p>在脚本里面变量$1就是第一个参数，\$2就是第二个参数，以此类推。注意，变量\$0指向的是当前脚本。</p><p>==zhg:== 可以将脚本名字以及后面的参数看做是一个完整的数组，这样就和数组的下标编号对应上了。</p><p>变量’$#’保存的是参数个数。</p><p>变量‘$@’保存的是包含所有参数和空格的字符串。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组名和变量名一样，后面的初始化值使用（）括起来，值之间使用空格分隔。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_array=(apple banana "Fruit Basket" orange)</span><br><span class="line">new_array[2]=apricot</span><br></pre></td></tr></table></figure><p>可以使用${ #arrayname[@]}获取数组的长度，即元素个数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_array=(apple banana "Fruit Basket" orange)</span><br><span class="line">echo  $&#123; #my_array[@]&#125;</span><br></pre></td></tr></table></figure><p>数组元素可以通过下标访问，下标从0开始的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_array=(apple banana "Fruit Basket" orange)</span><br><span class="line">echo $&#123;my_array[3]&#125;                     # orange - note that curly brackets are needed</span><br><span class="line"><span class="meta">#</span> adding another array element</span><br><span class="line">my_array[4]="carrot"                    # value assignment without a $ and curly brackets</span><br><span class="line">echo $&#123; #my_array[@]&#125;                    # 5</span><br><span class="line">echo $&#123;my_array[$&#123; #my_array[@]&#125;-1]&#125;     # carrot</span><br></pre></td></tr></table></figure><h2 id="基本操作-Basic-Operators"><a href="#基本操作-Basic-Operators" class="headerlink" title="基本操作(Basic Operators)"></a>基本操作(Basic Operators)</h2><p><strong>算数运算</strong></p><p>在变量上的简单数学运算可以使用算法表达式：$((expression))</p><p>The basic operators are:</p><p><strong>a + b</strong> addition (a plus b)</p><p><strong>a - b</strong> substraction (a minus b)</p><p><strong>a * b</strong> multiplication (a times b)</p><p><strong>a / b</strong> division (integer) (a divided by b)</p><p><strong>a % b</strong> modulo (the integer remainder of a divided by b)</p><p>==<strong>a</strong> <strong>**</strong> <strong>b</strong> exponentiation (a to the power of b)==</p><h2 id="基础字符串操作"><a href="#基础字符串操作" class="headerlink" title="基础字符串操作"></a>基础字符串操作</h2><p>字符串长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>       1234567890123456</span><br><span class="line">STRING="this is a string"</span><br><span class="line">echo $&#123; #STRING&#125;            # 16</span><br></pre></td></tr></table></figure><p>抽取子串</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STRING=<span class="string">"this is a string"</span></span><br><span class="line">POS=1</span><br><span class="line">LEN=3</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;STRING:$POS:$LEN&#125;</span>   <span class="comment"># his</span></span><br></pre></td></tr></table></figure><p>子串替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 替换第一次出现的地方</span></span><br><span class="line">STRING="to be or not to be"</span><br><span class="line">echo $&#123;STRING[@]/be/eat&#125;        # to eat or not to be</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 替换所有出现的地方</span></span><br><span class="line">STRING="to be or not to be"</span><br><span class="line">echo $&#123;STRING[@]//be/eat&#125;        # to eat or not to eat</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除所有子串出现的地方（替换为空串）</span></span><br><span class="line">STRING="to be or not to be"</span><br><span class="line">echo $&#123;STRING[@]// not/&#125;        # to be or to be</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Replace occurrence of substring <span class="keyword">if</span> at the beginning of <span class="variable">$STRING</span></span></span><br><span class="line">STRING="to be or not to be"</span><br><span class="line">echo $&#123;STRING[@]/#to be/eat now&#125;    # eat now or not to be</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Replace occurrence of substring <span class="keyword">if</span> at the end of <span class="variable">$STRING</span></span></span><br><span class="line">STRING="to be or not to be"</span><br><span class="line">echo $&#123;STRING[@]/%be/eat&#125;        # to be or not to eat</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> replace occurrence of substring with shell <span class="built_in">command</span> output</span></span><br><span class="line">STRING="to be or not to be"</span><br><span class="line">echo $&#123;STRING[@]/%be/be on $(date +%Y-%m-%d)&#125;    # to be or not to be on 2012-06-14</span><br></pre></td></tr></table></figure><h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><p>基本条件判断结构为：</p><p><strong>if [ expression ]; then</strong></p><p>code if ‘expression’ is true</p><p><strong>fi</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME="John"</span><br><span class="line">if [ "$NAME" = "John" ]; then</span><br><span class="line">  echo "True - my name is indeed John"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>if-else</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAME="Bill"</span><br><span class="line">if [ "$NAME" = "John" ]; then</span><br><span class="line">  echo "True - my name is indeed John"</span><br><span class="line">else</span><br><span class="line">  echo "False"</span><br><span class="line">  echo "You must mistaken me for $NAME"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>else-if</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME="George"</span><br><span class="line">if [ "$NAME" = "John" ]; then</span><br><span class="line">  echo "John Lennon"</span><br><span class="line">elif [ "$NAME" = "George" ]; then</span><br><span class="line">  echo "George Harrison"</span><br><span class="line">else</span><br><span class="line">  echo "This leaves us with Paul and Ringo"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>A empty string or a string consisting of spaces or an undefined variable name, are evaluated as false. The expression can be a logical combination of comparisons: negation is denoted by <strong>!</strong> , logical AND (conjunction) is denoted by <strong>&amp;&amp;</strong>, and logical OR (disjunction) is denoted by <strong>||</strong>. Conditional expressions should be surroun-ded by double brackets [[ ]].</p><p>数学类型的比较</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comparison    Evaluated to true when</span><br><span class="line"><span class="meta">$</span><span class="bash">a -lt <span class="variable">$b</span>    <span class="variable">$a</span> &lt; <span class="variable">$b</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">a -gt <span class="variable">$b</span>    <span class="variable">$a</span> &gt; <span class="variable">$b</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">a -le <span class="variable">$b</span>    <span class="variable">$a</span> &lt;= <span class="variable">$b</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">a -ge <span class="variable">$b</span>    <span class="variable">$a</span> &gt;= <span class="variable">$b</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">a -eq <span class="variable">$b</span>    <span class="variable">$a</span> is equal to <span class="variable">$b</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">a -ne <span class="variable">$b</span>    <span class="variable">$a</span> is not equal to <span class="variable">$b</span></span></span><br></pre></td></tr></table></figure><p>字符串类型的比较</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">comparison    Evaluated to true when</span><br><span class="line">"$a" = "$b"     $a is the same as $b</span><br><span class="line">"$a" == "$b"    $a is the same as $b</span><br><span class="line">"$a" != "$b"    $a is different from $b</span><br><span class="line">-z "$a"         $a is empty</span><br></pre></td></tr></table></figure><p>注意，“=”号两边的空格符是需要的，还有字符串变量周围要有双引号””，以避免shell识别特殊字符。</p><p>在shell中，单引号’’内的变量是不解析的，例如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n=3</span><br><span class="line">echo '$n'   # 输出：$n</span><br></pre></td></tr></table></figure></p><p>但是，双引号括起来的变量是会进行解析的，例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n=3</span><br><span class="line">echo "$n"    #输出：3</span><br></pre></td></tr></table></figure></p><p><strong>case-in结构</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case "$variable" in</span><br><span class="line">    "$condition1" )</span><br><span class="line">        command...</span><br><span class="line">    ;;</span><br><span class="line">    "$condition2" )</span><br><span class="line">        command...</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>简单的case结构示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mycase=1</span><br><span class="line">case $mycase in</span><br><span class="line">    1) echo "You selected bash";;</span><br><span class="line">    2) echo "You selected perl";;</span><br><span class="line">    3) echo "You selected phyton";;</span><br><span class="line">    4) echo "You selected c++";;</span><br><span class="line">    5) exit</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>注意：case 后面的每一条语句都是以两个分号结尾的。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>bash中基本的<strong>for循环结构</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> basic construct</span></span><br><span class="line">for arg in [list]</span><br><span class="line">do</span><br><span class="line"> command(s)...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>简单for循环例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> loop on array member</span></span><br><span class="line">NAMES=(Joe Jenny Sara Tony)</span><br><span class="line">for N in $&#123;NAMES[@]&#125; ; do</span><br><span class="line">  echo "My name is $N"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> loop on <span class="built_in">command</span> output results</span></span><br><span class="line">for f in $( ls prog.sh /etc/localtime ) ; do</span><br><span class="line">  echo "File is: $f"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>bash中基本的<strong>while循环结构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># basic construct</span><br><span class="line">while [ condition ]</span><br><span class="line">do</span><br><span class="line"> command(s)...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>简单的while循环例子</p><p>The while construct tests for a condition, and if true, executes commands. It keeps looping as long as the condition is true.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COUNT=4</span><br><span class="line">while [ $COUNT -gt 0 ]; do</span><br><span class="line">  echo "Value of count is: $COUNT"</span><br><span class="line">  COUNT=$(($COUNT - 1))   #计算一个表达式  $((数学表达式))</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>bash中基本的<strong>until循环结构</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> basic construct</span></span><br><span class="line">until [ condition ]</span><br><span class="line">do</span><br><span class="line">command(s)...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>until循环的简单例子</p><p>The until construct tests for a condition, and if false, executes commands. It keeps looping as long as the condition is false (opposite of while construct)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COUNT=1</span><br><span class="line">until [ $COUNT -gt 5 ]; do</span><br><span class="line">  echo "Value of count is: $COUNT"</span><br><span class="line">  COUNT=$(($COUNT + 1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>break 和 continue 语句</strong></p><p>break和continue用于控制for，while和until循环结构。continue用于跳过剩下的特殊循环迭代，但是break是用于跳过整个剩下的循环。下面是例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Prints out 0,1,2,3,4</span></span><br><span class="line"></span><br><span class="line">COUNT=0</span><br><span class="line">while [ $COUNT -ge 0 ]; do</span><br><span class="line">  echo "Value of COUNT is: $COUNT"</span><br><span class="line">  COUNT=$((COUNT+1))</span><br><span class="line">  if [ $COUNT -ge 5 ] ; then</span><br><span class="line">    break</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Prints out only odd numbers - 1,3,5,7,9</span></span><br><span class="line">COUNT=0</span><br><span class="line">while [ $COUNT -lt 10 ]; do</span><br><span class="line">  COUNT=$((COUNT+1))</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Check <span class="keyword">if</span> COUNT is even</span></span><br><span class="line">  if [ $(($COUNT % 2)) = 0 ] ; then</span><br><span class="line">    continue</span><br><span class="line">  fi</span><br><span class="line">  echo $COUNT</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><p>shell中的函数就是一个子程序，实现了一些功能和操作。基本的函数结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> basic construct</span></span><br><span class="line">function_name &#123;</span><br><span class="line">  command...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单例子：</p><p>Functions are called simply by writing their names. A function call is equivalent to a command. Parameters may be passed to a function, by specifying them after the function name. The first parameter is referred to in the function as $1, the second as $2 etc.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function function_B &#123;</span><br><span class="line">  echo "Function B."</span><br><span class="line">&#125;</span><br><span class="line">function function_A &#123;</span><br><span class="line">  echo "$1"</span><br><span class="line">&#125;</span><br><span class="line">function adder &#123;</span><br><span class="line">  echo "$(($1 + $2))"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> FUNCTION CALLS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Pass parameter to <span class="keyword">function</span> A</span></span><br><span class="line">function_A "Function A."     # Function A.</span><br><span class="line">function_B                   # Function B.</span><br><span class="line"><span class="meta">#</span><span class="bash"> Pass two parameters to <span class="keyword">function</span> adder</span></span><br><span class="line">adder 12 56                  # 68</span><br></pre></td></tr></table></figure><h2 id="特殊变量-Special-Variables"><a href="#特殊变量-Special-Variables" class="headerlink" title="特殊变量(Special Variables)"></a>特殊变量(Special Variables)</h2><p>In last tutorial about shell function, you use “$1” represent the first argument passed to function_A. Moreover, here are some special variables in shell:</p><ul><li><code>$0</code> - The filename of the current script.|</li><li><code>$n</code> - The Nth argument passed to script was invoked or function was called.|</li><li><code>$#</code> - The number of argument passed to script or function.|</li><li><code>$@</code> - All arguments passed to script or function.|</li><li><code>$*</code> - All arguments passed to script or function.|</li><li><code>$?</code> - The exit status of the last command executed.|</li><li><code>$$</code> - The process ID of the current shell. For shell scripts, this is the process ID under which they are executing.|</li><li><code>$!</code> - The process number of the last background command.|<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line">echo "Script Name: $0"</span><br><span class="line">function func &#123;</span><br><span class="line">    for var in $*</span><br><span class="line">    do</span><br><span class="line">        let i=i+1</span><br><span class="line">        echo "The \$$&#123;i&#125; argument is: $&#123;var&#125;"</span><br><span class="line">    done</span><br><span class="line">    echo "Total count of arguments: $#"</span><br><span class="line">&#125;</span><br><span class="line">func We are argument</span><br></pre></td></tr></table></figure></li></ul><p>执行结果为：</p><blockquote><p>Script Name: ./prog.sh<br>The $1 argument is: We<br>The $2 argument is: are<br>The $3 argument is: argument<br>Total count of arguments: 3</p></blockquote><p><code>$@</code> and <code>$*</code> have different behavior when they were enclosed in double quotes.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line">function func &#123;</span><br><span class="line">    echo "--- \"\$*\""</span><br><span class="line">    for ARG in "$*"</span><br><span class="line">    do</span><br><span class="line">        echo $ARG</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo "--- \"\$@\""</span><br><span class="line">    for ARG in "$@"</span><br><span class="line">    do</span><br><span class="line">        echo $ARG</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line">func We are argument</span><br></pre></td></tr></table></figure><p><code>$@</code>会将参数分开，而<code>$*</code>会将参数组成的字符串看做是一个整体。</p><p>上面脚本的执行结果为：</p><blockquote><p>— “$*”<br>We are argument<br>— “$@”<br>We<br>are<br>argument</p></blockquote><h2 id="Bash陷阱命令-Bash-Trap-Command"><a href="#Bash陷阱命令-Bash-Trap-Command" class="headerlink" title="Bash陷阱命令 (Bash Trap Command)"></a>Bash陷阱命令 (Bash Trap Command)</h2><p>这一小节主要参看：<a href="https://www.learnshell.org/en/Bash_trap_command" target="_blank" rel="noopener">https://www.learnshell.org/en/Bash_trap_command</a></p><p>It often comes the situations that you want to catch a special signal/interruption/user input in your script to prevent the unpredictables.</p><p>Trap is your command to try:</p><ul><li><code>trap &lt;arg/function&gt; &lt;signal&gt;</code></li></ul><p>上面语句的意思是，只要捕捉到指定的信号(signal)，然后就执行前面的命令或者函数功能。</p><p><strong>example</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> traptest.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> notice you cannot make Ctrl-C work <span class="keyword">in</span> this shell, </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> try with your <span class="built_in">local</span> one, also remeber to chmod +x </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> your <span class="built_in">local</span> .sh file so you can execute it!</span></span><br><span class="line"></span><br><span class="line">trap "echo Booh!" SIGINT SIGTERM</span><br><span class="line">echo "it's going to run until you hit Ctrl+Z"</span><br><span class="line">echo "hit Ctrl+C to be blown away!"</span><br><span class="line"></span><br><span class="line">while true:         </span><br><span class="line">do</span><br><span class="line">    sleep 60       </span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>Surely you can substitute the <code>&quot;echo Booh!&quot;</code> with a function:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function booh &#123;</span><br><span class="line">    echo "booh!"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and call it in trap:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap booh SIGINT SIGTERM</span><br></pre></td></tr></table></figure><p>Some of the common signal types you can trap:</p><ul><li><code>SIGINT</code>: user sends an interrupt signal (Ctrl + C)</li><li><code>SIGQUIT</code>: user sends a quit signal (Ctrl + C)</li><li><code>SIGFPE</code>: attempted an illegal mathematical operation</li></ul><p>You can check out all signal types by entering the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br></pre></td></tr></table></figure><p>Notice the numbers before each signal name, you can use that number to avoid typing long strings in trap:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2 corresponds to SIGINT and 15 corresponds to SIGTERM</span></span><br><span class="line">trap booh 2 15</span><br></pre></td></tr></table></figure><h2 id="文件测试-File-Testing"><a href="#文件测试-File-Testing" class="headerlink" title="文件测试(File Testing)"></a>文件测试(File Testing)</h2><p>Often you will want to do some file tests on the file system you are running. In this case, shell will provide you with several useful commands to achieve it.</p><p>The command looks like the following</p><ul><li><code>-&lt;command&gt; [filename]</code></li><li><code>[filename1] -&lt;command&gt; [filename2]</code></li></ul><p>We will briefly introduce some common commands you might encounter in your daily life.</p><p><strong>Example</strong></p><p><strong>use “-e” to test if file exist</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line">filename="sample.md"</span><br><span class="line">if [ -e "$filename" ]; then</span><br><span class="line">    echo "$filename exists as a file"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>use “-d” to test if directory exists</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line">directory_name="test_directory"</span><br><span class="line">if [ -d "$directory_name" ]; then</span><br><span class="line">    echo "$directory_name exists as a directory"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>use “-r” to test if file has read permission for the user running the script/test</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line">filename="sample.md"</span><br><span class="line">if [ ! -f "$filename" ]; then # -f 判断 该『档名』是否存在且为文件(file)？</span><br><span class="line">    touch "$filename"</span><br><span class="line">fi</span><br><span class="line">if [ -r "$filename" ]; then</span><br><span class="line">    echo "you are allowed to read $filename"</span><br><span class="line">else</span><br><span class="line">    echo "you are not allowed to read $filename"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>具体的文件判断命令，可以参考《鸟哥的Linux私房菜》的第十二章学习Shell Scripts的第12.3小节善用判断式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bash-Shell学习&quot;&gt;&lt;a href=&quot;#Bash-Shell学习&quot; class=&quot;headerlink&quot; title=&quot;Bash Shell学习&quot;&gt;&lt;/a&gt;Bash Shell学习&lt;/h1&gt;&lt;h2 id=&quot;bash-shell-小知识点&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Bash Shell" scheme="http://yoursite.com/tags/Bash-Shell/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://yoursite.com/2018/05/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/05/07/机器学习/机器学习/</id>
    <published>2018-05-07T06:05:11.000Z</published>
    <updated>2018-07-04T13:42:48.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a><center>机器学习</center></h1><h2 id="一-入门"><a href="#一-入门" class="headerlink" title="一. 入门"></a>一. 入门</h2><h3 id="1-可以参考的路线"><a href="#1-可以参考的路线" class="headerlink" title="1. 可以参考的路线"></a>1. 可以参考的路线</h3><p>1、去Coursera上Andrew Ng的《机器学习》，完成所有作业，最好能全部拿满分。<br>2、找一个项目或者找一门稍微具体点的关于机器学习的书。<br>3、修炼内功。话说自己发现光应用不行，还得整明白其背后的东东后，就想四处找人请教<br>4、走到这里，路已经比较清晰了。剩下的就是耐住寂寞与妹纸的诱惑，与实验室的电脑和灯光度过一个个中秋吧。</p><h3 id="2-简单理解"><a href="#2-简单理解" class="headerlink" title="2. 简单理解"></a>2. 简单理解</h3><p>参考网址：<a href="https://www.cnblogs.com/hellochennan/p/5423740.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellochennan/p/5423740.html</a></p><p>机器学习是一种让计算机利用<strong><font color="red">数据</font></strong>而不是指令来进行各种工作的方法。</p><p>机器学习方法是计算机利用已有的数据(经验)，得出了某种模型(迟到的规律)，并利用此模型预测未来(是否迟到)的一种方法。</p><h3 id="3-机器学习方法"><a href="#3-机器学习方法" class="headerlink" title="3. 机器学习方法"></a>3. 机器学习方法</h3><h4 id="1-、回归算法"><a href="#1-、回归算法" class="headerlink" title="(1)、回归算法"></a>(1)、回归算法</h4><p>在大部分机器学习课程中，回归算法都是介绍的第一个算法。原因有两个：一.回归算法比较简单，介绍它可以让人平滑地从统计学迁移到机器学习中。二.回归算法是后面若干强大算法的基石，如果不理解回归算法，无法学习那些强大的算法。回归算法有两个重要的子类：即<strong>线性回归和逻辑回归</strong>。<br>线性回归预测的是数值，例如预测以后的房价。逻辑回归预测的是离散值，例如，预测肿瘤是良性的还是恶性的。</p><h4 id="2-、神经网络"><a href="#2-、神经网络" class="headerlink" title="(2)、神经网络"></a>(2)、神经网络</h4><p>神经网络(也称之为人工神经网络，ANN)算法是80年代机器学习界非常流行的算法，不过在90年代中途衰落。现在，携着“深度学习”之势，神经网络重装归来，重新成为最强大的机器学习算法之一。<br>神经网络的学习机理简单来说，就是分解与整合。</p><h4 id="3-、SVM（支持向量机）"><a href="#3-、SVM（支持向量机）" class="headerlink" title="(3)、SVM（支持向量机）"></a>(3)、SVM（支持向量机）</h4><p>支持向量机算法从某种意义上来说是逻辑回归算法的强化：通过给予逻辑回归算法更严格的优化条件，支持向量机算法可以获得比逻辑回归更好的分类界线。但是如果没有某类函数技术，则支持向量机算法最多算是一种更好的线性分类技术。</p><p>支持向量机是一种数学成分很浓的机器学习算法（相对的，神经网络则有生物科学成分）。在算法的核心步骤中，有一步证明，即将数据从低维映射到高维不会带来最后计算复杂性的提升。于是，通过支持向量机算法，既可以保持计算效率，又可以获得非常好的分类效果。因此支持向量机在90年代后期一直占据着机器学习中最核心的地位，基本取代了神经网络算法。直到现在神经网络借着深度学习重新兴起，两者之间才又发生了微妙的平衡转变。</p><h4 id="4-、聚类算法"><a href="#4-、聚类算法" class="headerlink" title="(4)、聚类算法"></a>(4)、聚类算法</h4><p>前面的算法中的一个显著特征就是我的训练数据中包含了标签，训练出的模型可以对其他未知数据预测标签。在下面的算法中，训练数据都是不含标签的，而算法的目的则是通过训练，推测出这些数据的标签。这类算法有一个统称，即<strong>无监督算法</strong>(前面有标签的数据的算法则是有<strong>监督算法</strong>)。无监督算法中最典型的代表就是聚类算法。</p><p>让我们还是拿一个二维的数据来说，某一个数据包含两个特征。我希望通过聚类算法，给他们中不同的种类打上标签，我该怎么做呢？简单来说，聚类算法就是计算种群中的距离，根据距离的远近将数据划分为多个族群。</p><p>聚类算法中最典型的代表就是K-Means算法。</p><h4 id="5-、降维算法"><a href="#5-、降维算法" class="headerlink" title="(5)、降维算法"></a>(5)、降维算法</h4><p>降维算法也是一种无监督学习算法，其主要特征是将数据从高维降低到低维层次。在这里，维度其实表示的是数据的特征量的大小，例如，房价包含房子的长、宽、面积与房间数量四个特征，也就是维度为4维的数据。可以看出来，长与宽事实上与面积表示的信息重叠了，例如面积=长 × 宽。通过降维算法我们就可以去除冗余信息，将特征减少为面积与房间数量两个特征，即从4维的数据压缩到2维。于是我们将数据从高维降低到低维，不仅利于表示，同时在计算上也能带来加速。</p><p>刚才说的降维过程中减少的维度属于肉眼可视的层次，同时压缩也不会带来信息的损失(因为信息冗余了)。如果肉眼不可视，或者没有冗余的特征，降维算法也能工作，不过这样会带来一些信息的损失。但是，降维算法可以从数学上证明，从高维压缩到的低维中最大程度地保留了数据的信息。因此，使用降维算法仍然有很多的好处。</p><p>降维算法的主要作用是压缩数据与提升机器学习其他算法的效率。通过降维算法，可以将具有几千个特征的数据压缩至若干个特征。另外，降维算法的另一个好处是数据的可视化，例如将5维的数据压缩至2维，然后可以用二维平面来可视。降维算法的主要代表是PCA算法(即主成分分析算法)。</p><h4 id="6-、推荐算法"><a href="#6-、推荐算法" class="headerlink" title="(6)、推荐算法"></a>(6)、推荐算法</h4><p>推荐算法是目前业界非常火的一种算法，在电商界，如亚马逊，天猫，京东等得到了广泛的运用。推荐算法的主要特征就是可以自动向用户推荐他们最感兴趣的东西，从而增加购买率，提升效益。推荐算法有两个主要的类别：</p><p>一类是<strong>基于物品内容的推荐</strong>，是将与用户购买的内容近似的物品推荐给用户，这样的前提是每个物品都得有若干个标签，因此才可以找出与用户购买物品类似的物品，这样推荐的好处是关联程度较大，但是由于每个物品都需要贴标签，因此工作量较大。</p><p>另一类是<strong>基于用户相似度的推荐</strong>，则是将与目标用户兴趣相同的其他用户购买的东西推荐给目标用户，例如小A历史上买了物品B和C，经过算法分析，发现另一个与小A近似的用户小D购买了物品E，于是将物品E推荐给小A。</p><p>两类推荐都有各自的优缺点，在一般的电商应用中，一般是两类混合使用。推荐算法中最有名的算法就是<strong>协同过滤算法</strong>。</p><h4 id="7-、其他"><a href="#7-、其他" class="headerlink" title="(7)、其他"></a>(7)、其他</h4><p>除了以上算法之外，机器学习界还有其他的如高斯判别，朴素贝叶斯，决策树等等算法。但是上面列的六个算法是使用最多，影响最广，种类最全的典型。机器学习界的一个特色就是算法众多，发展百花齐放。</p><p>下面做一个总结，按照训练的数据有无标签，可以将上面算法分为监督学习算法和无监督学习算法，但推荐算法较为特殊，既不属于监督学习，也不属于非监督学习，是单独的一类。</p><p>监督学习算法：<br>线性回归，逻辑回归，神经网络，SVM</p><p>无监督学习算法：<br>聚类算法，降维算法</p><p>特殊算法：<br>推荐算法</p><p>除了这些算法以外，有一些算法的名字在机器学习领域中也经常出现。但他们本身并不算是一个机器学习算法，而是为了解决某个子问题而诞生的。你可以理解他们为以上算法的子算法，用于大幅度提高训练过程。其中的代表有：梯度下降法，主要运用在线型回归，逻辑回归，神经网络，推荐算法中；牛顿法，主要运用在线型回归中；BP算法，主要运用在神经网络中；SMO算法，主要运用在SVM中。</p><h3 id="4-机器学习的应用–大数据"><a href="#4-机器学习的应用–大数据" class="headerlink" title="4.机器学习的应用–大数据"></a>4.机器学习的应用–大数据</h3><p>说完机器学习的方法，下面要谈一谈机器学习的应用了。无疑，在2010年以前，机器学习的应用在某些特定领域发挥了巨大的作用，如车牌识别，网络攻击防范，手写字符识别等等。但是，从2010年以后，随着大数据概念的兴起，机器学习大量的应用都与大数据高度耦合，几乎可以认为<strong>大数据是机器学习应用的最佳场景</strong>。</p><p>大数据的核心是利用数据的价值，机器学习是利用数据价值的关键技术，对于大数据而言，机器学习是不可或缺的。相反，对于机器学习而言，越多的数据会越 可能提升模型的精确性，同时，复杂的机器学习算法的计算时间也迫切需要分布式计算与内存计算这样的关键技术。因此，机器学习的兴盛也离不开大数据的帮助。 大数据与机器学习两者是互相促进，相依相存的关系。</p><p>1.大数据，小分析：即数据仓库领域的OLAP分析思路，也就是多维分析思想。<br>2.大数据，大分析：这个代表的就是数据挖掘与机器学习分析法。<br>3.流式分析：这个主要指的是事件驱动架构。<br>4.查询分析：经典代表是NoSQL数据库。</p><p>机器学习与大数据的结合产生了巨大的价值。基于机器学习技术的发展，数据能够“预测”。对人类而言，积累的经验越丰富，阅历也广泛，对未来的判断越准确。例如常说的“经验丰富”的人比“初出茅庐”的小伙子更有工作上的优势，就在于经验丰富的人获得的规律比他人更准确。而在机器学习领域，根据著名的一个实验，有效的证实了机器学习界一个理论：即机器学习模型的数据越多，机器学习的预测的效率就越好。</p><h3 id="5-机器学习的子类–深度学习"><a href="#5-机器学习的子类–深度学习" class="headerlink" title="5.机器学习的子类–深度学习"></a>5.机器学习的子类–深度学习</h3><p>近来，机器学习的发展产生了一个新的方向，即“深度学习”。</p><p>虽然深度学习这四字听起来颇为高大上，但其理念却非常简单，就是传统的神经网络发展到了多隐藏层的情况。</p><p>在上文介绍过，自从90年代以后，神经网络已经消寂了一段时间。但是BP算法的发明人Geoffrey Hinton一直没有放弃对神经网络的研究。由于神经网络在隐藏层扩大到两个以上，其训练速度就会非常慢，因此实用性一直低于支持向量机。2006年，Geoffrey Hinton在科学杂志《Science》上发表了一篇文章，论证了两个观点：</p><p>　　1.多隐层的神经网络具有优异的特征学习能力，学习得到的特征对数据有更本质的刻画，从而有利于可视化或分类；</p><p>　　2.深度神经网络在训练上的难度，可以通过“逐层初始化” 来有效克服。</p><p>通过这样的发现，不仅解决了神经网络在计算上的难度，同时也说明了深层神经网络在学习上的优异性。从此，神经网络重新成为了机器学习界中的主流强大学习技术。<font color="red">同时，具有多个隐藏层的神经网络被称为深度神经网络，基于深度神经网络的学习研究称之为深度学习</font>。</p><p>由于深度学习的重要性质，在各方面都取得极大的关注，按照时间轴排序，有以下四个标志性事件值得一说：</p><p>2012年6月，《纽约时报》披露了Google Brain项目，这个项目是由Andrew Ng和Map-Reduce发明人Jeff Dean共同主导，用16000个CPU Core的并行计算平台训练一种称为“深层神经网络”的机器学习模型，在语音识别和图像识别等领域获得了巨大的成功。Andrew Ng就是文章开始所介绍的机器学习的大牛(图1中左者)。</p><p>2012年11月，微软在中国天津的一次活动上公开演示了一个全自动的同声传译系统，讲演者用英文演讲，后台的计算机一气呵成自动完成语音识别、英中机器翻译，以及中文语音合成，效果非常流畅，其中支撑的关键技术是深度学习；</p><p>2013年1月，在百度的年会上，创始人兼CEO李彦宏高调宣布要成立百度研究院，其中第一个重点方向就是深度学习，并为此而成立深度学习研究院(IDL)。</p><p>2013年4月，《麻省理工学院技术评论》杂志将深度学习列为2013年十大突破性技术(Breakthrough Technology)之首。</p><h3 id="6-机器学习的父类–人工智能"><a href="#6-机器学习的父类–人工智能" class="headerlink" title="6.机器学习的父类–人工智能"></a>6.机器学习的父类–人工智能</h3><p>人工智能是机器学习的父类。深度学习则是机器学习的子类。如果把三者的关系用图来表明的话，则是下图：</p><p><img src="\image\机器学习\深度学习、机器学习、人工智能三者关系.png" alt="深度学习、机器学习、人工智能三者关系" title="深度学习、机器学习、人工智能三者关系"></p><p>图19. 深度学习、机器学习、人工智能三者关系</p><p>毫无疑问，人工智能(AI)是人类所能想象的科技界最突破性的发明了，某种意义上来说，人工智能就像游戏最终幻想的名字一样，是人类对于科技界的最终梦想。从50年代提出人工智能的理念以后，科技界，产业界不断在探索，研究。这段时间各种小说、电影都在以各种方式展现对于人工智能的想象。人类可以发明类似于人类的机器，这是多么伟大的一种理念！但事实上，自从50年代以后，人工智能的发展就磕磕碰碰，未有见到足够震撼的科学技术的进步。</p><p>总结起来，人工智能的发展经历了如下若干阶段，从早期的逻辑推理，到中期的专家系统，这些科研进步确实使我们离机器的智能有点接近了，但还有一大段距离。直到机器学习诞生以后，人工智能界感觉终于找对了方向。基于机器学习的图像识别和语音识别在某些垂直领域达到了跟人相媲美的程度。机器学习使人类第一次如此接近人工智能的梦想。</p><p>事实上，如果我们把人工智能相关的技术以及其他业界的技术做一个类比，就可以发现机器学习在人工智能中的重要地位不是没有理由的。</p><p>人类区别于其他物体，植物，动物的最主要区别，作者认为是“智慧”。而智慧的最佳体现是什么？</p><p>是计算能力么，应该不是，心算速度快的人我们一般称之为天才。<br>是反应能力么，也不是，反应快的人我们称之为灵敏。<br>是记忆能力么，也不是，记忆好的人我们一般称之为过目不忘。<br>是推理能力么，这样的人我也许会称他智力很高，类似“福尔摩斯”，但不会称他拥有智慧。<br>是知识能力么，这样的人我们称之为博闻广，也不会称他拥有智慧。</p><p>想想看我们一般形容谁有大智慧？圣人，诸如庄子，老子等。智慧是对生活的感悟，是对人生的积淀与思考，这与我们机器学习的思想何其相似？通过经验获取规律，指导人生与未来。没有经验就没有智慧。</p><p>那么，从计算机来看，以上的种种能力都有种种技术去应对。</p><p>例如计算能力我们有分布式计算，反应能力我们有事件驱动架构，检索能力我们有搜索引擎，知识存储能力我们有数据仓库，逻辑推理能力我们有专家系统，但是，唯有对应智慧中最显著特征的归纳与感悟能力，只有机器学习与之对应。这也是机器学习能力最能表征智慧的根本原因。</p><p>让我们再看一下机器人的制造，在我们具有了强大的计算，海量的存储，快速的检索，迅速的反应，优秀的逻辑推理后我们如果再配合上一个强大的智慧大脑，一个真正意义上的人工智能也许就会诞生，这也是为什么说在机器学习快速发展的现在，人工智能可能不再是梦想的原因。</p><p>人工智能的发展可能不仅取决于机器学习，更取决于前面所介绍的深度学习，深度学习技术由于深度模拟了人类大脑的构成，在视觉识别与语音识别上显著性的突破了原有机器学习技术的界限，因此极有可能是真正实现人工智能梦想的关键技术。无论是谷歌大脑还是百度大脑，都是通过海量层次的深度学习网络所构成的。也许借助于深度学习技术，在不远的将来，一个��</p><h2 id="二、开始学习"><a href="#二、开始学习" class="headerlink" title="二、开始学习"></a>二、开始学习</h2><h3 id="1-制定路线"><a href="#1-制定路线" class="headerlink" title="1. 制定路线"></a>1. 制定路线</h3><p>(1）吴恩达的机器学习课程<br>(2) 《机器学习实战》<br>(3) 周志华的《机器学习》，李航的《统计学习方法》</p><h1 id="2014斯坦福大学机器学习——学习笔记"><a href="#2014斯坦福大学机器学习——学习笔记" class="headerlink" title="2014斯坦福大学机器学习——学习笔记"></a><center>2014斯坦福大学机器学习——学习笔记</center></h1><p>学习视频位置：F:\2014斯坦福大学机器学习mkv视频，主讲是吴恩达</p><h2 id="第一课-简单介绍"><a href="#第一课-简单介绍" class="headerlink" title="第一课   简单介绍"></a>第一课   简单介绍</h2><h3 id="1-1机器学习的介绍"><a href="#1-1机器学习的介绍" class="headerlink" title="1.1机器学习的介绍"></a>1.1机器学习的介绍</h3><p>机器学习可以在计算机视觉，图片分类，网页检索中应用，它其实是一个技术核心，可以应用在多个领域。除了了解基本的算法外，还必须要会应用。</p><p>机器学习的一个很实际的应用，让直升飞机自己飞行，识别信封上的手写体，自然语言处理，计算机视觉，理解语言和理解图像处理。</p><h3 id="1-2机器学习的正式定义，以及算法"><a href="#1-2机器学习的正式定义，以及算法" class="headerlink" title="1.2机器学习的正式定义，以及算法"></a>1.2机器学习的正式定义，以及算法</h3><p>目前各种不同类型的学习算法，主要分为两类：监督学习和非监督学习。学习的重点是如何使用机器学习算法。</p><h3 id="1-3监督学习-Supervised-Learing"><a href="#1-3监督学习-Supervised-Learing" class="headerlink" title="1.3监督学习(Supervised Learing)"></a>1.3监督学习(Supervised Learing)</h3><p>一个例子，假设你要预测房屋价格。</p><p>监督学习是指我们给算法一个数据集，并且给定正确答案，算法的目的是给出更多的正确答案。这其实是一个回归问题，回归是指我们设法预测连续值的属性。</p><p>另外一个例子，估计肿瘤是良性的还是恶性的。</p><p>分类是为了预测离散的值。</p><h3 id="1-4非监督学习-Unsupervised-Learning"><a href="#1-4非监督学习-Unsupervised-Learning" class="headerlink" title="1.4非监督学习(Unsupervised Learning)"></a>1.4非监督学习(Unsupervised Learning)</h3><p>在无监督学习中，数据是没有标签和属性的。无监督学习算法会把数据分成不同的聚类，实际上就是聚类算法。<br>对于数据，我们没有给出一个正确的答案。<br>聚类只是无监督学习的一种。</p><p>实现机器学习的算法，可以用Octave或者matkab，可以很方便。<br>使用Octave写出算法原型，会非常的快。可以将Octave作为开发原型和学习的工具。</p><font color="red"> End at 2018/1/1 </font><h2 id="第二课-建立模型与梯度下降算法"><a href="#第二课-建立模型与梯度下降算法" class="headerlink" title="第二课  建立模型与梯度下降算法"></a>第二课  建立模型与梯度下降算法</h2><h3 id="2-1-模型代表"><a href="#2-1-模型代表" class="headerlink" title="2.1 模型代表"></a>2.1 模型代表</h3><p>下面图是训练集与学习算法之间的关系。</p><center><img src="\image\机器学习\训练集与学习算法的关系.png" alt="训练集与学习算法" title="没加载出来"></center><p>自己的理解：就拿线性规划来说，最终的目标是找到一个直线函数h(x),机器学习算法的功能，就是通过数据集去帮助我们找到一个好的h(x)。</p><h3 id="2-2-代价函数"><a href="#2-2-代价函数" class="headerlink" title="2.2 代价函数"></a>2.2 代价函数</h3><p>平方误差代价函数对于线性回归问题来说，一般都是最好的选择。</p><h3 id="2-3-代价函数的内涵I"><a href="#2-3-代价函数的内涵I" class="headerlink" title="2.3 代价函数的内涵I"></a>2.3 代价函数的内涵I</h3><p>要理解的两个重要函数，一个是假设函数，另外一个是代价函数。</p><h3 id="2-4-代价函数的内涵II"><a href="#2-4-代价函数的内涵II" class="headerlink" title="2.4 代价函数的内涵II"></a>2.4 代价函数的内涵II</h3><p>使用等高线在二维平面中刻画三维曲面图。</p><p>拥有一个自变量的线性规划模型，是针对房价预测例子的。</p><p><img src="\image\机器学习\一个线性规划模型_1.png" alt="一个线性规划模型" title="一个线性规划模型"></p><h3 id="2-5-梯度下降法"><a href="#2-5-梯度下降法" class="headerlink" title="2.5 梯度下降法"></a>2.5 梯度下降法</h3><p>在梯度下降法中，要同时更新两个参数，即参数的更新要同步。同步更新是梯度下降中的一种常用方法，同步更新是非常自然的方法。</p><h3 id="2-6-梯度下降法的内涵"><a href="#2-6-梯度下降法的内涵" class="headerlink" title="2.6 梯度下降法的内涵"></a>2.6 梯度下降法的内涵</h3><p>梯度下降算法</p><p>repeat until convergence<br>\(\{ \\ \theta_j = \theta_j - \alpha\frac{\partial}{\partial\theta_j}\mathbf{J}(\theta_0,\theta_1) \\ \}\)</p><p>其中，偏导数数那一项可以判断出前进的方向，并且也可以让收敛速率不断变小，所以就不用再去减少\( \alpha \)了。</p><h3 id="2-7-梯度下降法求解线性规划"><a href="#2-7-梯度下降法求解线性规划" class="headerlink" title="2.7 梯度下降法求解线性规划"></a>2.7 梯度下降法求解线性规划</h3><p>对于一个凸函数，任何局部最优都是全局最有。</p><p>批处理梯度下降：就是在梯度下降的每一个步骤中都使用所有的数据集。</p><h3 id="2-8-一些概念的重要扩展"><a href="#2-8-一些概念的重要扩展" class="headerlink" title="2.8 一些概念的重要扩展"></a>2.8 一些概念的重要扩展</h3><font color="red"> End at 2018/1/3 </font><h2 id="第三课-线性代数知识"><a href="#第三课-线性代数知识" class="headerlink" title="第三课  线性代数知识"></a>第三课  线性代数知识</h2><p>自己修过线性代数，所以就不再看了！</p><h2 id="第四课-梯度下降法与标准方程法"><a href="#第四课-梯度下降法与标准方程法" class="headerlink" title="第四课  梯度下降法与标准方程法"></a>第四课  梯度下降法与标准方程法</h2><h3 id="4-1-多特征"><a href="#4-1-多特征" class="headerlink" title="4.1 多特征"></a>4.1 多特征</h3><p>在多个特征的情况下，可以使用矩阵和向量来简化假设h(x)的表示。</p><h3 id="4-2-梯度下降法应用于多变量"><a href="#4-2-梯度下降法应用于多变量" class="headerlink" title="4.2 梯度下降法应用于多变量"></a>4.2 梯度下降法应用于多变量</h3><p>可以类比用于一个变量的情况，其实是一样的。</p><h3 id="4-3-梯度下降算法实践技巧I"><a href="#4-3-梯度下降算法实践技巧I" class="headerlink" title="4.3 梯度下降算法实践技巧I"></a>4.3 梯度下降算法实践技巧I</h3><p>在有多个特征的情况下，如果每个特征的取值范围相似，那么梯度下降算法会收敛的比较快。<br>例如，现在对于房屋价格预测，有两个特征：</p><ul><li>\( x_1 = size (0-2000 feet^2) \)</li><li>\( x_2 = number of bedrooms(1-5) \)</li></ul><p>在现在这个情况下，代价函数J在平面(\(  \theta_1 \), \( \theta_2 \))中的等高线图是一个很瘦的椭圆。<br>如果做出如下改变：</p><ul><li>\(  x_1 = \frac{size(feet^2)}{2000} \)</li><li>\( x_2 = \frac{number of bedrooms}{5} \)</li></ul><p>那么现在的代价函数J的等高线图，就是一个圆，梯度下降法会收敛的比较快。<br>在特征值放缩中，通常将特征值约束在 \( -1 \leq x_i \leq 1 \)的范围。<br>总结：就是两个特征值的范围不要相差太大。</p><p><strong>均值归一化</strong>(mean normalization)<br>用\( x_i - \mu_i \)来代替\( x_i \)，使得有接近0的均值（不能应用于\( x_0=1 \)）<br><strong>E.g.</strong>  </p><ul><li>\( x_1 = \frac{size - 1000}{2000} \)</li><li>\( x_2 = \frac{\#bedrooms - 2}{5} \)<br>$$  -0.5 \leq x_1 \leq 0.5, -0.5 \leq x_2 \leq 0.5 $$</li></ul><h3 id="4-4-梯度下降算法实践技巧II"><a href="#4-4-梯度下降算法实践技巧II" class="headerlink" title="4.4 梯度下降算法实践技巧II"></a>4.4 梯度下降算法实践技巧II</h3><p><strong>问题：</strong></p><ol><li>怎样验证梯度下降法正确工作了？</li><li>怎样设置下降速率\( \alpha \)</li></ol><p>如果梯度下降法正确工作了，那么每一次迭代，代价函数的值都应该下降。</p><p>Summary:</p><ul><li>If \( \alpha \) is too small: slow convergence.</li><li>If \( \alpha \) is too large: may not decrease on every iteration; may not converge.</li></ul><p>To choose , try<br>…, 0.001, …, 0.01, …, 0.1, …, 1, ….</p><h3 id="4-5-特征和多项式回归"><a href="#4-5-特征和多项式回归" class="headerlink" title="4.5  特征和多项式回归"></a>4.5  特征和多项式回归</h3><p>可以通过已有的特征创造新的特征。在多项式回归中，将高次项看作是一个特征就好了，这样子就可以继续使用线性回归来求解。</p><h3 id="4-6-标准方程法。"><a href="#4-6-标准方程法。" class="headerlink" title="4.6 标准方程法。"></a>4.6 标准方程法。</h3><p>标准方程法就是用代价函数\( J(\theta) \)对\( \theta \)求偏导，并设其为0, 然后求出的\( \theta \)可以使得代价函数最小。<br>设置\( \theta \)为下面的值，可以使得代价函数最小化：</p><p>$$ \theta = (X^TX)^{-1}X^Ty $$</p><p>如果使用标准方程法，那么就不再需要归一化特征变量。</p><h3 id="4-7-正规方程不可逆性-Normal-Equation-Noninvertibility"><a href="#4-7-正规方程不可逆性-Normal-Equation-Noninvertibility" class="headerlink" title="4.7 正规方程不可逆性(Normal Equation Noninvertibility)"></a>4.7 正规方程不可逆性(Normal Equation Noninvertibility)</h3><p>对于标准方程法，如果\( X^TX \)不可逆，那么将无法求解。但是很少有不可逆的情况发生，并且Octave中的pinv()方法在矩阵不可逆的情况下，会求出来一个伪逆，所以仍然可以正确的计算出\( \theta \)。</p><h2 id="第五课"><a href="#第五课" class="headerlink" title="第五课"></a>第五课</h2><p>可以参考<a href="http://www.cnblogs.com/leezx/p/5635056.html" target="_blank" rel="noopener">http://www.cnblogs.com/leezx/p/5635056.html</a>，里面记录了这节课的内容。</p><h3 id="5-1-简单介绍Octave的基本操作"><a href="#5-1-简单介绍Octave的基本操作" class="headerlink" title="5.1 简单介绍Octave的基本操作"></a>5.1 简单介绍Octave的基本操作</h3><p>先用Octave实现机器学习算法原型，然后在使用C++或者Java实现。</p><h3 id="5-2-Octave中移动数据"><a href="#5-2-Octave中移动数据" class="headerlink" title="5.2 Octave中移动数据"></a>5.2 Octave中移动数据</h3><h3 id="5-3-在数据上进行计算"><a href="#5-3-在数据上进行计算" class="headerlink" title="5.3 在数据上进行计算"></a>5.3 在数据上进行计算</h3><p>A = magic(3)会返回一个3X3的魔方矩阵，其行列和对角线上的元素和都是相等的。</p><p>忘记函数怎么用的时候，使用help命令就可以了，例如：<br>help  find   会显示find命令的帮助文档。</p><h3 id="5-4-数据可视化-Plotting-Data"><a href="#5-4-数据可视化-Plotting-Data" class="headerlink" title="5.4  数据可视化(Plotting Data)"></a>5.4  数据可视化(Plotting Data)</h3><p>主要有plot subplot 命令，axis改变坐标轴的刻度。</p><h3 id="5-5-控制语句，for-while-if"><a href="#5-5-控制语句，for-while-if" class="headerlink" title="5.5 控制语句，for, while, if"></a>5.5 控制语句，for, while, if</h3><h3 id="5-6-向量化"><a href="#5-6-向量化" class="headerlink" title="5.6 向量化"></a>5.6 向量化</h3><p>向量化有利于提高计算效率，并且可以简化代码。</p><h3 id="5-7-作业提交和编程训练。"><a href="#5-7-作业提交和编程训练。" class="headerlink" title="5.7 作业提交和编程训练。"></a>5.7 作业提交和编程训练。</h3><h2 id="第六课"><a href="#第六课" class="headerlink" title="第六课"></a>第六课</h2><h3 id="6-1-分类问题"><a href="#6-1-分类问题" class="headerlink" title="6.1 分类问题"></a>6.1 分类问题</h3><p>逻辑回归实际上是一种分类算法。</p><h3 id="6-2-表征假设-the-Hypothesis-Representation"><a href="#6-2-表征假设-the-Hypothesis-Representation" class="headerlink" title="6.2 表征假设(the Hypothesis Representation)"></a>6.2 表征假设(the Hypothesis Representation)</h3><p>逻辑回归模型：<br>$$ 0 \leq h_{\theta}(x) \leq 1 $$</p><h3 id="6-3-决策边界-Decision-Boundary"><a href="#6-3-决策边界-Decision-Boundary" class="headerlink" title="6.3 决策边界(Decision Boundary)"></a>6.3 决策边界(Decision Boundary)</h3><p>决策边界是假设函数的一个属性，并不是训练数据集的属性。</p><h3 id="6-4-代价函数-Cost-Function"><a href="#6-4-代价函数-Cost-Function" class="headerlink" title="6.4 代价函数(Cost Function)"></a>6.4 代价函数(Cost Function)</h3><p>怎样确定假设函数的参数。</p><h3 id="6-5-简单代价函数和梯度下降法"><a href="#6-5-简单代价函数和梯度下降法" class="headerlink" title="6.5 简单代价函数和梯度下降法"></a>6.5 简单代价函数和梯度下降法</h3><h3 id="6-6-高级优化"><a href="#6-6-高级优化" class="headerlink" title="6.6 高级优化"></a>6.6 高级优化</h3><h3 id="6-7-多类分类-Multiclass-Classification"><a href="#6-7-多类分类-Multiclass-Classification" class="headerlink" title="6.7 多类分类(Multiclass Classification)"></a>6.7 多类分类(Multiclass Classification)</h3><p>多分类其实分解成多个二分类问题，可以先分出一个类和其余的类，重复这个动作分区所有的类别。<br>然后，对于一个\( x \)选择出概率最大的那个分类就好了。</p><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习&quot;&gt;&lt;a href=&quot;#机器学习&quot; class=&quot;headerlink&quot; title=&quot;机器学习&quot;&gt;&lt;/a&gt;&lt;center&gt;机器学习&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;一-入门&quot;&gt;&lt;a href=&quot;#一-入门&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>谷歌机器学习速成课程——笔记</title>
    <link href="http://yoursite.com/2018/05/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B0%B7%E6%AD%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/07/机器学习/谷歌机器学习速成课程——笔记/</id>
    <published>2018-05-07T06:05:11.000Z</published>
    <updated>2018-07-04T13:45:29.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谷歌机器学习速成课程——笔记"><a href="#谷歌机器学习速成课程——笔记" class="headerlink" title="谷歌机器学习速成课程——笔记"></a>谷歌机器学习速成课程——笔记</h1><p>参考网址：<a href="https://developers.google.cn/machine-learning/crash-course/" target="_blank" rel="noopener">机器学习速成课程</a></p><h2 id="第一课、机器学习简介"><a href="#第一课、机器学习简介" class="headerlink" title="第一课、机器学习简介"></a>第一课、机器学习简介</h2><p>机器学习的三个好处：</p><ol><li>可以让你在更短的时间编写更可靠的程序，例如，拼写错误检查</li><li>更容易迁移到不同的环境中，例如，拼写检查程序迁移到其他的语言上。</li><li>可以完成以前不能完成的工作，例如，面部识别</li></ol><h2 id="第二课、框架处理"><a href="#第二课、框架处理" class="headerlink" title="第二课、框架处理"></a>第二课、框架处理</h2><p><strong>什么是（监督式）机器学习？</strong></p><p>机器学习系统</p><p>通过学习如何组合输入信息</p><p>来对从未见过的数据</p><p>做出有用的预测</p><p><strong>术语：标签和特征</strong></p><p>标签是指我们要预测的真实事物：y</p><p>基本线性回归中的 y 变量</p><h2 id="第三课、深入了解机器学习"><a href="#第三课、深入了解机器学习" class="headerlink" title="第三课、深入了解机器学习"></a>第三课、深入了解机器学习</h2><p>常用的损失函数：</p><p>平方损失</p><h2 id="第四课、降低损失"><a href="#第四课、降低损失" class="headerlink" title="第四课、降低损失"></a>第四课、降低损失</h2><p>理想的学习速率</p><p>一维空间中的理想学习速率是$\frac{1}{f(x)^{‘’}}$（f(x) 对 x 的二阶导数的倒数）。</p><p>二维或多维空间中的理想学习速率是<a href="https://wikipedia.org/wiki/Hessian_matrix" target="_blank" rel="noopener">海森矩阵</a>（由二阶偏导数组成的矩阵）的倒数。</p><p>广义凸函数的情况则更为复杂。</p><p>done! 2018-4-23</p><h2 id="第五课、使用TF的基本步骤"><a href="#第五课、使用TF的基本步骤" class="headerlink" title="第五课、使用TF的基本步骤"></a>第五课、使用TF的基本步骤</h2><p>TensorFlow是基于图表的通用计算框架，可用于编写你想到的任何东西。</p><p>TensorFlow.org的API页面中提供了可在代码中使用的低级TensorFlow运算的完整列表。</p><p><img src="\image\机器学习\TensorFlow层次图.png" alt="TensorFlow层次图"></p><p><strong>图 1. TensorFlow 工具包层次结构。</strong></p><p>下表总结了不同层的用途：</p><table><thead><tr><th>工具包</th><th>说明</th></tr></thead><tbody><tr><td>Estimator (tf.estimator)</td><td>高级 OOP API。</td></tr><tr><td>tf.layers/tf.losses/tf.metrics</td><td>用于常见模型组件的库。</td></tr><tr><td>TensorFlow</td><td>低级 API</td></tr></tbody></table><p>TensorFlow 由以下两个组件组成：</p><ul><li><a href="https://tensorflow.google.cn/extend/tool_developers/#protocol_buffers" target="_blank" rel="noopener">图协议缓冲区</a></li><li>执行（分布式）图的运行时</li></ul><p>这两个组件类似于 Java 编译器和 JVM。正如 JVM 会实施在多个硬件平台（CPU 和 GPU）上一样，TensorFlow 也是如此。</p><p>您应该使用哪个 API？您应该使用能够解决问题的最高级抽象层。较高级别的抽象层更易于使用，但（设计方面）不够灵活。我们建议您先从最高级 API 入手，让所有组件正常运作起来。如果您希望在某些特殊建模方面能够更加灵活一些，则可以降低一个级别。请注意，每个级别都是使用低级 API 构建的，因此降低层次结构级别应该比较直观。</p><p><strong>tf.estimator API</strong></p><p>我们将使用 tf.estimator 来完成机器学习速成课程中的大部分练习。您在练习中所做的一切都可以在较低级别（原始）的 TensorFlow 中完成，但使用 tf.estimator 会大大减少代码行数。</p><p>tf.estimator 与 scikit-learn API 兼容。 <a href="http://scikit-learn.org/" target="_blank" rel="noopener">scikit-learn</a> 是极其热门的 Python 开放源代码机器学习库，拥有超过 10 万名用户，其中包括许多 Google 员工。</p><p>概括而言，以下是在 tf.estimator 中实现的线性回归程序的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a linear classifier.</span></span><br><span class="line">classifier = tf.estimator.LinearClassifier()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train the model on some example data.</span></span><br><span class="line">classifier.train(input_fn=train_input_fn, steps=<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use it to predict.</span></span><br><span class="line">predictions = classifier.predict(input_fn=predict_input_fn)</span><br></pre></td></tr></table></figure><p><strong>张量 (Tensor)</strong></p><p>TensorFlow 程序中的主要数据结构。张量是 N 维（其中 N 可能非常大）数据结构，最常见的是标量、向量或矩阵。张量的元素可以包含整数值、浮点值或字符串值。</p><p><strong>Estimator</strong><br>tf.Estimator 类的一个实例，用于封装负责构建 TensorFlow 图并运行 TensorFlow 会话的逻辑。您可以创建自己的自定义 Estimator（如需相关介绍，请点击此处），也可以将其他人预创建的 Estimator 实例化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;谷歌机器学习速成课程——笔记&quot;&gt;&lt;a href=&quot;#谷歌机器学习速成课程——笔记&quot; class=&quot;headerlink&quot; title=&quot;谷歌机器学习速成课程——笔记&quot;&gt;&lt;/a&gt;谷歌机器学习速成课程——笔记&lt;/h1&gt;&lt;p&gt;参考网址：&lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="课程笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode编程分析</title>
    <link href="http://yoursite.com/2018/04/28/leetCode%E7%BC%96%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/04/28/leetCode编程分析/</id>
    <published>2018-04-28T13:08:37.000Z</published>
    <updated>2018-07-04T11:30:37.205Z</updated>
    
    <content type="html"><![CDATA[<p>#LeetCode编程分析</p><p>459. Repeated Substring Pattern </p><table><thead><tr><th>步骤</th><th>操作</th><th>匹配状态</th></tr></thead><tbody><tr><td>1</td><td>0-&gt;19</td><td>匹配</td></tr><tr><td>2</td><td>找到子串，开始验证 1-&gt;19</td><td>失败</td></tr><tr><td>3</td><td>重新找子串”aba”</td><td>找到</td></tr><tr><td>4</td><td>验证子串”aba”</td><td>失败</td></tr><tr><td>5</td><td>找到子串“ababa”</td><td>找到</td></tr><tr><td>6</td><td>验证子串”ababa”</td><td>失败</td></tr><tr><td>7</td><td>找到子串“abababa”</td><td>找到</td></tr><tr><td>8</td><td>验证子串“abababa”</td><td>验证成功</td></tr><tr><td>10</td><td>返回true</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#LeetCode编程分析&lt;/p&gt;
&lt;p&gt;459. Repeated Substring Pattern &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;步骤&lt;/th&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;匹配状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod
      
    
    </summary>
    
      <category term="编程实战" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
      <category term="练习题" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="面向对象编程" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="http://yoursite.com/2018/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/27/数据库/数据库系统原理/</id>
    <published>2018-04-27T13:51:36.000Z</published>
    <updated>2018-07-04T15:17:33.955Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一事务">一、事务</a><ul><li><a href="#概念">概念</a></li><li><a href="#四大特性">四大特性</a></li><li><a href="#autocommit">AUTOCOMMIT</a></li></ul></li><li><a href="#二并发一致性问题">二、并发一致性问题</a><ul><li><a href="#问题">问题</a></li><li><a href="#解决方法">解决方法</a></li></ul></li><li><a href="#三封锁">三、封锁</a><ul><li><a href="#封锁粒度">封锁粒度</a></li><li><a href="#封锁类型">封锁类型</a></li><li><a href="#封锁协议">封锁协议</a></li><li><a href="#mysql-隐式与显示锁定">MySQL 隐式与显示锁定</a></li></ul></li><li><a href="#四隔离级别">四、隔离级别</a></li><li><a href="#五多版本并发控制">五、多版本并发控制</a><ul><li><a href="#版本号">版本号</a></li><li><a href="#undo-日志">Undo 日志</a></li><li><a href="#实现过程">实现过程</a></li><li><a href="#快照读与当前读">快照读与当前读</a></li></ul></li><li><a href="#六next-key-locks">六、Next-Key Locks</a><ul><li><a href="#record-locks">Record Locks</a></li><li><a href="#grap-locks">Grap Locks</a></li><li><a href="#next-key-locks">Next-Key Locks</a></li></ul></li><li><a href="#七关系数据库设计理论">七、关系数据库设计理论</a><ul><li><a href="#函数依赖">函数依赖</a></li><li><a href="#异常">异常</a></li><li><a href="#范式">范式</a></li></ul></li><li><a href="#八数据库系统概述">八、数据库系统概述</a><ul><li><a href="#基本术语">基本术语</a></li><li><a href="#数据库的三层模式和两层映像">数据库的三层模式和两层映像</a></li></ul></li><li><a href="#九关系数据库建模">九、关系数据库建模</a><ul><li><a href="#er-图">ER 图</a></li></ul></li><li><a href="#十约束">十、约束</a><ul><li><a href="#1-键码">1. 键码</a></li><li><a href="#2-单值约束">2. 单值约束</a></li><li><a href="#3-引用完整性约束">3. 引用完整性约束</a></li><li><a href="#4-域约束">4. 域约束</a></li><li><a href="#5-一般约束">5. 一般约束</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//185b9c49-4c13-4241-a848-fbff85c03a64.png"> </div><br></p><p>事务指的是满足 ACID 特性的一系列操作。在数据库中，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来保证持久性。</p><h2 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显示使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h1 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h1><p>在并发环境下，一个事务如果受到另一个事务的影响，那么事务操作就无法满足一致性条件。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-丢失修改"><a href="#1-丢失修改" class="headerlink" title="1. 丢失修改"></a>1. 丢失修改</h3><p>T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//88ff46b3-028a-4dbb-a572-1f062b8b96d3.png"> </div><br></p><h3 id="2-读脏数据"><a href="#2-读脏数据" class="headerlink" title="2. 读脏数据"></a>2. 读脏数据</h3><p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//dd782132-d830-4c55-9884-cfac0a541b8e.png"> </div><br></p><h3 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3. 不可重复读"></a>3. 不可重复读</h3><p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//c8d18ca9-0b09-441a-9a0c-fb063630d708.png"> </div><br></p><h3 id="4-幻影读"><a href="#4-幻影读" class="headerlink" title="4. 幻影读"></a>4. 幻影读</h3><p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png"> </div><br></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p><p>在没有并发的情况下，事务以串行的方式执行，互不干扰，因此可以保证隔离性。在并发的情况下，如果能通过并发控制，让事务的执行结果和某一个串行执行的结果相同，就认为事务的执行结果满足隔离性要求，也就是说是正确的。把这种事务执行方式称为  <strong>可串行化调度</strong> 。</p><p><strong>并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</strong> </p><h1 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//1a851e90-0d5c-4d4f-ac54-34c20ecfb903.jpg" width="300"> </div><br></p><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作，包括获取锁，检查锁是否已经解除、释放锁，都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="1-读写锁"><a href="#1-读写锁" class="headerlink" title="1. 读写锁"></a>1. 读写锁</h3><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ol><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ol><p>锁的兼容关系如下：</p><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">X</th><th style="text-align:center">S</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td></tr></tbody></table><h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ol><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ol><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">X</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">IS</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">IX</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">IS</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr></tbody></table><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong> </p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么一个事务的修改就不会被覆盖。</p><table><thead><tr><th style="text-align:center">T<sub>1</sub></th><th style="text-align:center">T<sub>1</sub></th></tr></thead><tbody><tr><td style="text-align:center">lock-x(A)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">read A=20</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">lock-x(A)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">wait</td></tr><tr><td style="text-align:center">write A=19</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center">commit</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center">unlock-x(A)</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">obtain</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">read A=19</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">write A=21</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">commit</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">unlock-x(A)</td></tr></tbody></table><p><strong>二级封锁协议</strong> </p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><table><thead><tr><th style="text-align:center">T<sub>1</sub></th><th style="text-align:center">T<sub>1</sub></th></tr></thead><tbody><tr><td style="text-align:center">lock-x(A)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">read A=20</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">write A=19</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">lock-s(A)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">wait</td></tr><tr><td style="text-align:center">rollback</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center">A=20</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center">unlock-x(A)</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">obtain</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">read A=20</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">commit</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">unlock-s(A)</td></tr></tbody></table><p><strong>三级封锁协议</strong> </p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><table><thead><tr><th style="text-align:center">T<sub>1</sub></th><th style="text-align:center">T<sub>1</sub></th></tr></thead><tbody><tr><td style="text-align:center">lock-s(A)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">read A=20</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">lock-x(A)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">wait</td></tr><tr><td style="text-align:center">read A=20</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center">commit</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center">unlock-s(A)</td><td style="text-align:center">.</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">obtain</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">read A=20</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">write A=19</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">commit</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">unlock-X(A)</td></tr></tbody></table><h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。事务 T 对数据 A 进行读或者写操作之前，必须先获得对 A 的封锁，并且在释放一个封锁之后，T 不能再获得任何的其它锁。</p><p>事务遵循两段锁协议是保证并发操作可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h2 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h1 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h1><p><font size="4">  <strong>1. 未提交读（READ UNCOMMITTED）</strong> </font> <br></p><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><p><font size="4">  <strong>2. 提交读（READ COMMITTED）</strong> </font> <br></p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><p><font size="4">  <strong>3. 可重复读（REPEATABLE READ）</strong> </font> <br></p><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><p><font size="4">  <strong>4. 可串行化（SERIALIXABLE）</strong> </font> <br></p><p>强制事务串行执行。</p><p><font size="4">  <strong>四个隔离级别的对比</strong> </font> <br></p><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻影读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">可串行化</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr></tbody></table><h1 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><p>InooDB 的 MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>InnoDB 的 MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//e41405a8-7c05-4f70-8092-e961e28d3112.jpg"> </div><br></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>以下过程针对可重复读（REPEATABLE READ）隔离级别。</p><h3 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h3><p>当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。</p><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。</p><p>除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h3 id="2-INSERT"><a href="#2-INSERT" class="headerlink" title="2. INSERT"></a>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p><h3 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p><h3 id="4-UPDATE"><a href="#4-UPDATE" class="headerlink" title="4. UPDATE"></a>4. UPDATE</h3><p>将当前系统版本号作为更新后的数据行快照的创建版本号，同时将当前系统版本号作为更新前的数据行快照的删除版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><h3 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h3><p>这是 MVCC 的一种方式，读取的是快照中的数据，可以减少加锁所带来的开销。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure><h3 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span>;</span><br><span class="line"><span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h1 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h1><p>Next-Key Locks 也是 MySQL 的 InnoDB 存储引擎的一种锁实现。MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h2 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h2><p>锁定的对象是索引，而不是数据。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。</p><h2 id="Grap-Locks"><a href="#Grap-Locks" class="headerlink" title="Grap Locks"></a>Grap Locks</h2><p>锁定一个范围内的索引，例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合。在 user 中有以下记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|   id | last_name   | first_name   |   age |</span><br><span class="line">|<span class="comment">------|-------------|--------------|-------|</span></span><br><span class="line">|    4 | stark       | tony         |    21 |</span><br><span class="line">|    1 | tom         | hiddleston   |    30 |</span><br><span class="line">|    3 | morgan      | freeman      |    40 |</span><br><span class="line">|    5 | jeff        | dean         |    50 |</span><br><span class="line">|    2 | donald      | trump        |    80 |</span><br><span class="line">+<span class="comment">------|-------------|--------------|-------+</span></span><br></pre></td></tr></table></figure><p>那么就需要锁定以下范围：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 21]</span><br><span class="line">(21, 30]</span><br><span class="line">(30, 40]</span><br><span class="line">(40, 50]</span><br><span class="line">(50, 80]</span><br><span class="line">(80, ∞)</span><br></pre></td></tr></table></figure><h1 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 W-&gt;A，如果能找到 W 的真子集 W’，使得 W’-&gt; A，那么 W-&gt;A 就是部分函数依赖，否则就是完全函数依赖；</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ol><li>冗余数据：例如 学生-2 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如如果删除了 课程-1，需要删除第一行和第三行，那么 学生-1 的信息就会丢失。</li><li>插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ol><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。高级别范式的依赖于低级别的范式。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//c2d343f7-604c-4856-9a3c-c71d6f67fecc.png" width="300"> </div><br></p><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分；</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><font size="4"> <strong>分解前</strong> </font><br></p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><font size="4"> <strong>分解后</strong> </font><br></p><p>关系-1</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept, Mname</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt;  Grade</li></ul><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递依赖于键码。</p><p>上面的 关系-1 中存在以下传递依赖：Sno -&gt; Sdept -&gt; Mname，可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><h3 id="4-BC-范式（BCNF）"><a href="#4-BC-范式（BCNF）" class="headerlink" title="4. BC 范式（BCNF）"></a>4. BC 范式（BCNF）</h3><p>所有属性不传递依赖于键码。</p><p>关系 STC(Sname, Tname, Cname, Grade) 的四个属性分别为学生姓名、教师姓名、课程名和成绩，它的键码为 (Sname, Cname, Tname)，有以下函数依赖：</p><ul><li>Sname, Cname -&gt; Tname</li><li>Sname, Cname -&gt; Grade</li><li>Sname, Tname -&gt; Cname</li><li>Sname, Tname -&gt; Grade</li><li>Tname -&gt; Cname</li></ul><p>存在着以下函数传递依赖：</p><ul><li>Sname -&gt; Tname -&gt; Cname</li></ul><p>可以分解成 SC(Sname, Cname, Grade) 和 ST(Sname, Tname)，对于 ST，属性之间是多对多关系，无函数依赖。</p><h1 id="八、数据库系统概述"><a href="#八、数据库系统概述" class="headerlink" title="八、数据库系统概述"></a>八、数据库系统概述</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><h3 id="1-数据模型"><a href="#1-数据模型" class="headerlink" title="1. 数据模型"></a>1. 数据模型</h3><p>由数据结构、数据操作和完整性三个要素组成。</p><h3 id="2-数据库系统"><a href="#2-数据库系统" class="headerlink" title="2. 数据库系统"></a>2. 数据库系统</h3><p>数据库系统包含所有与数据库相关的内容，包括数据库、数据库管理系统、应用程序以及数据库管理员和用户，还包括相关的硬件和软件。</p><h2 id="数据库的三层模式和两层映像"><a href="#数据库的三层模式和两层映像" class="headerlink" title="数据库的三层模式和两层映像"></a>数据库的三层模式和两层映像</h2><ul><li>外模式：局部逻辑结构</li><li>模式：全局逻辑结构</li><li>内模式：物理结构</li></ul><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//20150928140509757.png" width="600"> </div><br></p><h3 id="1-外模式"><a href="#1-外模式" class="headerlink" title="1. 外模式"></a>1. 外模式</h3><p>又称用户模式，是用户和数据库系统的接口，特定的用户只能访问数据库系统提供给他的外模式中的数据。例如不同的用户创建了不同数据库，那么一个用户只能访问他有权限访问的数据库。</p><p>一个数据库可以有多个外模式，一个用户只能有一个外模式，但是一个外模式可以给多个用户使用。</p><h3 id="2-模式"><a href="#2-模式" class="headerlink" title="2. 模式"></a>2. 模式</h3><p>可以分为概念模式和逻辑模式，概念模式可以用概念-关系来描述；逻辑模式使用特定的数据模式（比如关系模型）来描述数据的逻辑结构，这种逻辑结构包括数据的组成、数据项的名称、类型、取值范围。不仅如此，逻辑模式还要描述数据之间的关系、数据的完整性与安全性要求。</p><h3 id="3-内模式"><a href="#3-内模式" class="headerlink" title="3. 内模式"></a>3. 内模式</h3><p>又称为存储模式，描述记录的存储方式，例如索引的组织方式、数据是否压缩以及是否加密等等。</p><h3 id="4-外模式-模式映像"><a href="#4-外模式-模式映像" class="headerlink" title="4. 外模式/模式映像"></a>4. 外模式/模式映像</h3><p>把外模式的局部逻辑结构和模式的全局逻辑结构联系起来。该映像可以保证数据和应用程序的逻辑独立性。</p><h3 id="5-模式-内模式映像"><a href="#5-模式-内模式映像" class="headerlink" title="5. 模式/内模式映像"></a>5. 模式/内模式映像</h3><p>把模式的全局逻辑结构和内模式的物理结构联系起来，该映像可以保证数据和应用程序的物理独立性。</p><h1 id="九、关系数据库建模"><a href="#九、关系数据库建模" class="headerlink" title="九、关系数据库建模"></a>九、关系数据库建模</h1><h2 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h2><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><h3 id="1-实体的三种联系"><a href="#1-实体的三种联系" class="headerlink" title="1. 实体的三种联系"></a>1. 实体的三种联系</h3><p>联系包含一对一，一对多，多对多三种。</p><p>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//292b4a35-4507-4256-84ff-c218f108ee31.jpg"> </div><br></p><h3 id="2-表示出现多次的关系"><a href="#2-表示出现多次的关系" class="headerlink" title="2. 表示出现多次的关系"></a>2. 表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//8b798007-e0fb-420c-b981-ead215692417.jpg"> </div><br></p><h3 id="3-联系的多向性"><a href="#3-联系的多向性" class="headerlink" title="3. 联系的多向性"></a>3. 联系的多向性</h3><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//423f2a40-bee1-488e-b460-8e76c48ee560.png"> </div><br></p><p>一般只使用二元联系，可以把多元关系转换为二元关系。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//de9b9ea0-1327-4865-93e5-6f805c48bc9e.png"> </div><br></p><h3 id="4-表示子类"><a href="#4-表示子类" class="headerlink" title="4. 表示子类"></a>4. 表示子类</h3><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//7ec9d619-fa60-4a2b-95aa-bf1a62aad408.jpg"> </div><br></p><h1 id="十、约束"><a href="#十、约束" class="headerlink" title="十、约束"></a>十、约束</h1><h2 id="1-键码"><a href="#1-键码" class="headerlink" title="1. 键码"></a>1. 键码</h2><p>用于唯一表示一个实体。</p><p>键码可以由多个属性构成，每个构成键码的属性称为码。</p><h2 id="2-单值约束"><a href="#2-单值约束" class="headerlink" title="2. 单值约束"></a>2. 单值约束</h2><p>某个属性的值是唯一的。</p><h2 id="3-引用完整性约束"><a href="#3-引用完整性约束" class="headerlink" title="3. 引用完整性约束"></a>3. 引用完整性约束</h2><p>一个实体的属性引用的值在另一个实体的某个属性中存在。</p><h2 id="4-域约束"><a href="#4-域约束" class="headerlink" title="4. 域约束"></a>4. 域约束</h2><p>某个属性的值在特定范围之内。</p><h2 id="5-一般约束"><a href="#5-一般约束" class="headerlink" title="5. 一般约束"></a>5. 一般约束</h2><p>比如大小约束，数量约束。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li><li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">The InnoDB Storage Engine</a></li><li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" target="_blank" rel="noopener">Transaction isolation levels</a></li><li><a href="http://scanftree.com/dbms/2-phase-locking-protocol" target="_blank" rel="noopener">Concurrency Control</a></li><li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" target="_blank" rel="noopener">The Nightmare of Locking, Blocking and Isolation Levels!</a></li><li><a href="http://blog.csdn.net/d2457638978/article/details/48783923" target="_blank" rel="noopener">三级模式与两级映像</a></li><li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" target="_blank" rel="noopener">Database Normalization and Normal Forms with an Example</a></li><li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" target="_blank" rel="noopener">The basics of the InnoDB undo logging and history system</a></li><li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" target="_blank" rel="noopener">MySQL locking for the busy web developer</a></li><li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">浅入浅出 MySQL 和 InnoDB</a></li><li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">Innodb 中的事务隔离级别和锁的关系</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一事务&quot;&gt;一、事务&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概念&quot;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四大特性&quot;&gt;四大特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#autocomm
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="编程基础知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2018/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2018/04/23/计算机网络/</id>
    <published>2018-04-23T11:47:11.000Z</published>
    <updated>2018-07-04T12:05:27.299Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一概述">一、概述</a><ul><li><a href="#网络的网络">网络的网络</a></li><li><a href="#isp">ISP</a></li><li><a href="#互联网的组成">互联网的组成</a></li><li><a href="#主机之间的通信方式">主机之间的通信方式</a></li><li><a href="#电路交换与分组交换">电路交换与分组交换</a></li><li><a href="#时延">时延</a></li><li><a href="#计算机网络体系结构">计算机网络体系结构*</a></li></ul></li><li><a href="#二物理层">二、物理层</a><ul><li><a href="#通信方式">通信方式</a></li><li><a href="#带通调制">带通调制</a></li><li><a href="#信道复用技术">信道复用技术</a></li></ul></li><li><a href="#三数据链路层">三、数据链路层</a><ul><li><a href="#信道分类">信道分类</a></li><li><a href="#三个基本问题">三个基本问题</a></li><li><a href="#局域网">局域网</a></li><li><a href="#ppp-协议">PPP 协议</a></li><li><a href="#csmacd-协议">CSMA/CD 协议*</a></li><li><a href="#扩展局域网">扩展局域网*</a></li><li><a href="#mac-层">MAC 层*</a></li></ul></li><li><a href="#四网络层">四、网络层*</a><ul><li><a href="#网际协议-ip-概述">网际协议 IP 概述</a></li><li><a href="#ip-数据报格式">IP 数据报格式</a></li><li><a href="#ip-地址编址方式">IP 地址编址方式</a></li><li><a href="#ip-地址和-mac-地址">IP 地址和 MAC 地址</a></li><li><a href="#地址解析协议-arp">地址解析协议 ARP</a></li><li><a href="#路由器的结构">路由器的结构</a></li><li><a href="#路由器分组转发流程">路由器分组转发流程</a></li><li><a href="#路由选择协议">路由选择协议</a></li><li><a href="#网际控制报文协议-icmp">网际控制报文协议 ICMP</a></li><li><a href="#分组网间探测-ping">分组网间探测 PING</a></li><li><a href="#虚拟专用网-vpn">虚拟专用网 VPN</a></li><li><a href="#网络地址转换-nat">网络地址转换 NAT</a></li></ul></li><li><a href="#五运输层">五、运输层*</a><ul><li><a href="#udp-和-tcp-的特点">UDP 和 TCP 的特点</a></li><li><a href="#udp-首部格式">UDP 首部格式</a></li><li><a href="#tcp-首部格式">TCP 首部格式</a></li><li><a href="#tcp-的三次握手">TCP 的三次握手</a></li><li><a href="#tcp-的四次挥手">TCP 的四次挥手</a></li><li><a href="#tcp-滑动窗口">TCP 滑动窗口</a></li><li><a href="#tcp-可靠传输">TCP 可靠传输</a></li><li><a href="#tcp-流量控制">TCP 流量控制</a></li><li><a href="#tcp-拥塞控制">TCP 拥塞控制</a></li></ul></li><li><a href="#六应用层">六、应用层*</a><ul><li><a href="#域名系统-dns">域名系统 DNS</a></li><li><a href="#文件传输协议-ftp">文件传输协议 FTP</a></li><li><a href="#远程终端协议-telnet">远程终端协议 TELNET</a></li><li><a href="#电子邮件协议">电子邮件协议</a></li><li><a href="#动态主机配置协议-dhcp">动态主机配置协议 DHCP</a></li><li><a href="#点对点传输-p2p">点对点传输 P2P</a></li><li><a href="#web-页面请求过程">Web 页面请求过程</a></li><li><a href="#常用端口">常用端口</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p><p><div align="center"> <img src="/image/pics//77f81379-3987-4036-8d7c-93a4dcf7b05d.jpg" width="800"> </div><br></p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。</p><p>互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><p><div align="center"> <img src="/image/pics//02986f62-c641-44a8-a55f-983581490e0c.png" width="700"> </div><br></p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><ol><li><p>边缘部分：所有连接在互联网上的主机，用户可以直接使用；</p></li><li><p>核心部分：由大量的网络和连接这些网络的路由器组成，为边缘部分的主机提供服务。</p></li></ol><p><div align="center"> <img src="/image/pics//10f5e35b-1c71-4717-9e80-47f259702642.jpg" width="600"> </div><br></p><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><ol><li><p>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</p></li><li><p>对等（P2P）：不区分客户和服务器。</p></li></ol><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><p><div align="center"> <img src="/image/pics//d1f81ac3-9fdb-4371-a49d-ca84917aa89f.jpg" width="800"> </div><br></p><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1. 电路交换"></a>1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><h3 id="2-报文交换"><a href="#2-报文交换" class="headerlink" title="2. 报文交换"></a>2. 报文交换</h3><p>报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。</p><h3 id="3-分组交换"><a href="#3-分组交换" class="headerlink" title="3. 分组交换"></a>3. 分组交换</h3><p>分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。</p><p><div align="center"> <img src="/image/pics//94589319-975f-490b-8bae-90b3a4953559.png" width="600"> </div><br></p><p>存储转发允许在一条传输线路上传送多个主机的分组，也就是说两个用户之间的通信不需要占用端到端的线路资源。</p><p>相比于报文交换，由于分组比报文更小，因此分组交换的存储转发速度更加快速。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p><p><div align="center"> <img src="/image/pics//3939369b-3a4a-48a0-b9eb-3efae26dd400.png" width="800"> </div><br></p><h3 id="1-发送时延"><a href="#1-发送时延" class="headerlink" title="1. 发送时延"></a>1. 发送时延</h3><p>主机或路由器发送数据帧所需要的时间。</p><p>$$<br>delay= \frac{l(bit)}{v(bit/s)}<br>$$</p><p>其中 l 表示数据帧的长度，v 表示发送速率。</p><h3 id="2-传播时延"><a href="#2-传播时延" class="headerlink" title="2. 传播时延"></a>2. 传播时延</h3><p>电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。</p><p>$$<br>delay=\frac{l(m)}{v(m/s)}<br>$$</p><p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。</p><h3 id="3-处理时延"><a href="#3-处理时延" class="headerlink" title="3. 处理时延"></a>3. 处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据部、进行差错检验或查找适当的路由等。</p><h3 id="4-排队时延"><a href="#4-排队时延" class="headerlink" title="4. 排队时延"></a>4. 排队时延</h3><p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构*"></a>计算机网络体系结构*</h2><p><div align="center"> <img src="/image/pics//426df589-6f97-4622-b74d-4a81fcb1da8e.png" width="800"> </div><br></p><h3 id="1-七层协议"><a href="#1-七层协议" class="headerlink" title="1. 七层协议"></a>1. 七层协议</h3><p>如图 a 所示，其中表示层和会话层用途如下：</p><ol><li>表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩；</li><li>会话层：不同机器上的用户之间建立及管理会话。</li></ol><h3 id="2-五层协议"><a href="#2-五层协议" class="headerlink" title="2. 五层协议"></a>2. 五层协议</h3><ol><li><p>应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</p></li><li><p>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p></li><li><p>网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</p></li><li><p>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。</p></li><li><p>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></li></ol><h3 id="3-数据在各层之间的传递过程"><a href="#3-数据在各层之间的传递过程" class="headerlink" title="3. 数据在各层之间的传递过程"></a>3. 数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p><p><div align="center"> <img src="/image/pics//ac106e7e-489a-4082-abd9-dabebe48394c.jpg" width="800"> </div><br></p><h3 id="4-TCP-IP-体系结构"><a href="#4-TCP-IP-体系结构" class="headerlink" title="4. TCP/IP 体系结构"></a>4. TCP/IP 体系结构</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><div align="center"> <img src="/image/pics//45e0e0bf-386d-4280-a341-a0b9496c7674.png" width="400"> </div><br></p><p>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p><p><div align="center"> <img src="/image/pics//d4eef1e2-5703-4ca4-82ab-8dda93d6b81f.png" width="500"> </div><br></p><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><ol><li>单向通信，又称为单工通信；</li><li>双向交替通信，又称为半双工通信；</li><li>双向同时通信，又称为全双工通信。</li></ol><h2 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><p><div align="center"> <img src="/image/pics//7b68b142-9489-44f6-87b0-4cb5c6431e63.jpg" width="600"> </div><br></p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="1-频分复用、时分复用"><a href="#1-频分复用、时分复用" class="headerlink" title="1. 频分复用、时分复用"></a>1. 频分复用、时分复用</h3><p>频分复用的所有用户在相同的时间占用不同的频率带宽资源；时分复用的所有用户在不同的时间占用相同的频率带宽资源。</p><p>使用这两种方式进行通信，在通信的过程中用户会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p><p><div align="center"> <img src="/image/pics//f3bfe11f-9cba-4ff2-8cc6-629068408a80.jpg" width="600"> </div><br></p><h3 id="2-统计时分复用"><a href="#2-统计时分复用" class="headerlink" title="2. 统计时分复用"></a>2. 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><p><div align="center"> <img src="/image/pics//5999e5de-7c16-4b52-b3aa-6dc7b58c7894.png" width="700"> </div><br></p><h3 id="3-波分复用"><a href="#3-波分复用" class="headerlink" title="3. 波分复用"></a>3. 波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><p><div align="center"> <img src="/image/pics//21041ec2-babb-483f-bf47-8b8148eec162.png" width="700"> </div><br></p><h3 id="4-码分复用"><a href="#4-码分复用" class="headerlink" title="4. 码分复用"></a>4. 码分复用</h3><p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"> 和 <img src="https://latex.codecogs.com/gif.latex?\vec{T}"> 有</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{T}=0"></div> <br></p><p>为了讨论方便，取 m=8，设码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p><p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S}=1"></div> <br></p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S'}=-1"></div> <br></p><p>其中 <img src="https://latex.codecogs.com/gif.latex?\vec{S'}"> 为 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"> 的反码。</p><p>利用上面的式子我们知道，当接收端使用码片 <img src="https://latex.codecogs.com/gif.latex?\vec{S}"> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p><p>码分复用需要发送的数据量为原先的 m 倍。</p><p><div align="center"> <img src="/image/pics//92ad9bae-7d02-43ba-8115-a9d6f530ca28.png" width="600"> </div><br></p><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><ol><li>点对点信道：一对一通信方式；</li><li>广播信道：一对多通信方式。</li></ol><h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><div align="center"> <img src="/image/pics//ea5f3efe-d5e6-499b-b278-9e898af61257.jpg" width="500"> </div><br></p><h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符，如果出现转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><p><div align="center"> <img src="/image/pics//c5022dd3-be22-4250-b9f6-38ae984a04d7.jpg" width="600"> </div><br></p><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h3><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是典型的一种广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>可以按照网络拓扑对局域网进行分类：</p><p><div align="center"> <img src="/image/pics//a6026bb4-3daf-439f-b1ec-a5a24e19d2fb.jpg" width="600"> </div><br></p><h2 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h2><p>用于点对点信道中。互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p><div align="center"> <img src="/image/pics//ddcf2327-8d84-425d-8535-121a94bcb88d.jpg" width="600"> </div><br></p><p>在 PPP 的帧中：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><p><div align="center"> <img src="/image/pics//69f16984-a66f-4288-82e4-79b4aa43e835.jpg" width="500"> </div><br></p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议*"></a>CSMA/CD 协议*</h2><p>用于广播信道中。在广播信道上，同一时间只能允许一台计算机发送数据。</p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>多点接入</strong> ：说明这是总线型网络，许多计算机以多点的方式连接到总线上。</li><li><strong>载波监听</strong> ：每个站都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p><div align="center"> <img src="/image/pics//5aa82b89-f266-44da-887d-18f31f01d8ef.png" width="600"> </div><br></p><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为  <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用  <strong>截断二进制指数退避算法</strong>  来确定，从离散的整数集合 {0, 1, ./image, (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h2 id="扩展局域网"><a href="#扩展局域网" class="headerlink" title="扩展局域网*"></a>扩展局域网*</h2><h3 id="1-在物理层进行扩展"><a href="#1-在物理层进行扩展" class="headerlink" title="1. 在物理层进行扩展"></a>1. 在物理层进行扩展</h3><p>使用集线器进行扩展。</p><p>集线器的主要功能是对接收到的信号进行放大，以扩大网络的传输距离。</p><p>集线器不能根据 MAC 地址进行转发，而是以广播的方式发送数据帧。</p><p>集线器是一种共享式的传输设备，意味着同一时刻只能传输一组数据帧。</p><p><div align="center"> <img src="/image/pics//823cdab7-3779-4e3a-a951-dc2d154e0ee6.jpg" width="800"> </div><br></p><h3 id="2-在链路层进行扩展"><a href="#2-在链路层进行扩展" class="headerlink" title="2. 在链路层进行扩展"></a>2. 在链路层进行扩展</h3><p>最开始使用的是网桥，它收到一个帧时，根据帧的 MAC 地址，查找网桥中的地址表，确定帧转发的接口。</p><p>网桥不是共享式设备，因此性能比集线器这种共享式设备更高。</p><p>交换机的问世很快就淘汰了网桥，它实质上是一个多接口网桥，而网桥是两接口。交换机的每个接口都能直接与一个主机或者另一个交换机相连，并且一般都工作在全双工方式。</p><p>交换机具有自学习能力，学习的是交换表的内容。交换表中存储着 MAC 地址到接口的映射。下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧。主机 B 收下之后，查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 3 的映射。</p><p><div align="center"> <img src="/image/pics//c9cfcd20-c901-435f-9a07-3e46830c359f.jpg" width="800"> </div><br></p><h3 id="3-虚拟局域网"><a href="#3-虚拟局域网" class="headerlink" title="3. 虚拟局域网"></a>3. 虚拟局域网</h3><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息，例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p><p><div align="center"> <img src="/image/pics//a74b70ac-323a-4b31-b4d5-90569b8a944b.png" width="600"> </div><br></p><h2 id="MAC-层"><a href="#MAC-层" class="headerlink" title="MAC 层*"></a>MAC 层*</h2><p>MAC 地址是 6 字节（48 位）的地址，用于唯一标识网络适配器（网卡），一台主机拥有多少个适配器就有多少个 MAC 地址，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。</p><p><div align="center"> <img src="/image/pics//50d38e84-238f-4081-8876-14ef6d7938b5.jpg" width="600"> </div><br></p><p>在 MAC 帧中：</p><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li><li><strong>前同步码</strong> ：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。</li></ul><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层*"></a>四、网络层*</h1><h2 id="网际协议-IP-概述"><a href="#网际协议-IP-概述" class="headerlink" title="网际协议 IP 概述"></a>网际协议 IP 概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p><div align="center"> <img src="/image/pics//7b038838-c75b-4538-ae84-6299386704e5.jpg" width="500"> </div><br></p><p>与 IP 协议配套使用的还有三个协议：</p><ol><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ol><p><div align="center"> <img src="/image/pics//0a9f4125-b6ab-4e94-a807-fd7070ae726a.png" width="400"> </div><br></p><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><p><div align="center"> <img src="/image/pics//85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700"> </div><br></p><ul><li><p><strong>版本</strong>  : 有 4（IPv4）和 6（IPv6）两个值；</p></li><li><p><strong>首部长度</strong>  : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务</strong>  : 用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度</strong>  : 包括首部长度和数据部分长度。</p></li><li><p><strong>标识</strong>  : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>片偏移</strong>  : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><p><div align="center"> <img src="/image/pics//23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700"> </div><br></p><ul><li><p><strong>生存时间</strong>  ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p></li></ul><h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ol><li>分类</li><li>子网划分</li><li>无分类</li></ol><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><div align="center"> <img src="/image/pics//cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500"> </div><br></p><h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2. 子网划分"></a>2. 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><h3 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3. 无分类"></a>3. 无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为  <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="IP-地址和-MAC-地址"><a href="#IP-地址和-MAC-地址" class="headerlink" title="IP 地址和 MAC 地址"></a>IP 地址和 MAC 地址</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p><div align="center"> <img src="/image/pics//66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" width="700"> </div><br></p><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><p>实现由 IP 地址得到 MAC 地址。</p><p><div align="center"> <img src="/image/pics//b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" width="500"> </div><br></p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。</p><p><div align="center"> <img src="/image/pics//8006a450-6c2f-498c-a928-c927f758b1d0.png" width="700"> </div><br></p><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p><div align="center"> <img src="/image/pics//c3369072-c740-43b0-b276-202bd1d3960d.jpg" width="600"> </div><br></p><h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><ol><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ol><p><div align="center"> <img src="/image/pics//1ab49e39-012b-4383-8284-26570987e3c4.jpg" width="800"> </div><br></p><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>互联网使用的路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ol><li>内部网关协议 IGP（Interior Gateway Protocol）：在 AS 内部使用，如 RIP 和 OSPF。</li><li>外部网关协议 EGP（External Gateway Protocol）：在 AS 之间使用，如 BGP。</li></ol><p><div align="center"> <img src="/image/pics//276c31df-3b28-4ac2-b006-1e80fc86a64f.jpg" width="600"> </div><br></p><h3 id="1-内部网关协议-RIP"><a href="#1-内部网关协议-RIP" class="headerlink" title="1. 内部网关协议 RIP"></a>1. 内部网关协议 RIP</h3><p>RIP 是一种分布式的基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ol><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ol><p>RIP 协议实现简单，开销小，但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3 id="2-内部网关协议-OSPF"><a href="#2-内部网关协议-OSPF" class="headerlink" title="2. 内部网关协议 OSPF"></a>2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3 id="3-外部网关协议-BGP"><a href="#3-外部网关协议-BGP" class="headerlink" title="3. 外部网关协议 BGP"></a>3. 外部网关协议 BGP</h3><p>AS 之间的路由选择很困难，主要是互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</p><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。它采用路径向量路由选择协议。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><p><div align="center"> <img src="/image/pics//9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png" width="600"> </div><br></p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p><div align="center"> <img src="/image/pics//e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"> </div><br></p><p>ICMP 报文分为差错报告报文和询问报文。</p><p><div align="center"> <img src="/image/pics//aa29cc88-7256-4399-8c7f-3cf4a6489559.png" width="600"> </div><br></p><h2 id="分组网间探测-PING"><a href="#分组网间探测-PING" class="headerlink" title="分组网间探测 PING"></a>分组网间探测 PING</h2><p>PING 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报。</p><p>Ping 的过程：</p><ol><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，但 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ol><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ol><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ol><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p><div align="center"> <img src="/image/pics//1556770b-8c01-4681-af10-46f1df69202c.jpg" width="800"> </div><br></p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><p><div align="center"> <img src="/image/pics//2719067e-b299-4639-9065-bed6729dbf0b.png" width=""> </div><br></p><h1 id="五、运输层"><a href="#五、运输层" class="headerlink" title="五、运输层*"></a>五、运输层*</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h2><ul><li><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。</p></li><li><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。</p></li></ul><h2 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h2><p><div align="center"> <img src="/image/pics//d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" width="600"> </div><br></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p><div align="center"> <img src="/image/pics//55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700"> </div><br></p><ul><li><p><strong>序号</strong>  ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p><strong>确认号</strong>  ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p><strong>数据偏移</strong>  ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p><strong>确认 ACK</strong>  ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p><strong>同步 SYN</strong>  ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p><strong>终止 FIN</strong>  ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p></li><li><p><strong>窗口</strong>  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><p><div align="center"> <img src="/image/pics//e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600"> </div><br></p><p>假设 A 为客户端，B 为服务器端。</p><ol><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ol><p><strong>三次握手的原因</strong> </p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。</p><h2 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h2><p><div align="center"> <img src="/image/pics//f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"> </div><br></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ol><li><p>A 发送连接释放报文段，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2MSL 时间后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ol><p><strong>四次挥手的原因</strong> </p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong> </p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ol><li><p>确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。</p></li><li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。</p></li></ol><h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p><div align="center"> <img src="/image/pics//a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" width="800"> </div><br></p><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><h2 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT"></div> <br></p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d"></div> <br></p><p>其中 RTT<sub>d</sub> 为偏差。</p><h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><div align="center"> <img src="/image/pics//51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500"> </div><br></p><p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ol><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ol><p><div align="center"> <img src="/image/pics//910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"> </div><br></p><h3 id="1-慢开始与拥塞避免"><a href="#1-慢开始与拥塞避免" class="headerlink" title="1. 慢开始与拥塞避免"></a>1. 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。</p><h3 id="2-快重传与快恢复"><a href="#2-快重传与快恢复" class="headerlink" title="2. 快重传与快恢复"></a>2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M~1~ 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p><p>在发送方，如果收到三个==重复确认==，那么可以确认下一个报文段丢失，例如收到三个 M<sub>2</sub> ，则 M<sub>3</sub> 丢失。此时执行快重传，立即重传下一个报文段。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p><div align="center"> <img src="/image/pics//f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png" width="600"> </div><br></p><h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层*"></a>六、应用层*</h1><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><p>把主机名解析为 IP 地址。</p><p>被设计成分布式系统。</p><p>==DNS解析过程的请求和回答都是使用的UDP数据报。==</p><h3 id="1-层次结构"><a href="#1-层次结构" class="headerlink" title="1. 层次结构"></a>1. 层次结构</h3><p>一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。</p><p><div align="center"> <img src="/image/pics//c2117f61-1177-4768-bf33-cf4f950d911c.png" width=""> </div><br></p><p><div align="center"> <img src="/image/pics//a4b162e5-db2a-4a27-b213-1fe481c5a06a.png" width=""> </div><br></p><p>域名服务器可以分为以下四类：</p><ol><li>根域名服务器：解析顶级域名；</li><li>顶级域名服务器：解析二级域名；</li><li>权限域名服务器：解析区内的域名；</li><li>本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。</li></ol><p>区和域的概念不同，可以在一个域中划分多个区。图 b 在域 abc.com 中划分了两个区：abc.com 和 y.abc.com</p><p><div align="center"> <img src="/image/pics//fc0c6b2d-68c7-4de8-aaaa-97355a4f0472.jpg" width=""> </div><br></p><p>因此就需要两个权限域名服务器：</p><p><div align="center"> <img src="/image/pics//8b335d94-c1ca-42e1-ad48-bb179d28a4f1.jpg" width=""> </div><br></p><h3 id="2-解析过程"><a href="#2-解析过程" class="headerlink" title="2. 解析过程"></a>2. 解析过程</h3><p>主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。</p><p>迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归的方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。</p><p><div align="center"> <img src="/image/pics//e6723b94-1a33-4605-b775-f6813352d383.png" width="800"> </div><br></p><h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h2><p>FTP 在运输层使用 TCP，并且需要建立两个并行的 TCP 连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开，而数据连接在数据传送完毕之后就关闭。控制连接使用端口号 21，数据连接使用端口号 20。</p><p><div align="center"> <img src="/image/pics//30210b86-472d-4574-abb6-b74898cc17a4.jpg" width="700"> </div><br></p><h2 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><p><div align="center"> <img src="/image/pics//7b3efa99-d306-4982-8cfb-e7153c33aab4.png" width="700"> </div><br></p><h3 id="1-POP3"><a href="#1-POP3" class="headerlink" title="1. POP3"></a>1. POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p><h3 id="2-IMAP"><a href="#2-IMAP" class="headerlink" title="2. IMAP"></a>2. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。</p><h3 id="3-SMTP"><a href="#3-SMTP" class="headerlink" title="3. SMTP"></a>3. SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则。</p><p><div align="center"> <img src="/image/pics//ed5522bb-3a60-481c-8654-43e7195a48fe.png" width=""> </div><br></p><h2 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h2><p>DHCP 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。</p><p>工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。</p><h2 id="点对点传输-P2P"><a href="#点对点传输-P2P" class="headerlink" title="点对点传输 P2P"></a>点对点传输 P2P</h2><p>把某个文件分发的所有对等集合称为一个洪流。文件的数据单元称为文件块，它的大小是固定的。一个新的对等方加入某个洪流，一开始并没有文件块，但是能够从其它对等方中逐渐地下载到一些文件块，与此同时，它也为别的对等方上传一些文件块。</p><p>每个洪流都有一个基础设施，称为追踪器。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。可以在任何时间加入和退出某个洪流。</p><p>一个新的对等方加入洪流时，追踪器会随机从洪流中选择若干个对等方，并让新对等方与这些对等方建立连接，把这些对等方称为相邻对等方。接收和发送文件块都是在相邻对等方中进行。</p><p>当一个对等方需要很多文件块时，通过使用最稀有优先的策略来取得文件块，也就是一个文件块在相邻对等方中副本最少，那么就优先请求这个文件块。</p><p>当很多对等方向同一个对等方请求文件块时，该对等方优先选择以最高速率向其发送文件块的对等方。</p><p>P2P 是一个分布式系统，任何时候都有对等方加入或者退出。使用分布式散列表 DHT，可以查找洪流中的资源和 IP 地址映射。</p><h2 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h2><h3 id="1-DHCP-配置主机信息"><a href="#1-DHCP-配置主机信息" class="headerlink" title="1. DHCP 配置主机信息"></a>1. DHCP 配置主机信息</h3><ol><li><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p></li><li><p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p></li><li><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p></li><li><p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</p></li><li><p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p></li><li><p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p></li><li><p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p></li></ol><h3 id="2-ARP-解析-MAC-地址"><a href="#2-ARP-解析-MAC-地址" class="headerlink" title="2. ARP 解析 MAC 地址"></a>2. ARP 解析 MAC 地址</h3><ol><li><p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p></li><li><p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p></li><li><p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p></li><li><p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p></li><li><p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p></li><li><p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p></li><li><p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p></li></ol><h3 id="3-DNS-解析域名"><a href="#3-DNS-解析域名" class="headerlink" title="3. DNS 解析域名"></a>3. DNS 解析域名</h3><ol><li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p></li><li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p></li><li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p></li><li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p></li><li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p></li></ol><h3 id="4-HTTP-请求页面"><a href="#4-HTTP-请求页面" class="headerlink" title="4. HTTP 请求页面"></a>4. HTTP 请求页面</h3><ol><li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p></li><li><p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p></li><li><p>HTTP 服务器收到该报文段之后，生成 TCP SYNACK 报文段，发回给主机。</p></li><li><p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p></li><li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p></li><li><p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p></li></ol><h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><table><thead><tr><th>应用层协议</th><th>端口号</th><th>运输层协议</th></tr></thead><tbody><tr><td>DNS</td><td>53</td><td>UDP</td></tr><tr><td>FTP</td><td>控制连接 21，数据连接 20</td><td>TCP</td></tr><tr><td>TELNET</td><td>23</td><td>TCP</td></tr><tr><td>DHCP</td><td>67 68</td><td>UDP</td></tr><tr><td>HTTP</td><td>80</td><td>TCP</td></tr><tr><td>SMTP</td><td>25</td><td>TCP</td></tr><tr><td>POP3</td><td>110</td><td>TCP</td></tr><tr><td>IMAP</td><td>143</td><td>TCP</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>计算机网络, 谢希仁</li><li>JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一概述&quot;&gt;一、概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#网络的网络&quot;&gt;网络的网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#isp&quot;&gt;ISP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#互联网的
      
    
    </summary>
    
      <category term="编程基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="http://yoursite.com/2018/04/16/1_Java%20IO/"/>
    <id>http://yoursite.com/2018/04/16/1_Java IO/</id>
    <published>2018-04-16T04:05:41.000Z</published>
    <updated>2018-07-03T15:41:50.082Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一概览">一、概览</a></li><li><a href="#二磁盘操作">二、磁盘操作</a></li><li><a href="#三字节操作">三、字节操作</a></li><li><a href="#四字符操作">四、字符操作</a></li><li><a href="#五对象操作">五、对象操作</a></li><li><a href="#六网络操作">六、网络操作</a><ul><li><a href="#inetaddress">InetAddress</a></li><li><a href="#url">URL</a></li><li><a href="#sockets">Sockets</a></li><li><a href="#datagram">Datagram</a></li></ul></li><li><a href="#七nio">七、NIO</a><ul><li><a href="#流与块">流与块</a></li><li><a href="#通道与缓冲区">通道与缓冲区</a></li><li><a href="#缓冲区状态变量">缓冲区状态变量</a></li><li><a href="#文件-nio-实例">文件 NIO 实例</a></li><li><a href="#套接字-nio-实例">套接字 NIO 实例</a></li><li><a href="#内存映射文件">内存映射文件</a></li><li><a href="#对比">对比</a></li></ul></li><li><a href="#八参考资料">八、参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I/O 大概可以分成以下几类：</p><ol><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ol><h1 id="二、磁盘操作"><a href="#二、磁盘操作" class="headerlink" title="二、磁盘操作"></a>二、磁盘操作</h1><p>File 类可以用于表示文件和目录，但是它只用于表示文件的信息，而不表示文件的内容。</p><h1 id="三、字节操作"><a href="#三、字节操作" class="headerlink" title="三、字节操作"></a>三、字节操作</h1><div align="center"> <img src="/image/pics//DP-Decorator-java.io.png" width="500"> </div><p><br></p><p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，InputStream 是抽象组件，FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作。FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能，例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</p><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br></pre></td></tr></table></figure><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><p>批量读入文件内容到字节数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> bytes = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 最多读取 buf.length 个字节，返回的是实际读取的个数，返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line"><span class="keyword">while</span>((bytes = in.read(buf, <span class="number">0</span> , buf.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、字符操作"><a href="#四、字符操作" class="headerlink" title="四、字符操作"></a>四、字符操作</h1><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p><p>InputStreamReader 实现从文本文件的字节流解码成字符流；OutputStreamWriter 实现字符流编码成为文本文件的字节流。它们继承自 Reader 和 Writer。</p><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(encoding);     <span class="comment">// 编码</span></span><br><span class="line">String str = <span class="keyword">new</span> String(bytes, encoding)； <span class="comment">// 解码</span></span><br></pre></td></tr></table></figure><p>GBK 编码中，中文占 2 个字节，英文占 1 个字节；UTF-8 编码中，中文占 3 个字节，英文占 1 个字节；Java 使用双字节编码 UTF-16be，中文和英文都占 2 个字节。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><h1 id="五、对象操作"><a href="#五、对象操作" class="headerlink" title="五、对象操作"></a>五、对象操作</h1><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><p>序列化：ObjectOutputStream.writeObject()</p><p>反序列化：ObjectInputStream.readObject()</p><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现。</p><p>transient 关键字可以使一些属性不会被序列化。</p><p><strong>ArrayList 序列化和反序列化的实现</strong> ：ArrayList 中存储数据的数组是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><h1 id="六、网络操作"><a href="#六、网络操作" class="headerlink" title="六、网络操作"></a>六、网络操作</h1><p>Java 中的网络支持：</p><ol><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符，通过 URL 可以直接读取或者写入网络上的数据；</li><li>Sockets：使用 TCP 协议实现网络通信；</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ol><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>没有公有构造函数，只能通过静态方法来创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="keyword">byte</span>[] addr);</span><br></pre></td></tr></table></figure><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>可以直接从 URL 中读取字节流数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">InputStream is = url.openStream();                           <span class="comment">// 字节流</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">"utf-8"</span>);  <span class="comment">// 字符流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String line = br.readLine();</span><br><span class="line"><span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">    line = br.readLine();</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">isr.close();</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><ul><li>ServerSocket：服务器端类</li><li>Socket：客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><p><div align="center"> <img src="/image/pics//ClienteServidorSockets1521731145260.jpg"> </div><br></p><h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><ul><li>DatagramPacket：数据包类</li><li>DatagramSocket：通信类</li></ul><h1 id="七、NIO"><a href="#七、NIO" class="headerlink" title="七、NIO"></a>七、NIO</h1><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。</p><h2 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>面向流的 I/O 一次处理一个字节数据，一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p><p>一个面向块的 I/O 系统以块的形式处理数据，一次处理一个数据块。按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h2 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h2><h3 id="1-通道"><a href="#1-通道" class="headerlink" title="1. 通道"></a>1. 通道</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p><p>通道与流的不同之处在于，流只能在一个方向上移动，(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>通道包括以下类型：</p><ul><li>FileChannel：从文件中读写数据；</li><li>DatagramChannel：通过 UDP 读写网络中数据；</li><li>SocketChannel：通过 TCP 读写网络中数据；</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h3 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h3><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h2 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h2><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p><p><div align="center"> <img src="/image/pics//1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png"> </div><br></p><p>② 从输入通道中读取 3 个字节数据写入缓冲区中，此时 position 移动设为 3，limit 保持不变。</p><p><div align="center"> <img src="/image/pics//4628274c-25b6-4053-97cf-d1239b44c43d.png"> </div><br></p><p>③ 以下图例为已经从输入通道读取了 5 个字节数据写入缓冲区中。在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p><p><div align="center"> <img src="/image/pics//952e06bd-5a65-4cab-82e4-dd1536462f38.png"> </div><br></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p><p><div align="center"> <img src="/image/pics//b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png"> </div><br></p><p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p><p><div align="center"> <img src="/image/pics//67bf5487-c45d-49b6-b9c0-a058d8c68902.png"> </div><br></p><h2 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h2><p>① 为要读取的文件创建 FileInputStream，之后通过 FileInputStream 获取输入 FileChannel；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"readandshow.txt"</span>);</span><br><span class="line">FileChannel fic = fin.getChannel();</span><br></pre></td></tr></table></figure><p>② 创建一个容量为 1024 的 Buffer；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>③ 将数据从输入 FileChannel 写入到 Buffer 中，如果没有数据的话，read() 方法会返回 -1；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = fcin.read(buffer);</span><br><span class="line"><span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④ 为要写入的文件创建 FileOutputStream，之后通过 FileOutputStream 获取输出 FileChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"writesomebytes.txt"</span>);</span><br><span class="line">FileChannel foc = fout.getChannel();</span><br></pre></td></tr></table></figure><p>⑤ 调用 flip() 切换读写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.flip();</span><br></pre></td></tr></table></figure><p>⑥ 把 Buffer 中的数据读取到输出 FileChannel 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foc.write(buffer);</span><br></pre></td></tr></table></figure><p>⑦ 最后调用 clear() 重置缓冲区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.clear();</span><br></pre></td></tr></table></figure><h2 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2><h3 id="1-ServerSocketChannel"><a href="#1-ServerSocketChannel" class="headerlink" title="1. ServerSocketChannel"></a>1. ServerSocketChannel</h3><p>每一个监听端口都需要有一个 ServerSocketChannel 用来监听连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 设置为非阻塞</span></span><br><span class="line"></span><br><span class="line">ServerSocket ss = ssc.socket();</span><br><span class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(ports[i]);</span><br><span class="line">ss.bind(address); <span class="comment">// 绑定端口号</span></span><br></pre></td></tr></table></figure><h3 id="2-Selectors"><a href="#2-Selectors" class="headerlink" title="2. Selectors"></a>2. Selectors</h3><p>异步 I/O 通过 Selector 注册对特定 I/O 事件的兴趣 ― 可读的数据的到达、新的套接字连接等等，在发生这样的事件时，系统将会发送通知。</p><p>创建 Selectors 之后，就可以对不同的通道对象调用 register() 方法。register() 的第一个参数总是这个 Selector。第二个参数是 OP_ACCEPT，这里它指定我们想要监听 ACCEPT 事件，也就是在新的连接建立时所发生的事件。</p><p>SelectionKey 代表这个通道在此 Selector 上的这个注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">SelectionKey key = ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><h3 id="3-主循环"><a href="#3-主循环" class="headerlink" title="3. 主循环"></a>3. 主循环</h3><p>首先，我们调用 Selector 的 select() 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时，select() 方法将返回所发生的事件的数量。</p><p>接下来，我们调用 Selector 的 selectedKeys() 方法，它返回发生了事件的 SelectionKey 对象的一个集合。</p><p>我们通过迭代 SelectionKeys 并依次处理每个 SelectionKey 来处理事件。对于每一个 SelectionKey，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line"></span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator it = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     SelectionKey key = (SelectionKey)it.next();</span><br><span class="line">     <span class="comment">// ... deal with I/O event ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-监听新连接"><a href="#4-监听新连接" class="headerlink" title="4. 监听新连接"></a>4. 监听新连接</h3><p>程序执行到这里，我们仅注册了 ServerSocketChannel，并且仅注册它们“接收”事件。为确认这一点，我们对 SelectionKey 调用 readyOps() 方法，并检查发生了什么类型的事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</span><br><span class="line">     == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line">     <span class="comment">// Accept the new connection</span></span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以肯定地说，readOps() 方法告诉我们该事件是新的连接。</p><h3 id="5-接受新的连接"><a href="#5-接受新的连接" class="headerlink" title="5. 接受新的连接"></a>5. 接受新的连接</h3><p>因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 accept() 操作会阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</span><br><span class="line">SocketChannel sc = ssc.accept();</span><br></pre></td></tr></table></figure><p>下一步是将新连接的 SocketChannel 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 SocketChannel 注册到 Selector 上，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>注意我们使用 register() 的 OP_READ 参数，将 SocketChannel 注册用于读取而不是接受新连接。</p><h3 id="6-删除处理过的-SelectionKey"><a href="#6-删除处理过的-SelectionKey" class="headerlink" title="6. 删除处理过的 SelectionKey"></a>6. 删除处理过的 SelectionKey</h3><p>在处理 SelectionKey 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的 remove() 方法来删除处理过的 SelectionKey：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it.remove();</span><br></pre></td></tr></table></figure><p>现在我们可以返回主循环并接受从一个套接字中传入的数据 (或者一个传入的 I/O 事件) 了。</p><h3 id="7-传入的-I-O"><a href="#7-传入的-I-O" class="headerlink" title="7. 传入的 I/O"></a>7. 传入的 I/O</h3><p>当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 Selector.select()，并返回一个或者多个 I/O 事件。这一次， SelectionKey 将被标记为 OP_READ 事件，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ)</span><br><span class="line">     == SelectionKey.OP_READ) &#123;</span><br><span class="line">     <span class="comment">// Read the data</span></span><br><span class="line">     SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p><p>只有文件中实际读取或者写入的部分才会映射到内存中。</p><p>现代操作系统一般会根据需要将文件的部分映射为内存的部分，从而实现文件系统。Java 内存映射机制只不过是在底层操作系统中可以采用这种机制时，提供了对该机制的访问。</p><p>向内存映射文件写入可能是危险的，仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p><p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，您可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p><ul><li>NIO 是非阻塞的。应当注意，FileChannel 不能切换到非阻塞模式，套接字 Channel 可以。</li><li>NIO 面向块，I/O 面向流。</li></ul><h1 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h1><ul><li>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</li><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM: NIO 入门</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" target="_blank" rel="noopener">深入分析 Java I/O 的工作机制</a></li><li><a href="http://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">NIO 与传统 IO 的区别</a></li><li><a href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" target="_blank" rel="noopener">Decorator Design Pattern</a></li><li><a href="http://labojava.blogspot.com/2012/12/socket-multicast.html" target="_blank" rel="noopener">Socket Multicast</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一概览&quot;&gt;一、概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二磁盘操作&quot;&gt;二、磁盘操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三字节操作&quot;&gt;三、字节操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href
      
    
    </summary>
    
      <category term="Java基础知识" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="编程语法" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机学习</title>
    <link href="http://yoursite.com/2018/04/05/1_Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/04/05/1_Java 虚拟机/</id>
    <published>2018-04-05T05:09:56.000Z</published>
    <updated>2018-07-03T10:07:18.719Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一运行时数据区域">一、运行时数据区域</a><ul><li><a href="#程序计数器">程序计数器</a></li><li><a href="#虚拟机栈">虚拟机栈</a></li><li><a href="#本地方法栈">本地方法栈</a></li><li><a href="#堆">堆</a></li><li><a href="#方法区">方法区</a></li><li><a href="#运行时常量池">运行时常量池</a></li><li><a href="#直接内存">直接内存</a></li></ul></li><li><a href="#二垃圾收集">二、垃圾收集</a><ul><li><a href="#判断一个对象是否可回收">判断一个对象是否可回收</a></li><li><a href="#垃圾收集算法">垃圾收集算法</a></li><li><a href="#垃圾收集器">垃圾收集器</a></li><li><a href="#内存分配与回收策略">内存分配与回收策略</a></li><li><a href="#full-gc-的触发条件">Full GC 的触发条件</a></li></ul></li><li><a href="#三类加载机制">三、类加载机制</a><ul><li><a href="#类的生命周期">类的生命周期</a></li><li><a href="#类初始化时机">类初始化时机</a></li><li><a href="#类加载过程">类加载过程</a></li><li><a href="#类加载器">类加载器</a></li></ul></li><li><a href="#四jvm-参数">四、JVM 参数</a><ul><li><a href="#gc-优化配置">GC 优化配置</a></li><li><a href="#gc-类型设置">GC 类型设置</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a>一、运行时数据区域</h1><p><div align="center"> <img src="/image/pics//540631a4-6018-40a5-aed7-081e2eeeaeea.png" width="500"> </div><br></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><div align="center"> <img src="/image/pics//f5757d09-88e7-4bbd-8cfb-cecf55604854.png" width=""> </div><br></p><p>可以通过 -Xss 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss=<span class="number">512</span>M HackTheJava</span><br></pre></td></tr></table></figure><p>该区域可能抛出以下异常：</p><ol><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li></ol><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法不是用 Java 实现，对待这些方法需要特别处理。</p><p>与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p><p><div align="center"> <img src="/image/pics//JNIFigure1.gif" width="350"> </div><br></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有对象实例都在这里分配内存。</p><p>是垃圾收集的主要区域（”GC 堆”），现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把 Java 堆分成以下三块：</p><ul><li>新生代（Young Generation）</li><li>老年代（Old Generation）</li><li>永久代（Permanent Generation）</li></ul><p>当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间：</p><ul><li>Eden</li><li>From Survivor</li><li>To Survivor</li></ul><p><div align="center"> <img src="/image/pics//ppt_img.gif" width=""> </div><br></p><p>Java 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p><p>可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms=<span class="number">1</span>M -Xmx=<span class="number">2</span>M HackTheJava</span><br></pre></td></tr></table></figure><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。JDK1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收，JDK8 之后，取消了永久代，用 metaspace（元数据）区替代。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。</p><p>Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><h1 id="二、垃圾收集"><a href="#二、垃圾收集" class="headerlink" title="二、垃圾收集"></a>二、垃圾收集</h1><p>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。</p><h2 id="判断一个对象是否可回收"><a href="#判断一个对象是否可回收" class="headerlink" title="判断一个对象是否可回收"></a>判断一个对象是否可回收</h2><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br></pre></td></tr></table></figure><h3 id="2-可达性"><a href="#2-可达性" class="headerlink" title="2. 可达性"></a>2. 可达性</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是可用的，不可达的对象可被回收。</p><p><div align="center"> <img src="/image/pics//0635cbe8.png" width=""> </div><br></p><p>GC Roots 一般包含以下内容：</p><ol><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中引用的对象</li></ol><h3 id="3-引用类型"><a href="#3-引用类型" class="headerlink" title="3. 引用类型"></a>3. 引用类型</h3><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与引用有关。</p><p>Java 对引用的概念进行了扩充，引入四种强度不同的引用类型。</p><p><strong>（一）强引用</strong> </p><p>只要强引用存在，垃圾回收器永远不会回收被引用的对象。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p><strong>（二）软引用</strong> </p><p>用来描述一些还有用但是并非必需的对象。</p><p>在系统将要发生内存溢出异常之前，会将这些对象列进回收范围之中进行第二次回收。</p><p>软引用主要用来实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源获取数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源获取这些数据。</p><p>使用 SoftReference 类来实现软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure><p><strong>（三）弱引用</strong> </p><p>只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会被回收。</p><p>使用 WeakReference 类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure><p><strong>（四）虚引用</strong> </p><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><p>使用 PhantomReference 来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure><h3 id="4-方法区的回收"><a href="#4-方法区的回收" class="headerlink" title="4. 方法区的回收"></a>4. 方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p><ol><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ol><p>可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。</p><p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGo 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p><h3 id="5-finalize"><a href="#5-finalize" class="headerlink" title="5. finalize()"></a>5. finalize()</h3><p>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h3><p><div align="center"> <img src="/image/pics//a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" width=""> </div><br></p><p>将需要回收的对象进行标记，然后清除。</p><p>不足：</p><ol><li>标记和清除过程效率都不高；</li><li>会产生大量碎片，内存碎片过多可能导致无法给大对象分配内存。</li></ol><h3 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h3><p><div align="center"> <img src="/image/pics//902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" width=""> </div><br></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h3><p><div align="center"> <img src="/image/pics//e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" width=""> </div><br></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是只使用了内存的一半。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和 使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间。</p><h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将 Java 堆分为新生代和老年代。</p><ol><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清理 或者 标记 - 整理 算法</li></ol><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><div align="center"> <img src="/image/pics//c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" width=""> </div><br></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用.。</p><h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><p><div align="center"> <img src="/image/pics//22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" width=""> </div><br></p><p>它是单线程的收集器，不仅意味着只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停所有其他工作线程，往往造成过长的等待时间。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>在 Client 应用场景中，分配给虚拟机管理的内存一般来说不会很大，该收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h3><p><div align="center"> <img src="/image/pics//81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" width=""> </div><br></p><p>它是 Serial 收集器的多线程版本。</p><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h3><p>是并行的多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。自适应调节策略也是它与 ParNew 收集器的一个重要区别。</p><h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h3><p><div align="center"> <img src="/image/pics//08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" width=""> </div><br></p><p>Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</p><ol><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ol><h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h3><p><div align="center"> <img src="/image/pics//278fe431-af88-4a95-a895-9c3b80117de3.jpg" width=""> </div><br></p><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h3><p><div align="center"> <img src="/image/pics//62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" width=""> </div><br></p><p>CMS（Concurrent Mark Sweep），从 Mark Sweep 可以知道它是基于标记 - 清除算法实现的。</p><p>特点：并发收集、低停顿。</p><p>分为以下四个流程：</p><ol><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ol><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ol><li><p>对 CPU 资源敏感。CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4，当 CPU 不足 4 个时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。并且低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率变低。</p></li><li><p>无法处理浮动垃圾。由于并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留到下一次 GC 时再清理掉，这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此它不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。可以使用 -XX:CMSInitiatingOccupancyFraction 的值来改变触发收集器工作的内存占用百分比，JDK 1.5 默认设置下该值为 68，也就是当老年代使用了 68% 的空间之后会触发收集器工作。如果该值设置的太高，导致浮动垃圾无法保存，那么就会出现 Concurrent Mode Failure，此时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集。</p></li><li><p>标记 - 清除算法导致的空间碎片，给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</p></li></ol><h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><p><div align="center"> <img src="/image/pics//f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" width=""> </div><br></p><p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。</p><p>具备如下特点：</p><ul><li>并行与并发：能充分利用多 CPU 环境下的硬件优势，使用多个 CPU 来缩短停顿时间。</li><li>分代收集：分代概念依然得以保留，虽然它不需要其它收集器配合就能独立管理整个 GC 堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次 GC 的旧对象来获取更好的收集效果。</li><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：这是它相对 CMS 的一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。</li></ul><p>在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老生代，而 G1 不再是这样，Java 堆的内存布局与其他收集器有很大区别，将整个 Java 堆划分为多个大小相等的独立区域（Region）。虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分 Region（不需要连续）的集合。</p><p>之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。它跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了它在有限的时间内可以获取尽可能高的收集效率。</p><p>Region 不可能是孤立的，一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个 Java 堆才能保证准确性，这显然是对 GC 效率的极大伤害。为了避免全堆扫描的发生，每个 Region 都维护了一个与之对应的 Remembered Set。虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中，如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ol><h3 id="8-七种垃圾收集器的比较"><a href="#8-七种垃圾收集器的比较" class="headerlink" title="8. 七种垃圾收集器的比较"></a>8. 七种垃圾收集器的比较</h3><table><thead><tr><th style="text-align:center">收集器</th><th style="text-align:center">串行、并行 or 并发</th><th style="text-align:center">新生代 / 老年代</th><th style="text-align:center">算法</th><th style="text-align:center">目标</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Serial</strong></td><td style="text-align:center">串行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单 CPU 环境下的 Client 模式</td></tr><tr><td style="text-align:center"><strong>Serial Old</strong></td><td style="text-align:center">串行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单 CPU 环境下的 Client 模式、CMS 的后备预案</td></tr><tr><td style="text-align:center"><strong>ParNew</strong></td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr><tr><td style="text-align:center"><strong>Parallel Scavenge</strong></td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>Parallel Old</strong></td><td style="text-align:center">并行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>CMS</strong></td><td style="text-align:center">并发</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-清除</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">集中在互联网站或 B/S 系统服务端上的 Java 应用</td></tr><tr><td style="text-align:center"><strong>G1</strong></td><td style="text-align:center">并发</td><td style="text-align:center">both</td><td style="text-align:center">标记-整理 + 复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">面向服务端应用，将来替换 CMS</td></tr></tbody></table><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。</p><h3 id="1-优先在-Eden-分配"><a href="#1-优先在-Eden-分配" class="headerlink" title="1. 优先在 Eden 分配"></a>1. 优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p><p>关于 Minor GC 和 Full GC：</p><ul><li>Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。</li></ul><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>提供 -XX:PretenureSizeThreshold 参数，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p><h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h3><p>JVM 为对象定义年龄计数器，经过 Minor GC 依然存活，并且能被 Survivor 区容纳的，移被移到 Survivor 区，年龄就增加 1 岁，增加到一定年龄则移动到老年代中（默认 15 岁，通过 -XX:MaxTenuringThreshold 设置）。</p><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>JVM 并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等待 MaxTenuringThreshold 中要求的年龄。</p><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生 Minor GC 之前，JVM 先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话 JVM 会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。</p><h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h3 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h3><p>此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc()。</p><h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。</p><h3 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。</p><h3 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h3 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h1 id="三、类加载机制"><a href="#三、类加载机制" class="headerlink" title="三、类加载机制"></a>三、类加载机制</h1><p>类是在运行期间动态加载的。</p><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><div align="center"> <img src="/image/pics//32b8374a-e822-4720-af0b-c0f485095ea2.jpg" width=""> </div><br></p><p>包括以下 7 个阶段：</p><ul><li><strong>加载（Loading）</strong> </li><li><strong>验证（Verification）</strong> </li><li><strong>准备（Preparation）</strong> </li><li><strong>解析（Resolution）</strong> </li><li><strong>初始化（Initialization）</strong> </li><li></li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><h2 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h2><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随着发生）：</p><ol><li><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p></li><li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</p></li><li><p>当使用 JDK.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p></li></ol><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value); <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载是类加载的一个阶段，注意不要混淆。</p><p>加载过程完成以下三件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。</li><li>在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>其中二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。</li><li>从网络中获取，这种场景最典型的应用是 Applet。</li><li>运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li><li>由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li><li>从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。<br>…</li></ul><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>主要有以下 4 个阶段：</p><p>（一）文件格式验证</p><p>验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。</p><p>（二）元数据验证</p><p>对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</p><p>（三）字节码验证</p><p>通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。</p><p>（四）符号引用验证</p><p>发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p><p>实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。</p><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>将常量池的符号引用替换为直接引用的过程。</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。</p><p>在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p><p>&lt;clinit&gt;() 方法具有以下特点：</p><ul><li>是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>与类的构造函数（或者说实例构造器 &lt;init&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 &lt;clinit&gt;() 方法运行之前，父类的 &lt;clinit&gt;() 方法已经执行结束。因此虚拟机中第一个执行 &lt;clinit&gt;() 方法的类肯定为 java.lang.Object。</p></li><li><p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 输出结果是父类中的静态变量 A 的值 ，也就是 2。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>&lt;clinit&gt;() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 &lt;clinit&gt;() 方法。</p></li><li><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p></li><li><p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。</p></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流 ( 即字节码 )”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><h3 id="1-类与类加载器"><a href="#1-类与类加载器" class="headerlink" title="1. 类与类加载器"></a>1. 类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗而言：比较两个类是否“相等”（这里所指的“相等”，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况），只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><h3 id="2-类加载器分类"><a href="#2-类加载器分类" class="headerlink" title="2. 类加载器分类"></a>2. 类加载器分类</h3><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；</p></li><li><p>所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</p></li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p></li><li><p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p></li><li><p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ul><h3 id="3-双亲委派模型"><a href="#3-双亲委派模型" class="headerlink" title="3. 双亲委派模型"></a>3. 双亲委派模型</h3><p>应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</p><p><div align="center"> <img src="/image/pics//class_loader_hierarchy.png" width="600"> </div><br></p><p><strong>（一）工作过程</strong> </p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是把这个请求委派给父类加载器，每一个层次的加载器都是如此，依次递归。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成此加载请求（它搜索范围中没有找到所需类）时，子加载器才会尝试自己加载。</p><p><strong>（二）好处</strong> </p><p>使用双亲委派模型来组织类加载器之间的关系，使得 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型，由各个类加载器自行加载的话，如果用户编写了一个称为java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将变得一片混乱。如果开发者尝试编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但是永远无法被加载运行。</p><p><strong>（三）实现</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">// 先检查请求的类是否已经被加载过了</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出 ClassNotFoundException，说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器无法完成加载请求，再调用自身的 findClass() 来进行加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、JVM-参数"><a href="#四、JVM-参数" class="headerlink" title="四、JVM 参数"></a>四、JVM 参数</h1><h2 id="GC-优化配置"><a href="#GC-优化配置" class="headerlink" title="GC 优化配置"></a>GC 优化配置</h2><table><thead><tr><th>配置</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>初始化堆内存大小</td></tr><tr><td>-Xmx</td><td>堆内存最大值</td></tr><tr><td>-Xmn</td><td>新生代大小</td></tr><tr><td>-XX:PermSize</td><td>初始化永久代大小</td></tr><tr><td>-XX:MaxPermSize</td><td>永久代最大容量</td></tr></tbody></table><h2 id="GC-类型设置"><a href="#GC-类型设置" class="headerlink" title="GC 类型设置"></a>GC 类型设置</h2><table><thead><tr><th>配置</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>串行垃圾回收器</td></tr><tr><td>-XX:+UseParallelGC</td><td>并行垃圾回收器</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>并发标记扫描垃圾回收器</td></tr><tr><td>-XX:ParallelCMSThreads=</td><td>并发标记扫描垃圾回收器 = 为使用的线程数量</td></tr><tr><td>-XX:+UseG1GC</td><td>G1 垃圾回收器</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=<span class="number">20</span>m -XX:MaxPermSize=<span class="number">20</span>m -XX:+UseSerialGC -jar java-application.jar</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li><li><a href="https://www.slideshare.net/benewu/jvm-memory" target="_blank" rel="noopener">Jvm memory</a></li><li><a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/" target="_blank" rel="noopener">Memory Architecture Of JVM(Runtime Data Areas)</a></li><li><a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/" target="_blank" rel="noopener">JVM Run-Time Data Areas</a></li><li><a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271" target="_blank" rel="noopener">Android on x86: Java Native Interface and the Android Native Development Kit</a></li><li><a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener">深入理解 JVM(2)——GC 算法与内存分配策略</a></li><li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">深入理解 JVM(3)——7 种垃圾收集器</a></li><li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一运行时数据区域&quot;&gt;一、运行时数据区域&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#程序计数器&quot;&gt;程序计数器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#虚拟机栈&quot;&gt;虚拟机栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
      <category term="Java基础知识" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM虚拟机" scheme="http://yoursite.com/tags/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>设计模式补充-23种设计模式</title>
    <link href="http://yoursite.com/2018/04/01/1_Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2018/04/01/1_Java设计模式-模式补充/</id>
    <published>2018-04-01T09:02:13.000Z</published>
    <updated>2018-07-03T12:25:59.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式补充-23种设计模式"><a href="#设计模式补充-23种设计模式" class="headerlink" title="设计模式补充-23种设计模式"></a>设计模式补充-23种设计模式</h1><h2 id="设计模式补充"><a href="#设计模式补充" class="headerlink" title="设计模式补充"></a>设计模式补充</h2><p>​    这一个知识总结是对前面设计模式总结没有介绍的设计模式进行一个补充介绍。主要参考第四章模式系统里面的归纳，补充的设计模式主要来自于GOF的《设计模式》。</p><h2 id="设计模式概括"><a href="#设计模式概括" class="headerlink" title="设计模式概括"></a>设计模式概括</h2><p>设计模式分为三大类：</p><p><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>其实还有两类：并发型模式和线程池模式。</p><h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><p>​    那么,什么是设计模式呢?</p><p>​    从广义角度讲设计模式是可解决一类软件问题并能重复使用的设计方案;</p><p>​    从狭义角度讲设计模式是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述,是在类和对象的层次描述的可重复使用的软件设计问题的解决方案.</p><p>​    模式体现的是程序整体的构思,也会出现在分析或者是概要设计阶段,包括创建型模式、结构型模式和行为型模式.</p><p>​    ==模式的核心思想是通过增加抽象层,把变化部分从那些不变部分里分离出来.==</p><p>​    模式的四大基本要素包括：</p><p>​    1.<strong>模式名称（Pattern Name）</strong></p><p>​    2.<strong>问题（Problem）</strong>：描述应该在何时使用模式,解释了设计问题和问题存在的前因后果,可能还描述模式必须满足的先决条件</p><p>​    3.<strong>解决方案（Solution）</strong>：描述了设计的组成成分、相互关系及各自的职责和协作方式.模式就像一个模板,可应用于多种场合,所以解决方案并不描述一个具体的设计或实现,而是提供设计问题的抽象描述和解决问题所采用的元素组合（类和对象）.</p><p>​    4.<strong>效果（Consequences）</strong>：描述模式的应用效果及使用模式应权衡的问题.</p><h2 id="设计模式的SOLID原则"><a href="#设计模式的SOLID原则" class="headerlink" title="设计模式的SOLID原则"></a>设计模式的SOLID原则</h2><pre><code> **S.O.L.I.D **是面向对象设计(OOD)和面向对象编程(OOP)中的几个重要编码原则(Programming Priciple)的首字母缩写。前辈们总结出来的，遵循五大原则可以使程序解决紧耦合，更加健壮。</code></pre><p>​                                面向对象设计的原则<br>| 简称 | 全称 | 解释 |<br>| —- | ———————————– | ———— |<br>| SRP  | The Single Responsibility Principle | 单一职责原则 |<br>| OCP  | The Open Closed Principle           | 开放封闭原则 |<br>| LSP  | The Liskov Substitution Principle   | 里氏替换原则 |<br>| ISP  | The Interface Segregation Principle | 接口分离原则 |<br>| DIP  | The Dependency Inversion Principle  | 依赖倒置原则 |</p><p><strong>一、单一职责原则（SRP）</strong></p><p><strong>定义：</strong>不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 </p><p><strong>问题由来：</strong>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 </p><p><strong>解决方案：</strong>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p><p>遵循单一职责原的优点有： </p><ol><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； </li><li>提高类的可读性，提高系统的可维护性； </li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ol><p>​    需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。</p><p><strong>实际例子</strong></p><p>​    如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能抑制或者削弱这个类完成其他职责的能力。例如餐厅服务员负责把订单给厨师去做，而不是服务员又要订单又要炒菜。</p><p><img src="\image\java设计模式\单一职责原则-示例图.png" alt="单一职责原则-示例图"></p><p><strong>二、开闭原则（OCP）</strong></p><p><strong>定义：</strong>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 </p><p><strong>问题由来：</strong>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。 </p><p><strong>解决方案：</strong>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><p><strong>实际例子</strong></p><p>​    对扩展开放，对修改关闭。意为一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。例如一开始做了普通计算器程序，突然添加新需求，要再做一个程序员计算器，这时不应该修改普通计算器内部，应该使用面向接口编程，组合实现扩展。</p><p><img src="\image\java设计模式\开放封闭原则-示例图.png" alt="开放封闭原则-示例图"></p><p><strong>三、里氏替换原则（LSP）</strong></p><p><strong>定义：</strong>所有引用基类的地方必须能透明地使用其子类的对象。 </p><p><strong>问题由来：</strong>有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p><p><strong>解决方案：</strong>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p><p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： </p><ol><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 </li><li>子类中可以增加自己特有的方法。 </li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 </li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ol><p><strong>实际例子</strong></p><p>​    所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。例如机动车必须有轮胎和发动机，子类宝马和奔驰不应该改写没轮胎或者没发动机。</p><p><img src="\image\java设计模式\里氏替换原则-示例图.png" alt="里氏替换原则-示例图"></p><p><strong>四、接口隔离原则（ISP）</strong></p><p><strong>定义：</strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 </p><p><strong>问题由来：</strong>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 </p><p><strong>解决方案：</strong>将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p><p>​    很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>​    采用接口隔离原则对接口进行约束时，要注意以下几点： </p><ol><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 </li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 </li><li><p>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p><pre><code>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</code></pre></li></ol><p><strong>实际例子</strong></p><p>​    类不应该依赖不需要的接口，知道越少越好。例如电话接口只约束接电话和挂电话，不需要让依赖者知道还有通讯录。</p><p><img src="\image\java设计模式\接口隔离原则-示例图.png" alt="接口隔离原则-示例图"></p><p><strong>五、依赖倒置原则（DIP）</strong></p><p><strong>定义：</strong>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 </p><p><strong>问题由来：</strong>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 </p><p><strong>解决方案：</strong>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p><p>​    传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p><p>​    在实际编程中，我们一般需要做到如下3点：<br>​    1. 低层模块尽量都要有抽象类或接口，或者两者都有。<br>​    2. 变量的声明类型尽量是抽象类或接口。<br>​    3. 使用继承时遵循里氏替换原则。</p><p>​    依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p><p><strong>实际例子</strong></p><p>​    指的是高级模块不应该依赖低级模块，而是依赖抽象。抽象不能依赖细节，细节要依赖抽象。比如类A内有类B对象，称为类A依赖类B，但是不应该这样做，而是选择类A去依赖抽象。例如垃圾收集器不管垃圾是什么类型，要是垃圾就行。</p><p><img src="\image\java设计模式\依赖倒置原则-示例.png" alt="依赖倒置原则-示例"></p><p><strong>附、迪米特法则（最少知道原则）（Demeter Principle）</strong></p><p><strong>定义：</strong>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><p><strong>问题由来：</strong>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 </p><p><strong>解决方案：</strong>尽量降低类与类之间的耦合。</p><p><strong>总结</strong></p><p>​    单一职责原则告诉我们实现类要职责单一；</p><p>​    里氏替换原则告诉我们不要破坏继承体系；</p><p>​    依赖倒置原则告诉我们要面向接口编程；</p><p>​    接口隔离原则告诉我们在设计接口的时候要精简单一；</p><p>​    开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p><p>​    迪米特法则告诉我们要降低耦合。</p><p>参考资料：<a href="http://blog.csdn.net/Eastmount/article/details/41575053" target="_blank" rel="noopener">设计模式之SOLID原则再回首</a></p><p>​           <a href="http://blog.csdn.net/cj1029/article/details/49865913" target="_blank" rel="noopener">设计模式原则SOLID</a></p><p>​           <a href="http://blog.csdn.net/YegodYue/article/details/66887047" target="_blank" rel="noopener">设计模式之SOLID原则</a></p><h2 id="Interpreter-解释器-模式"><a href="#Interpreter-解释器-模式" class="headerlink" title="Interpreter(解释器)模式"></a>Interpreter(解释器)模式</h2><p><strong>实际的例子</strong></p><p>​    在执行加减乘除四则运算，或者执行正则表达式的时候，都是将表示的文本内容进行解释，然后再进行执行的。</p><p><strong>定义</strong></p><p>​    Interpreter(解释器)模式是一种特殊的设计模式，它建立一个解释器（Interpreter），对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。解释器模式属于行为模式，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><p><strong>组成结构</strong></p><p>​    Interpreter 模式UML结构图如图1所示：</p><p><img src="\image\java设计模式\Interpreter模式UML结构图.png" alt="Interpreter模式UML结构图"></p><p>​    一个解释器模式中包含的<strong>四种角色</strong></p><ul><li><p>抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器和非终结符解释器完成。</p></li><li><p>终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</p><p>自己的理解：终结符就是不可以再拆分、单一的符号，也就是语言的<strong>基本元素</strong>。</p></li><li><p>非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</p><p>自己的理解：非终结符，就是具有逻辑功能的、并不是表示数值的符号，实际上非终结符定义的是<strong>语言的规则</strong>。</p></li><li><p>环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。</p><p>​</p></li></ul><p><strong>例子</strong></p><p>​    我们需要一个能够解释加法和减法的解释器，那么最好的方式就是用解释器模式来实现。</p><p>​    先来看看抽象表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以环境为准，本方法解释给定的任何一个表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验两个表达式在结构上是否相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回表达式的hash code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将表达式转换成字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    因为需要解释加法和减法，因此实现类也有Plus和Minus两个非终结符表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression left,right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plus</span><span class="params">(Expression left , Expression right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Plus)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> left.equals(((Plus)obj).left) &amp;&amp;</span><br><span class="line">                right.equals(((Plus)obj).right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left.interpret(ctx) + right.interpret(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + left.toString() + <span class="string">" + "</span> + right.toString() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Expression left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Minus</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Minus) &#123;</span><br><span class="line">            <span class="keyword">return</span> left.equals(((Minus) obj).left) &amp;&amp; right.equals(((Minus) obj).right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> left.interpret(ctx) - right.interpret(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + left.toString() + <span class="string">" - "</span> + right.toString() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    除此之外我们还需要变量与常量两个终结符表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Constant</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Constant)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value == ((Constant)obj).value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(value).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Variable</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Variable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(</span><br><span class="line">                    ((Variable)obj).name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.lookup(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    环境角色基本可以存放文法中各个终结符所对应的具体值，下面的类就是用一个map来负责<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Variable,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Variable,Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Variable var , <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        map.put(var, <span class="keyword">new</span> Integer(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lookup</span><span class="params">(Variable var)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">        Integer value = map.get(var);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    Client客户端的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> Context();</span><br><span class="line">        Variable x = <span class="keyword">new</span> Variable(<span class="string">"x"</span>);</span><br><span class="line">        Variable y = <span class="keyword">new</span> Variable(<span class="string">"y"</span>);</span><br><span class="line">        Constant c = <span class="keyword">new</span> Constant(<span class="number">1</span>);</span><br><span class="line">        ctx.assign(x, <span class="number">2</span>);</span><br><span class="line">        ctx.assign(y, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        Expression exp = <span class="keyword">new</span> Plus(<span class="keyword">new</span> Plus(c,x) , <span class="keyword">new</span> Minus(y,x));</span><br><span class="line">        System.out.println(exp.toString() + <span class="string">"="</span> + exp.interpret(ctx));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    输出结果如下</p><p><code>((1 + x) + (y - x))=4</code></p><p><strong>优缺点</strong></p><p>​    解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了。比如我们现在需要修改Plus的含义，那么只需要修改Plus类即可，如果要增加乘法操作，那么也只需要增加一个Multiple类就行。<br>​    但是，解释器模式会引起类的膨胀，每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来非常多的麻烦。同时，从例子我们也可以看到，整个表达式的运算过程采用了递归调用方法，每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。由于使用了大量的循环和递归，效率是一个不容忽视的问题。特别是用于解释一个解析复杂、冗长的语法时，效率是难以忍受的。</p><p><strong>Interpreter 模式适用性：</strong></p><p>(1).可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</p><p>(2). 一些重复出现的问题可以用一种简单的语言来进行表达。</p><p>(3).一个语言的文法较为简单。</p><p>(4).执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。）</p><p><strong>Interpreter 模式使用总结：</strong></p><p>​        尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。</p><p><strong>总结</strong></p><p>​    解释器模式，将语言的表示与执行进行了分离。语言的表示会不停的变化，语言的执行也是会发生变化的。不变的是，语言的表示一定要的解释才能够执行。在解释器模式中要注意终结符和非终结符的区分。</p><p>参考资料：<a href="https://www.jianshu.com/p/c138a1d2be5e" target="_blank" rel="noopener">解释器模式</a></p><p>​           <a href="http://blog.csdn.net/fanyun_01/article/details/51862242" target="_blank" rel="noopener">Interpreter 模式详解–设计模式</a></p><h2 id="简单工厂模式（Simple-Factory）"><a href="#简单工厂模式（Simple-Factory）" class="headerlink" title="简单工厂模式（Simple Factory）"></a>简单工厂模式（Simple Factory）</h2><p><strong>定义</strong></p><p>​    简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式（同属于创建型模式的还有工厂方法模式，抽象工厂模式，单例模式，建造者模式）。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><strong>模式结构</strong></p><p><img src="\image\java设计模式\简单工厂模式结构图.jpg" alt="简单工厂模式结构图"></p><p>​    从上图可以看出，简单工厂模式由三部分组成：具体工厂、具体产品和抽象产品。</p><ul><li>工厂类（Creator）角色：担任这个角色的是简单工厂模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。</li><li>抽象产品（AbstractProduct）角色：担任这个角色的类是由简单工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现。</li><li><p>具体产品（ConcreteProduct）角色：简单工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。</p><p>产品类：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMW</span><span class="params">()</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW320</span> <span class="keyword">extends</span> <span class="title">BMW</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMW320</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;BMW320"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW523</span> <span class="keyword">extends</span> <span class="title">BMW</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMW523</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;BMW523"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    工厂类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BMW <span class="title">createBMW</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> <span class="number">320</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BMW320();  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">523</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BMW523();  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    客户类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        BMW bmw320 = Factory.createBMW(<span class="number">320</span>);  </span><br><span class="line">        BMW bmw523 = Factory.createBMW(<span class="number">523</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解决的问题</strong></p><p>​    将对象的使用与创建进行分离。例如，想要一辆奔驰车时，只需要向造车工厂传入奔驰车的型号，然后工厂就可以造出来一辆符合要求的奔驰车了，而不用去关注对象创建过程中的细节。</p><p><strong>简单工厂的优点/缺点：</strong></p><p>​    优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。<br>​    缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则。</p><p><strong>适用场景</strong></p><p>在以下情况下可以使用简单工厂模式：</p><p>1、工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p><p>2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p><p><strong>总结：</strong></p><p>​    客户端要求的具体产品会不断的变化，可能这一次需要车型A，下一次就需要车型B了，而且在工厂中建造不同车型的方法也不一样。但是，一辆车如果需要使用，那么一定要被建造。简单工厂模式就是固定了产品会被工厂创建的这种关系，同时将产品的消费和生产进行了分离。</p><p>参考资料:  <a href="http://blog.csdn.net/xingjiarong/article/details/49999121" target="_blank" rel="noopener">设计模式（一）简单工厂模式</a></p><p>​           <a href="http://blog.csdn.net/jason0539/article/details/23020989" target="_blank" rel="noopener">JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式)</a></p><h2 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h2><p><strong>定义</strong></p><p>​    工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类来规定创建对象的公共接口，而子类则负责生成具体的对象。</p><p><strong>解决的问题</strong></p><p>​    上文介绍的简单工厂模式存在一系列问题：</p><ul><li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</li><li>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</li><li>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</li></ul><p>为了解决上述的问题，我们又使用了一种新的设计模式：工厂方法模式。</p><p><strong>模式原理</strong></p><p>​    UML类图</p><p><img src="\image\java设计模式\工厂方法模式UML类图.jpg" alt="工厂方法模式UML类图"></p><p>​    模式的组成</p><table><thead><tr><th>组成（角色）</th><th>关系</th><th>作用</th></tr></thead><tbody><tr><td>抽象产品（Product）</td><td>具体产品的父类</td><td>描述具体产品的公共接口</td></tr><tr><td>具体产品（Concrete Product）</td><td>抽象产品的子类；工厂类创建的目标类</td><td>描述生产的具体产品</td></tr><tr><td>抽象工厂（Creator）</td><td>具体工厂的父类</td><td>描述具体工厂的公共接口</td></tr><tr><td>具体工厂（Concrete Creator）</td><td>抽象工厂的子类；被外界调用</td><td>描述具体工厂；实现FactoryMethod工厂方法创建产品的实例</td></tr></tbody></table><p>使用步骤</p><p>步骤1： 创建抽象工厂类，定义具体工厂的公共接口；<br>步骤2： 创建抽象产品类 ，定义具体产品的公共接口；<br>步骤3： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；<br>步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</p><p><strong>实际例子</strong></p><p><em>实例概况</em></p><p>背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；<br>冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；<br>解决方案：小成决定置办塑料分厂B来生产B类产品； </p><blockquote><p>即工厂方法模式</p></blockquote><p><em>使用步骤</em></p><p>步骤1： 创建抽象工厂类，定义具体工厂的公共接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">Manufacture</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤2： 创建抽象产品类 ，定义具体产品的公共接口；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体产品A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductA</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductB</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂A类 - 生产A类产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">Manufacture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂B类 - 生产B类产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">Manufacture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产工作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        FactoryA mFactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        mFactoryA.Manufacture().Show();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        FactoryB mFactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        mFactoryB.Manufacture().Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生产出了产品A</span><br><span class="line">生产出了产品C</span><br></pre></td></tr></table></figure></p><p><strong>优点</strong></p><ul><li><p>更符合开-闭原则<br>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</p><blockquote><p>简单工厂模式需要修改工厂类的判断逻辑</p></blockquote></li><li><p>符合单一职责原则<br>每个具体工厂类只负责创建对应的产品</p><blockquote><p>简单工厂中的工厂类存在复杂的switch逻辑判断</p></blockquote></li><li><p>不使用静态工厂方法，可以形成基于继承的等级结构。</p><blockquote><p>简单工厂模式的工厂类使用静态工厂方法</p></blockquote></li></ul><p>总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p><p><strong>缺点</strong></p><ul><li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li><li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li><li>一个具体工厂只能创建一种具体产品</li></ul><p><strong>应用场景</strong></p><p>在了解了优缺点后，我总结了工厂方法模式的应用场景：</p><ul><li>当一个类不知道它所需要的对象的类时<br>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</li><li>当一个类希望通过其子类来指定创建对象时<br>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><p><strong>答疑解惑</strong></p><p>使用工厂方法模式，看上去会感觉到这不是更麻烦了吗，直接在外界创建具体的抽象子类不行吗？还用这么麻烦的创建工厂子类，然后再用工厂子类去创建抽象子类。</p><p><strong>我将从两方面回答这个问题：</strong></p><ol><li>假设现在项目比较大，在外界很多地方都直接使用了抽象子类直接进行运算，这种方式在写代码的时候确实很快也很爽。但是，假设有一天，产品经理过来说要改需求，我现在不要加减乘除这四种运算了，我要换成更高级的其他运算。。。如果这样改起来改动就大了，需要把所有直接使用抽象子类实例化的地方都做修改。</li><li>这只是一种设计模式的思路，在程序的开发中没有一种设计模式是万能的，在适合的地方用适合的设计模式，或根据业务需求自己制定一套模式，这才是最好的。只有最适合业务的模式，才是最好的模式。</li></ol><p><strong>总结</strong></p><p>​    工厂方法模式是对简单工厂模式的改进，使得模式对修改关闭，对扩展开放。在工厂方法模式中，变化的是：随着具体产品的不同，那么对应的具体工厂也就不同。不变的是：产品与工厂的关系没有发生改变，产品还是要从工厂生产。这个模式依然可以使得对象的使用与创建分离。不过，相对于简单工厂模式，工厂方法模式更加往上抽象了一层。</p><p>参考资料: <a href="http://blog.csdn.net/jason0539/article/details/23020989" target="_blank" rel="noopener">JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式)</a></p><p>​         <a href="http://blog.csdn.net/carson_ho/article/details/52343584" target="_blank" rel="noopener">工厂方法模式（Factory Method）-最易懂的设计模式解析</a></p><p>​        <a href="https://www.jianshu.com/p/03519d5e47b6" target="_blank" rel="noopener">工厂模式三部曲－工厂方法模式</a></p><h2 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h2><p><strong>例子背景</strong></p><p>​    着客户的要求越来越高，宝马车需要不同配置的空调和发动机等配件。于是这个工厂开始生产空调和发动机，用来组装汽车。这时候工厂有两个系列的产品:空调和发动机。宝马320系列配置A型号空调和A型号发动机，宝马230系列配置B型号空调和B型号发动机。 </p><p><strong>问题 </strong></p><p>​     抽象工厂模式是工厂方法模式的升级版本，他用来创建==一组相关或者相互依赖的对象==。比如宝马320系列使用空调型号A和发动机型号A，而宝马230系列使用空调型号B和发动机型号B，那么使用抽象工厂模式，在为320系列生产相关配件时，就无需制定配件的型号，它会自动根据车型生产对应的配件型号A。</p><p><strong>抽象工厂（Abstract Factory）模式结构</strong></p><pre><code>抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品具体类型的情况下，创建多个产品族中的产品对象。这就是抽象工厂模式的用意。</code></pre><p>​        每个模式都是针对一定问题的解决方案。抽象工厂模式面对的问题是多产品等级结构的系统设计。<br>​        在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。<br>​        产品族：是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的CPU和ADM芯片的主板，组成一个家族。Intel的CPU和Intel芯片的主板，又组成一个家族。而这两个家族都来自于两个产品等级：CPU，主板。一个等级结构是由相同的结构的产品组成，示意图如下：</p><p><img src="\image\java设计模式\产品结构示意图.png" alt="产品结构示意图"></p><pre><code>理解这个产品结构是理解抽象工厂模式的关键所在，所以我不惜花费时间来画此图。如果领悟不到此图的含义，就无法区分工厂方法模式和抽象工厂模式的区别。</code></pre><p>​        从上图可以看出，抽象工厂模式的每个工厂创造出来的都是一族产品，而不是一个或者一组。组是可以随意组合的！其实两个就这点点差别，呵呵，估计现在你已经差不多明白了抽象工厂模式的含义。</p><p>​    抽象工厂模式中各个组件之间的结构如下图所示：</p><p>​         <img src="\image\java设计模式\抽象工厂结构.png" alt="抽象工厂结构"></p><p><strong>抽象工厂模式代码</strong></p><p>​    产品类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发动机以及型号  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineA</span> <span class="keyword">extends</span> <span class="title">Engine</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineA</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;EngineA"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineBextends</span> <span class="title">Engine</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineB</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;EngineB"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//空调以及型号  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aircondition</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirconditionA</span> <span class="keyword">extends</span> <span class="title">Aircondition</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirconditionA</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;AirconditionA"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirconditionB</span> <span class="keyword">extends</span> <span class="title">Aircondition</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirconditionB</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;AirconditionB"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    创建工厂类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂的接口  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//制造发动机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//制造空调 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span></span>; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为宝马320系列生产配件  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBMW320</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EngineA();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirconditionA();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//宝马523系列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBMW523</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EngineB();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirconditionB();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    客户:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//生产宝马320系列配件</span></span><br><span class="line">        FactoryBMW320 factoryBMW320 = <span class="keyword">new</span> FactoryBMW320();  </span><br><span class="line">        factoryBMW320.createEngine();</span><br><span class="line">        factoryBMW320.createAircondition();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//生产宝马523系列配件  </span></span><br><span class="line">        FactoryBMW523 factoryBMW523 = <span class="keyword">new</span> FactoryBMW523();  </span><br><span class="line">        factoryBMW320.createEngine();</span><br><span class="line">        factoryBMW320.createAircondition();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>抽象工厂模式的起源</strong></p><p>​    下面引用一段<a href="http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" target="_blank" rel="noopener">抽象工厂模式</a>的起源：</p><p>​    抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。</p><p>​    在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。</p><p><img src="\image\java设计模式\抽象工厂模式起源图1.png" alt="抽象工厂模式起源图1"></p><p>​    可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。</p><p><img src="\image\java设计模式\抽象工厂模式-产品等级.png" alt="抽象工厂模式-产品等级"></p><p>​    系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图：</p><p><img src="\image\java设计模式\抽象工厂模式的解决方案.png" alt="抽象工厂模式的解决方案"></p><p>​    显然，一个系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行。所以，系统实际上只能消费属于同一个产品族的产品。</p><p>​    在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了。</p><p><strong>总结</strong></p><p>​    抽象工厂模式，使得一个工厂可以创建一组相关或联系的对象，功能更加的强大。如果采用工厂方法模式，创建一组相关或联系的对象，会产生很多的工厂对象。说白了，抽象工厂模式也是一个工厂模式。</p><p>​    无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p><p>​       所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。</p><p>参考资料： <a href="http://blog.csdn.net/jason0539/article/details/44976775" target="_blank" rel="noopener">JAVA设计模式之抽象工厂模式</a></p><p>​            <a href="http://blog.51cto.com/lavasoft/11674" target="_blank" rel="noopener">Java设计模式圣经连载（03）－抽象工厂模式</a>    </p><p>​          《设计模式》</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>问题</strong></p><p>​    许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在计算机中只有一个打印机，那么管理打印机的程序就应该只有一个，否则会出现多个文件被同时打印的情况。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p><p><strong>概念</strong></p><p>​    单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p><p>​    j单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。<br>　　单例模式有以下特点：<br>　　1、单例类只能有一个实例。<br>　　2、单例类必须自己创建自己的唯一实例。<br>　　3、单例类必须给所有其他对象提供这一实例。<br>　　单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p><p><strong>基本的实现思路</strong></p><p>​    单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。</p><p>​    单例的实现主要是通过以下两个步骤：</p><ol><li>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</li><li>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li></ol><p><strong>注意事项</strong></p><p>​    单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建    方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p><p><strong>一、懒汉式单例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123;  </span><br><span class="line">             single = <span class="keyword">new</span> Singleton();</span><br><span class="line">         &#125;  </span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。</p><p>​    事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。</p><p>​    但是以上懒汉式单例的实现没有考虑线程安全问题，<strong>它是线程不安全</strong>的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全。</p><p>1、在getInstance方法上加同步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123;  </span><br><span class="line">             single = <span class="keyword">new</span> Singleton();</span><br><span class="line">         &#125;  </span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、双重检查锁定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton single=<span class="keyword">null</span>;<span class="comment">//注意有volatile关键字</span></span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                  singleton = <span class="keyword">new</span> Singleton(); </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    注意，使用双重检查锁定这种方式的时候，为了达到真正的线程安全，还需要在声明私有变量<em>singleton</em> 使用关键字volatile。然synchronized已经起到了多线程下原子性、有序性、可见性的作用，为什么还要加volatile呢，原因可参考<a href="http://www.iteye.com/topic/652440和http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html。" target="_blank" rel="noopener">http://www.iteye.com/topic/652440和http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html。</a></p><p>3、静态内部类(==zhg: 使用这种==)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> LazyHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这种比上面1、2都好一些，既实现了线程安全，又避免了同步带来的性能影响。    </p><p><strong>二、饿汉式单例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例类.在类初始化时，已经自行实例化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 single = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。</p><p>​    优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p>​    缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p><p><strong>三、登记式单例(可忽略)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似Spring里面的方法，将类名注册，下次从里面直接获取。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Singleton3&gt; map = <span class="keyword">new</span> HashMap&lt;String,Singleton3&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Singleton3 single = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        map.put(single.getClass().getName(), single);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保护的默认构造子</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态工厂方法,返还此类惟一的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = Singleton3.class.getName();</span><br><span class="line">            System.out.println(<span class="string">"name == null"</span>+<span class="string">"---&gt;name="</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map.get(name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                map.put(name, (Singleton3) Class.forName(name).newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一个示意性的商业方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">about</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, I am RegSingleton."</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton3 single3 = Singleton3.getInstance(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(single3.about());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。 </code></pre><p>​    这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。</p><p><strong>四、枚举方式单例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。</p><p><strong>饿汉式和懒汉式区别</strong></p><p>​    从名字上来说，饿汉和懒汉，</p><p>​    饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。</p><p>​    另外从以下两点再区分以下这两种方式：</p><p>​    1、线程安全：</p><p>​    饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，</p><p>​    懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。</p><p>​    2、资源加载和性能：</p><p>​    饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，</p><p>​    而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。</p><p>​    至于1、2、3这三种实现又有些区别，</p><p>​    第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的，</p><p>​    第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗</p><p>​    第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。</p><p><strong>什么是线程安全？</strong></p><p>​    如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>​    或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。</p><p><strong>总结</strong></p><p>​    由结果可以得知单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。</p><p>对于单例模式的几种实现方式，知道饿汉式和懒汉式的区别，线程安全，资源加载的时机，还有懒汉式为了实现线程安全的3种方式的细微差别。</p><p>参考资料：<a href="http://blog.csdn.net/jason0539/article/details/23297037" target="_blank" rel="noopener">JAVA设计模式之单例模式</a></p><p>​           <a href="http://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">单例模式的八种写法比较</a></p><h2 id="建造者-builder-模式"><a href="#建造者-builder-模式" class="headerlink" title="建造者(builder)模式"></a>建造者(builder)模式</h2><p><strong>定义</strong></p><p>​    在阎宏博士的《JAVA与模式》一书中开头是这样描述建造（Builder）模式的：</p><p>　　建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p><p>​    产品的内部表象：</p><p>​    一个产品常有不同的组成成分作为产品的零件，这些零件有可能是对象，也有可能不是对象，它们通常又叫做产品的内部表象（internal representation）。不同的产品可以有不同的内部表象，也就是不同的零件。使用建造模式可以使客户端不需要知道所生成的产品有哪些零件，每个产品的对应零件彼此有何不同，是怎么建造出来的，以及怎么组成产品。</p><p><strong>实际的例子</strong></p><p>​    有些情况下，一个对象会有一些重要的性质，在它们没有恰当的值之前，对象不能作为一个完整的产品使用。比如，一个电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，而在最起码的收件人地址得到赋值之前，这个电子邮件不能发送。</p><p>​    在进入肯德基点一个套餐时，每一个套餐的基本东西都是鸡翅、汉堡、可乐等，只不过不同的套餐中这些东西的组成不同，分量也不同。我们不用知道他们的具体组成方式，只用了解套餐就可以了。</p><p><strong>建造模式的结构</strong></p><p><img src="\image\java设计模式\建造者模式结构图.png" alt="建造者模式结构图"></p><p>​    在这个示意性的系统中，最终的产品Product只有两个部件，即part1和part2。相应的建造方法也有两个：buildPart1()和buildPart2()。同时可以看到该模式涉及到四个角色，它们分别是：</p><ul><li><p>Builder：抽象Builder类，规范产品的组建，一般是由子类实现。</p></li><li><p>ConcreteBulider: 抽象Builder类的实现类，实现抽象Builder类定义的所有方法，并且返回一个组建好的对象</p></li><li><p>Dirextor: 指挥者类，用于统一组装流程</p></li><li><p>Product: 产品类</p></li></ul><p>​    建造模式利用一个导演者对象和具体建造者对象一个个地建造出所有的零件，从而建造出完整的产品对象。建造者模式将产品的结构和产品的零件的建造过程对客户端隐藏起来。</p><p><strong>源代码</strong></p><p>产品类Product<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一些关于产品的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span>  String part1;</span><br><span class="line">    <span class="keyword">private</span>  String part2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> part1;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart1</span><span class="params">(String part1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part1 = part1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> part2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart2</span><span class="params">(String part2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part2 = part2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象建造者类Builder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">retrieveResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 具体建造者类ConcreteBuilder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品零件建造方法1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建产品的第一个零件</span></span><br><span class="line"> 　　　　product.setPart1(<span class="string">"编号：9527"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品零件建造方法2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建产品的第二个零件</span></span><br><span class="line"> 　　　　product.setPart2(<span class="string">"名称：XXX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品返还方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">retrieveResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>导演者类Director<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有当前需要使用的建造器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入建造器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder 建造器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品构造方法，负责调用各个零件建造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildPart1();</span><br><span class="line">        builder.buildPart2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端类Client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line">        Product product = builder.retrieveResult();</span><br><span class="line">        System.out.println(product.getPart1());</span><br><span class="line">        System.out.println(product.getPart2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>时序图</strong></p><p><img src="\image\java设计模式\建造者模式时序图.png" alt="建造者模式时序图"></p><p>​    客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。</p><p><strong>优缺点</strong></p><p>​    优点：</p><ul><li><p>使用建造者模式可以使客户端不必知道产品内部组成的细节。</p></li><li><p>具体的建造者类之间是相互独立的，容易扩展。</p></li><li><p>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p></li></ul><p>​    缺点：</p><ul><li>产生多余的Build对象以及Dirextor类。</li></ul><p><strong>总结</strong></p><p>​    在一个复杂对象的创建过程中，复杂对象的每一个部分可能会经常性的变化，但是将复杂对象各个部分组装到一起的算法比较稳定，这个时候就可以将具体每个部分的建造放在较低层次，组装流程放在较高层次。使得具体部分的建造改变不会影响整个复杂对象的创建。</p><p>​    建造模式在将复杂对象的装配过程封装在Dirctor中，并且客户端不用关注复杂对象建造的具体细节。</p><p>参考资料： <a href="http://blog.csdn.net/itachi85/article/details/50644745" target="_blank" rel="noopener">设计模式（三）建造者模式</a></p><p>​             <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html" target="_blank" rel="noopener">《JAVA与模式》之建造模式</a></p><h2 id="原型-Prototype-模式"><a href="#原型-Prototype-模式" class="headerlink" title="原型(Prototype)模式"></a>原型(Prototype)模式</h2><p><strong>定义</strong></p><p>​    原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。所谓原型模式，就是java中的克隆技术，以某个对象为原型。复制出新的对象。显然新的对象具备原型对象的特点。效率高（避免了重新执行构造过程步骤）</p><p>​    克隆类似于new，但和new不同。new创建新的对象属性采用的是默认值。克隆出来的对象的属性值完全和原型对象相同。并且克隆出的新对象不会影响原型对象，克隆后。还可以再修改克隆对象的值。</p><p>​    要实现原型模式，必须实现Cloneable接口，而这个接口里面是空的。</p><p>​    Cloneable接口是一个空接口，使用Cloneable接口都不用导入包。而clone方法是属于Object对象的。如果要克隆某个对象的话必须实现Cloneable接口。</p><p><strong>结构</strong></p><p><img src="\image\java设计模式\原型模式结构图.jpg" alt="原型模式结构图"></p><p>​    原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：</p><ul><li>实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</li><li>重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。</li></ul><p>​    原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，它的原型类Prototype也常用抽象类来替代。</p><p><strong>原型模式的注意事项</strong></p><ul><li>使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。</li><li>深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（8种基本数据类型byte,char,short,int,long,float,double，boolean），对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。</li></ul><p>​    如果我们要克隆某个对象有<strong>浅克隆和深克隆</strong></p><p>​    浅克隆：<strong>copy该对象，然后保留该对象原有的引用。也就是说不克隆该对象的属性。</strong></p><p>​    深克隆：<strong>copy该对象，并且把该对象的所有属性也克隆出一份新的。</strong></p><p><img src="\image\java设计模式\浅克隆与深克隆.jpg" alt="浅克隆与深克隆"></p><p><strong>实现代码：</strong></p><p>​    用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</p><p>1、浅克隆代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 原型模式:浅克隆</span></span><br><span class="line"><span class="comment"> * Cloneable是一个空接口（标记接口），是一个规范。但是如果要克隆这个类对象的话必须实现Cloneable接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写Object对象的clone方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用Object对象的clone方法</span></span><br><span class="line">        Object obj = <span class="keyword">super</span>.clone();<span class="comment">//这个super.clone()会将当前对象的属性进行拷贝，不过是浅拷贝。</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略get，set方法和构造方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试原型模式（浅克隆）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1274397294739L</span>);</span><br><span class="line">        Sheep s1 = <span class="keyword">new</span> Sheep(<span class="string">"原型羊"</span>,date);</span><br><span class="line">        Sheep s2 = (Sheep) s1.clone();<span class="comment">//克隆一个羊</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s1.getSname());</span><br><span class="line">        System.out.println(<span class="string">"原日期："</span>+s1.getBirthday());</span><br><span class="line">        date.setTime(<span class="number">34732834827389L</span>);<span class="comment">//改变原有date的值</span></span><br><span class="line">        System.out.println(<span class="string">"改变后的日期："</span>+date.toString());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//克隆羊的信息</span></span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s2.getSname());</span><br><span class="line">        System.out.println(s2.getBirthday());<span class="comment">//此时的birthday日期使用的是改变后的日期对象引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最后的结果为：克隆的对象仍然保留了原有对象的引用，值随着改变而改变<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.fz.prototype.Sheep@<span class="number">153f</span>67e</span><br><span class="line">原型羊</span><br><span class="line">原日期：Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br><span class="line"></span><br><span class="line">改变后的日期：Mon Aug <span class="number">22</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">27</span> CST <span class="number">3070</span></span><br><span class="line">---------------------------------</span><br><span class="line">com.fz.prototype.Sheep@<span class="number">18f</span>51f</span><br><span class="line">原型羊</span><br><span class="line">Mon Aug <span class="number">22</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">27</span> CST <span class="number">3070</span></span><br></pre></td></tr></table></figure></p><p>2、深克隆代码实现：克隆对象的同时，把该对象的属性也连带着克隆出新的。</p><p>深克隆只需要在clone方法中将该对象的属性也克隆即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重写Object对象的clone方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">//直接调用Object对象的clone方法</span></span><br><span class="line">    Object obj = <span class="keyword">super</span>.clone();</span><br><span class="line">    <span class="comment">//深克隆：把对象下的所有属性也克隆出来</span></span><br><span class="line">    Sheep22 s = (Sheep22) obj;</span><br><span class="line">    s.birthday = (Date) <span class="keyword">this</span>.birthday.clone();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试代码不变，结果则会变了。克隆了之后把原来的日期改变后，克隆的对象2的属性则不会被影响。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.fz.prototype.Sheep2@<span class="number">15</span>bdc50</span><br><span class="line">原型羊</span><br><span class="line">原日期：Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br><span class="line"></span><br><span class="line">改变后的日期：Mon Aug <span class="number">22</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">27</span> CST <span class="number">3070</span></span><br><span class="line">---------------------------------</span><br><span class="line">com.fz.prototype.Sheep2@<span class="number">18f</span>51f</span><br><span class="line">原型羊</span><br><span class="line">Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br></pre></td></tr></table></figure></p><p>3、通过序列化和反序列化来实现深克隆对象：序列化需要原型对象实现Serializable接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试原型模式（利用序列化和反序列化实现深克隆）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1274397294739L</span>);</span><br><span class="line">        Sheep s1 = <span class="keyword">new</span> Sheep(<span class="string">"原型羊"</span>,date);</span><br><span class="line">        <span class="comment">//      Sheep s2 = (Sheep) s1.clone();//克隆一个羊</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用序列化和反序列化实现深复制</span></span><br><span class="line">        <span class="comment">//1、将s1对象序列化为一个数组</span></span><br><span class="line">        <span class="comment">//通过ObjectOutputStream流将s1对象读出来给ByteArrayOutputStream流</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream    oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(s1);</span><br><span class="line">        <span class="comment">//ByteArrayOutputStream流将对象信息转成byte数组，这样byte数组里就包含了对象的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、将字节数组中的内容反序列化为一个Sheep对象</span></span><br><span class="line">        <span class="comment">//通过ByteArrayInputStream流读入bytes字节数组中数据，然后传给ObjectInputStream对象输入流</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream    ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="comment">//通过ObjectInputStream返回一个Sheep对象</span></span><br><span class="line">        Sheep s2 = (Sheep) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原型羊的信息</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(<span class="string">"原日期："</span>+s1.getBirthday());</span><br><span class="line">        date.setTime(<span class="number">34732834827389L</span>);<span class="comment">//改变原有date的值</span></span><br><span class="line">        System.out.println(<span class="string">"改变后的日期："</span>+date.toString());</span><br><span class="line">        <span class="comment">//克隆羊的信息</span></span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s2.getBirthday());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过序列化和反序列化的结果，最终结果还是和深克隆一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">com.fz.prototype.Sheep@<span class="number">1</span>a116c9</span><br><span class="line"></span><br><span class="line">原日期：Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br><span class="line"></span><br><span class="line">改变后的日期：Mon Aug <span class="number">22</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">27</span> CST <span class="number">3070</span></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">com.fz.prototype.Sheep@<span class="number">7</span>eb6e2</span><br><span class="line"></span><br><span class="line">Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br></pre></td></tr></table></figure></p><p><strong>测试克隆对象的效率</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fz.prototype;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 测试clone对象的效率</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNew</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Laptop l = <span class="keyword">new</span> Laptop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"new 对象耗时："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//clone 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testClone</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Laptop l = <span class="keyword">new</span> Laptop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Laptop temp = (Laptop) l.clone();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"clone 对象耗时："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testNew(<span class="number">1000</span>);</span><br><span class="line">        testClone(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟创建Laptop对象的时候比较耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后结果为：</p><p>new 对象耗时：10063</p><p>clone 对象耗时：10</p><p><strong>总结</strong></p><p>​    原型模式解决的问题是，复杂的对象需要多次创建，如果使用new创建，则会很耗时。使用原型模式，则可以极大的提升效率，并且可以向客户端隐藏创建对象的细节。</p><p>​    在使用原型模式的时候，要注意实现Clonable接口，并且要注意浅克隆和深克隆的区别。并且，使用原型模式的时候，构造函数的private权限会失效，这个时候就需要注意单例模式的实现了。在实现单例模式的时候，尽量不要再使用原型模式。</p><p>​    原型模式适用场景：如果某个对象new的过程中很耗时，则可以考虑使用原型模式。</p><p>​    Spring框架中bean对象的创建就两种模式：<strong>单例模式或者原型模式</strong>。</p><p>参考资料： <a href="http://blog.csdn.net/jason0539/article/details/23158081" target="_blank" rel="noopener">JAVA设计模式之原型模式</a></p><p>​            <a href="http://www.cnblogs.com/cxxjohnson/p/6403949.html" target="_blank" rel="noopener">原型模式（Prototype）</a></p><h2 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h2><p><strong>实际例子</strong></p><p>​    对于树形结构，在代码中有容器节点和叶子节点之分，容器节点可以有子节点，而叶子节点没有，所以两者是有区分的，而在实际使用中，我们更希望一致的对待他们，因为如若区别对待，在程序上会非常复杂。组合模式则是为了解决此类问题而生的，它可以让叶子对象和容器对象的使用具有一致性。他是组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。</p><p>​    比较常见的例子就是，电脑中的文件系统，一级目录里面有普通的文本文件、照片文件，还有二级目录。在做某些操作时，例如查看一个文件夹中所有文件大小（包括子目录中的文件），如果能将里面的文件统一对待，那么在迭代遍历的时候就会非常的方便。</p><p><img src="\image\java设计模式\文件系统目录层级结构.jpg" alt="文件系统目录层级结构"></p><p><strong>模式定义</strong></p><p>​    组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。<br>​    在组合模式中引入了抽象构件类Component，它是所有容器类和叶子类的公共父类，客户端针对Component进行编程。</p><p><strong>模式结构</strong></p><p><img src="\image\java设计模式\组合模式结构图.jpg" alt="组合模式结构图"></p><p><strong>Component</strong> 抽象构件，叶子构件和容器构件的接口或抽象类</p><p><strong>Leaf</strong> 叶子构件，叶子节点没有子节点</p><p><strong>Composite</strong> 容器构件，容器节点可以有子节点，子节点也可以是容<br>器构件。</p><p><strong>适用场景</strong></p><p>​    在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。 </p><p>​    在一个使用面向对象语言开发的系统中需要处理一个树形结构。 </p><p><strong>实现代码</strong></p><p>​    抽象角色，抽象文件： 具体文件和具体文件夹都继承该抽象文件角色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">showFileName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>树枝角色：具体文件夹<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;File&gt; fileList = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFile</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.add(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印文件夹下的文件名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayFiles</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file : <span class="keyword">this</span>.fileList)&#123;</span><br><span class="line">            file.showFileName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>叶子角色：具体文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TXTFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TXTFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVIFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVIFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端，模拟文件/文件夹树形结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Folder folder = <span class="keyword">new</span> Folder(<span class="string">"一级目录"</span>);</span><br><span class="line">        File txtFile = <span class="keyword">new</span> TXTFile(<span class="string">"二级文件txt"</span>);</span><br><span class="line">        File aviFile = <span class="keyword">new</span> AVIFile(<span class="string">"二级文件avi"</span>);</span><br><span class="line">        Folder txtFolder = <span class="keyword">new</span> Folder(<span class="string">"二级txt目录"</span>);</span><br><span class="line">        Folder aviFolder = <span class="keyword">new</span> Folder(<span class="string">"二级avi目录"</span>);</span><br><span class="line">    </span><br><span class="line">        File txtFile1 = <span class="keyword">new</span> TXTFile(<span class="string">"三级文件txt1"</span>);</span><br><span class="line">        File txtFile2 = <span class="keyword">new</span> TXTFile(<span class="string">"三级文件txt2"</span>);</span><br><span class="line">        File txtFile3 = <span class="keyword">new</span> TXTFile(<span class="string">"三级文件txt3"</span>);</span><br><span class="line">        File aviFile1 = <span class="keyword">new</span> AVIFile(<span class="string">"三级文件avi1"</span>);</span><br><span class="line">        File aviFile2 = <span class="keyword">new</span> AVIFile(<span class="string">"三级文件avi2"</span>);</span><br><span class="line">        </span><br><span class="line">        folder.addFile(txtFile);</span><br><span class="line">        folder.addFile(aviFile);</span><br><span class="line">        folder.addFile(txtFolder);</span><br><span class="line">        folder.addFile(aviFolder);</span><br><span class="line">        </span><br><span class="line">        txtFolder.addFile(txtFile1);</span><br><span class="line">        txtFolder.addFile(txtFile2);</span><br><span class="line">        txtFolder.addFile(txtFile3);</span><br><span class="line">        </span><br><span class="line">        aviFolder.addFile(aviFile1);</span><br><span class="line">        aviFolder.addFile(aviFile2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"一级目录下的文件:"</span>);</span><br><span class="line">        folder.displayFiles();</span><br><span class="line">        System.out.println(<span class="string">"\n二级txt目录下的文件:"</span>);</span><br><span class="line">        txtFolder.displayFiles();</span><br><span class="line">        System.out.println(<span class="string">"\n二级avi目录目录下的文件:"</span>);</span><br><span class="line">        aviFolder.displayFiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一级目录下的文件:</span><br><span class="line">二级文件txt</span><br><span class="line">二级文件avi</span><br><span class="line">二级txt目录</span><br><span class="line">二级avi目录</span><br><span class="line"></span><br><span class="line">二级txt目录下的文件:</span><br><span class="line">三级文件txt1</span><br><span class="line">三级文件txt2</span><br><span class="line">三级文件txt3</span><br><span class="line"></span><br><span class="line">二级avi目录目录下的文件:</span><br><span class="line">三级文件avi1</span><br><span class="line">三级文件avi2</span><br></pre></td></tr></table></figure></p><p><strong>总结</strong></p><p>​    树形结构由容器节点和叶子节点组成，组合模式将容器节点和叶子节点都转化为一种节点来使用。这样一来便可以将精力更专注于树的结构，而不是节点的类型上了。</p><p>​    使用组合模式构建的树形结构，很容易就可以进行遍历操作，可以将叶子和容器节点同等的对待。</p><p>参考资料：<a href="http://www.cnblogs.com/chenpi/p/5196870.html" target="_blank" rel="noopener">【设计模式】组合模式</a></p><p>​          <a href="http://blog.csdn.net/u012984054/article/details/52235590" target="_blank" rel="noopener">结构型模式之——组合模式</a></p><h2 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h2><p><strong>概述</strong></p><p>​    将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p><p><strong>解决的问题</strong></p><p>​    即Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p><p>​          下面是两个非常形象的例子</p><p><img src="\image\java设计模式\适配器模式实际例子-1.jpg" alt="适配器模式实际例子-1"></p><p><img src="\image\java设计模式\适配器模式实际例子-2.jpg" alt="适配器模式实际例子-2"></p><p><strong>模式的结构</strong></p><p>​     （1）类的适配器模式（采用继承实现）</p><p>​     （2）对象适配器（采用对象组合方式实现）</p><p>​    适配器模式的类图</p><p><img src="\image\java设计模式\适配器模式的类图.jpg" alt="适配器模式的类图"></p><p><strong>模式中的角色</strong></p><p>​    目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。</p><p>　　需要适配的类（Adaptee）：需要适配的类或适配者类。</p><p>　　适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。　　</p><p><strong>实现代码</strong></p><p>​    一、类的适配器模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"被适配类具有 特殊功能..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口，或称为标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标类，只提供普通功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"普通类 具有 普通功能..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类，继承了被适配类，同时实现标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.specificRequest();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类public class Client &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用普通功能类</span></span><br><span class="line">Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">concreteTarget.request();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用特殊功能类，即适配类</span></span><br><span class="line">Target adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">adapter.request();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通类 具有 普通功能...  </span><br><span class="line">被适配类具有 特殊功能...</span><br></pre></td></tr></table></figure></p><p>​    上面这种实现的适配器称为类适配器，因为 Adapter 类既继承了 Adaptee （被适配类），也实现了 Target 接口（因为 Java 不支持多继承，所以这样来实现），在 Client 类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。另外一种适配器模式是对象适配器，它不是使用多继承或继承再实现的方式，而是使用直接关联，或者称为委托的方式，类图如下：</p><p><img src="\image\java设计模式\对象适配器类图.jpg" alt="对象适配器类图"></p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器类，直接关联被适配类，同时实现标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接关联被适配类</span></span><br><span class="line"><span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里是使用委托的方式完成特殊功能</span></span><br><span class="line"><span class="keyword">this</span>.adaptee.specificRequest();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用普通功能类</span></span><br><span class="line">Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">concreteTarget.request();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用特殊功能类，即适配类，</span></span><br><span class="line"><span class="comment">// 需要先创建一个被适配类的对象作为参数</span></span><br><span class="line">Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">adapter.request();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    测试结果与上面的一致。从类图中我们也知道需要修改的只不过就是 Adapter 类的内部结构，即 Adapter 自身必须先拥有一个被适配类的对象，再把具体的特殊功能<strong>委托</strong>给这个对象来实现。使用对象适配器模式，可以使得 Adapter 类（适配类）根据传入的 Adaptee 对象达到适配多个不同被适配类的功能，当然，此时我们可以为多个被适配类提取出一个接口或抽象类。这样看起来的话，似乎对象适配器模式更加灵活一点。</p><p><strong>一个实际的例子</strong></p><p>​    我们就拿日本电饭煲的例子进行说明，日本电饭煲电源接口标准是110V电压，而中国标准电压接口是220V，所以要想在中国用日本电饭煲，需要一个电源转换器。</p><p>​    定义日本和中国两种接口及其实现</p><p>​    我们先定义日本220V电源接口和实现。</p><p>​    110V接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日本110V电源接口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JP110VInterface</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>​    110Ｖ接口实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class JP110VInterfaceImpl implements JP110VInterface &#123;</span><br><span class="line">   public void connect() &#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;接通电源，开始工作....&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    我们再定义中国220V电源接口和实现。</p><p>​    220V接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CN220VInterface</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    220V接口实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CN220VInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">CN220VInterface</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"接通电源，开始工作......"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    定义一个电压适配器</p><p>​    要想在中国使用日本电饭煲，需要把电饭煲110v的电源接口适配成我们220V的电源接口，这就需要一个电源适配器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了能够适配定电饭煲110v电源接口，我们需要继承110v接口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdaptor</span> <span class="keyword">implements</span> <span class="title">JP110VInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CN220VInterface cn220VInterface;<span class="comment">//用220V接口进行适配</span></span><br><span class="line">    PowerAdaptor(CN220VInterface cn220VInterface)&#123;</span><br><span class="line">        <span class="keyword">this</span>.cn220VInterface=cn220VInterface;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cn220VInterface.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    适配器继承的是要适配的接口，并持有对客户的接口的引用。使用的是关联一个对象的方式。</p><p>​    电饭煲</p><p>​    下面正式开始啦，现在我们有一个日本电饭煲，用的是110v的电源接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCooker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> JP110VInterface jp110VInterface;<span class="comment">//日本电饭煲，用的是日本110V标准电源接口</span></span><br><span class="line">   ElectricCooker(JP110VInterface jp110VInterface)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.jp110VInterface=jp110VInterface;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      jp110VInterface.connect();<span class="comment">//接通电源</span></span><br><span class="line">      System.out.println(<span class="string">"开始做饭......"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    <em>电饭煲用的是110V接口</em></p><p>​    电饭煲配合适配器工作</p><p>​    测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptorTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       CN220VInterface cn220VInterface=<span class="keyword">new</span> CN220VInterfaceImpl();<span class="comment">//中国的220V电源</span></span><br><span class="line">       PowerAdaptor adaptor=<span class="keyword">new</span> PowerAdaptor(cn220VInterface);<span class="comment">//电源适配器</span></span><br><span class="line">       ElectricCooker cooker=<span class="keyword">new</span> ElectricCooker(adaptor);<span class="comment">//使用110V接口的电饭煲</span></span><br><span class="line">       cooker.cook();<span class="comment">//使用了适配器，在220V的环境下可以工作啦</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    <em>适配器继承了110V接口，就可以用于日本电饭煲；适配器又持有220V接口的引用，就可以用220V进行工作。</em></p><p>​    运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接通电源，开始工作......</span><br><span class="line">开始做饭......</span><br></pre></td></tr></table></figure></p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    通过适配器，可以是两个不兼容的类在一起工作。可以复用现有的类来适应原来不能提供的接口。将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。</p><p>​    缺点：</p><p>​    适配的过程比较复杂。过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p><p>​    由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类</p><p><strong>总结</strong></p><p>​    适配者模式，类似于在两个不能兼容的类之间做了一个中间者，来兼容这两个类。适配者模式分离了被适配者和目标接口变化的影响。例如，被适配者发生变化时，由于有适配器的存在，不会影响到目标接口。</p><p>参考资料： <a href="http://blog.csdn.net/jason0539/article/details/22468457" target="_blank" rel="noopener">JAVA设计模式初探之适配器模式</a></p><p>​            <a href="http://blog.csdn.net/suifeng3051/article/details/51497041" target="_blank" rel="noopener">设计模式之适配器模式(adaptor pattern)</a></p><h2 id="装饰者模式-Decorator-Pattern"><a href="#装饰者模式-Decorator-Pattern" class="headerlink" title="装饰者模式(Decorator Pattern)"></a>装饰者模式(Decorator Pattern)</h2><p><strong>简单介绍</strong></p><p>​    Decorator Pattern叫装饰模式，或装饰者模式，以前叫包装器模式（Wrapper，GoF在92-93年由Wrapper改为Decorator）。</p><p>​    装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p><p>​    Decorator模式的工作原理是：可以创建始于Decorator对象（负责新的功能的对象）终于原对象的一个对象“链”。</p><p><img src="\image\java设计模式\装饰者模式的装饰链.jpg" alt="装饰者模式的装饰链"></p><p>​    装饰者模式隐含的是通过一条条装饰链去实现具体对象，每一条装饰链都始于一个Componet对象，每个装饰者对象后面紧跟着另一个装饰者对象，而对象链终于ConcreteComponet对象。 </p><p><strong>定义</strong></p><p>==装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供比继承更有弹性的替代方案。==</p><p><strong>适用性</strong></p><ol><li>需要扩展一个类的功能，或给一个类添加附加职责。</li><li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销。</li><li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</li></ol><p><strong>结构</strong></p><p><img src="\image\java设计模式\装饰者模式结构.png" alt="装饰者模式结构"></p><p>在装饰模式中的各个角色有：<br>　　（1）抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。<br>　　（2）具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。<br>　　（3）装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。<br>　　（4）具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</p><p><strong>例子</strong></p><p>​    咖啡的例子：当我们去咖啡厅的时候。不知道是不是会遇到这种问题呢？本来你点一杯普通的coffe，然后他的价格是10元，但是你尝了之后发现有点苦，想要加点红糖，然后加这个糖的价格是2元；然后过了一会你的朋友过来了，他叫了一杯普通coffee，然后加了点牛奶（假设可以加），这个牛奶的价格是3元，如果叫你设计一个程序负责这部分的内容，你会怎么做呢？</p><p>​    会不会有人这么想，java不是面向对象的语言吗？我们可以通过设计对象来啊，首先创建coffee一个抽象类，然后在列出可能添加调料的可能食品，然后付款的时候，调用方法不就行了吗？确实这样做是可以的，但是前面说了耦合度高，这个时候，就到了我们的装饰者出场了。</p><p>首先画出关系图：</p><p><img src="\image\java设计模式\装饰者模式-咖啡例子.png" alt="装饰者模式-咖啡例子"></p><p>我们要做的就是点咖啡1的时候加sugar，点咖啡2的时候加milk</p><p>（1）创建coffee的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line">String coffeeInformation = <span class="string">"普通咖啡"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCoffeeInformation</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> coffeeInformation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类coffee1，coffee2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">coffee1</span> <span class="keyword">extends</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">coffee1</span><span class="params">()</span></span>&#123;</span><br><span class="line">coffeeInformation = <span class="string">"coffee1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">coffee2</span> <span class="keyword">extends</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">coffee2</span><span class="params">()</span></span>&#123;</span><br><span class="line">coffeeInformation = <span class="string">"coffee2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">12.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）调料类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThings</span> <span class="keyword">extends</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getCoffeeInformation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">milk</span> <span class="keyword">extends</span> <span class="title">AddThings</span></span>&#123;</span><br><span class="line">coffee coff;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">milk</span><span class="params">(coffee c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.coff = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCoffeeInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String addThings = coff.getCoffeeInformation()+<span class="string">"添加"</span>+<span class="string">"milk"</span>;</span><br><span class="line"><span class="keyword">return</span> addThings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">3.0</span>+coff.cost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sugar</span> <span class="keyword">extends</span> <span class="title">AddThings</span> </span>&#123;</span><br><span class="line">coffee coff;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">sugar</span><span class="params">(coffee c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.coff = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCoffeeInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String addThings = coff.getCoffeeInformation()+<span class="string">"添加"</span>+<span class="string">"sugar"</span>;</span><br><span class="line"><span class="keyword">return</span> addThings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">2.0</span>+coff.cost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cost</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">coffee c1 = <span class="keyword">new</span> coffee1();</span><br><span class="line">coffee c2 = <span class="keyword">new</span> coffee2();</span><br><span class="line">coffee a1 = <span class="keyword">new</span> sugar(c1);</span><br><span class="line">coffee a2 = <span class="keyword">new</span> milk(c1);</span><br><span class="line"><span class="comment">//coffee a3 = new milk(c2);</span></span><br><span class="line">System.out.println(a1.getCoffeeInformation()+<span class="string">" "</span>+a1.cost());</span><br><span class="line">System.out.println(a2.getCoffeeInformation()+<span class="string">" "</span>+a2.cost());</span><br><span class="line"><span class="comment">//System.out.println(a3.getCoffeeInformation()+" "+a3.cost());</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果截图：</p><p><img src="\image\java设计模式\装饰者模式-咖啡例子-运行结果图.png" alt="装饰者模式-咖啡例子-运行结果图"></p><p>​    你会发现很神奇的实现了，我们要的功能，可能有的人会好奇，为什么我们的调料类也要继承coffee的呢？这个问题问得好，但是我相信你把我注释掉的那部分代码再执行一遍，你会很神奇的发现，我们的coffee1或者是coffee2还能添加牛奶呢。这你实践一下就会明白的，这样的目的怎么，是不是非常棒！！！</p><p><strong>优缺点</strong></p><p>​    优点：可以动态的给对象添加一些功能，并且添加功能的顺序可以动态的进行调整。</p><p>​    缺点：继承层级比较深。暂时还没有发现其他的缺点。</p><p><strong>总结</strong></p><p>​    装饰者模式利用关联被装饰的对象，使得可以给被装饰的对象添加新的功能。并且被装饰后，还可以当作原来对象的类型来使用。</p><p>参考资料：<a href="http://blog.csdn.net/cooldragon/article/details/52174157" target="_blank" rel="noopener">设计模式总结之Decorator Pattern（装饰者模式）</a></p><p>​           <a href="http://blog.csdn.net/YQYnsmile/article/details/52673529" target="_blank" rel="noopener">简单理解设计模式之装饰者模式</a></p><h2 id="代理模式-Proxy-pattern"><a href="#代理模式-Proxy-pattern" class="headerlink" title="代理模式( Proxy pattern)"></a>代理模式( Proxy pattern)</h2><p><strong>定义</strong></p><p>​    ==给某一个对象提供一个代理，并由代理对象控制对原对象的访问==。对应到现实生活中，代理模式就类似于中介。</p><p>​    可以详细控制访问某个类（对象）的方法，在调用这个方法前作的前置处理（统一的流程代码放到代理中处理）。调用这个方法后做后置处理。</p><p>​    例如：<u>明星的经纪人，租房的中介等等都是代理</u></p><p><strong>结构</strong></p><p><img src="\image\java设计模式\代理模式结构.png" alt="代理模式结构"></p><p>代理模式包含如下角色：</p><p>​    <strong>Subject</strong>：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。</p><p>​    <strong>RealSubject</strong>：真实主题角色，是实现抽象主题接口的类。</p><p>​    <strong>ProxySubject</strong>：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</p><p>​    实现动态代理的关键技术是反射。</p><p><strong>静态代理</strong></p><p>​    代理模式有几种，虚拟代理，计数代理，远程代理，动态代理。主要分为两类，静态代理和动态代理。静态代理比较简单，是由程序员编写的代理类，并在程序运行前就编译好的，而不是由程序动态产生代理类，这就是所谓的静态。</p><p>​    考虑这样的场景，管理员在网站上执行操作，在生成操作结果的同时需要记录操作日志，这是很常见的。此时就可以使用代理模式，代理模式可以通过聚合和继承两种方式实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**方式一：聚合式静态代理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Goser    (mailto:goskalrie@163.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Since</span> 2016年9月7日</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//1.抽象主题接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.真实主题类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">implements</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Admin do something."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.以聚合方式实现的代理主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminPoly</span> <span class="keyword">implements</span> <span class="title">Manager</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Admin admin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdminPoly</span><span class="params">(Admin admin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.admin = admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Log:admin操作开始"</span>);</span><br><span class="line">        admin.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"Log:admin操作结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.测试代码</span></span><br><span class="line">        Admin admin = <span class="keyword">new</span> Admin();</span><br><span class="line">        Manager m = <span class="keyword">new</span> AdminPoly(admin);</span><br><span class="line">        m.doSomething();</span><br><span class="line">    <span class="comment">//方式二：继承式静态代理</span></span><br><span class="line">    <span class="comment">//与上面的方式仅代理类和测试代码不同</span></span><br><span class="line">    <span class="comment">//1.代理类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminProxy</span> <span class="keyword">extends</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Log:admin操作开始"</span>);</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"Log:admin操作开始"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.测试代码</span></span><br><span class="line">        AdminProxy proxy = <span class="keyword">new</span> AdminProxy();</span><br><span class="line">        proxy.doSomething();</span><br></pre></td></tr></table></figure></p><p>​    聚合实现方式中代理类聚合了被代理类，且代理类及被代理类都实现了同一个接口，可实现灵活多变。继承式的实现方式则不够灵活。</p><p><strong>动态代理</strong></p><p>​    一般来说，对代理模式而言，一个主题类与一个代理类一一对应，这也是静态代理模式的特点。</p><p>​    但是，也存在这样的情况，有n各主题类，但是代理类中的“前处理、后处理”都是一样的，仅调用主题不同。也就是说，多个主题类对应一个代理类，共享“前处理，后处理”功能，动态调用所需主题，大大减小了程序规模，这就是动态代理模式的特点。</p><p><strong>JDK动态代理</strong></p><p><strong>实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 抽象主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span>  <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 真实主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        System.out.println(<span class="string">"汽车行驶中…"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.事务处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数：</span></span><br><span class="line"><span class="comment">     *proxy 被代理的对象</span></span><br><span class="line"><span class="comment">     *method 被代理对象的方法</span></span><br><span class="line"><span class="comment">     *args 方法的参数</span></span><br><span class="line"><span class="comment">     * 返回：</span></span><br><span class="line"><span class="comment">     *Object 方法返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"汽车开始行驶…"</span>);</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        <span class="keyword">long</span> stopTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"汽车结束行驶…汽车行驶时间："</span> + (stopTime - startTime) + <span class="string">"毫秒！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> TimeHandler(car);</span><br><span class="line">        Class&lt;?&gt; cls = car.getClass();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *loader 类加载器</span></span><br><span class="line"><span class="comment">         *interfaces 实现接口</span></span><br><span class="line"><span class="comment">         *h InvocationHandler</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Moveable m = (Moveable) Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(), h);</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码讲解：</p><p>在测试代码中，Proxy.newProxyInstance()方法需要3个参数：类加载器（要进行代理的类）、被代理类实现的接口，事务处理器。所以先实例化Car，实例化InvocationHandler的子类TimeHandler，将各参数传入Proxy的静态方法newProxyInstance()即可获得Car的代理类，前面的静态代理，代理类是我们编写好的，而动态代理则不需要我们去编写代理类，是在程序中动态生成的。</p><p><strong>JDK动态代理步骤</strong></p><p>1.       创建一个实现InvocationHandler接口的类，它必须实现invoke()方法</p><p>2.       创建被代理的类及接口</p><p>3.       调用Proxy的静态方法，创建一个代理类</p><p>4.        通过代理调用方法</p><p>​    在JDK动态代理中，发现生成的代理类字节码中类的声明为：</p><p><code>public final class $Proxy1 extends Proxy</code></p><p>​    可以看到生成的代理类是继承了Proxy类的，这就是说明了为什么使用JDK动态代理不能实现继承式动态代理，原因是Java不允许多继承，而生成的代理类本身就已经继承了Proxy类。也就是说在Proxy.newProxyInstance（）转递的类型参数应该是被代理类实现的接口。</p><p><strong>cglib动态代理</strong></p><p>​    前面分析到，因为Java只允许单继承，而JDK生成的代理类本身就继承了Proxy类，因此，使用JDK实现的动态代理不能完成继承式的动态代理，但是我们可以使用cglib来实现继承式的动态代理。</p><p>​    大名鼎鼎的Spring中就含有cglib动态代理，在此也以Spring中自带的cglib完成动态代理的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.具体主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Train</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"火车行驶中…"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.生成代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截所有目标类方法的调用</span></span><br><span class="line"><span class="comment">     * 参数：</span></span><br><span class="line"><span class="comment">     * obj目标实例对象</span></span><br><span class="line"><span class="comment">     *method 目标方法的反射对象</span></span><br><span class="line"><span class="comment">     * args方法的参数</span></span><br><span class="line"><span class="comment">     * proxy代理类的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//代理类调用父类的方法</span></span><br><span class="line">        System.out.println(<span class="string">"日志开始"</span>);</span><br><span class="line">        proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">"日志结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CGLibProxy proxy = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">        Train t = (Train) proxy.getProxy(Train.class);</span><br><span class="line">        t.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>小结</p><p>​    动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样对每一个方法或方法组合进行处理。Proxy 很美很强大，但是仅支持 interface 代理。Java 的单继承机制注定了这些动态代理类们无法实现对 class 的动态代理。好在有cglib为Proxy提供了弥补。class与interface的区别本来就模糊，在java8中更是增加了一些新特性，使得interface越来越接近class，当有一日，java突破了单继承的限制，动态代理将会更加强大。</p><p><strong>总结</strong></p><p>​    代理模式就类似于中介，会控制被代理对象的访问，可以添加前置处理和后置处理。真正强大的是动态代理。</p><p>参考资料：<a href="http://www.importnew.com/26116.html" target="_blank" rel="noopener">说说 JAVA 代理模式</a></p><p>​           <a href="http://blog.csdn.net/goskalrie/article/details/52458773" target="_blank" rel="noopener">Java设计模式——代理模式实现及原理</a></p><p>​          <a href="http://www.cnblogs.com/chinajava/p/5880887.html" target="_blank" rel="noopener">说说cglib动态代理</a></p><h2 id="门面模式-Facade-Pattern-外观模式"><a href="#门面模式-Facade-Pattern-外观模式" class="headerlink" title="门面模式( Facade Pattern  外观模式)"></a>门面模式( Facade Pattern  外观模式)</h2><p><strong>定义</strong></p><p>​    门面模式(Facade Pattern)：==为子系统中的一组接口提供一个一致的界面==，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。门面模式又称为<strong>外观模式</strong>，它是一种对象结构型模式。</p><p><strong>模式动机</strong></p><p>​    现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其“分而治之”，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。</p><p>　　首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。</p><p><img src="\image\java设计模式\门面模式-病人到医院看病.png" alt="门面模式-病人到医院看病"></p><p>​    上图描述的是病人在医院里的体验，图中的方框代表医院。</p><p>　　解决这种不便的方法便是引进门面模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是门面模式的体现，病人只接触接待员，由接待员与各个部门打交道。</p><p><img src="\image\java设计模式\门面模式-医院接待员.png" alt="门面模式-医院接待员"></p><p><strong>结构</strong></p><p>​    门面模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明。</p><p><img src="\image\java设计模式\门面模式-结构示意图1.png" alt="门面模式-结构示意图1"></p><p>​    由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，那么此时示例的整体结构图如下：</p><p><img src="\image\java设计模式\门面模式-结构示意图2.png" alt="门面模式-结构示意图2"></p><p>在这个对象图中，出现了两个角色：</p><ul><li><strong>门面(Facade)角色</strong> ：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。（门面对象不干活，而是将活让子系统干）</li><li><strong>子系统(SubSystem)角色</strong> ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。</li></ul><p><strong>实例分析</strong></p><p>​    这次我们来关注一下土豪的个人生活，话说土豪下班回到家里后首先要做的就是把灯打开，我们假设他一共需要打开三个灯，然后就是打开热水器烧水准备洗澡，在等待的过程还会打开电视机看新闻。如果我们用一般的方法来实现的话，代码就会是下面这个样子。</p><p>​    这是电灯的类，里边有打开的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Light has been opened!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    这是热水器的类，里边有打开的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heater</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Heater has been opened!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    这是电视机的类，里边有打开的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TV has been opened!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    在主函数里就要创建各种对象，并且调用他们的额open方法。我们看到主函数为了实现土豪下班回家这一个功能需要和三个电灯，一个热水器和一台电视机打交道，非常的复杂，所以这时候我们就应该使用门面模式。相当于给土豪弄一个总开关，一键打开所有的东西。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Light light1 = <span class="keyword">new</span> Light();</span><br><span class="line">        Light light2 = <span class="keyword">new</span> Light();</span><br><span class="line">        Light light3 = <span class="keyword">new</span> Light();</span><br><span class="line">        Heater heater = <span class="keyword">new</span> Heater();</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要一步一步的操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        light1.open();</span><br><span class="line">        light2.open();</span><br><span class="line">        light3.open();</span><br><span class="line">        heater.open();</span><br><span class="line">        tv.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    在门面类中我们创建一个统一的open方法，来调度所有的开关。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light1, light2, light3;</span><br><span class="line">    <span class="keyword">private</span> Heater heater;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light1 = <span class="keyword">new</span> Light();</span><br><span class="line">        light2 = <span class="keyword">new</span> Light();</span><br><span class="line">        light3 = <span class="keyword">new</span> Light();</span><br><span class="line">        heater = <span class="keyword">new</span> Heater();</span><br><span class="line">        tv = <span class="keyword">new</span> TV();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light1.open();</span><br><span class="line">        light2.open();</span><br><span class="line">        light3.open();</span><br><span class="line">        heater.open();</span><br><span class="line">        tv.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    这样在主函数类只需要使用门面类就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一步操作就可以完成所有的准备工作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        facade.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong></p><p>​    一个系统可以有几个门面类?</p><p>​    在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。</p><p>​    为子系统增加新行为</p><p>​    初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。</p><p><strong>优缺点</strong></p><p>​    门面模式的优点：</p><p>　　●　　松散耦合</p><p>　　门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</p><p>　　●　　简单易用</p><p>　　门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。</p><p>　　●　　更好的划分访问层次</p><p>　　通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。</p><p>​    缺点：</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><p><strong>总结</strong></p><p>​    门面模式可以给子系统中的多个接口提供一个一致的对外界面，既方便客户端对于子系统的使用，也可以将客户端与子系统内部功能解耦，客户端不用知道子系统的细节，只需要跟门面对象沟通就可以了。</p><p>参考资料：<a href="http://blog.csdn.net/jason0539/article/details/22775311" target="_blank" rel="noopener">JAVA设计模式之门面模式（外观模式）</a></p><p>​           <a href="http://blog.csdn.net/xingjiarong/article/details/50066133" target="_blank" rel="noopener">设计模式（七）门面模式（Facade Pattern 外观模式）</a></p><h2 id="桥接模式（Bridge"><a href="#桥接模式（Bridge" class="headerlink" title="桥接模式（Bridge)"></a>桥接模式（Bridge)</h2><p><strong>定义</strong></p><p>​    ==桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化==。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><p>​    这个定义可能刚开始看不太懂，可以结合下面的结构图和实际例子来理解。其实一个模式的定义是从一个高度抽象的层面描述模式的本质。</p><p>　    这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><p><strong>结构</strong></p><p>​    桥接模式的UML图如下：</p><p><img src="\image\java设计模式\桥接模式-UML类图.png" alt="桥接模式-UML类图"></p><p>​    桥接模式（Bridge)是一种结构型设计模式。Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。</p><p>​    桥接模式的角色和职责：</p><p>​    1.Client 调用端</p><p>​    这是Bridge模式的调用者。</p><p>​    2.抽象类（Abstraction）</p><p>​    抽象类接口（接口这货抽象类）维护队行为实现（implementation）的引用。它的角色就是桥接类。</p><p>​    3.Refined Abstraction</p><p>​    这是Abstraction的子类。</p><p>​    4.Implementor</p><p>​    行为实现类接口（Abstraction接口定义了基于Implementor接口的更高层次的操作）</p><p>​    5.ConcreteImplementor</p><p>​    Implementor的子类</p><p><strong>示例代码如下</strong></p><p>​    首先定义Implementor接口，其中定义了其实现类必须要实现的接口operation()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>​    下面定义Implementor接口的两个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         System.out.println(<span class="string">"this is concreteImplementorA's operation..."</span>);</span><br><span class="line"><span class="number">5</span>     &#125;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateImplementorB</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         System.out.println(<span class="string">"this is concreteImplementorB's operation..."</span>);</span><br><span class="line"><span class="number">5</span>     &#125;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure><p>下面定义桥接类Abstraction，其中有对Implementor接口的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Implementor implementor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Implementor <span class="title">getImplementor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> implementor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImplementor</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.implementor = implementor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        implementor.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    下面是Abstraction类的子类RefinedAbstraction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         <span class="keyword">super</span>.getImplementor().operation();</span><br><span class="line"><span class="number">5</span>     &#125;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure><p>​    下面给出测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Abstraction abstraction = <span class="keyword">new</span> RefinedAbstraction();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用第一个实现类</span></span><br><span class="line">        abstraction.setImplementor(<span class="keyword">new</span> ConcreateImplementorA());</span><br><span class="line">        abstraction.operation();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用第二个实现类</span></span><br><span class="line">        abstraction.setImplementor(<span class="keyword">new</span> ConcreateImplementorB());</span><br><span class="line">        abstraction.operation();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    其运行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is concreteImplementorA<span class="string">'s operation...</span></span><br><span class="line"><span class="string">this is concreteImplementorB'</span>s operation...</span><br></pre></td></tr></table></figure></p><p>​    这样，通过对Abstraction桥接类的调用，实现了对接口Implementor的实现类ConcreteImplementorA和ConcreteImplementorB的调用。实现了抽象与行为实现的分离。</p><p><strong>实际例子</strong></p><p>​    个人理解：桥接是一个接口，它与一方应该是绑定的，也就是解耦的双方中的一方必然是继承这个接口的，这一方就是实现方，而另一方正是要与这一方解耦的抽象方，如果不采用桥接模式，一般我们的处理方式是直接使用继承来实现，这样双方之间处于强链接，类之间关联性极强，如要进行扩展，必然导致类结构急剧膨胀。采用桥接模式，正是为了避免这一情况的发生，将一方与桥绑定，即实现桥接口，另一方在抽象类中调用桥接口（指向的实现类），这样桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响。</p><p>　　下面的实例能真正体现着一点：</p><p>　　实例准备：我们假设有一座桥，桥左边为A，桥右边为B，A有A1，A2，A3等，表示桥左边的三个不同地方，B有B1，B2，B3等，表示桥右边的三个不同地方，假设我们要从桥左侧A出发到桥的右侧B，我们可以有多重方案，A1到B1，A1到B2，A1到B3，A2到B1…等等，以此为例，代码如下：</p><p>桥接口：Qiao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Qiao</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="comment">//目的地B</span></span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">void</span> <span class="title">targetAreaB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure><p>目的地B1,B2,B3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目的地B1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaB1</span> <span class="keyword">implements</span> <span class="title">Qiao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetAreaB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要去B1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目的地B2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaB2</span> <span class="keyword">implements</span> <span class="title">Qiao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetAreaB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要去B2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目的地B3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaB3</span> <span class="keyword">implements</span> <span class="title">Qiao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetAreaB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要去B3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象来源地A：AreaA</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaA</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="comment">//引用桥接口</span></span><br><span class="line"><span class="number">3</span>     Qiao qiao;</span><br><span class="line"><span class="number">4</span>     <span class="comment">//来源地</span></span><br><span class="line"><span class="number">5</span>     <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fromAreaA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure><p>来源地A1，A2，A3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 来源地A1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaA1</span> <span class="keyword">extends</span> <span class="title">AreaA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fromAreaA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我来自A1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 来源地A2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaA2</span> <span class="keyword">extends</span> <span class="title">AreaA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fromAreaA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我来自A2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 来源地A3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaA3</span> <span class="keyword">extends</span> <span class="title">AreaA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fromAreaA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我来自A3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：Clienter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AreaA a = <span class="keyword">new</span> AreaA2();</span><br><span class="line">        a.qiao = <span class="keyword">new</span> AreaB3();</span><br><span class="line">        a.fromAreaA();</span><br><span class="line">        a.qiao.targetAreaB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我来自A2</span><br><span class="line">我要去B3</span><br></pre></td></tr></table></figure><p>如何，只要你认真看完了实例，你就明白了这种模式的好处，现在我们要添加来源地和目的地，只要继续继承AreaA和实现Qiao即可，之前我所说的绑定，正式此处将桥与目的地绑定在一起，使用一个接口完成。</p><p>　　其实要完成桥接模式，注意点并不多，重在理解模式的使用场景。</p><p>　　注意点：</p><p>　　　　1、定义一个桥接口，使其与一方绑定，这一方的扩展全部使用实现桥接口的方式。</p><p>　　　　2、定义一个抽象类，来表示另一方，在这个抽象类内部要引入桥接口，而这一方的扩展全部使用继承该抽象类的方式。</p><p>　　其实我们可以发现桥接模式应对的场景有方向性的，桥绑定的一方都是被调用者，属于被动方，抽象方属于主动方。</p><p>　　其实我的JDK提供的JDBC数据库访问接口API正是经典的桥接模式的实现者，接口内部可以通过实现接口来扩展针对不同数据库的具体实现来进行扩展，而对外的仅仅只是一个统一的接口调用，调用方过于抽象，可以将其看做每一个JDBC调用程序（这是真实实物，当然不存在抽象）</p><p><strong>优缺点</strong></p><p>1.桥接模式的优点</p><p>​    （1）实现了抽象和实现部分的分离</p><p>​    桥接模式分离了抽象部分和实现部分，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，分别定义接口，这有助于系统进行分层设计，从而产生更好的结构化系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。</p><p>​    （2）更好的可扩展性</p><p>​    由于桥接模式把抽象部分和实现部分分离了，从而分别定义接口，这就使得抽象部分和实现部分可以分别独立扩展，而不会相互影响，大大的提供了系统的可扩展性。</p><p>​    （3）可动态的切换实现</p><p>​    由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。</p><p>​    （4）实现细节对客户端透明，可以对用户隐藏实现细节。</p><p>​    </p><p>2.桥接模式的缺点</p><p>​    （1）桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。</p><p>​    （2）桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。</p><p><strong>桥接模式的使用场景</strong></p><p>​    （1）如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</p><p>​    （2）抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</p><p>​    （3）一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p><p><strong>总结</strong></p><p>​    桥接模式，就是将实现行为的一方，与需要这些行为的抽象一方进行解耦。具体行为在变化，需要执行行为的实体一方也在变化，但是实体方需要具体行为对象的这个关系不会发生变化。桥接模式就是将这种变化与关系的不变化进行分离。使得变化的行为方和实体方可以独立变化，而相互不影响。</p><p>参考资料：<a href="http://www.cnblogs.com/V1haoge/p/6497919.html" target="_blank" rel="noopener">Java设计模式之《桥接模式》及应用场景</a></p><p>​           <a href="http://www.cnblogs.com/lixiuyu/p/5923160.html" target="_blank" rel="noopener">设计模式之桥接模式</a></p><h2 id="享元模式-Flyweight-Pattern"><a href="#享元模式-Flyweight-Pattern" class="headerlink" title="享元模式(Flyweight Pattern)"></a>享元模式(Flyweight Pattern)</h2><p><strong>定义</strong></p><p>​    ==采用一个共享来避免大量拥有相同内容对象的开销==。这种开销中最常见、直观的就是内存的损耗。享元模式以共享的方式高效的支持大量的细粒度对象。</p><p><strong>实际例子</strong></p><p>​    比如在文档编辑器的设计过程中，我们如果为没有字母创建一个对象的话，系统可能会因为大量的对象而造成存储开销的浪费。例如一个字母“a”在文档中出现了100000次，而实际上我们可以让这一万个字母“a”共享一个对象，当然因为在不同的位置可能字母“a”有不同的显示效果（例如字体和大小等设置不同），在这种情况我们可以为将对象的状态分为“外部状态”和“内部状态”，将可以被共享（不会变化）的状态作为内部状态存储在对象中，而外部对象（例如上面提到的字体、大小等）我们可以在适当的时候将外部对象最为参数传递给对象（例如在显示的时候，将字体、大小等信息传递给对象）。</p><p><strong>适用场景</strong></p><p>​    当以下所有的条件都满足时，可以考虑使用享元模式：</p><p>（1）.一个系统有大量的对象。</p><p>（2）.这些对象耗费大量的内存。</p><p>（3）.这些对象的状态中的大部分都可以外部化。</p><p>（4）.这些对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。</p><p>（5）.软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。</p><p>满足以上的这些条件的系统可以使用享元对象。</p><p>最后，使用享元模式需要维护一个记录了系统已有的所有享元的表，而这需要耗费资源。因此，应当在有足够多的享元实例可供共享时才值得使用享元模式。</p><p><strong>结构</strong></p><p>​    ==单纯Flyweight享元模式==典型的UML结构图如图1所示：</p><p><img src="\image\java设计模式\单纯享元模式-uml类图.png" alt="单纯享元模式-uml类图"></p><p>​    单纯Flyweight享元模式抽象基类及接口：</p><pre><code>抽象享元(Flyweight)角色：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态(External State)的操作可以通过调用商业方法以参数形式传入。</code></pre><p>​    具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享的。</p><p>​    享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个复合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应 当创建一个合适的享元对象。</p><p>​    客户端(Client)角色：本角色需要维护一个对所有享元对象的引用。本角色需要自行存储所有享元对象的外蕴状态。</p><p>​    复合Flyweight享元模式典型的UML结构图如图2所示：</p><p><img src="\image\java设计模式\复合享元模式-uml类图.png" alt="复合享元模式-uml类图"></p><p>​    复合Flyweight享元模式抽象基类及接口：</p><p>​    抽象享元角色：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态(External State)的操作可以通过方法的参数传入。抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。</p><p>​    具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。有时候具体享元角色又叫做单纯具体享元角色，因为复合享元角色是由单纯具体享元角色通过复合而成的。</p><p>​    复合享元(UnsharableFlyweight)角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称做不可共享的享元对象。</p><p>​    享元工厂(FlyweightFactoiy)角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象请求一个享元对象的时候，享元工厂角色需要检查系统中是否已经有一个符合要求的享元对象，如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个新的合适的享元对象。</p><p>​    客户端(Client)角色：本角色还需要自行存储所有享元对象的外蕴状态。</p><p><strong>示例代码</strong></p><p>​    单纯Flyweight享元模式典型的示例代码如下：</p><p>​    先定义一个抽象的Flyweight类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flyweight;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span></span>&#123;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    实现一个具体类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flyweight;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        string = str;</span><br><span class="line">　  &#125;</span><br><span class="line">　   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　 System.out.println(<span class="string">"Concrete---Flyweight : "</span> + string);</span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    实现一个工厂方法类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flyweight;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hashtable flyweights = <span class="keyword">new</span> Hashtable();<span class="comment">//----------------------------1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyweightFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyWeight</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Flyweight flyweight = (Flyweight) flyweights.get(obj);<span class="comment">//----------------2</span></span><br><span class="line">        <span class="keyword">if</span>(flyweight == <span class="keyword">null</span>)&#123;<span class="comment">//---------------------------------------------------3</span></span><br><span class="line">            <span class="comment">//产生新的ConcreteFlyweight</span></span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight((String)obj);</span><br><span class="line">            flyweights.put(obj, flyweight);<span class="comment">//--------------------------------------5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;<span class="comment">//---------------------------------------------------------6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFlyweightSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flyweights.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    这个工厂方法类非常关键，这里详细解释一下：<br>　　在1处定义了一个Hashtable用来存储各个对象；在2处选出要实例化的对象，在6处将该对象返回，如果在Hashtable中没有要选择的对象，此时变量flyweight为null，产生一个新的flyweight存储在Hashtable中，并将该对象返回。<br>　　最后看看Flyweight的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flyweight;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span></span>&#123;</span><br><span class="line">    FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory(); </span><br><span class="line">    Flyweight fly1;</span><br><span class="line">    Flyweight fly2;</span><br><span class="line">    Flyweight fly3;</span><br><span class="line">    Flyweight fly4;</span><br><span class="line">    Flyweight fly5;</span><br><span class="line">    Flyweight fly6;</span><br><span class="line">    <span class="comment">/** */</span><span class="comment">/** Creates a new instance of FlyweightPattern */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyweightPattern</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fly1 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">        fly2 = factory.getFlyWeight(<span class="string">"Qutr"</span>);</span><br><span class="line">        fly3 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">        fly4 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">        fly5 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">        fly6 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFlyweight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fly1.operation();</span><br><span class="line">        fly2.operation();</span><br><span class="line">        fly3.operation();</span><br><span class="line">        fly4.operation();</span><br><span class="line">        fly5.operation();</span><br><span class="line">        fly6.operation();</span><br><span class="line">        <span class="keyword">int</span> objSize = factory.getFlyweightSize();</span><br><span class="line">        System.out.println(<span class="string">"objSize = "</span> + objSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The FlyWeight Pattern!"</span>);</span><br><span class="line">        FlyweightPattern fp = <span class="keyword">new</span> FlyweightPattern();</span><br><span class="line">        fp.showFlyweight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    下面是运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Concrete---Flyweight : Google</span><br><span class="line">Concrete---Flyweight : Qutr</span><br><span class="line">Concrete---Flyweight : Google</span><br><span class="line">Concrete---Flyweight : Google</span><br><span class="line">Concrete---Flyweight : Google</span><br><span class="line">Concrete---Flyweight : Google</span><br><span class="line">objSize = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>​    我们定义了6个对象，其中有5个是相同的，按照Flyweight模式的定义“Google”应该共享一个对象，在实际的对象数中我们可以看出实际的对象却是只有2个。</p><p>　　Flyweight(享元)模式是如此的重要，因为它能帮你在一个复杂的系统中大量的节省内存空间。在JAVA语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。</p><p>​    复合式享元相当于多个单纯享元的集合。也就是说复合享元相当于对单纯享元进行了一个再分组，在复合享元的每个分组里又是一个独立的单纯享元模式。相关关键代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompositeFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Flyweight&gt; labels = <span class="keyword">new</span> HashMap&lt;Integer, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key, Flyweight flyweight)</span> </span>&#123;</span><br><span class="line">        labels.put(key, flyweight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String extrinsicState)</span> </span>&#123;</span><br><span class="line">        Flyweight flyweight = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object key : labels.keySet()) &#123;</span><br><span class="line">            flyweight = labels.get(key);</span><br><span class="line">            flyweight.operation(extrinsicState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    对于其构建工厂也需要进行重新设计，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Flyweight&gt; labels = <span class="keyword">new</span> HashMap&lt;Integer, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单纯享元工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">factory</span><span class="params">(String intrinsicState)</span> </span>&#123;</span><br><span class="line">         ... ...</span><br><span class="line">         <span class="keyword">return</span> fly;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复合享元工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">compositeFactory</span><span class="params">(List&lt;String&gt; intrinsicStates)</span> </span>&#123;</span><br><span class="line">        ConcreteCompositeFlyweight flyweight = <span class="keyword">new</span> ConcreteCompositeFlyweight();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (String intrinsicState : intrinsicStates) &#123;</span><br><span class="line">            flyweight.add(intrinsicState.hashCode(), factory(intrinsicState));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compositeFlyweight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; intrinsicStates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        intrinsicStates.add(<span class="string">"Hello"</span>);</span><br><span class="line">        intrinsicStates.add(<span class="string">"Java"</span>);</span><br><span class="line">        intrinsicStates.add(<span class="string">"DesignPattern"</span>);</span><br><span class="line">        intrinsicStates.add(<span class="string">"Flyweight"</span>);</span><br><span class="line">    </span><br><span class="line">        FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight flyweight1 = factory.compositeFactory(intrinsicStates);</span><br><span class="line">        Flyweight flyweight2 = factory.compositeFactory(intrinsicStates);</span><br><span class="line">        System.out.println(<span class="string">"flyweight1 == flyweight2 ? "</span> + (flyweight1 == flyweight2));</span><br><span class="line">    </span><br><span class="line">        flyweight1.operation(<span class="string">"复合享元-1"</span>);</span><br><span class="line">        flyweight2.operation(<span class="string">"复合享元-2"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>​    执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flyweight1 == flyweight2 ? <span class="keyword">false</span></span><br><span class="line">内蕴状态：Java</span><br><span class="line">外蕴状态：复合享元-<span class="number">1</span></span><br><span class="line">内蕴状态：Flyweight</span><br><span class="line">外蕴状态：复合享元-<span class="number">1</span></span><br><span class="line">内蕴状态：Hello</span><br><span class="line">外蕴状态：复合享元-<span class="number">1</span></span><br><span class="line">内蕴状态：DesignPattern</span><br><span class="line">外蕴状态：复合享元-<span class="number">1</span></span><br><span class="line">内蕴状态：Java</span><br><span class="line">外蕴状态：复合享元-<span class="number">2</span></span><br><span class="line">内蕴状态：Flyweight</span><br><span class="line">外蕴状态：复合享元-<span class="number">2</span></span><br><span class="line">内蕴状态：Hello</span><br><span class="line">外蕴状态：复合享元-<span class="number">2</span></span><br><span class="line">内蕴状态：DesignPattern</span><br><span class="line">外蕴状态：复合享元-<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p><strong>示例1：一个咖啡的例子</strong></p><p>​    在这个咖啡摊(CoffeeStall)所使用的系统里，有一系列的咖啡”风味(Flavor)”。客人到摊位上购买咖啡，所有的咖啡均放在台子上，客人自己拿到咖啡后就离开摊位。咖啡有内蕴状态，也就是咖啡的风味；咖啡没有环境因素，也就是说没有外蕴状态。如果系统为每一杯咖啡都创建一个独立的对象的话，那么就需要创建出很多的细小对象来。这样就不如把咖啡按照种类(即”风味”)划分，每一种风味的咖啡只创建一个对象，并实行共享。</p><p>​    使用咖啡摊主的语言来讲，所有的咖啡都可按”风味”划分成如Capucino、Espresso等，每一种风味的咖啡不论卖出多少杯，都是全同、不可分辨的。所谓共享，就是咖啡风味的共享，制造方法的共享等。因此，享元模式对咖啡摊来说，就意味着不需要为每一份单独调制。摊主可以在需要时，一次性地调制出足够一天出售的某一种风味的咖啡。</p><p>​    很显然，这里适合使用单纯享元模式。</p><p><strong>示例2：咖啡店的例子</strong></p><p>​    在前面的咖啡摊项目里，由于没有供客人坐的桌子，所有的咖啡均没有环境的影响。换言之，咖啡仅有内蕴状态，也就是咖啡的种类，而没有外蕴状态。下面考虑一个规模稍稍大一点的咖啡屋(Coffee Shop)项目。屋子里有很多的桌子供客人坐，系统除了需要提供咖啡的”风味”之外，还需要跟踪咖啡被送到哪一个桌位上，因此，咖啡就有了桌子作为外蕴状态。</p><p>​    由于外蕴状态的存在，没有外蕴状态的单纯享元模式不再符合要求。系统的设计可以利用有外蕴状态的单纯享元模式。</p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    Flyweight享元模式的优点在于它大幅度地降低内存中对象的数量。</p><p>​    缺点：</p><p>​    Flyweight享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。Flyweight享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。    </p><p><strong>总结</strong></p><p>​    Flyweight享元模式就是共享一些对象，来达到减少资源的消耗。其中共享的对象一旦创建就不会改变了。其实解决的问题就是，大量不同的对象却有很多共同的内容，将共同的内容抽取出来形成对象，并共享。主要注意的是FlyweightFactory对象，其中使用一个键值对集合来存储共享对象。</p><p>参考资料：<a href="https://www.2cto.com/kf/201606/521524.html" target="_blank" rel="noopener">Flyweight模式详解</a>    </p><p>​           <a href="http://blog.csdn.net/ai92/article/details/224598" target="_blank" rel="noopener">深入浅出享元模式</a></p><p>​           <a href="http://blog.csdn.net/lemon_tree12138/article/details/51241598#%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">Java设计模式——享元模式</a></p><p>​                  <a href="http://blog.csdn.net/jason0539/article/details/22908915" target="_blank" rel="noopener">JAVA设计模式之享元模式</a></p><h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式( Strategy )"></a>策略模式( Strategy )</h2><p><strong>定义</strong></p><p>​    策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。</p><p>​    分析下定义，策略模式定义和封装了一系列的算法，它们是可以相互替换的，也就是说它们具有共性，而它们的共性就体现在策略接口的行为上，另外为了达到最后一句话的目的，也就是说让算法独立于使用它的客户而独立变化，我们需要让客户端依赖于策略接口。</p><p><strong>问题</strong></p><p>​    在软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。</p><p>​    这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><p>​    如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？</p><p><strong>方案</strong></p><p>​    把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。</p><p>​    比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。</p><p><strong>结构</strong></p><p>​    策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="\image\java设计模式\策略模式结构.png" alt="策略模式结构"></p><p>​    这个模式涉及到三个角色：</p><p>　    ●　　<strong>环境(Context)角色：</strong>持有一个Strategy的引用。</p><p>　　●　　<strong>抽象策略(Strategy)角色：</strong>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</p><p>　　●　　<strong>具体策略(ConcreteStrategy)角色：</strong>包装了相关的算法或行为。</p><p><strong>源代码</strong> </p><p>​    抽象策略类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    具体策略类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环境角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有一个具体策略的对象</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体策略对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy    具体策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        strategy.strategyInterface();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实际例子</strong></p><p>​    假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p><p>　　根据描述，折扣是根据以下的几个算法中的一个进行的：</p><p>　　算法一：对初级会员没有折扣。</p><p>　　算法二：对中级会员提供10%的促销折扣。</p><p>　　算法三：对高级会员提供20%的促销折扣。</p><p>　　使用策略模式来实现的结构图如下：</p><p><img src="\image\java设计模式\策略模式-实际例子.png" alt="策略模式-实际例子"></p><p>​    实现代码</p><p>​    抽象折扣类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算图书的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> booksPrice    图书的原价</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    计算出打折后的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    初级会员折扣类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimaryMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"对于初级会员的没有折扣"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    中级会员折扣类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntermediateMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">"对于中级会员的折扣为10%"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice * <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    高级会员折扣类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"对于高级会员的折扣为20%"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    价格类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Price</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有一个具体的策略对象</span></span><br><span class="line">    <span class="keyword">private</span> MemberStrategy strategy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体的策略对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy    具体的策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Price</span><span class="params">(MemberStrategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算图书的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> booksPrice    图书的原价</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    计算出打折后的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quote</span><span class="params">(<span class="keyword">double</span> booksPrice)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.calcPrice(booksPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择并创建需要使用的策略对象</span></span><br><span class="line">        MemberStrategy strategy = <span class="keyword">new</span> AdvancedMemberStrategy();</span><br><span class="line">        <span class="comment">//创建环境</span></span><br><span class="line">        Price price = <span class="keyword">new</span> Price(strategy);</span><br><span class="line">        <span class="comment">//计算价格</span></span><br><span class="line">        <span class="keyword">double</span> quote = price.quote(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"图书的最终价格为："</span> + quote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。</p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    策略模式将相关的算法作为一个算法族进行管理。算法实现之间可以相互替换，使得程序结构灵活，并且客户端不会依赖算法的具体实现。</p><p>​    缺点：</p><p>​    客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。</p><p><strong>适用场景</strong></p><p>​    1.针对同一类型问题的多种处理方式，仅仅是具体行为有差别时；<br>​    2.需要安全地封装多种同一类型的操作时；<br>​    3.出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。</p><p><strong>总结</strong></p><p>​    某一个任务或功能，可以有多种算法来实现，并且不同算法之间还有很大的差异。这个时候可以使用策略模式来管理这组相关的算法实现，并且可以使得使用策略的客户端不依赖于具体的算法实现。</p><p>​    变化的是实现相同功能的不同算法，不变的是客户端对于这个功能的使用与需求。策略模式可以将这个问题的变化的内容和不变的内容分开。</p><p>参考资料：<a href="http://blog.csdn.net/u012124438/article/details/70039943" target="_blank" rel="noopener">设计模式学习之策略模式</a></p><p>​           <a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">《JAVA与模式》之策略模式</a></p><p>​                   <a href="http://blog.csdn.net/jason0539/article/details/45007553" target="_blank" rel="noopener">Java设计模式之策略模式</a></p><h2 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式( Template Method )"></a>模板方法模式( Template Method )</h2><p><strong>定义</strong></p><p>​    定义一个算法中的操作框架，而将一些步骤延迟到子类中。使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。（Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure）</p><p><strong>问题</strong></p><p>​    某一些流程的骨架是确定的，但是每一步骤具体的细节会随着情况的改变发生大的变化。例如煮饭，都是第一步烧水，第二步做主食，第三步做菜。但是主食做什么，菜又做什么，这些要看具体的情况而定。</p><p><strong>方案</strong></p><p>​    准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</p><p><strong>结构</strong></p><p>​    模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p><p>　　模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p><p>　　模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示：</p><p><img src="\image\java设计模式\模板方法模式结构图.png" alt="模板方法模式结构图"></p><p>这里涉及到两个角色：</p><p>　　抽象模板(Abstract Template)角色有如下责任：</p><p>　　■　　定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</p><p>　　■　　定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p><p>　　具体模板(Concrete Template)角色又如下责任：</p><p>　　■　　实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</p><p>　　■　　每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p><p><strong>实际例子</strong></p><p>​    举个例子，以准备去学校所要做的工作（prepareGotoSchool）为例，假设需要分三步：穿衣服（dressUp），吃早饭（eatBreakfast），带上东西（takeThings）。学生和老师要做得具体事情肯定有所区别。</p><p>​    抽象类AbstractClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//抽象类定义整个流程骨架</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareGotoSchool</span><span class="params">()</span></span>&#123;</span><br><span class="line">          dressUp();</span><br><span class="line">          eatBreakfast();</span><br><span class="line">          takeThings();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//以下是不同子类根据自身特性完成的具体步骤</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dressUp</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">takeThings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    具体类ConcreteClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dressUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(“穿校服<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">     @Override</span></span><br><span class="line"><span class="string">     protected void eatBreakfast() &#123;</span></span><br><span class="line"><span class="string">          System.out.println(“吃妈妈做好的早饭"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">takeThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(“背书包，带上家庭作业和红领巾<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dressUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(“穿工作服<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">     @Override</span></span><br><span class="line"><span class="string">     protected void eatBreakfast() &#123;</span></span><br><span class="line"><span class="string">          System.out.println(“做早饭，照顾孩子吃早饭"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">takeThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(“带上昨晚准备的考卷<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>​    测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Student student = <span class="keyword">new</span> Student()</span><br><span class="line">     student.prepareGotoSchool();</span><br><span class="line">    </span><br><span class="line">     Teacher teacher  = <span class="keyword">new</span> Teacher()</span><br><span class="line">     teacher.prepareGotoSchool();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>优缺点</strong></p><p>​    在全面解析完模板方法模式后，我来分析下其优缺点：</p><p>​    优点：</p><ul><li><p>提高代码复用性<br>将相同部分的代码放在抽象的父类中</p></li><li><p>提高了拓展性<br>将不同的代码放入不同的子类中，通过对子类的扩展增加新的行为</p></li><li><p>实现了反向控制<br>通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，实现了反向控制 &amp; 符合“开闭原则”</p><p>缺点 ： </p><p>引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度。</p></li></ul><p><strong>应用场景</strong></p><ul><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复；</li><li>控制子类的扩展。 </li></ul><p><strong>总结</strong></p><p>​    模板方法模式将那些不变的，稳定的内容或步骤放在一个抽象类中。将那些需要随着具体情况发生变化的内容延迟到子类实现。主要是抽象类中的骨架部分非常重要。<br>​    有一些流程，虽然步骤的具体细节会不停的变化，但是向上抽象一层，则发现步骤是固定的。模板方法模式就是将这些固定的步骤抽象出来并且固定，让那些细节可以在子类中随着具体情况发生改变。</p><p>参考资料：<a href="http://www.cnblogs.com/jswang/p/7697732.html" target="_blank" rel="noopener">模板方法模式</a></p><p>​                  <a href="http://blog.csdn.net/carson_ho/article/details/54910518" target="_blank" rel="noopener">模板方法模式（Template Method） - 最易懂的设计模式解析</a></p><pre><code>[Java设计模式之模板方法模式（Template Method）](http://blog.csdn.net/jason0539/article/details/45037535)</code></pre><h2 id="观察者模式（-Observer-Pattern-）"><a href="#观察者模式（-Observer-Pattern-）" class="headerlink" title="观察者模式（ Observer Pattern ）"></a>观察者模式（ Observer Pattern ）</h2><p><strong>定义</strong></p><p>​    ==定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。==</p><p>​    在这里先讲一下面向对象设计的一个重要原则——单一职责原则。因此系统的每个对象应该将重点放在问题域中的离散抽象上。因此理想的情况下，一个对象只做一件事情。这样在开发中也就带来了诸多的好处：提供了重用性和维护性，也是进行重构的良好的基础。</p><p>​    因此几乎所有的设计模式都是基于这个基本的设计原则来的。</p><p>​    观察者模式是关于多个对象想知道一个对象中数据变化情况的一种成熟的模式。观察者模式中有一个称作“主题”的对象和若干个称作“观察者”的对象，“主题”和“观察者”间是一种一对多的依赖关系，当“主题”的状态发生变化时，所有“观察者”都得到通知。前面所述的“求职中心”相当于观察者模式的一个具体“主题”；每个“求职者”相当于观察者模式中的一个具体“观察者”。</p><p><strong>问题</strong></p><p>​    一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>解决方案</strong></p><p>​    一个被观察者管理所有相依于它的观察者物件，并且在本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p><p><strong>结构</strong></p><p>观察者模式结构的类图如下所示：</p><p><img src="\image\java设计模式\观察者模式结构图.png" alt="观察者模式结构图"></p><p>图例说明</p><ul><li>图片中的空心三角箭头，代表着继承（extends）或实现（Implement）关系， 由继承者/实现者 指向 被继承者/被继承者。</li><li>图片中的实心三角箭头且箭头末尾没有圆圈的， 代表着单一的引用关系， 但是被引用的对象也有可能被其他对象引用。</li><li>图片中的实心三角箭头且箭头末尾有圆圈的， 代表着一对多的引用关系。</li><li>图片中的末端有圆圈的虚线是一个对方法体内容用伪代码说明的关系</li></ul><p>观察者模式的结构中包含四种角色：</p><p>​    （1）主题（Subject）：主题是一个接口，该接口规定了具体主题需要实现的方法，比如，添加、删除观察者以及通知观察者更新数据的方法。</p><p>​    （2）观察者（Observer）：观察者是一个接口，该接口规定了具体观察者用来更新数据的方法。</p><p>​    （3）具体主题（ConcreteSubject）：具体主题是实现主题接口类的一个实例，该实例包含有可以经常发生变化的数据。具体主题需使用一个集合，比如ArrayList，存放观察者的引用，以便数据变化时通知具体观察者。</p><p>​    （4）具体观察者（ConcreteObserver）：具体观察者是实现观察者接口类的一个实例。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，使自己成为它的观察者，或让这个具体主题将自己从具体主题的集合中删除，使自己不再是它的观察者。</p><p><strong>适用场景</strong></p><p>​    1) 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</p><p>​    2) 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</p><p>​    3) 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</p><p><strong>实际例子</strong></p><p>​    珠宝商运送一批钻石，有黄金强盗准备抢劫，珠宝商雇佣了私人保镖，警察局也派人护送，于是当运输车上路的时候，强盗保镖警察都要观察运输车一举一动，</p><p>​    抽象的观察者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watcher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    抽象的被观察者(主题，subject)，在其中声明方法（添加、移除观察者，通知观察者）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWatcher</span><span class="params">(Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWatcher</span><span class="params">(Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyWatchers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    具体的观察者</p><p>​    保镖<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          System.out.println(“运输车有行动，保安贴身保护<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>​    强盗<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          System.out.println(“运输车有行动，强盗准备动手<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>​    警察<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Police</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          System.out.println(“运输车有行动，警察护航<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>​    具体的被观察者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> List&lt;Watcher&gt; list = <span class="keyword">new</span> ArrayList&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWatcher</span><span class="params">(Watcher watcher)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          list.add(watcher);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWatcher</span><span class="params">(Watcher watcher)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          list.remove(watcher);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyWatchers</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (Watcher watcher : list)</span><br><span class="line">          &#123;</span><br><span class="line">               watcher.update();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          Transporter transporter = <span class="keyword">new</span> Transporter();</span><br><span class="line">    </span><br><span class="line">          Police police = <span class="keyword">new</span> Police();</span><br><span class="line">          Security security = <span class="keyword">new</span> Security();</span><br><span class="line">          Thief thief = <span class="keyword">new</span> Thief();</span><br><span class="line">    </span><br><span class="line">          transporter.addWatcher(police);</span><br><span class="line">          transporter.addWatcher(security);</span><br><span class="line">          transporter.addWatcher(thief);</span><br><span class="line">    </span><br><span class="line">          transporter.notifyWatchers();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>我推你拉模型</strong></p><p>​    例子中没有关于数据和状态的变化通知，只是简单通知到各个观察者，告诉他们被观察者有行动。<br>观察者模式在关于目标角色、观察者角色通信的具体实现中，有两个版本。</p><p>​    一种情况便是目标角色在发生变化后，仅仅告诉观察者角色“我变化了”，观察者角色如果想要知道具体的变化细节，则就要自己从目标角色的接口中得到。这种模式被很形象的称为：拉模式——就是说变化的信息是观察者角色主动从目标角色中“拉”出来的。</p><p>​    还有一种方法，那就是我目标角色“服务一条龙”，通知你发生变化的同时，通过一个参数将变化的细节传递到观察者角色中去。这就是“推模式”——管你要不要，先给你啦。</p><p>​    这两种模式的使用，取决于系统设计时的需要。如果目标角色比较复杂，并且观察者角色进行更新时必须得到一些具体变化的信息，则“推模式”比较合适。如果目标角色比较简单，则“拉模式”就很合适啦。</p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    （1）具体主题和具体观察者是松耦合关系。由于主题接口仅仅依赖于观察者接口，因此具体主题只是知道它的观察者是实现观察者接口的某个类的实例，但不需要知道具体是哪个类。同样，由于观察者仅仅依赖于主题接口，因此具体观察者只是知道它依赖的主题是实现主题接口的某个类的实例，但不需要知道具体是哪个类。</p><p>​    （2）观察者模式满足“开-闭原则”。主题接口仅仅依赖于观察者接口，这样，就可以让创建具体主题的类也仅仅是依赖于观察者接口，因此，如果增加新的实现观察者接口的类，不必修改创建具体主题的类的代码。。同样，创建具体观察者的类仅仅依赖于主题接口，如果增加新的实现主题接口的类，也不必修改创建具体观察者类的代码。</p><p>​    ( 3 )  可以将一个对象的改变通知到依赖它的对象。这是观察者模式完成的基本任务，并且由于抽象观察者与抽象主题的存在，具体观察者和具体主题可以独立变化，而不影响另外一方。</p><p>​    缺点：</p><p>​    增加了类结构层级，使得设计时比较复杂。</p><p><strong>总结</strong></p><p>​    在观察者模式对应的问题中，具体观察者会发生改变，并且具体主题也会发生改变。但是主题一定是要被观察者来关注的，这个关系是不会发生改变的。观察者模式向上抽象了一层，利用抽象观察者接口和抽象主题接口，使得主题与观察者的一对多关系被固定下来。同时也将观察者与主题的具体类别解耦，使得一方的改变不会影响到另外一方。</p><p>参考资料：<a href="http://blog.csdn.net/lengxiao1993/article/details/55511101" target="_blank" rel="noopener">设计模式拾荒之观察者模式( Observer Pattern )： MVC的进一步泛化</a></p><p>​           <a href="http://www.cnblogs.com/liuzhen1995/p/5975352.html" target="_blank" rel="noopener">设计模式学习笔记（二：观察者模式）</a></p><pre><code>[深入浅出观察者模式](http://blog.csdn.net/ai92/article/details/375691)</code></pre><p>​           <a href="http://blog.csdn.net/jason0539/article/details/45055233" target="_blank" rel="noopener">Java设计模式之观察者模式</a></p><h2 id="迭代子-Iterator-模式"><a href="#迭代子-Iterator-模式" class="headerlink" title="迭代子(Iterator)模式"></a>迭代子(Iterator)模式</h2><p><strong>定义</strong></p><p>​    在软件构建过程中，集合对象内部结构常常变化各异，但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作提供了可能。</p><p>​    使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。</p><p>​    迭代子(Iterator)模式又叫游标(Cursor)模式，是对象的行为模式。==迭代子模式可以提供一种方法顺序访问一个聚集对象中各个元素 , 而又不需暴露该对象的内部表示。==</p><p><strong>聚集和JAVA聚集</strong></p><p>​    多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。数组就是最基本的聚集，也是其他的JAVA聚集对象的设计基础。</p><p>　　JAVA聚集对象是实现了共同的java.util.Collection接口的对象，是JAVA语言对聚集概念的直接支持。从1.2版开始，JAVA语言提供了很多种聚集，包括Vector、ArrayList、HashSet、HashMap、Hashtable等，这些都是JAVA聚集的例子。</p><p><strong>问题背景</strong></p><p>​    顺序访问聚集中的对象，主要用于集合中。一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。 迭代子模式为遍历集合提供了统一的接口方法。从而使得客户端不需要知道聚集的内部结构就能就能对聚集进行遍历等操作。Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 </p><p>​    例如，如果没有使用Iterator，遍历一个数组的方法是使用索引：<br>​    for(int i=0; i&lt;array.size(); i++) {<br>​        … get(i) … </p><p>​    }<br>​    而访问一个链表（LinkedList）又必须使用while循环： </p><p>​    while((e=e.next())!=null) { … e.data() … } </p><p>​    以上两种方法客户端都必须事先知道集合的内部结构，访问代码和集合本身是紧耦合，无法将访问逻辑从集合类和客户端代码中分离出来，每一种集合对应一种遍历方法，客户端代码无法复用。 </p><p>​    更恐怖的是，如果以后需要把ArrayList更换为LinkedList，则原来的客户端代码必须全部重写。 </p><p>​    为解决以上问题，Iterator模式总是用同一种逻辑来遍历集合：<br>​    for(Iterator it = c.iterater(); it.hasNext(); ) { … } </p><p>​    奥秘在于客户端自身不维护遍历集合的”指针”，所有的内部状态（如当前元素位置，是否有下一个元素）都由Iterator来维护，而这个Iterator由集合类通过工厂方法生成，因此，它知道如何遍历整个集合。 </p><p>​    客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。</p><p><strong>迭代子模式的结构</strong></p><p>​    迭代子模式有两种实现方式，分别是<strong>白箱聚集与外禀迭代子</strong>和<strong>黑箱聚集于内禀迭代子。</strong></p><p>​    <strong>白箱聚集与外禀(bing, 三声)迭代子</strong></p><p>​    如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做白箱聚集。聚集对象向外界提供同样的宽接口，如下图所示：</p><p><img src="\image\java设计模式\迭代子模式-白箱聚集结构.png" alt="迭代子模式-白箱聚集结构">    </p><p>​    由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代子叫做<strong>游标迭代子（Cursor Iterator）</strong>。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做<strong>外禀迭代子（Extrinsic Iterator）</strong>。</p><p>​    现在看一看白箱聚集与外禀迭代子的实现。一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代子可以通过聚集的遍历方法实现迭代功能。</p><p>　    因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代子角色往往仅仅保持迭代的游标位置。</p><p>　　一个典型的由白箱聚集与外禀迭代子组成的系统如下图所示，在这个实现中具体迭代子角色是一个外部类，而具体聚集角色向外界提供遍历聚集元素的接口。</p><p><img src="\image\java设计模式\白箱聚集与外禀迭代子-示意图.png" alt="白箱聚集与外禀迭代子-示意图"></p><p>​    注意，从上图可以看出，在具体迭代子中关联了一个具体的聚集对象！</p><p>​    迭代子模式涉及到以下几个角色：</p><p>　　●　　抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。</p><p>　　●　　具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。</p><p>　　●　　聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。</p><p>　　●　　具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。</p><p>　　●　　客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。</p><p>​    <strong>源代码</strong></p><p>​    抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，创建相应迭代子对象的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    具体聚集角色类，实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title">Aggregate</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] objArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入聚合对象的具体内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteAggregate</span><span class="params">(Object[] objArray)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objArray = objArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法：向外界提供聚集元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElement</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index &lt; objArray.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> objArray[index];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法：向外界提供聚集的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objArray.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    抽象迭代子角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    具体迭代子角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有被迭代的具体的聚合对象</span></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate agg;</span><br><span class="line">    <span class="comment">//内部索引，记录当前迭代到的索引位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录当前聚集对象的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(ConcreteAggregate agg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.agg = agg;</span><br><span class="line">        <span class="keyword">this</span>.size = agg.size();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> agg.getElement(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (index &gt;= size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(index &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　    客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object[] objArray = &#123;<span class="string">"One"</span>,<span class="string">"Two"</span>,<span class="string">"Three"</span>,<span class="string">"Four"</span>,<span class="string">"Five"</span>,<span class="string">"Six"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建聚合对象</span></span><br><span class="line">        Aggregate agg = <span class="keyword">new</span> ConcreteAggregate(objArray);</span><br><span class="line">        <span class="comment">//循环输出聚合对象中的值</span></span><br><span class="line">        Iterator it = agg.createIterator();</span><br><span class="line">        <span class="keyword">while</span>(!it.isDone())&#123;</span><br><span class="line">            System.out.println(it.currentItem());</span><br><span class="line">            it.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代子对象。在得到迭代子的实例后，客户端开始迭代过程，打印出所有的聚集元素。</p><p>​    <strong>外禀迭代子的意义</strong></p><p>​    一个常常会问的问题是：既然白箱聚集已经向外界提供了遍历方法，客户端已经可以自行进行迭代了，为什么还要应用迭代子模式，并创建一个迭代子对象进行迭代呢？</p><p>　　客户端当然可以自行进行迭代，不一定非得需要一个迭代子对象。但是，迭代子对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代子责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代子作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。</p><p>　　此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代子模式和一个外界的迭代子对象是有意义的。具有同一迭代接口的不同迭代子对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。</p><p><strong>黑箱聚集与内禀迭代子</strong></p><p>​    如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的<strong>窄接口</strong>。</p><p>　　聚集对象为迭代子对象提供一个宽接口，而为其他对象提供一个窄接口。换言之，聚集对象的内部结构应当对迭代子对象适当公开，以便迭代子对象能够对聚集对象有足够的了解，从而可以进行迭代操作。但是，聚集对象应当避免向其他的对象提供这些方法，因为其他对象应当经过迭代子对象进行这些工作，而不是直接操控聚集对象。</p><p><img src="\image\java设计模式\黑箱聚集与内禀迭代子-结构示意图.png" alt="黑箱聚集与内禀迭代子-结构示意图"></p><p>　    在JAVA语言中，实现双重接口的办法就是将迭代子类设计成聚集类的内部成员类。这样迭代子对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构。下面给出一个示意性的实现，说明这种双重接口的结构时怎么样产生的，以及使用了双重接口结构之后迭代子模式的实现方案。这种同时保证聚集对象的封装和迭代子功能的实现的方案叫做<strong>黑箱实现方案</strong>。</p><p>　　由于迭代子是聚集的内部类，迭代子可以自由访问聚集的元素，所以迭代子可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代子是在聚集的结构之内定义的，因此这样的迭代子又叫做<strong>内禀迭代子（Intrinsic Iterator）。</strong></p><p>​    为了说明黑箱方案的细节，这里给出一个示意性的黑箱实现。在这个实现里，聚集类ConcreteAggregate含有一个内部成员类ConcreteIterator，也就是实现了抽象迭代子接口的具体迭代子类，同时聚集并不向外界提供访问自己内部元素的方法。</p><p><img src="\image\java设计模式\内禀迭代子-实现代码结构图.png" alt="内禀迭代子-实现代码结构图"></p><p>​    从上图可以看出，相对于外禀迭代子，内禀迭代子由于是聚集对象的内部类，所以它(ConcreteIterator)不用持有具体聚集对象的引用。</p><p>​    <strong>源代码</strong></p><p>​    抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，创建相应迭代子对象的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    抽象迭代子角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    具体聚集角色类，实现了抽象聚集角色所要求的接口，也就是createIterator()方法。此外，聚集类有一个内部成员类ConcreteIterator，这个内部类实现了抽象迭代子角色所规定的接口；而工厂方法createIterator()所返还的就是这个内部成员类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">​    </span><br><span class="line">    <span class="keyword">private</span> Object[] objArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入聚合对象的具体内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteAggregate</span><span class="params">(Object[] objArray)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objArray = objArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部成员类，具体迭代子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">//内部索引，记录当前迭代到的索引位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录当前聚集对象的大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.size = objArray.length;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> objArray[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (index &gt;= size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(index &lt; size)</span><br><span class="line">            &#123;</span><br><span class="line">                index ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object[] objArray = &#123;<span class="string">"One"</span>,<span class="string">"Two"</span>,<span class="string">"Three"</span>,<span class="string">"Four"</span>,<span class="string">"Five"</span>,<span class="string">"Six"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建聚合对象</span></span><br><span class="line">        Aggregate agg = <span class="keyword">new</span> ConcreteAggregate(objArray);</span><br><span class="line">        <span class="comment">//循环输出聚合对象中的值</span></span><br><span class="line">        Iterator it = agg.createIterator();</span><br><span class="line">        <span class="keyword">while</span>(!it.isDone())&#123;</span><br><span class="line">            System.out.println(it.currentItem());</span><br><span class="line">            it.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代子对象。在得到迭代子的实例后，客户端开始迭代过程，打印出所有的聚集元素。</p><p><strong>主动迭代子和被动迭代子</strong></p><p>​    主动迭代子和被动迭代子又称作外部迭代子和内部迭代子。</p><p>　　所谓主动（外部）迭代子，指的是由客户端来控制迭代下一个元素的步骤，客户端会明显调用迭代子的next()等迭代方法，在遍历过程中向前进行。</p><p>　　所谓被动（内部）迭代子，指的是由迭代子自己来控制迭代下一个元素的步骤。因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传递给迭代子，迭代子在迭代的时候会在每个元素上执行这个操作，类似于JAVA的回调机制。</p><p>　　总体来说外部迭代器比内部迭代器要灵活一些，因此我们常见的实现多属于主动迭代子。</p><p><strong>静态迭代子和动态迭代子</strong></p><p>​    ●　　静态迭代子由聚集对象创建，并持有聚集对象的一份快照(snapshot)，在产生后这个快照的内容就不再变化。客户端可以继续修改原聚集的内容，但是迭代子对象不会反映出聚集的新变化。</p><p>　　静态迭代子的好处是它的安全性和简易性，换言之，静态迭代子易于实现，不容易出现错误。但是由于静态迭代子将原聚集复制了一份，因此它的短处是对时间和内存资源的消耗。</p><p>　　●　　动态迭代子则与静态迭代子完全相反，在迭代子被产生之后，迭代子保持着对聚集元素的引用，因此，任何对原聚集内容的修改都会在迭代子对象上反映出来。</p><p>　　完整的动态迭代子不容易实现，但是简化的动态迭代子并不难实现。大多数JAVA设计师遇到的迭代子都是这种简化的动态迭代子。为了说明什么是简化的动态迭代子，首先需要介绍一个新的概念：<strong>Fail Fast</strong>。</p><p><strong>Fail Fast</strong></p><p>​    JAVA语言以接口java.util.Iterator的方式支持迭代子模式，Collection接口要求提供iterator()方法，此方法在调用时返还一个Iterator类型的对象。而作为Collection接口的子类型，AbstractList类的内部成员类Itr便是实现Iterator接口的类。</p><p>　Itr类的源代码如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            E next = get(cursor);</span><br><span class="line">            lastRet = cursor++;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>　    从Itr类的源代码中可以看到，方法checkForComodification()会检查聚集的内容是否刚刚被外界直接修改过(不是通过迭代子提供的方法修改的)。如果在迭代开始后，聚集的内容被外界绕过迭代子对象而直接修改的话，这个方法会立即抛出ConcurrentModificationException()异常。</p><p>​    这就是说，AbstractList.Itr迭代子是一个Fail Fast的迭代子。</p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    （1）迭代子模式简化了聚集的接口。迭代子具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。</p><p>　　（2）每一个聚集对象都可以有一个或多个迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。</p><p>　　（3）由于遍历算法被封装在迭代子角色里面，因此迭代的算法可以独立于聚集角色变化。</p><p>​    缺点：</p><p>​    暂时想到的缺点就是，会增加结构层次，并且在聚集类中增加方法，并且会关联到迭代子对象。</p><p><strong>总结</strong></p><p>​    迭代子模式可以为不同的聚集对象提供一个遍历集合中所有元素的统一接口，使得客户端在遍历集合元素时，不需要考虑集合的内部实现和访问方式。</p><p>​    聚集对象的内部结构在变化，访问方式也在变化，但是客户端始终是需要对集合元素进行遍历的需求不会变化。迭代子模式很好的屏蔽了集合内部变化对客户端遍历元素的影响。</p><p>​    要注意下外禀迭代子和内禀迭代子的实现。</p><p>参考资料：<a href="http://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html" target="_blank" rel="noopener">《JAVA与模式》之迭代子模式</a></p><p>​           <a href="http://www.cnblogs.com/JAYIT/p/5081695.html" target="_blank" rel="noopener">java设计模式—-迭代子模式</a></p><p>​           <a href="http://blog.csdn.net/jason0539/article/details/45070441" target="_blank" rel="noopener">Java设计模式之迭代子模式</a></p><h2 id="责任链模式（Chain-fo-Responsibility）"><a href="#责任链模式（Chain-fo-Responsibility）" class="headerlink" title="责任链模式（Chain fo Responsibility）"></a>责任链模式（Chain fo Responsibility）</h2><p><strong>定义</strong></p><p>​    使多个对象都有机会处理请求，从而避免了请求的发送和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p><p><strong>模式解析</strong></p><p>​    责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p><p>　　责任链模式的要点主要是：</p><p>　　1、有多个对象共同对一个任务进行处理。</p><p>　　2、这些对象使用链式存储结构，形成一个链，每个对象知道自己的下一个对象。</p><p>　　3、一个对象对任务进行处理，可以添加一些操作后将对象传递个下一个任务。也可以在此对象上结束任务的处理，并结束任务。</p><p>　　3、客户端负责组装链式结构，但是客户端不需要关心最终是谁来处理了任务。</p><p><strong>结构</strong></p><p>​    责任链模式结构的类图，如下图所示：</p><p><img src="\image\java设计模式\责任链模式-结构示意图.jpg" alt="责任链模式-结构示意图"></p><p>​    责任链模式涉及到的角色：</p><p>​    抽象处理者角色(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。</p><p>​    具体处理者角色(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。</p><p><strong>源代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有后继的责任对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意处理请求的方法，虽然这个示意方法是没有传入参数的</span></span><br><span class="line"><span class="comment">     * 但实际是可以传入参数的，根据具体需要来选择是否传递参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 赋值方法，设置后继的责任对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    具体处理者角色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理方法，调用此方法处理请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否有后继的责任对象</span></span><br><span class="line"><span class="comment">         * 如果有，就转发请求给后继的责任对象</span></span><br><span class="line"><span class="comment">         * 如果没有，则处理请求</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>)</span><br><span class="line">        &#123;            </span><br><span class="line">            System.out.println(<span class="string">"放过请求"</span>);</span><br><span class="line">            getSuccessor().handleRequest();            </span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;            </span><br><span class="line">            System.out.println(<span class="string">"处理请求"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//组装责任链</span></span><br><span class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler();</span><br><span class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler();</span><br><span class="line">        handler1.setSuccessor(handler2);</span><br><span class="line">        <span class="comment">//提交请求</span></span><br><span class="line">        handler1.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    可以看出，客户端创建了两个处理者对象，并指定第一个处理者对象的下家是第二个处理者对象，而第二个处理者对象没有下家。然后客户端将请求传递给第一个处理者对象。</p><p>​    由于本示例的传递逻辑非常简单：只要有下家，就传给下家处理；如果没有下家，就自行处理。</p><p>​    因此，第一个处理者对象接到请求后，会将请求传递给第二个处理者对象。由于第二个处理者对象没有下家，于是自行处理请求。活动时序图如下所示。</p><p><strong>实际例子</strong></p><p>​    申请聚餐费用的管理，申请聚餐费用的大致流程一般是，由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。<br>​    不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。</p><p><img src="\image\java设计模式\责任链模式实例1.png" alt="责任链模式实例1"></p><p>​    当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。申请人只要直接与项目经理交互就可以，其余的工作在黑盒中，究竟流程是怎样的，最后是由谁审批通过的，申请人无需关心。</p><p><img src="\image\java设计模式\责任链模式实例1-类图.png" alt="责任链模式实例1-类图"></p><p>​    抽象处理者角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有下一个处理请求的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置下一个处理请求的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理聚餐费用的申请</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user    申请人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fee    申请的钱数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>        成功或失败的具体通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">handleFeeRequest</span><span class="params">(String user , <span class="keyword">double</span> fee)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    具体处理者角色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFeeRequest</span><span class="params">(String user, <span class="keyword">double</span> fee)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//项目经理权限比较小，只能在500以内</span></span><br><span class="line">        <span class="keyword">if</span>(fee &lt; <span class="number">500</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意张三的请求</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"张三"</span>.equals(user))</span><br><span class="line">            &#123;</span><br><span class="line">                str = <span class="string">"成功：项目经理同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;    </span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他人一律不同意</span></span><br><span class="line">                str = <span class="string">"失败：项目经理不同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//超过500，继续传递给级别更高的人处理</span></span><br><span class="line">            <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFeeRequest</span><span class="params">(String user, <span class="keyword">double</span> fee)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//部门经理的权限只能在1000以内</span></span><br><span class="line">        <span class="keyword">if</span>(fee &lt; <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意张三的请求</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"张三"</span>.equals(user))</span><br><span class="line">            &#123;</span><br><span class="line">                str = <span class="string">"成功：部门经理同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;    </span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他人一律不同意</span></span><br><span class="line">                str = <span class="string">"失败：部门经理不同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//超过1000，继续传递给级别更高的人处理</span></span><br><span class="line">            <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFeeRequest</span><span class="params">(String user, <span class="keyword">double</span> fee)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//总经理的权限很大，只要请求到了这里，他都可以处理</span></span><br><span class="line">        <span class="keyword">if</span>(fee &gt;= <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意张三的请求</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"张三"</span>.equals(user))</span><br><span class="line">            &#123;</span><br><span class="line">                str = <span class="string">"成功：总经理同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;    </span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他人一律不同意</span></span><br><span class="line">                str = <span class="string">"失败：总经理不同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果还有后继的处理对象，继续传递</span></span><br><span class="line">            <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先要组装责任链</span></span><br><span class="line">        Handler h1 = <span class="keyword">new</span> GeneralManager();</span><br><span class="line">        Handler h2 = <span class="keyword">new</span> DeptManager();</span><br><span class="line">        Handler h3 = <span class="keyword">new</span> ProjectManager();</span><br><span class="line">        h3.setSuccessor(h2);</span><br><span class="line">        h2.setSuccessor(h1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始测试</span></span><br><span class="line">        String test1 = h3.handleFeeRequest(<span class="string">"张三"</span>, <span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"test1 = "</span> + test1);</span><br><span class="line">        String test2 = h3.handleFeeRequest(<span class="string">"李四"</span>, <span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"test2 = "</span> + test2);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">        </span><br><span class="line">        String test3 = h3.handleFeeRequest(<span class="string">"张三"</span>, <span class="number">700</span>);</span><br><span class="line">        System.out.println(<span class="string">"test3 = "</span> + test3);</span><br><span class="line">        String test4 = h3.handleFeeRequest(<span class="string">"李四"</span>, <span class="number">700</span>);</span><br><span class="line">        System.out.println(<span class="string">"test4 = "</span> + test4);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">        </span><br><span class="line">        String test5 = h3.handleFeeRequest(<span class="string">"张三"</span>, <span class="number">1500</span>);</span><br><span class="line">        System.out.println(<span class="string">"test5 = "</span> + test5);</span><br><span class="line">        String test6 = h3.handleFeeRequest(<span class="string">"李四"</span>, <span class="number">1500</span>);</span><br><span class="line">        System.out.println(<span class="string">"test6 = "</span> + test6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    1、降低耦合度。它将请求的发送者和接收者解耦。</p><p>​    2、简化了对象。使得对象不需要知道链的结构。</p><p>​    3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</p><p>​    4、增加新的请求处理类很方便。</p><p>​    缺点：</p><p>​    1、不能保证请求一定被接收。</p><p>​    2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</p><p>​    3、可能不容易观察运行时的特征，有碍于除错。</p><p><strong>适用场景</strong></p><p>​    当有多个对象需要对某一个任务进行检查或者处理的时候，可以使用责任链模式来简化对象的关系。并且也可以使得任务发送者与任务接送者之间的解耦。</p><p><strong>总结</strong></p><p>​    责任链模式可以处理任务多个处理对象之间的组织关系，并且可以简化客户端的考虑。处理任务的对象可能会增加、减少，或者发生其他的结构变化，但是由于责任链的存在，客户端不需要考虑这些变化带来的影响，客户端只知道任务最终是会被处理的，这件事情是确定的。</p><p>参考资料： <a href="http://blog.csdn.net/lmb55/article/details/51052866" target="_blank" rel="noopener">大话设计模式—责任链模式</a></p><p>​            <a href="http://www.cnblogs.com/jyyzzjl/p/5187340.html" target="_blank" rel="noopener">[工作中的设计模式]责任链模式chain</a></p><p>​                <a href="https://www.jianshu.com/p/9d6987fd17a8" target="_blank" rel="noopener">设计模式之责任链模式</a></p><p>​                    <a href="http://blog.csdn.net/jason0539/article/details/45091639" target="_blank" rel="noopener">Java设计模式之责任链模式、职责链模式</a></p><h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式( Command )"></a>命令模式( Command )</h2><p><strong>定义</strong></p><p>​    命令模式是一个高内聚的模式，其定义为：Encapsulate a request as an object,there by letting you parameterize clients with different requests,queue or log requests,and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请 求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）</p><p><strong>问题</strong></p><p>​    在软件设计中，我们经常会遇到某些对象发送请求，然后某些对象接受请求后执行，但发送请求的对象可能并不知道接受请求的对象是谁，执行的是什么动作。此时可通过 <strong>命令模式</strong> 来实现，让发送者和接受者完全的松耦合，这样可大大增强程序的灵活性。</p><p><strong>结构</strong></p><p>​    命令模式的示意性类图如下所示：</p><p><img src="\image\java设计模式\命令模式结构.jpg" alt="命令模式结构"></p><p>​     在命令模式结构图中包含如下几个角色：</p><ul><li><p>Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。</p></li><li><p>ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。</p></li><li><p>Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。</p></li><li><p>Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</p></li></ul><p>​    命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。</p><p><strong>适用情况</strong></p><p>​    1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</p><p>​    2.系统需要在不同的时间指定请求、将请求排队和执行请求。</p><p>​    3.系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</p><p>​    4.系统需要将一组操作组合在一起，即支持宏命令。</p><p><strong>实际例子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行命令的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令接收者Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tv</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">int</span> currentChannel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   System.out.println(<span class="string">"The televisino is on."</span>);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   System.out.println(<span class="string">"The television is off."</span>);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeChannel</span><span class="params">(<span class="keyword">int</span> channel)</span> </span>&#123;</span><br><span class="line">　　   <span class="keyword">this</span>.currentChannel = channel;</span><br><span class="line">　　   System.out.println(<span class="string">"Now TV channel is "</span> + channel);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开机命令ConcreteCommand</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandOn</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Tv myTv;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">CommandOn</span><span class="params">(Tv tv)</span> </span>&#123;</span><br><span class="line">　　   myTv = tv;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   myTv.turnOn();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关机命令ConcreteCommand</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandOff</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Tv myTv;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">CommandOff</span><span class="params">(Tv tv)</span> </span>&#123;</span><br><span class="line">　　   myTv = tv;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   myTv.turnOff();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//频道切换命令ConcreteCommand</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandChange</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Tv myTv;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">int</span> channel;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">CommandChange</span><span class="params">(Tv tv, <span class="keyword">int</span> channel)</span> </span>&#123;</span><br><span class="line">　　   myTv = tv;</span><br><span class="line"> 　　  <span class="keyword">this</span>.channel = channel;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   myTv.changeChannel(channel);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看作是遥控器Invoker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Command onCommand, offCommand, changeChannel;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">Control</span><span class="params">(Command on, Command off, Command channel)</span> </span>&#123;</span><br><span class="line"> 　　  onCommand = on;</span><br><span class="line"> 　　  offCommand = off;</span><br><span class="line">　　   changeChannel = channel;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   onCommand.execute();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   offCommand.execute();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　  changeChannel.execute();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类Client</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  　　 <span class="comment">// 命令接收者Receiver</span></span><br><span class="line"> 　　  Tv myTv = <span class="keyword">new</span> Tv();</span><br><span class="line"> 　　  <span class="comment">// 开机命令ConcreteCommond</span></span><br><span class="line">  　　 CommandOn on = <span class="keyword">new</span> CommandOn(myTv);</span><br><span class="line">  　　 <span class="comment">// 关机命令ConcreteCommond</span></span><br><span class="line">  　　 CommandOff off = <span class="keyword">new</span> CommandOff(myTv);</span><br><span class="line">  　　 <span class="comment">// 频道切换命令ConcreteCommond</span></span><br><span class="line"> 　　  CommandChange channel = <span class="keyword">new</span> CommandChange(myTv, <span class="number">2</span>);</span><br><span class="line"> 　　  <span class="comment">// 命令控制对象Invoker</span></span><br><span class="line">　　   Control control = <span class="keyword">new</span> Control(on, off, channel);</span><br><span class="line"></span><br><span class="line">  　　 <span class="comment">// 开机</span></span><br><span class="line">  　　 control.turnOn();</span><br><span class="line"> 　　  <span class="comment">// 切换频道</span></span><br><span class="line"> 　　  control.changeChannel();</span><br><span class="line"> 　　  <span class="comment">// 关机</span></span><br><span class="line"> 　　  control.turnOff();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The televisino is on.</span><br><span class="line">Now TV channel is <span class="number">2</span></span><br><span class="line">The television is off.</span><br></pre></td></tr></table></figure></p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    1.降低对象之间的耦合度。</p><p>​    2.新的命令可以很容易地加入到系统中。</p><p>​    3.可以比较容易地设计一个组合命令。</p><p>​    4.调用同一方法实现不同的功能</p><p>​    缺点：</p><p>​    使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</p><p><strong>总结</strong></p><p>​    命令模式的本质就是将命令封装起来了，这样在命令发送者和接受者之间就构建了一个桥梁，使得他们解耦。所以每一个命令都不同，但是将命令封装并抽象一个层次，那么就可以对命令做一些共性的操作，比如撤销、记录和排队等。主要的作用还是在解耦命令的发送者和接受者。</p><p>参考资料：<a href="http://www.cnblogs.com/f-zhao/p/6203208.html" target="_blank" rel="noopener">设计模式-命令模式</a></p><p>​           <a href="http://blog.csdn.net/wwh578867817/article/details/51533263" target="_blank" rel="noopener">设计模式 —— 命令模式（Command Pattern）</a></p><p>​           <a href="http://www.cnblogs.com/lfxiao/p/6825644.html" target="_blank" rel="noopener">java设计模式之命令模式</a></p><p>​           <a href="http://blog.csdn.net/jason0539/article/details/45110355" target="_blank" rel="noopener">Java设计模式之命令模式</a></p><h2 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式( Memento )"></a>备忘录模式( Memento )</h2><p><strong>定义</strong></p><p>​    备忘录（Memento）模式又称标记（Token）模式。GOF给备忘录模式的定义为：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><p><strong>问题</strong></p><p>​    一个对象中一般都封装了很多属性，这些属性的值会随着程序的运行而变化。当我们需要保存某一时刻对象的某些值的时候，我们就再创建一个对象，将当前对象中的一些属性保存到新的对象中，当我们需要恢复的时候再从新的对象中取出属性值即可。这种想法就是备忘录模式。</p><p><strong>结构</strong></p><p>​    备忘录模式的类图：</p><p><img src="\image\java设计模式\备忘录模式结构.png" alt="备忘录模式结构"></p><p>角色分类</p><p>​    1) 备忘录（Memento）角色：备忘录角色存储“备忘发起角色”的内部状态。“备忘发起角色”根据需要决定备忘录角色存储“备忘发起角色”的哪些内部状态。为了防止“备忘发起角色”以外的其他对象访问备忘录。备忘录实际上有两个接口，“备忘录管理者角色”只能看到备忘录提供的窄接口——对于备忘录角色中存放的属性是不可见的。“备忘发起角色”则能够看到一个宽接口——能够得到自己放入备忘录角色中属性。</p><p>　　2) 备忘发起（Originator）角色：“备忘发起角色”创建一个备忘录，用以记录当前时刻它的内部状态。在需要时使用备忘录恢复内部状态。</p><p>　　3) 备忘录管理者（Caretaker）角色：负责保存好备忘录。不能对备忘录的内容进行操作或检查。</p><p><strong>备忘录模式的分类</strong></p><p>​    1.”白箱”备忘录模式的实现 </p><p><img src="\image\java设计模式\白箱-备忘录模式.png" alt="白箱-备忘录模式"></p><p>​    2.“黑箱”备忘录模式的实现</p><p><img src="\image\java设计模式\黑箱-备忘录模式.png" alt="黑箱-备忘录模式"></p><p>​    3.“多重”检查点 </p><p><img src="\image\java设计模式\多重检查点-备忘录模式.png" alt="多重检查点-备忘录模式"></p><p>​    4.”自述历史”模式 </p><p><img src="\image\java设计模式\自述历史-备忘录模式.png" alt="自述历史-备忘录模式"></p><p><strong>举例</strong></p><p>​    “白箱”备忘录模式的实现</p><p>​    备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。因此这个实现又叫做“白箱实现”。 </p><p>​    “白箱”实现将发起人角色的状态存储在一个大家都看得到的地方，因此是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。因此白箱实现仍然是有意义的。 </p><p>​    下面给出一个示意性的“白箱实现”。</p><p>​    demo 入口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类似白箱备忘录模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">3</span>;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(state);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建备忘录对象的 缓存起来</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            caretaker.saveMemento(originator.creatMementoObject());</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 进行设置重新还原</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            originator.setState(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">"发起人更改状态："</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">        originator.restoreMemento(caretaker.retrieveMemento());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    管理者，负责发起者的管理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管理者 负责管理Caretaker</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录的取值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">retrieveMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录的赋值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    备忘录，对发起者进行缓存的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备忘录</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">this</span>.state = state;</span><br><span class="line">    ​    System.out.println(<span class="string">"备忘录 当前保存 状态："</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    发起者，负责备忘录的创建，修改，恢复<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起者</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">creatMementoObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将发起人恢复到备忘录对象所记载的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = memento.getState();</span><br><span class="line">        System.out.println(<span class="string">"恢复 备忘录 状态："</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    “黑箱”备忘录模式的实现</p><p>​    备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。这样的实现叫做“黑箱实现”。 </p><p>​    在JAVA语言中，实现双重接口的办法就是将备忘录角色类设计成发起人角色类的内部成员类。 </p><p>​    将Memento设成Originator类的内部类，从而将Memento对象封装在Originator里面；在外部提供一个标识接口 MementoIF给Caretaker以及其他对象。这样，Originator类看到的是Menmento的所有接口，而Caretaker以及其他 对象看到的仅仅是标识接口MementoIF所暴露出来的接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto.black;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类似黑箱备忘录模式</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * ​</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">3</span>;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(state);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建备忘录对象的 缓存起来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        caretaker.saveMemento(originator.creatMementoObject());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 进行设置重新还原</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        originator.setState(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">" 黑箱发起人更改状态："</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">        originator.restoreMemento(caretaker.retrieveMemento());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto.black;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemotoIF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto.black;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起者</span></span><br><span class="line"><span class="comment"> *  内部类如何拿到外部类的引用   https://zhidao.baidu.com/question/513464853.html</span></span><br><span class="line"><span class="comment"> *  已经外部类如何访问内部类中的成员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">creatMementoObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将发起人恢复到备忘录对象所记载的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(MemotoIF momIf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(((Memento) momIf).getState());</span><br><span class="line">        System.out.println(<span class="string">"黑箱恢复 备忘录 状态："</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> <span class="keyword">implements</span> <span class="title">MemotoIF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ​    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    ​    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​        <span class="keyword">this</span>.state = state;</span><br><span class="line">    ​        System.out.println(<span class="string">"黑箱备忘录 当前保存 状态："</span> + state);</span><br><span class="line">    ​    &#125;</span><br><span class="line"></span><br><span class="line">    ​    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​        <span class="keyword">return</span> state;</span><br><span class="line">    ​    &#125;</span><br><span class="line"></span><br><span class="line">    ​    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ​        <span class="keyword">this</span>.state = state;</span><br><span class="line">    ​    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto.black;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管理者 负责管理Caretaker</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MemotoIF memento;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录的取值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemotoIF <span class="title">retrieveMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录的赋值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemento</span><span class="params">(MemotoIF memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多重检查点</strong></p><p>​    前面所给出的白箱和黑箱的示意性实现都是只存储一个状态的简单实现，也可以叫做只有一个检查点。常见的系统往往需要存储不止一个状态，而是需要存储多个状态，或者叫做有多个检查点。<br>　　备忘录模式可以将发起人对象的状态存储到备忘录对象里面，备忘录模式可以将发起人对象恢复到备忘录对象所存储的某一个检查点上。</p><p><strong>”自述历史”模式</strong></p><p>​    所谓“自述历史”模式(History-On-Self Pattern)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(Originator)角色、负责人(Caretaker)角色和备忘录 (Memento)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历 史”模式里面，发起人角色自己兼任负责人角色。 </p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    1、备忘录模式可以把发起人内部信息对象屏蔽起来，从而可以保持封装的边界。<br>​    2、简化了发起人类。当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</p><p>​    优点：</p><p>​    1、如果状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象比较昂贵。</p><p><strong>总结</strong></p><p>​    备忘录模式就是将一个对象的状态保存在它的外部，这样方便以后恢复这个对象的状态。由于备忘录角色和管理角色的存在，所以当发起者角色的状态变化方式不一样的时候，客户端仍然可以按照之前的方式来操作对象，而不需要进行改变。</p><p>​    可以说，备忘录模式使得客户端恢复对象状态的方式固定不变，而对象状态发生改变的方式可以改变并不会影响到客户端。</p><p>参考资料：<a href="http://blog.csdn.net/o279642707/article/details/60767258#t2" target="_blank" rel="noopener">23种设计模式之—备忘录模式</a></p><pre><code>[JAVA设计模式之：备忘录模式](http://blog.csdn.net/true100/article/details/50561081)</code></pre><p>​          <a href="http://blog.csdn.net/u010425776/article/details/48008713" target="_blank" rel="noopener">“备忘录模式”就这么简单</a></p><h2 id="状态模式-state-pattern"><a href="#状态模式-state-pattern" class="headerlink" title="状态模式( state pattern )"></a>状态模式( state pattern )</h2><p><strong>定义</strong></p><p>​    允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式是一种对象行为型模式。</p><p>​    也就是说状态模式封装的非常好，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。</p><p><strong>问题</strong></p><p>​    一个对象的内部状态会影响到它的行为，并且行为还会改变这个对象的状态。状态之间存在着复杂的切换关系。</p><p><strong>方案</strong></p><p>​    将对象的状态抽象出来，对象状态的改变也封装到状态对象中去。这样客户端和对象就不在关注状态改变的细节，以及状态和行为之间的改变也不需要关注。</p><p><strong>使用场景</strong></p><p>​    （1）对象的行为依赖于它的状态，并且可以在运行时根据状态改变行为。</p><p>​    （2）代码中包含大量与对象状态有关的if/else语句，这些条件对应于对象的各种状态，这些冗余条件语句的出现导致代码的可维护性和灵活性变差，这种情况适合使用状态模式进行优化。</p><p><strong>结构</strong></p><p>​    下图是状态模式结构的简单示意图</p><p><img src="\image\java设计模式\状态模式结构.jpg" alt="状态模式结构"></p><p>状态模式涉及的角色：</p><p>​    （1）Context类，定义客户端所感兴趣的接口，并且内部维护一个具体状态类的实例，从而维护了对象的现有状态。</p><p>​    （2）State：抽象状态类或状态接口，用以抽象封装行为。</p><p>​    （3）ConcreteState类：具体状态类，实现了State中的抽象方法。</p><p><strong>实际例子</strong></p><p>​    实例1</p><p>​    我们使用一个常见的场景，比如我们用手机打开了CSDN，找到了一篇文章，觉得写的不错，当我们点击“收藏”时，会突然跳出一个登录界面，这时我们才发觉原来我们还没有登录，如果我们已经登录成功，在点击“收藏”，就会有相应的业务逻辑处理。</p><p>​    实例2</p><p>​     我们每天都在乘电梯，电梯就涉及到状态（停止、运行等）和动作（敞开、关闭等）。那我们来看看电梯有哪些动作（映射到Java 中就是有多少方法）:开门、关门、运行、停止，就这四个动作，好，我们就用程序来实现一下电梯的动作，先看类图设计：</p><p><img src="\image\java设计模式\状态模式-电梯实例-类图1.png" alt="状态模式-电梯实例-类图1"></p><p>​    非常简单的类图，定义一个接口，然后是一个实现类，然后业务类Client 就可以调用，并运行起来，简单也来看看我们的程序,先看接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 定义一个电梯的接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先电梯门开启动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯门有开启，那当然也就有关闭了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯要能上能下，跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯还要能停下来，停不下来那就扯淡了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    然后看实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 电梯的实现类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lift</span> <span class="keyword">implements</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯门关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门关闭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门开启</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门开启..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯开始跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯上下跑起来..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>​    电梯的开、关、跑、停都实现了，开看业务是怎么调用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 模拟电梯的动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILift lift = <span class="keyword">new</span> Lift();</span><br><span class="line">        <span class="comment">//首先是电梯门开启，人进去</span></span><br><span class="line">        lift.open();</span><br><span class="line">        <span class="comment">//然后电梯门关闭</span></span><br><span class="line">        lift.close();</span><br><span class="line">        <span class="comment">//再然后，电梯跑起来，向上或者向下</span></span><br><span class="line">        lift.run();</span><br><span class="line">        <span class="comment">//最后到达目的地，电梯挺下来</span></span><br><span class="line">        lift.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>  ​    运行的结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电梯门开启...</span><br><span class="line">电梯门关闭...</span><br><span class="line">电梯上下跑起来...</span><br><span class="line">电梯停止了...</span><br></pre></td></tr></table></figure></p><p>​    太简单的程序了，是个程序员都会写这个程序，这么简单的程序还拿出来show，是不是太小看我们的智商了？！非也，非也，我们继续往下分析，这个程序有什么问题，你想呀电梯门可以打开，但不是随时都可以开，是有前提条件的的，你不可能电梯在运行的时候突然开门吧？！电梯也不会出现停止了但是不开门的情况吧？！那要是有也是事故嘛，再仔细想想，电梯的这四个动作的执行都是有前置条件，具体点说说在特定状态下才能做特定事，那我们来分析一下电梯有什么那些特定状态：</p><p>​    门敞状态—按了电梯上下按钮，电梯门开，这中间有5 秒的时间（当然你也可以用身体挡住电梯门，那就不是5 秒了），那就是门敞状态；在这个状态下电梯只能做的动作是关门动作，做别的动作？那就危险喽</p><p>​    门闭状态—电梯门关闭了，在这个状态下，可以进行的动作是：开门（我不想坐电梯了）、停止（忘记按路层号了）、运行</p><p>​       运行状态—电梯正在跑，上下窜，在这个状态下，电梯只能做的是停止；</p><p>​    停止状态—电梯停止不动，在这个状态下，电梯有两个可选动作：继续运行和开门动作；</p><p>​    我们用一张表来表示电梯状态和动作之间的关系：  </p><table><thead><tr><th></th><th>开门(open)</th><th>关门(close)</th><th>运行(run)</th><th>停止(stop)</th></tr></thead><tbody><tr><td>门敞状态</td><td>○</td><td>☆</td><td>○</td><td>○</td></tr><tr><td>门闭状态</td><td>☆</td><td>○</td><td>☆</td><td>☆</td></tr><tr><td>运行状态</td><td>○</td><td>○</td><td>○</td><td>☆</td></tr><tr><td>停止状态</td><td>☆</td><td>○</td><td>☆</td><td>○</td></tr></tbody></table><p>​    电梯状态和动作对应表（○表示不允许，☆表示允许动作）</p><p>​    看到这张表后，我们才发觉，哦~~，我们的程序做的很不严谨，好，我们来修改一下，先看类图：</p><p><img src="\image\java设计模式\状态模式-电梯示例-类图2.png" alt="状态模式-电梯示例-类图2"></p><pre><code>增加了状态的类图</code></pre><p>​    在接口中定义了四个常量，分别表示电梯的四个状态：门敞状态、关闭状态、运行状态、停止状态，然后在实现类中电梯的每一次动作发生都要对状态进行判断，判断是否运行执行，也就是动作的执行是否符合业务逻辑，实现类中的四个私有方法是仅仅实现电梯的动作，没有任何的前置条件，因此这四个方法是不能为外部类调用的，设置为私有方法。我们先看接口的改变：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common2;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 定义一个电梯的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯的四个状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> OPENING_STATE = <span class="number">1</span>; <span class="comment">//门敞状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CLOSING_STATE = <span class="number">2</span>; <span class="comment">//门闭状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RUNNING_STATE = <span class="number">3</span>; <span class="comment">//运行状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> STOPPING_STATE = <span class="number">4</span>; <span class="comment">//停止状态；</span></span><br><span class="line">    <span class="comment">//设置电梯的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br><span class="line">    <span class="comment">//首先电梯门开启动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯门有开启，那当然也就有关闭了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯要能上能下，跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯还要能停下来，停不下来那就扯淡了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>增加了四个静态常量，增加了一个方法setState，设置电梯的状态。我们再来看实现类是如何实现的：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common2;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 电梯的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lift</span> <span class="keyword">implements</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//电梯在什么状态下才能关闭</span></span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.state)&#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//如果是则可以关门，同时修改电梯状态</span></span><br><span class="line">            <span class="keyword">this</span>.closeWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(CLOSING_STATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE: <span class="comment">//如果电梯就是关门状态，则什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE: <span class="comment">//如果是正在运行，门本来就是关闭的，也说明都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE: <span class="comment">//如果是停止状态，本也是关闭的，什么也不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门开启</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//电梯在什么状态才能开启</span></span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.state)&#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//如果已经在门敞状态，则什么都不做</span></span><br><span class="line">           <span class="comment">//do nothing;</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则可以开启</span></span><br><span class="line">           <span class="keyword">this</span>.openWithoutLogic();</span><br><span class="line">           <span class="keyword">this</span>.setState(OPENING_STATE);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> RUNNING_STATE: <span class="comment">//正在运行状态，则不能开门，什么都不做</span></span><br><span class="line">           <span class="comment">//do nothing;</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> STOPPING_STATE: <span class="comment">//停止状态，淡然要开门了</span></span><br><span class="line">           <span class="keyword">this</span>.openWithoutLogic();</span><br><span class="line">           <span class="keyword">this</span>.setState(OPENING_STATE);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯开始跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.state)&#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//如果已经在门敞状态，则不你能运行，什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则可以运行</span></span><br><span class="line">            <span class="keyword">this</span>.runWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(RUNNING_STATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE: <span class="comment">//正在运行状态，则什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE: <span class="comment">//停止状态，可以运行</span></span><br><span class="line">            <span class="keyword">this</span>.runWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(RUNNING_STATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.state)&#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//如果已经在门敞状态，那肯定要先停下来的，什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则当然可以停止了</span></span><br><span class="line">            <span class="keyword">this</span>.stopWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(CLOSING_STATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE: <span class="comment">//正在运行状态，有运行当然那也就有停止了</span></span><br><span class="line">            <span class="keyword">this</span>.stopWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(CLOSING_STATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE: <span class="comment">//停止状态，什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纯粹的电梯关门，不考虑实际的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeWithoutLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门关闭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纯粹的店门开，不考虑任何条件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openWithoutLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门开启..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纯粹的运行，不考虑其他条件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWithoutLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯上下跑起来..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单纯的停止，不考虑其他条件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopWithoutLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    程序有点长，但是还是很简单的，就是在每一个接口定义的方法中使用witch…case 来进行判断，是否运行运行指定的动作。我们来看Client 程序的变更：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common2;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 模拟电梯的动作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILift lift = <span class="keyword">new</span> Lift();</span><br><span class="line">        <span class="comment">//电梯的初始条件应该是停止状态</span></span><br><span class="line">        lift.setState(ILift.STOPPING_STATE);</span><br><span class="line">        <span class="comment">//首先是电梯门开启，人进去</span></span><br><span class="line">        lift.open();</span><br><span class="line">        <span class="comment">//然后电梯门关闭</span></span><br><span class="line">        lift.close();</span><br><span class="line">        <span class="comment">//再然后，电梯跑起来，向上或者向下</span></span><br><span class="line">        lift.run();</span><br><span class="line">        <span class="comment">//最后到达目的地，电梯挺下来</span></span><br><span class="line">        lift.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    业务调用的方法中增加了电梯状态判断，电梯要开门不是随时都可以开的，必须满足了一定条件你才能开门，人才能走进去，我们设置电梯的起始是停止状态，看运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电梯门开启...</span><br><span class="line">电梯门关闭...</span><br><span class="line">电梯上下跑起来...</span><br><span class="line">电梯停止了...</span><br></pre></td></tr></table></figure></p><pre><code>我们来想一下，这段程序有什么问题，首先Lift.java 这个文件有点长，长的原因是我们在程序中使用了大量的switch…case 这样的判断（if…else 也是一样），程序中只要你有这样的判断就避免不了加长程序，同步的在业务比较复杂的情况下，程序体会更长，这个就不是一个很好的习惯了，较长的方法或者类的维护性比较差，毕竟程序是给人来阅读的；其次，扩展性非常的不好，大家来想想，电梯还有两个状态没有加，是什么？通电状态和断电状态，你要是在程序再增加这两个方法，你看看Open()、Close()、Run()、Stop()这四个方法都要增加判断条件，也就是说switch 判断体中还要增加case 项，也就说与开闭原则相违背了；再其次，我们来思考我们的业务，电梯在门敞开状态下就不能上下跑了吗？电梯有没有发生过只有运行没有停止状态呢（从40 层直接坠到1 层嘛）？电梯故障嘛，还有电梯在检修的时候，可以在stop状态下不开门，这也是正常的业务需求呀，你想想看，如果加上这些判断条件，上面的程序有多少需要修改？虽然这些都是电梯的业务逻辑，但是一个类有且仅有一个原因引起类的变化，单一职责原则，看看我们的类，业务上的任务一个小小增加或改动都对我们的这个电梯类产生了修改，这是在项目开发上是有很大风险的。既然我们已经发现程序上有以上问题，我们怎么来修改呢？</code></pre><p>​    刚刚我们是从电梯的有哪些方法以及这些方法执行的条件去分析，现在我们换个角度来看问题，我们来想电梯在具有这些状态的时候，能够做什么事情，也就是说在电梯处于一个具体状态时，我们来思考这个状态是由什么动作触发而产生以及在这个状态下电梯还能做什么事情，举个例子来说，电梯在停止状态时，我们来思考两个问题：</p><pre><code>第一、这个停止状态时怎么来的，那当然是由于电梯执行了stop 方法而来的；</code></pre><p>​        第二、在停止状态下，电梯还能做什么动作?继续运行？开门？那当然都可以了。</p><p>​    我们再来分析其他三个状态，也都是一样的结果，我们只要实现电梯在一个状态下的两个任务模型就可以了：这个状态是如何产生的以及在这个状态下还能做什么其他动作（也就是这个状态怎么过渡到其他状态），既然我们以状态为参考模型，那我们就先定义电梯的状态接口，思考过后我们来看类图：</p><p><img src="\image\java设计模式\状态模式-以状态作为导向的类图.png" alt="状态模式-以状态作为导向的类图"></p><p>​                            以状态作为导向的类图</p><p>​    在类图中，定义了一个LiftState 抽象类，声明了一个受保护的类型Context 变量，这个是串联我们各个状态的封装类，封装的目的很明显，就是电梯对象内部状态的变化不被调用类知晓，也就是迪米特法则了，我的类内部情节你知道越少越好，并且还定义了四个具体的实现类，承担的是状态的产生以及状态间的转换过渡，我们先来看LiftState 程序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 定义一个电梯的接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftState</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个环境角色，也就是封装状态的变换引起的功能变化</span></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context _context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = _context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首先电梯门开启动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯门有开启，那当然也就有关闭了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯要能上能下，跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯还要能停下来，停不下来那就扯淡了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>  抽象类比较简单，我们来先看一个具体的实现，门敞状态的实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cbf4life.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 在电梯门开启的状态下能做什么事情</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">  <span class="comment">//开启当然可以关闭了，我就想测试一下电梯门开关功能</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//状态修改</span></span><br><span class="line">  <span class="keyword">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">  <span class="comment">//动作委托为CloseState来执行</span></span><br><span class="line">  <span class="keyword">super</span>.context.getLiftState().close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//打开电梯门</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"电梯门开启..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//门开着电梯就想跑，这电梯，吓死你！</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//do nothing;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开门还不停止？</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//do nothing;</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>​    我来解释一下这个类的几个方法，Openning 状态是由open()方法产生的，因此这个方法中有一个具体的业务逻辑，我们是用print 来代替了；在Openning 状态下，电梯能过渡到其他什么状态呢？按照现在的定义的是只能过渡到Closing 状态，因此我们在Close()中定义了状态变更，同时把Close 这个动作也委托了给CloseState 类下的Close 方法执行，这个可能不好理解，我们再看看Context 类就可能好理解一点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义出所有的电梯状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> OpenningState openningState = <span class="keyword">new</span> OpenningState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ClosingState closeingState = <span class="keyword">new</span> ClosingState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> RunningState runningState = <span class="keyword">new</span> RunningState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> StoppingState stoppingState = <span class="keyword">new</span> StoppingState();</span><br><span class="line">    <span class="comment">//定一个当前电梯状态</span></span><br><span class="line">    <span class="keyword">private</span> LiftState liftState;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiftState <span class="title">getLiftState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> liftState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLiftState</span><span class="params">(LiftState liftState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState = liftState;</span><br><span class="line">        <span class="comment">//把当前的环境通知到各个实现类中</span></span><br><span class="line">        <span class="keyword">this</span>.liftState.setContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>​    结合以上三个类，我们可以这样理解，Context 是一个环境角色，它的作用是串联各个状态的过渡，在LiftSate 抽象类中我们定义了并把这个环境角色聚合进来，并传递到了子类，也就是四个具体的实现类中自己根据环境来决定如何进行状态的过渡。我们把其他的三个具体实现类阅读完毕，下面是关闭状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 电梯门关闭以后，电梯可以做哪些事情</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯门关闭，这是关闭状态要实现的动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门关闭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门关了再打开，逗你玩呢，那这个允许呀</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.openningState); <span class="comment">//置为门敞状态</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门关了就跑，这是再正常不过了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.runningState); <span class="comment">//设置为运行状态；</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门关着，我就不按楼层</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.stoppingState); <span class="comment">//设置为停止状态；</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><pre><code>下面是电梯的运行状态：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 电梯在运行状态下能做哪些动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯门关闭？这是肯定了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//运行的时候开电梯门？你疯了！电梯不会给你开的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是在运行状态下要实现的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯上下跑..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.stoppingState); <span class="comment">//环境设置为停止状态；</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    下面是停止状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 在停止状态下能做什么事情</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoppingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停止状态关门？电梯门本来就是关着的！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//停止状态，开门，那是要的！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//停止状态再跑起来，正常的很</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//停止状态是怎么发生的呢？当然是停止方法执行了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>  业务逻辑都已经实现了，我们来看看Client 怎么实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 模拟电梯的动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setLiftState(<span class="keyword">new</span> ClosingState());</span><br><span class="line">        context.open();</span><br><span class="line">        context.close();</span><br><span class="line">        context.run();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>​    Client 调用类太简单了，只要定义个电梯的初始状态，然后调用相关的方法，就完成了，完全不用考虑状态的变更，看运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电梯门开启...</span><br><span class="line">电梯门关闭...</span><br><span class="line">电梯上下跑起来...</span><br><span class="line">电梯停止了...</span><br></pre></td></tr></table></figure></p><p>​    我们再来回顾一下我们刚刚批判上一段的代码，首先我们说人家代码太长，这个问题我们解决了，通过各个子类来实现，每个子类的代码都很短，而且也取消了的switch…case 条件的判断；其次，说人家不符合开闭原则，那如果在我们这个例子中要增加两个状态怎么加？增加两个子类，一个是通电状态，一个是断电状态，同时修改其他实现类的相应方法，因为状态要过渡呀，那当然要修改原有的类，只是在原有类中的方法上增加，而不去做修改；再其次，我们说人家不符合迪米特法则，我们现在呢是各个状态是单独的一个类，只有与这个状态的有关的因素修改了这个类才修改，符合迪米特法则，非常完美!</p><p><strong>优缺点</strong></p><p>​    状态模式既然有优点，那当然有缺点了，只有一个缺点，子类会太多，也就是类膨胀，你想一个事物有七八、十来个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目自己衡量。其实有很大方式解决这个状态问题，比如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。状态模式使用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说行为是受状态约束的情况下可以使用状态模式，而且状态模式使用时对象的状态最好不要超过五个，防止你写子类写疯掉。</p><p><strong>拓展</strong></p><p>​    上面的例子可能比较复杂，请各位看官耐心的看，看完我想肯定有所收获。我翻遍了所有能找的到的资料（至少也有十几本，其中有几本原文的书还是很的很不错的，我举这个电梯的例子也是从《Design  Pattern for Dummies》这本书来激发出来的），基本（基本哦，还是有几本讲的不错）上没有一本把这个状态模式讲透彻的，我不敢说我就讲的透彻，大家都只讲了一个状态到另一个状态过渡，状态间的过渡是固定的，举个简单的例子：</p><p><img src="\image\java设计模式\状态模式-状态过度固定-示意图.png" alt="状态模式-状态过度固定-示意图"></p><pre><code>这个状态图是很多书上都有的，状态A 只能变更到状态B，状态B 再变更到状态C，例子举的最多的就是TCP 监听的例子，TCP 有三个状态：等待，连接，断开，然后这三个状态中按照顺序循环变更，按照这个状态变更来讲解状态模式，我认为是不太合适的，为什么呢？你在项目中太少看到一个状态只能过渡到另一个状态情形，项目中遇到的大多数情况都是一个状态可以转换为几种状态，如下图：</code></pre><p><img src="\image\java设计模式\状态模式-状态过度不固定-示意图.png" alt="状态模式-状态过度不固定-示意图"></p><pre><code>状态B 可以转换为状态C 也可以转换为状态D，而状态D 呢也可以转换为状态A 或状态B，这在项目分析过程中有一个叫状态图可以完整的展示这种蜘蛛网结构，举个实际例子来说，一些收费网站的用户就有很多状态，比如普通用户，普通会员，VIP 会员，白金级用户等等，这个状态的变更你不允许跳跃？！这不可能，所以我在例子中就举了一个比较复杂的应用，基本上可以实现状态间自由切换，这才是最经常用到的状态模式。然后我再提问个问题，状态间的自由切换，那会有很多种呀，你要一个一个的牢记一遍吗？比如上面那个电梯的例子，我要一个正常的电梯运行逻辑，规则是开门-&gt;关门-&gt;运行-&gt;停止；还要一个紧急状态（比如火灾）下的运行逻辑，关门-&gt;停止，紧急状态电梯当然不能用了；再要一个维修状态下的运行逻辑，这个状态任何情况都可以，开着门电梯运行？可以！门来回开关？可以！永久停止不动？可以！ 那这怎么实现呢？需要我们把已经有的几种状态按照一定的顺序再重新组装一下，那这个是什么模式？什么模式？大声点！建造者模式！对，建造模式+状态模式会起到非常好的封装作用。</code></pre><p>​         再往深里面扯几句，应该有部分读者做过工作流开发，如果不是土制框架的话，就应该有个状态机管理（即使是土制框架也应该有），比如一个Activity（节点）有初始化状态（Initialized State）、挂起状态（Suspended State）、完成状态（Completed State）等等，流程实例也是有这么多状态，那这些状态怎么管理呢？通过状态机(State Machine)来管理，那状态机是个什么东西呢？就是我们上面提到的Context类的升级变态BOSS！</p><p><strong>总结</strong></p><p>​    状态模式主要是对对象涉及的内部状态进行封装，使得状态对象来负责与状态相关的动作和状态变化。这样，客户端就不需要再来关心状态与行为的影响，以及状态变化的细节。</p><p>​    在状态模式中，状态在不停的变换，行为也在不停的变化，并且状态还会影响到行为。但是，状态和行为之间的影响关系不会变化，状态对象的封装，使得状态与行为之间的影响关系固定，并且向客户端隐藏状态过渡细节。</p><p>参考资料： <a href="http://blog.csdn.net/SEU_Calvin/article/details/52779282" target="_blank" rel="noopener">设计模式——状态模式详解</a></p><p>​            <a href="http://blog.csdn.net/u012401711/article/details/52675873" target="_blank" rel="noopener">Java设计模式——状态模式（STATE PATTERN）</a></p><h2 id="访问者模式-Vistor"><a href="#访问者模式-Vistor" class="headerlink" title="访问者模式(Vistor)"></a>访问者模式(Vistor)</h2><p><strong>定义</strong></p><p>​    表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提<br>下定义作用于这些元素的新操作。</p><p>​    可以对定义这么理解：有这么一个操作，它是作用于一些元素之上的，而这些元素属于某一个对象结构。同时这个操作是在不改变各元素类的前提下，在这个前提下定义新操作是访问者模式精髓中的精髓。 </p><p><strong>问题</strong></p><p>​    在一些数据结构上，会频繁的执行一些操作，并且这个操作是变化的，可能会增加新的操作。</p><p><strong>方案</strong></p><p>​    将操作与数据结构进行分离，将操作封装成独立的对象。这样，及时操作改变了，或者增加新的操作时，都不会影响到数据结构。</p><p><strong>使用场景</strong></p><p>​    （1）数据结构稳定，作用于数据结构的操作经常变化的时候。</p><p>​    （2）需要对一个对象结构中的对象进行很多不同的且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</p><p>​     （3）有时在对数据结构上的元素进行操作的时候，需要区分具体的类型，这时使用访问者模式可以针对不同的类型，在访问者类中定义不同的操作，从而去除掉类型判断。</p><p><strong>结构</strong></p><p>​    访问者模式的结构示意图为：</p><p><img src="\image\java设计模式\访问者模式结构示意图.png" alt="访问者模式结构示意图"></p><p>​    结构图补充：在ElementA和ElementB中的accept(Vistor)    方法中会调用vistor的方法对元素进行访问。</p><p>​    访问者模式涉及的角色：</p><p>​    （1）Visitor：接口或者抽象类，它定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法数理论上来讲与元素个数是一样的，因此，访问者模式要求元素的类族要稳定，如果经常添加、移除元素类，必然会导致频繁地修改Visitor接口，如果这样则不适合使用访问者模式。</p><p>​    （2）ConcreteVisitor1、ConcreteVisitor2：具体的访问类，它需要给出对每一个元素类访问时所产生的具体行为。</p><p>​    （3）Element：元素接口或者抽象类，它定义了一个接受访问者的方法（Accept），其意义是指每一个元素都要可以被访问者访问。</p><p>​    （4）ConcreteElementA、ConcreteElementB：具体的元素类，它提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</p><p>​    （5）ObjectStructure：定义当中所说的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素供访问者访问。</p><p><strong>实际例子</strong></p><p>​    我们都知道财务都是有账本的，这个账本就可以作为一个对象结构，而它其中的元素有两种，收入和支出，这满足我们访问者模式的要求，即元素的个数是稳定的，因为账本中的元素只能是收入和支出。</p><p>​    而查看账本的人可能有这样几种，比如老板，会计事务所的注会，财务主管，等等。而这些人在看账本的时候显然目的和行为是不同的。</p><p>​    首先我们给出单子的接口，它只有一个方法accept。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个单子的接口（相当于Element）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bill</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer viewer)</span></span>;<span class="comment">//相当于接受一个访问者</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    其中的方法参数AccountBookViewer是一个账本访问者接口，接下来也就是实现类，收入单子和消费单子，或者说收入和支出类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费的单子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeBill</span> <span class="keyword">implements</span> <span class="title">Bill</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumeBill</span><span class="params">(<span class="keyword">double</span> amount, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer viewer)</span> </span>&#123;</span><br><span class="line">        viewer.view(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收入单子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncomeBill</span> <span class="keyword">implements</span> <span class="title">Bill</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncomeBill</span><span class="params">(<span class="keyword">double</span> amount, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer viewer)</span> </span>&#123;</span><br><span class="line">        viewer.view(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面最关键的还是里面的accept方法，它直接让访问者访问自己，这相当于一次静态分派（文章最后进行解释），当然我们也可以不使用重载而直接给方法不同的名称。</p><p>​    接下来是账本访问者接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//账单查看者接口（相当于Visitor）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountBookViewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看消费的单子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill bill)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看收入的单子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill bill)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个方法是重载方法，就是在上面的元素类当中用到的，当然你也可以按照访问者模式类图当中的方式去做，将两个方法分别命名为viewConsumeBill和viewIncomeBill，而一般建议按照类图上来做的</p><p>访问者的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老板类，查看账本的类之一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">AccountBookViewer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalIncome;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalConsume;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//老板只关注一共花了多少钱以及一共收入多少钱，其余并不关心</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill bill)</span> </span>&#123;</span><br><span class="line">        totalConsume += bill.getAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill bill)</span> </span>&#123;</span><br><span class="line">        totalIncome += bill.getAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalIncome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老板查看一共收入多少，数目是："</span> + totalIncome);</span><br><span class="line">        <span class="keyword">return</span> totalIncome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalConsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老板查看一共花费多少，数目是："</span> + totalConsume);</span><br><span class="line">        <span class="keyword">return</span> totalConsume;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册会计师类，查看账本的类之一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPA</span> <span class="keyword">implements</span> <span class="title">AccountBookViewer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注会在看账本时，如果是支出，则如果支出是工资，则需要看应该交的税交了没</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill bill)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bill.getItem().equals(<span class="string">"工资"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"注会查看工资是否交个人所得税。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是收入，则所有的收入都要交税</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill bill)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"注会查看收入交税了没。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    老板只关心收入和支出的总额，而注会只关注该交税的是否交税</p><p>​    接下来是账本类，它是当前访问者模式例子中的对象结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//账本类（相当于ObjectStruture）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountBook</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单子列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Bill&gt; billList = <span class="keyword">new</span> ArrayList&lt;Bill&gt;();</span><br><span class="line">    <span class="comment">//添加单子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBill</span><span class="params">(Bill bill)</span></span>&#123;</span><br><span class="line">        billList.add(bill);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//供账本的查看者查看账本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(AccountBookViewer viewer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Bill bill : billList) &#123;</span><br><span class="line">            bill.accept(viewer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    账本类当中有一个列表，这个列表是元素（Bill）的集合，这便是对象结构的通常表示，它一般会是一堆元素的集合，不过这个集合不一定是列表，也可能是树，链表等等任何数据结构，甚至是若干个数据结构。其中show方法，就是账本类的精髓，它会枚举每一个元素，让访问者访问。</p><p>​    测试客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AccountBook accountBook = <span class="keyword">new</span> AccountBook();</span><br><span class="line">        <span class="comment">//添加两条收入</span></span><br><span class="line">        accountBook.addBill(<span class="keyword">new</span> IncomeBill(<span class="number">10000</span>, <span class="string">"卖商品"</span>));</span><br><span class="line">        accountBook.addBill(<span class="keyword">new</span> IncomeBill(<span class="number">12000</span>, <span class="string">"卖广告位"</span>));</span><br><span class="line">        <span class="comment">//添加两条支出</span></span><br><span class="line">        accountBook.addBill(<span class="keyword">new</span> ConsumeBill(<span class="number">1000</span>, <span class="string">"工资"</span>));</span><br><span class="line">        accountBook.addBill(<span class="keyword">new</span> ConsumeBill(<span class="number">2000</span>, <span class="string">"材料费"</span>));</span><br><span class="line">    </span><br><span class="line">        AccountBookViewer boss = <span class="keyword">new</span> Boss();</span><br><span class="line">        AccountBookViewer cpa = <span class="keyword">new</span> CPA();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//两个访问者分别访问账本</span></span><br><span class="line">        accountBook.show(cpa);</span><br><span class="line">        accountBook.show(boss);</span><br><span class="line">    </span><br><span class="line">        ((Boss) boss).getTotalConsume();</span><br><span class="line">        ((Boss) boss).getTotalIncome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    上面的代码中，可以这么理解，账本以及账本中的元素是非常稳定的，这些几乎不可能改变，而最容易改变的就是访问者这部分。</p><p>​    访问者模式最大的优点就是增加访问者非常容易，我们从代码上来看，如果要增加一个访问者，你只需要做一件事即可，那就是写一个类，实现AccountBookViewer接口，然后就可以直接调用AccountBook的show方法去访问账本了。</p><p>​    如果没使用访问者模式，一定会增加许多if else，而且每增加一个访问者，你都需要改你的if else，代码会显得非常臃肿，而且非常难以扩展和维护。</p><p><strong>静态分派以及动态分派</strong></p><p>​    变量被声明时的类型叫做变量的静态类型(Static Type)，有些人又把静态类型叫做明显类型(Apparent Type)；而变量所引用的对象的真实类型又叫做变量的实际类型(Actual Type)。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">null</span>;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure></p><p>​    声明了一个变量list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。静态分派(Static Dispatch)发生在编译时期，分派根据静态类型信息发生。</p><p><strong>静态分派</strong> </p><p>​    静态分派就是按照变量的静态类型进行分派，从而确定方法的执行版本，静态分派在编译时期就可以确定方法的版本。而静态分派最典型的应用就是方法重载.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"string"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Integer integer)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"integer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">"1"</span>;</span><br><span class="line">        Integer integer = <span class="number">1</span>;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.test(integer);</span><br><span class="line">        main.test(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    在静态分派判断的时候，我们根据多个判断依据（即参数类型和个数）判断出了方法的版本，那么这个就是多分派的概念，因为我们有一个以上的考量标准，也可以称为宗量。所以JAVA是静态多分派的语言。</p><p><strong>动态分派</strong><br>​    对于动态分派，与静态相反，它不是在编译期确定的方法版本，而是在运行时才能确定。而动态分派最典型的应用就是多态的特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"男人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"女人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person man = <span class="keyword">new</span> Man();</span><br><span class="line">        Person woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.test();</span><br><span class="line">        woman.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    这段程序输出结果为依次打印男人和女人，然而这里的test方法版本，就无法根据man和woman的静态类型去判断了，他们的静态类型都是Person接口，根本无从判断。</p><p>​    显然，产生的输出结果，就是因为test方法的版本是在运行时判断的，这就是动态分派。</p><p>​    动态分派判断的方法是在运行时获取到man和woman的实际引用类型，再确定方法的版本，而由于此时判断的依据只是实际引用类型，只有一个判断依据，所以这就是单分派的概念，这时我们的考量标准只有一个宗量，即变量的实际引用类型。相应的，这说明JAVA是动态单分派的语言。</p><p><strong>访问者模式中的伪动态双分派</strong></p><p>​    访问者模式中使用的是伪动态双分派，所谓的动态双分派就是在运行时依据两个实际类型去判断一个方法的运行行为，而访问者模式实现的手段是进行了两次动态单分派来达到这个效果。</p><p>​    回到上面例子当中账本类中的accept方法</p><p>​    for (Bill bill : billList) {<br>​            bill.accept(viewer);<br>​        }</p><p>​    这里就是依据biil和viewer两个实际类型决定了view方法的版本，从而决定了accept方法的动作。</p><p>​    分析accept方法的调用过程<br>​    1.当调用accept方法时，根据bill的实际类型决定是调用ConsumeBill还是IncomeBill的accept方法。</p><p>​    2.这时accept方法的版本已经确定，假如是ConsumeBill，它的accept方法是调用下面这行代码。</p><p>public void accept(AccountBookViewer viewer) {<br>​        viewer.view(this);<br> }</p><p>​    此时的this是ConsumeBill类型，所以对应于AccountBookViewer接口的view(ConsumeBill bill)方法，此时需要再根据viewer的实际类型确定view方法的版本，如此一来，就完成了动态双分派的过程。</p><p>​    以上的过程就是通过两次动态双分派，第一次对accept方法进行动态分派，第二次对view（类图中的visit方法）方法进行动态分派，从而达到了根据两个实际类型确定一个方法的行为的效果。</p><p>​    而原本我们的做法，通常是传入一个接口，直接使用该接口的方法，此为动态单分派，就像策略模式一样。在这里，show方法传入的viewer接口并不是直接调用自己的view方法，而是通过bill的实际类型先动态分派一次，然后在分派后确定的方法版本里再进行自己的动态分派。</p><p>​    注意：这里确定view(ConsumeBill bill)方法是静态分派决定的，所以这个并不在此次动态双分派的范畴内，而且静态分派是在编译期就完成的，所以view(ConsumeBill bill)方法的静态分派与访问者模式的动态双分派并没有任何关系。动态双分派说到底还是动态分派，是在运行时发生的，它与静态分派有着本质上的区别，不可以说一次动态分派加一次静态分派就是动态双分派，而且访问者模式的双分派本身也是另有所指。</p><p>​    这里的this的类型不是动态确定的，你写在哪个类当中，它的静态类型就是哪个类，这是在编译期就确定的，不确定的是它的实际类型，请各位区分开这一点。</p><p><strong>优缺点</strong></p><p>​    优点：</p><p>​    1、使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。</p><p>​    2、添加新的操作或者说访问者会非常容易。</p><p>​    3、将对各个元素的一组操作集中在一个访问者类当中。</p><p>​    缺点：</p><p>​    1、增加新的元素会非常困难。</p><p>​    2、实现起来比较复杂，会增加系统的复杂性。</p><p>​    3、破坏封装，如果将访问行为放在各个元素中，则可以不暴露元素的内部结构和状态，但使用访问者模式的时候，为了让访问者能获取到所关心的信息，元素类不得不暴露出一些内部的状态和结构，就像收入和支出类必须提供访问金额和单子的项目的方法一样。点：</p><p><strong>总结</strong></p><p>​    访问者模式，主要是在数据结构不变的情况下，方便访问数据的操作改变或者增加。其实就是将稳定不变的数据结构与变化的数据访问操作分离开来，并将数据访问操作进行抽象和封装，使得可以很容易的增加数据访问操作。</p><p>参考资料：<a href="http://blog.csdn.net/u012124438/article/details/70537203" target="_blank" rel="noopener">设计模式学习之访问者模式</a></p><p>​           <a href="http://blog.csdn.net/sidihuo/article/details/54892215" target="_blank" rel="noopener">java设计模式-访问者模式visit</a></p><p>​           <a href="http://blog.csdn.net/jason0539/article/details/45146271" target="_blank" rel="noopener">Java设计模式之访问者模式</a></p><h2 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式(Mediator)"></a>中介者模式(Mediator)</h2><p><strong>定义</strong></p><p>​    用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 </p><p>​    ①中介者模式主要<strong>用来将同事类之间网状结构变为星状结构</strong>，使同事类之间的关系变的清晰一些。</p><p>　　②所有对象只跟中介者对象进行通信，相互之间不再有联系，这样也能够<strong>集中控制这些对象的交互关系</strong>。</p><p><strong>问题背景</strong></p><pre><code>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</code></pre><p><img src="\image\java设计模式\中介者模式-问题背景1.jpg" alt="中介者模式-问题背景1"></p><p><img src="\image\java设计模式\中介者模式-问题背景2.jpg" alt="中介者模式-问题背景2"></p><p>​    如果引入中介者模式，那么同事类之间的关系将变为星型结构，从图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p><p><img src="\image\java设计模式\中介者模式-问题背景3.jpg" alt="中介者模式-问题背景3"></p><p><strong>结构</strong></p><p>​    中介者模式的结构如下所示：</p><p><img src="\image\java设计模式\中介者模式的结构.png" alt="中介者模式的结构"></p><p>​    ①Mediator： 中介者接口。在里面<strong>定义各个同事之间交互需要的方法</strong>，可以是公共的通信方法，比如<strong>changed方法</strong>，大家都可以用（一般会传入同事类的this指针），也可以是小范围的交互方法。</p><p>　　②ConcreteMediator：具体中介者实现对象。这需要<strong>了解并维扩各个同事对象</strong>，并负具体的协调各同事对象的交互关系。</p><p>　　③Colleague：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。同事类的定义，通常实现为抽象类，主要负责约束同事对象的类型，并能实现一些具体同事类之间的公共功能。同时，<strong>一般会持有中介者的引用</strong>。在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。在中介者模式中，同事类之间必须通过中介者才能进行消息传递</p><p>　　④ConcreteColleague：具体的同事类，实现自己的业务，在需要与其他同事通信的时候，就与持有的中介者通信，中介者会负责与其他的同事交互。</p><p><strong>实际例子</strong></p><pre><code>我们使用一个例子来说明一下什么是同事类：有两个类A和B，类中各有一个数字，并且要保证类B中的数字永远是类A中数字的100倍。也就是说，当修改类A的数时，将这个数字乘以100赋给类B，而修改类B时，要将数除以100赋给类A。类A类B互相影响，就称为同事类。代码如下：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractColleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象方法，修改数字时同时修改关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">coll.setNumber(number*<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueB</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">coll.setNumber(number/<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">AbstractColleague collA = <span class="keyword">new</span> ColleagueA();</span><br><span class="line">AbstractColleague collB = <span class="keyword">new</span> ColleagueB();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"==========设置A影响B=========="</span>);</span><br><span class="line">collA.setNumber(<span class="number">1288</span>, collB);</span><br><span class="line">System.out.println(<span class="string">"collA的number值："</span>+collA.getNumber());</span><br><span class="line">System.out.println(<span class="string">"collB的number值："</span>+collB.getNumber());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"==========设置B影响A=========="</span>);</span><br><span class="line">collB.setNumber(<span class="number">87635</span>, collA);</span><br><span class="line">System.out.println(<span class="string">"collB的number值："</span>+collB.getNumber());</span><br><span class="line">System.out.println(<span class="string">"collA的number值："</span>+collA.getNumber());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面的代码中，类A类B通过直接的关联发生关系，假如我们要使用中介者模式，类A类B之间则不可以直接关联，他们之间必须要通过一个中介者来达到关联的目的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractColleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意这里的参数不再是同事类，而是一个中介者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">am.AaffectB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueB</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number = number;</span><br><span class="line">am.BaffectA();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMediator</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> AbstractColleague A;</span><br><span class="line"><span class="keyword">protected</span> AbstractColleague B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractMediator</span><span class="params">(AbstractColleague a, AbstractColleague b)</span> </span>&#123;</span><br><span class="line">A = a;</span><br><span class="line">B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">AaffectB</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BaffectA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> <span class="keyword">extends</span> <span class="title">AbstractMediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">(AbstractColleague a, AbstractColleague b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理A对B的影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AaffectB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> number = A.getNumber();</span><br><span class="line">B.setNumber(number*<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理B对A的影响</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BaffectA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> number = B.getNumber();</span><br><span class="line">A.setNumber(number/<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">AbstractColleague collA = <span class="keyword">new</span> ColleagueA();</span><br><span class="line">AbstractColleague collB = <span class="keyword">new</span> ColleagueB();</span><br><span class="line"></span><br><span class="line">AbstractMediator am = <span class="keyword">new</span> Mediator(collA, collB);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"==========通过设置A影响B=========="</span>);</span><br><span class="line">collA.setNumber(<span class="number">1000</span>, am);</span><br><span class="line">System.out.println(<span class="string">"collA的number值为："</span>+collA.getNumber());</span><br><span class="line">System.out.println(<span class="string">"collB的number值为A的10倍："</span>+collB.getNumber());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"==========通过设置B影响A=========="</span>);</span><br><span class="line">collB.setNumber(<span class="number">1000</span>, am);</span><br><span class="line">System.out.println(<span class="string">"collB的number值为："</span>+collB.getNumber());</span><br><span class="line">System.out.println(<span class="string">"collA的number值为B的0.1倍："</span>+collA.getNumber());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    虽然代码比较长，但是还是比较容易理解的，其实就是把原来处理对象关系的代码重新封装到一个中介类中，通过这个中介类来处理对象间的关系。</p><p><strong>优缺点</strong></p><p>​    中介者模式优点：   </p><ul><li>适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。</li><li>使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。</li><li>使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。</li></ul><p>​    缺点：</p><ul><li>潜在的过度集中化。如果同事对象的交互非常多，而且比较复杂。当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，难于管理和维护。</li><li>由于“中介“承担了较多的责任，所以一旦这个中介对象出现了问题，那么整个系统就会受到重大的影响。</li></ul><p><strong>适用场景</strong></p><p>​    在面向对象编程中，一个类必然会与其他的类发生依赖关系，完全独立的类是没有意义的。一个类同时依赖多个类的情况也相当普遍，既然存在这样的情况，说明，一对多的依赖关系有它的合理性，适当的使用中介者模式可以使原本凌乱的对象关系清晰，但是如果滥用，则可能会带来反的效果。一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。</p><p><strong>总结</strong></p><p>​    中介者模式可以将同事类之间的复杂交互关系抽离出来形成单独类。同事类之间如果交互过多，则一个同事类发生改变，那么将牵扯到很多的同事类。引入中介者类后，一个同事类的改变只会影响到自身和中介者。</p><p>参考资料：<a href="http://www.cnblogs.com/5iedu/p/5618826.html" target="_blank" rel="noopener">第19章 行为型模式—中介者模式</a></p><p>​           <a href="http://blog.csdn.net/zhengzhb/article/details/7430098" target="_blank" rel="noopener">23种设计模式（7）：中介者模式</a></p><pre><code>[Java 设计模式之中介者模式](http://blog.csdn.net/jason0539/article/details/45216585)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式补充-23种设计模式&quot;&gt;&lt;a href=&quot;#设计模式补充-23种设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式补充-23种设计模式&quot;&gt;&lt;/a&gt;设计模式补充-23种设计模式&lt;/h1&gt;&lt;h2 id=&quot;设计模式补充&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Java高级知识" scheme="http://yoursite.com/categories/Java%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/Java%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象思想</title>
    <link href="http://yoursite.com/2018/03/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2018/03/29/面向对象思想/</id>
    <published>2018-03-29T01:38:21.000Z</published>
    <updated>2018-07-04T12:08:33.332Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一设计原则">一、设计原则</a><ul><li><a href="#solid">S.O.L.I.D</a></li><li><a href="#其他常见原则">其他常见原则</a></li></ul></li><li><a href="#二三大特性">二、三大特性</a><ul><li><a href="#封装">封装</a></li><li><a href="#继承">继承</a></li><li><a href="#多态">多态</a></li></ul></li><li><a href="#三类图">三、类图</a><ul><li><a href="#泛化关系-generalization">泛化关系 (Generalization)</a></li><li><a href="#实现关系-realization">实现关系 (Realization)</a></li><li><a href="#聚合关系-aggregation">聚合关系 (Aggregation)</a></li><li><a href="#组合关系-composition">组合关系 (Composition)</a></li><li><a href="#关联关系-association">关联关系 (Association)</a></li><li><a href="#依赖关系-dependency">依赖关系 (Dependency)</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、设计原则"><a href="#一、设计原则" class="headerlink" title="一、设计原则"></a>一、设计原则</h1><h2 id="S-O-L-I-D"><a href="#S-O-L-I-D" class="headerlink" title="S.O.L.I.D"></a>S.O.L.I.D</h2><table><thead><tr><th style="text-align:center">简写</th><th style="text-align:center">全拼</th><th style="text-align:center">中文翻译</th></tr></thead><tbody><tr><td style="text-align:center">SRP</td><td style="text-align:center">The Single Responsibility Principle</td><td style="text-align:center">单一责任原则</td></tr><tr><td style="text-align:center">OCP</td><td style="text-align:center">The Open Closed Principle</td><td style="text-align:center">开放封闭原则</td></tr><tr><td style="text-align:center">LSP</td><td style="text-align:center">The Liskov Substitution Principle</td><td style="text-align:center">里氏替换原则</td></tr><tr><td style="text-align:center">ISP</td><td style="text-align:center">The Interface Segregation Principle</td><td style="text-align:center">接口分离原则</td></tr><tr><td style="text-align:center">DIP</td><td style="text-align:center">The Dependency Inversion Principle</td><td style="text-align:center">依赖倒置原则</td></tr></tbody></table><h3 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1. 单一责任原则"></a>1. 单一责任原则</h3><blockquote><p>修改一个类的原因应该只有一个。</p></blockquote><p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><blockquote><p>类应该对扩展开放，对修改关闭。</p></blockquote><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h3><blockquote><p>子类对象必须能够替换掉所有父类对象。</p></blockquote><p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h3 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="4. 接口分离原则"></a>4. 接口分离原则</h3><blockquote><p>不应该强迫客户依赖于它们不用的方法。</p></blockquote><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h3><blockquote><p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li></ul><h2 id="其他常见原则"><a href="#其他常见原则" class="headerlink" title="其他常见原则"></a>其他常见原则</h2><p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p><table><thead><tr><th style="text-align:center">简写</th><th style="text-align:center">全拼</th><th style="text-align:center">中文翻译</th></tr></thead><tbody><tr><td style="text-align:center">LOD</td><td style="text-align:center">The Law of Demeter</td><td style="text-align:center">迪米特法则</td></tr><tr><td style="text-align:center">CRP</td><td style="text-align:center">The Composite Reuse Principle</td><td style="text-align:center">合成复用原则</td></tr><tr><td style="text-align:center">CCP</td><td style="text-align:center">The Common Closure Principle</td><td style="text-align:center">共同封闭原则</td></tr><tr><td style="text-align:center">SAP</td><td style="text-align:center">The Stable Abstractions Principle</td><td style="text-align:center">稳定抽象原则</td></tr><tr><td style="text-align:center">SDP</td><td style="text-align:center">The Stable Dependencies Principle</td><td style="text-align:center">稳定依赖原则</td></tr></tbody></table><h3 id="1-迪米特法则"><a href="#1-迪米特法则" class="headerlink" title="1. 迪米特法则"></a>1. 迪米特法则</h3><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p><h3 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h3><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><h3 id="3-共同封闭原则"><a href="#3-共同封闭原则" class="headerlink" title="3. 共同封闭原则"></a>3. 共同封闭原则</h3><p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p><h3 id="4-稳定抽象原则"><a href="#4-稳定抽象原则" class="headerlink" title="4. 稳定抽象原则"></a>4. 稳定抽象原则</h3><p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p><h3 id="5-稳定依赖原则"><a href="#5-稳定依赖原则" class="headerlink" title="5. 稳定依赖原则"></a>5. 稳定依赖原则</h3><p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p><h1 id="二、三大特性"><a href="#二、三大特性" class="headerlink" title="二、三大特性"></a>二、三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p><p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">"man"</span> : <span class="string">"woman"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" is working very hard!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">" can't work any more!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承实现了  <strong>IS-A</strong>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <strong>向上转型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态和运行时多态。编译时多态主要指方法的重载，运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定。</p><p>运行时多态有三个条件：</p><ol><li>继承</li><li>覆盖</li><li>向上转型</li></ol><p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instument is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Percussion is playing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Wind());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> Percussion());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、类图"><a href="#三、类图" class="headerlink" title="三、类图"></a>三、类图</h1><h2 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h2><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p><p><div align="center"> <img src="/image/pics//5341d726-ffde-4d2a-a000-46597bcc9c5a.png"> </div><br></p><h2 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h2><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p><p><div align="center"> <img src="/image/pics//123bdf81-1ef5-48a9-a08c-2db97057b4d2.png"> </div><br></p><h2 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h2><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><p><div align="center"> <img src="/image/pics//1be8b4b0-cc7a-44d7-9c77-85be37b76f7d.png"> </div><br></p><h2 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h2><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><p><div align="center"> <img src="/image/pics//eb4a7007-d437-4740-865d-672973effe25.png"> </div><br></p><h2 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 (Association)"></a>关联关系 (Association)</h2><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><p><div align="center"> <img src="/image/pics//518f16f2-a9f7-499a-98e1-f1dbb37b5a9a.png"> </div><br></p><h2 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 (Dependency)"></a>依赖关系 (Dependency)</h2><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p><ol><li>A 类是 B 类中的（某中方法的）局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ol><p><div align="center"> <img src="/image/pics//c7d4956c-9988-4a10-a704-28fdae7f3d28.png"> </div><br></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Java 编程思想</li><li>敏捷软件开发：原则、模式与实践</li><li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" target="_blank" rel="noopener">面向对象设计的 SOLID 原则</a></li><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization" target="_blank" rel="noopener">看懂 UML 类图和时序图</a></li><li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html" target="_blank" rel="noopener">UML 系列——时序图（顺序图）sequence diagram</a></li><li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015" target="_blank" rel="noopener">面向对象编程三大特性 —— 封装、继承、多态</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一设计原则&quot;&gt;一、设计原则&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#solid&quot;&gt;S.O.L.I.D&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#其他常见原则&quot;&gt;其他常见原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="编程基础知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="编程思想" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="http://yoursite.com/2018/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
    <id>http://yoursite.com/2018/03/24/数据库/SQL/</id>
    <published>2018-03-24T03:25:26.000Z</published>
    <updated>2018-07-04T15:01:34.862Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一基础">一、基础</a></li><li><a href="#二创建表">二、创建表</a></li><li><a href="#三修改表">三、修改表</a></li><li><a href="#四插入">四、插入</a></li><li><a href="#五更新">五、更新</a></li><li><a href="#六删除">六、删除</a></li><li><a href="#七查询">七、查询</a></li><li><a href="#八排序">八、排序</a></li><li><a href="#九过滤">九、过滤</a></li><li><a href="#十通配符">十、通配符</a></li><li><a href="#十一计算字段">十一、计算字段</a></li><li><a href="#十二函数">十二、函数</a></li><li><a href="#十三分组">十三、分组</a></li><li><a href="#十四子查询">十四、子查询</a></li><li><a href="#十五连接">十五、连接</a></li><li><a href="#十六组合查询">十六、组合查询</a></li><li><a href="#十七视图">十七、视图</a></li><li><a href="#十八存储过程">十八、存储过程</a></li><li><a href="#十九游标">十九、游标</a></li><li><a href="#二十触发器">二十、触发器</a></li><li><a href="#二十一事务处理">二十一、事务处理</a></li><li><a href="#二十二字符集">二十二、字符集</a></li><li><a href="#二十三权限管理">二十三、权限管理</a></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>SQL 支持以下三种注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure><p>数据库创建与使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><h1 id="二、创建表"><a href="#二、创建表" class="headerlink" title="二、创建表"></a>二、创建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h1 id="三、修改表"><a href="#三、修改表" class="headerlink" title="三、修改表"></a>三、修改表</h1><p>添加列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h1><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure><p>插入检索出来的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure><p>将一个表的内容插入到一个新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="五、更新"><a href="#五、更新" class="headerlink" title="五、更新"></a>五、更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">col</span> = val</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="六、删除"><a href="#六、删除" class="headerlink" title="六、删除"></a>六、删除</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>TRUNCATE TABLE</strong>  可以清空表，也就是删除所有行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h1 id="七、查询"><a href="#七、查询" class="headerlink" title="七、查询"></a>七、查询</h1><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回第 3 ~ 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><ul><li><strong>ASC</strong> ：升序（默认）</li><li><strong>DESC</strong> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h1 id="九、过滤"><a href="#九、过滤" class="headerlink" title="九、过滤"></a>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>=</code> <code>&lt;</code> <code>&gt;</code></td><td>等于 小于 大于</td></tr><tr><td><code>&lt;&gt;</code> <code>!=</code></td><td>不等于</td></tr><tr><td><code>&lt;=</code> <code>!&gt;</code></td><td>小于等于</td></tr><tr><td><code>&gt;=</code> <code>!&lt;</code></td><td>大于等于</td></tr><tr><td><code>BETWEEN</code></td><td>在两个值之间</td></tr><tr><td><code>IS NULL</code></td><td>为 NULL 值</td></tr></tbody></table><p>应该注意到，NULL 与 0、空字符串都不同。</p><p><strong>AND 和 OR</strong>  用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong>  操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong>  操作符用于否定一个条件。</p><h1 id="十、通配符"><a href="#十、通配符" class="headerlink" title="十、通配符"></a>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><p><strong>%</strong>  匹配 &gt;=0 个任意字符；</p></li><li><p><strong>_</strong>  匹配 ==1 个任意字符；</p></li><li><p><strong>[ ]</strong>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p></li></ul><p>使用 Like 来进行通配符匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">LIKE</span> <span class="string">'[^AB]%'</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h1 id="十一、计算字段"><a href="#十一、计算字段" class="headerlink" title="十一、计算字段"></a>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用  <strong>AS</strong>  来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 * col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><p><strong>CONCAT()</strong>  用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">'('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="十二、函数"><a href="#十二、函数" class="headerlink" title="十二、函数"></a>十二、函数</h1><p>各个 DBMS 的函数都是不相同的，因此不可移植。</p><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>LEFT()</code> <code>RIGHT()</code></td><td style="text-align:center">左边或者右边的字符</td></tr><tr><td style="text-align:center"><code>LOWER()</code> <code>UPPER()</code></td><td style="text-align:center">转换为小写或者大写</td></tr><tr><td style="text-align:center"><code>LTRIM()</code> <code>RTIM()</code></td><td style="text-align:center">去除左边或者右边的空格</td></tr><tr><td style="text-align:center"><code>LENGTH()</code></td><td style="text-align:center">长度</td></tr><tr><td style="text-align:center"><code>SOUNDEX()</code></td><td style="text-align:center">转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong>  可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)</span><br></pre></td></tr></table></figure><h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center"><code>AddDate()</code></td><td style="text-align:center">增加一个日期（天、周等）</td></tr><tr><td style="text-align:center"><code>AddTime()</code></td><td style="text-align:center">增加一个时间（时、分等）</td></tr><tr><td style="text-align:center"><code>CurDate()</code></td><td style="text-align:center">返回当前日期</td></tr><tr><td style="text-align:center"><code>CurTime()</code></td><td style="text-align:center">返回当前时间</td></tr><tr><td style="text-align:center"><code>Date()</code></td><td style="text-align:center">返回日期时间的日期部分</td></tr><tr><td style="text-align:center"><code>DateDiff()</code></td><td style="text-align:center">计算两个日期之差</td></tr><tr><td style="text-align:center"><code>Date_Add()</code></td><td style="text-align:center">高度灵活的日期运算函数</td></tr><tr><td style="text-align:center"><code>Date_Format()</code></td><td style="text-align:center">返回一个格式化的日期或时间串</td></tr><tr><td style="text-align:center"><code>Day()</code></td><td style="text-align:center">返回一个日期的天数部分</td></tr><tr><td style="text-align:center"><code>DayOfWeek()</code></td><td style="text-align:center">对于一个日期，返回对应的星期几</td></tr><tr><td style="text-align:center"><code>Hour()</code></td><td style="text-align:center">返回一个时间的小时部分</td></tr><tr><td style="text-align:center"><code>Minute()</code></td><td style="text-align:center">返回一个时间的分钟部分</td></tr><tr><td style="text-align:center"><code>Month()</code></td><td style="text-align:center">返回一个日期的月份部分</td></tr><tr><td style="text-align:center"><code>Now()</code></td><td style="text-align:center">返回当前日期和时间</td></tr><tr><td style="text-align:center"><code>Second()</code></td><td style="text-align:center">返回一个时间的秒部分</td></tr><tr><td style="text-align:center"><code>Time()</code></td><td style="text-align:center">返回一个日期时间的时间部分</td></tr><tr><td style="text-align:center"><code>Year()</code></td><td style="text-align:center">返回一个日期的年份部分</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-4-14 20:25:11</span><br></pre></td></tr></table></figure><h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>SIN()</code></td><td style="text-align:center">正弦</td></tr><tr><td style="text-align:center"><code>COS()</code></td><td style="text-align:center">余弦</td></tr><tr><td style="text-align:center"><code>TAN()</code></td><td style="text-align:center">正切</td></tr><tr><td style="text-align:center"><code>ABS()</code></td><td style="text-align:center">绝对值</td></tr><tr><td style="text-align:center"><code>SQRT()</code></td><td style="text-align:center">平方根</td></tr><tr><td style="text-align:center"><code>MOD()</code></td><td style="text-align:center">余数</td></tr><tr><td style="text-align:center"><code>EXP()</code></td><td style="text-align:center">指数</td></tr><tr><td style="text-align:center"><code>PI()</code></td><td style="text-align:center">圆周率</td></tr><tr><td style="text-align:center"><code>RAND()</code></td><td style="text-align:center">随机数</td></tr></tbody></table><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center"><code>AVG()</code></td><td style="text-align:center">返回某列的平均值</td></tr><tr><td style="text-align:center"><code>COUNT()</code></td><td style="text-align:center">返回某列的行数</td></tr><tr><td style="text-align:center"><code>MAX()</code></td><td style="text-align:center">返回某列的最大值</td></tr><tr><td style="text-align:center"><code>MIN()</code></td><td style="text-align:center">返回某列的最小值</td></tr><tr><td style="text-align:center"><code>SUM()</code></td><td style="text-align:center">返回某列值之和</td></tr></tbody></table><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br></pre></td></tr></table></figure><h1 id="十三、分组"><a href="#十三、分组" class="headerlink" title="十三、分组"></a>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分组规定：</p><ol><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ol><h1 id="十四、子查询"><a href="#十四、子查询" class="headerlink" title="十四、子查询"></a>十四、子查询</h1><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h1 id="十五、连接"><a href="#十五、连接" class="headerlink" title="十五、连接"></a>十五、连接</h1><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a, b, c</span><br><span class="line"><span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a, b, c</span><br><span class="line"><span class="keyword">FROM</span> A, B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>在没有条件语句的情况下返回笛卡尔积。</p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department = (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure><p>自连接版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1, employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure><p>连接一般比子查询的效率高。</p><h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> department;</span><br></pre></td></tr></table></figure><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure><p>如果需要统计顾客的订单数，使用聚集函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id,</span><br><span class="line">       <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br></pre></td></tr></table></figure><h1 id="十六、组合查询"><a href="#十六、组合查询" class="headerlink" title="十六、组合查询"></a>十六、组合查询</h1><p>使用  <strong>UNION</strong>  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="十七、视图"><a href="#十七、视图" class="headerlink" title="十七、视图"></a>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ol><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h1 id="十八、存储过程"><a href="#十八、存储过程" class="headerlink" title="十八、存储过程"></a>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理；</p><p>使用存储过程的好处</p><ol><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ol><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="built_in">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="built_in">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y*y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(@ret);</span><br><span class="line"><span class="keyword">select</span> @ret;</span><br></pre></td></tr></table></figure><h1 id="十九、游标"><a href="#十九、游标" class="headerlink" title="十九、游标"></a>十九、游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="built_in">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span><br><span class="line">        <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">'02000'</span> <span class="keyword">set</span> done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        open mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            fetch mycursor into ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line"></span><br><span class="line">        close mycursor;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure><h1 id="二十、触发器"><a href="#二十、触发器" class="headerlink" title="二十、触发器"></a>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化。</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> @<span class="keyword">result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。</p><p>可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p><p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p><h1 id="二十一、事务处理"><a href="#二十一、事务处理" class="headerlink" title="二十一、事务处理"></a>二十一、事务处理</h1><p>基本术语：</p><ol><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ol><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 autocommit 为 0 可以取消自动提交，直到 autocommit 被设置为 1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure><h1 id="二十二、字符集"><a href="#二十二、字符集" class="headerlink" title="二十二、字符集"></a>二十二、字符集</h1><p>基本术语：</p><ol><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ol><p>除了给表指定字符集和校对外，也可以给列指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(<span class="keyword">col</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><p>可以在排序、分组时指定校对：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">col</span> <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure><h1 id="二十三、权限管理"><a href="#二十三、权限管理" class="headerlink" title="二十三、权限管理"></a>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>创建账户</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypassword'</span>;</span><br></pre></td></tr></table></figure><p>新创建的账户没有任何权限。</p><p><strong>修改账户名</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure><p><strong>删除账户</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>查看权限</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>授予权限</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><p><strong>删除权限</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p><strong>更改密码</strong> </p><p>必须使用 Password() 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser = <span class="keyword">Password</span>(<span class="string">'new_password'</span>);</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一基础&quot;&gt;一、基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二创建表&quot;&gt;二、创建表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三修改表&quot;&gt;三、修改表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="编程基础知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>JAVA学习</title>
    <link href="http://yoursite.com/2018/03/05/1_Java%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/03/05/1_Java学习/</id>
    <published>2018-03-05T03:05:11.000Z</published>
    <updated>2018-07-04T01:09:27.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA学习"><a href="#JAVA学习" class="headerlink" title="JAVA学习"></a><center>JAVA学习<center></center></center></h1><h2 id="Java常用知识"><a href="#Java常用知识" class="headerlink" title="Java常用知识"></a>Java常用知识</h2><h3 id="一、数组的三种创建方式及区别"><a href="#一、数组的三种创建方式及区别" class="headerlink" title="一、数组的三种创建方式及区别"></a>一、数组的三种创建方式及区别</h3><p>​    创建数组的三种方式：其实分为2类,一种是静态的创建，如方式一。一种是动态的创建，只不过根据写法的不同分为方式二和方式三：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.方式一  声明 分配空间并赋值</span></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 2.方式二 显示初始化</span></span><br><span class="line"><span class="keyword">int</span>[] arr2;</span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// 3.方式三 显示初始化()</span></span><br><span class="line"><span class="keyword">int</span>[] arr3;</span><br><span class="line">arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    他们的区别，方式一：在声明的时候直接就已经分配空间，并赋值，方式一是不能写成如下这种形式的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1;</span><br><span class="line">arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//错误写法 编译不同过</span></span><br></pre></td></tr></table></figure></p><p>​    方式二和方式三,声明和内存分配是分开的，如上面的例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr2;  和  <span class="keyword">int</span>[] arr3;</span><br></pre></td></tr></table></figure></p><p>​    这一步是在栈空间分配一个引用，存放的是一个引用，null<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr3 = new int[3];&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>​    到这一步的时候jvm才开始在内存堆区域分配空间，并赋值，方式二直接赋值 1,2,3  方式三 默认初始化，基本类型是 0  布尔类型是 false 引用类型为null，<br>    <strong>注意</strong>：内存一旦分配不能改变，所有说数组长度固定</p><h3 id="二、Integer执行-操作解析"><a href="#二、Integer执行-操作解析" class="headerlink" title="二、Integer执行++操作解析"></a>二、Integer执行++操作解析</h3><p>​    当我们对基本类型int的包装类进行自增操作，返回的值不是原来的对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qianqiang;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    Integer inttest=<span class="keyword">new</span> Integer(<span class="number">15</span>);  </span><br><span class="line">    Integer inttest2=inttest++;  </span><br><span class="line">    System.out.println(inttest==inttest2);  </span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    答案输出的是false，这是因为Integer执行自加操作的时候，是要进行拆箱操作即调用Integer的intValue返回基本类型数据，执行完自增以后，再调用Integer的装箱操作即调用valueOf重新创建对象。当然如果值的范围是在（-128-127）之间调用Integer已经缓存的对象，上面的代码中返回inttest2返回15的Integer缓存的对象。而此时的inttest因为值自增了1，变为16，所以要调用装箱操作，返回Integer中的已经缓存的16对应的Integer对象。</p><h3 id="三、Java-与-C-的区别"><a href="#三、Java-与-C-的区别" class="headerlink" title="三、Java 与 C++ 的区别"></a>三、Java 与 C++ 的区别</h3><p>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</p><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>Java does not support pointers, templates, unions, operator overloading, structures etc. The Java language promoters initially said “No pointers!”, but when many programmers questioned how you can work without pointers, the promoters began saying “Restricted pointers.” Java supports what it calls “references”. References act a lot like pointers in C++ languages but you cannot perform arithmetic on pointers in Java. References have types, and they’re type-safe. These references cannot be interpreted as raw address and unsafe conversion is not allowed.</td><td>C++ supports structures, unions, templates, operator overloading, pointers and pointer arithmetic.</td></tr><tr><td>Java support automatic garbage collection. It does not support destructors as C++ does.</td><td>C++ support destructors, which is automatically invoked when the object is destroyed.</td></tr><tr><td>Java does not support conditional compilation and inclusion.</td><td>Conditional inclusion (#ifdef #ifndef type) is one of the main features of C++.</td></tr><tr><td>Java has built in support for threads. In Java, there is a <code>Thread</code> class that you inherit to create a new thread and override the <code>run()</code> method.</td><td>C++ has no built in support for threads. C++ relies on non-standard third-party libraries for thread support.</td></tr><tr><td>Java does not support default arguments. There is no scope resolution operator (::) in Java. The method definitions must always occur within a class, so there is no need for scope resolution there either.</td><td>C++ supports default arguments. C++ has scope resolution operator (::) which is used to to define a method outside a class and to access a global variable within from the scope where a local variable also exists with the same name.</td></tr><tr><td>There is no <em>goto</em> statement in Java. The keywords <code>const</code> and <code>goto</code> are reserved, even though they are not used.</td><td>C++ has <em>goto</em> statement. However, it is not considered good practice to use of <em>goto</em> statement.</td></tr><tr><td>Java doesn’t provide multiple inheritance, at least not in the same sense that C++ does.</td><td>C++ does support multiple inheritance. The keyword <code>virtual</code> is used to resolve ambiguities during multiple inheritance if there is any.</td></tr><tr><td>Exception handling in Java is different because there are no destructors. Also, in Java, try/catch must be defined if the function declares that it may throw an exception.</td><td>While in C++, you may not include the try/catch even if the function throws an exception.</td></tr><tr><td>Java has method overloading, but no operator overloading. The <code>String</code> class does use the <code>+</code> and <code>+=</code> operators to concatenate strings and <code>String</code>expressions use automatic type conversion, but that’s a special built-in case.</td><td>C++ supports both method overloading and operator overloading.</td></tr><tr><td>Java has built-in support for documentation comments (<code>/** ... */</code>); therefore, Java source files can contain their own documentation, which is read by a separate tool usually <code>javadoc</code> and reformatted into HTML. This helps keeping documentation maintained in easy way.</td><td>C++ does not support documentation comments.</td></tr><tr><td>Java is interpreted for the most part and hence platform independent.</td><td>C++ generates object code and the same code may not run on different platforms.</td></tr></tbody></table><blockquote><p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php" target="_blank" rel="noopener">What are the main differences between Java and C++?</a></p></blockquote><h3 id="四、方法中的局部变量不会初始化"><a href="#四、方法中的局部变量不会初始化" class="headerlink" title="四、方法中的局部变量不会初始化"></a>四、方法中的局部变量不会初始化</h3><p>​    类变量、实例变量，如果不对他们进行显示的初始化，编译器会给他们赋值默认的初始值。但是对于方法体重局部变量，如果不进行显示的初始化操作，那么编译器也不会给它默认值，并且会编译报错。</p><p><img src="\image\JAVA学习\局部变量不初始化-编译器报错.png" alt="局部变量不初始化-编译器报错"></p><p>​     可以看到，在idea开发环境中，直接就报错了。</p><h2 id="Java语言三大特性"><a href="#Java语言三大特性" class="headerlink" title="Java语言三大特性"></a>Java语言三大特性</h2><p>Java语言的三大特性即是：封装、继承、多态</p><h2 id="Java基础知识总结"><a href="#Java基础知识总结" class="headerlink" title="Java基础知识总结"></a>Java基础知识总结</h2><p>转载地址:<a href="http://www.cnblogs.com/BYRans/p/Java.html" target="_blank" rel="noopener">http://www.cnblogs.com/BYRans/p/Java.html</a></p><h3 id="一：java概述"><a href="#一：java概述" class="headerlink" title="一：java概述"></a>一：java概述</h3><h4 id="1，JDK：Java-Development-Kit"><a href="#1，JDK：Java-Development-Kit" class="headerlink" title="1，JDK：Java Development Kit"></a>1，JDK：Java Development Kit</h4><p>java的开发和运行环境，java的开发工具和jre。</p><h4 id="2，JRE：Java-Runtime-Environment"><a href="#2，JRE：Java-Runtime-Environment" class="headerlink" title="2，JRE：Java Runtime Environment"></a>2，JRE：Java Runtime Environment</h4><p>java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。</p><h4 id="3，配置环境变量"><a href="#3，配置环境变量" class="headerlink" title="3，配置环境变量:"></a>3，配置环境变量:</h4><p>让java jdk\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。</p><h5 id="环境变量的配置："><a href="#环境变量的配置：" class="headerlink" title="环境变量的配置："></a>环境变量的配置：</h5><p> 1）：永久配置方式：</p><pre><code>JAVA_HOME=%安装路径%\Java\jdkpath=%JAVA_HOME%\bin</code></pre><p> 2）：临时配置方式：</p><pre><code>set path=%path%;C:\Program Files\Java\jdk\bin</code></pre><p>特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。</p><h5 id="classpath的配置"><a href="#classpath的配置" class="headerlink" title="classpath的配置:"></a>classpath的配置:</h5><p>1）：永久配置方式：classpath=.;c:\;e:\</p><p>2）：临时配置方式：set classpath=.;c:\;e:\</p><p>注意：在定义classpath环境变量时，需要注意的情况，如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件；</p><p>如果指定了classpath，那么会在指定的目录下查找要运行的类文件。<br>还会在当前目录找吗？两种情况：</p><p>注意classpath环境变量前面的那个小点”.”，这个点就代表当前目录，如果有这个点的话，就会先在当前目录下查找要运行的类，如果没有的话，那么就不会在当前目录下找。 </p><h5 id="CLASSPATH是什么？它的作用是什么？"><a href="#CLASSPATH是什么？它的作用是什么？" class="headerlink" title="CLASSPATH是什么？它的作用是什么？"></a>CLASSPATH是什么？它的作用是什么？</h5><p>它是javac编译器的一个环境变量。它的作用与import、package关键字有关。当你写下improt java.util.*时，编译器面对import关键字时，就知道你要引入java.util这个package中的类；但是编译器如何知道你把这个package放在哪里了呢？所以你首先得告诉编译器这个package的所在位置；如何告诉它呢？就是设置CLASSPATH啦 :) </p><p>如果java.util这个package在c:/jdk/ 目录下，你得把c:/jdk/这个路径设置到CLASSPATH中去！当编译器面对import java.util.*这个语句时，它先会查找CLASSPATH所指定的目录，并检视子目录java/util是否存在，然后找出名称吻合的已编译文件（.class文件）。如果没有找到就会报错！</p><p>CLASSPATH有点像c/c++编译器中的INCLUDE路径的设置哦，是不是？当c/c++编译器遇到include 这样的语句，它是如何运作的？哦，其实道理都差不多！搜索INCLUDE路径，检视文件！当你自己开发一个package时，然后想要用这个package中的类；自然，你也得把这个package所在的目录设置到CLASSPATH中去！</p><p>CLASSPATH的设定，对JAVA的初学者而言是一件棘手的事。所以Sun让JAVA2的JDK更聪明一些。你会发现，在你安装之后，即使完全没有设定CLASSPATH，你仍然能够编译基本的JAVA程序，并且加以执行。 </p><h5 id="PATH环境变量"><a href="#PATH环境变量" class="headerlink" title="PATH环境变量"></a>PATH环境变量</h5><p>PATH环境变量。作用是指定命令搜索路径，在命令行下面执行命令如javac编译java程序时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序。我们需要把jdk安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件如javac/java/javadoc等待，设置好PATH变量后，就可以在任何目录下执行javac/java等工具了。</p><h4 id="4，javac命令和java命令做什么事情呢？"><a href="#4，javac命令和java命令做什么事情呢？" class="headerlink" title="4，javac命令和java命令做什么事情呢？"></a>4，javac命令和java命令做什么事情呢？</h4><p>要知道java是分两部分的：一个是编译，一个是运行。 </p><p><strong>javac：</strong>负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。</p><p><strong>java：</strong>负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.</p><p>一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数. </p><h3 id="二：java语法基础"><a href="#二：java语法基础" class="headerlink" title="二：java语法基础"></a>二：java语法基础</h3><h4 id="1-标示符："><a href="#1-标示符：" class="headerlink" title="1. 标示符："></a>1. 标示符：</h4><p>1），数字不可以开头。</p><p>2），不可以使用关键字。</p><h4 id="2-变量的作用域和生存期"><a href="#2-变量的作用域和生存期" class="headerlink" title="2. 变量的作用域和生存期:"></a>2. 变量的作用域和生存期:</h4><p>变量的作用域：<br>作用域从变量定义的位置开始，到该变量所在的那对大括号结束；</p><p>生命周期：<br>变量从定义的位置开始就在内存中活了；<br>变量到达它所在的作用域的时候就在内存中消失了； </p><h4 id="3-数据类型："><a href="#3-数据类型：" class="headerlink" title="3. 数据类型："></a>3. 数据类型：</h4><h5 id="1）基本数据类型："><a href="#1）基本数据类型：" class="headerlink" title="1）基本数据类型："></a>1）基本数据类型：</h5><p>byte、short、int、long、float、double、char、boolean</p><table><thead><tr><th style="text-align:center">简单类型</th><th style="text-align:center">boolean</th><th style="text-align:center">byte</th><th style="text-align:center">char</th><th style="text-align:center">short</th><th style="text-align:center">int</th><th style="text-align:center">long</th><th style="text-align:center">float</th><th style="text-align:center">double</th><th style="text-align:center">void</th></tr></thead><tbody><tr><td style="text-align:center">二进制位数</td><td style="text-align:center">1</td><td style="text-align:center">8</td><td style="text-align:center">16</td><td style="text-align:center">16</td><td style="text-align:center">32</td><td style="text-align:center">64</td><td style="text-align:center">32</td><td style="text-align:center">64</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">封装器类</td><td style="text-align:center">Boolean</td><td style="text-align:center">Byte</td><td style="text-align:center">Character</td><td style="text-align:center">Short</td><td style="text-align:center">Integer</td><td style="text-align:center">Long</td><td style="text-align:center">Float</td><td style="text-align:center">Double</td><td style="text-align:center">Void</td></tr></tbody></table><h4 id="4-运算符号："><a href="#4-运算符号：" class="headerlink" title="4.  运算符号："></a>4.  运算符号：</h4><h5 id="1-逻辑运算符。"><a href="#1-逻辑运算符。" class="headerlink" title="1). 逻辑运算符。"></a>1). 逻辑运算符。</h5><p>&amp; | ^ ! &amp;&amp; ||</p><p>逻辑运算符除了 ! 外都是用于连接两个boolean类型表达式。</p><p>&amp;: 只有两边都为true结果是true。否则就是false。</p><p>|:只要两边都为false结果是false，否则就是true</p><p>^:异或：和或有点不一样。两边结果一样，就为false。两边结果不一样，就为true.</p><p> &amp; 和 &amp;&amp;区别： &amp; ：无论左边结果是什么，右边都参与运算。 &amp;&amp;:短路与，如果左边为false，那么右边不参与运算。</p><p>| 和|| 区别：|：两边都运算。||：短路或，如果左边为true，那么右边不参</p><h5 id="2-位运算符-用于操作二进制位的运算符。"><a href="#2-位运算符-用于操作二进制位的运算符。" class="headerlink" title="2). 位运算符:用于操作二进制位的运算符。"></a>2). 位运算符:用于操作二进制位的运算符。</h5><p> &amp; | ^</p><p> &lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移)</p><p>练习：对两个变量的数据进行互换。不需要第三方变量。</p><p>int a = 3,b = 5;–&gt;b = 3,a = 5;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">方法一：        </span><br><span class="line"></span><br><span class="line">a = a + b; a = 8;</span><br><span class="line"></span><br><span class="line">b = a - b; b = 3;</span><br><span class="line"></span><br><span class="line">a = a - b; a = 5;</span><br><span class="line"></span><br><span class="line">方法二： </span><br><span class="line"></span><br><span class="line">a = a ^ b;// </span><br><span class="line"></span><br><span class="line">b = a ^ b;//b = a ^ b ^ b = a</span><br><span class="line"></span><br><span class="line">a = a ^ b;//a = a ^ b ^ a = b;</span><br><span class="line"></span><br><span class="line">练习：高效的算出 2*8 = 2&lt;&lt;3;</span><br></pre></td></tr></table></figure><h4 id="5-重载与重写"><a href="#5-重载与重写" class="headerlink" title="5. 重载与重写"></a>5. 重载与重写</h4><font color="red"><strong>重载</strong></font>的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。<br><br><strong>如何区分重载：</strong>当函数同名时，只看参数列表。和返回值类型没关系。<br><br><font color="red"><strong>重写</strong></font>：父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。<br><br>#### 6. Java内存管理<br><br><strong>Java内存管理：深入Java内存区域</strong><br><br>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。<br><br>##### 1） 概述：<br>对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的”所有权”，又担负着每一个对象生命开始到终结的维护责任。<br><br>对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。<br><br>##### 2)  运行时数据区域<br><br>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：<br><br><img src="\image\JAVA学习\java内存管理示意图.jpg" alt="java内存管理示意图" title="java内存管理示意图"><br><br>##### 3)  程序计数器　　　　　<br><br>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 <font color="blue">由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为”线程私有”的内存。</font> 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。<font color="red">此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</font><h5 id="4-Java虚拟机栈"><a href="#4-Java虚拟机栈" class="headerlink" title="4)  Java虚拟机栈"></a>4)  Java虚拟机栈</h5><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）<font color="blue">用于存储局部变量表、操作栈、动态链接、方法出口</font>等信息。<font color="blue">每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</font>。</p><p>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的”堆”在后面会专门讲述，而所指的”栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><font color="blue">其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot）</font>，其余的数据类型只占用1个。<font color="blue">局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</font> 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。<br><br>##### 5)  本地方法栈<br><br>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。<br><br>##### 6)  Java堆<br><br>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<font color="blue">此内存区域的唯一目的就是存放对象实例</font>，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么”绝对”了。<br><br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做”GC堆”（Garbage Collected Heap，幸好国内没翻译成”垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的<font color="blue">分代收集算法</font>，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。<font color="blue">如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）</font>。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配和回收等细节将会是下一章的主题。<br><br>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。<br><br>##### 7)  方法区<br><br>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它<font color="blue">用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</font>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。<br><br>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为”永久代”Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并”搬家”至Native Memory来实现方法区的规划了。<br><br>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样”永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收”成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，　　曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<br><br><br>##### 8)  运行时常量池<br><br><font color="blue">运行时常量池（Runtime Constant Pool）是方法区的一部分</font>。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），<font color="blue">用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</font> Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。<br><br>#### 7.  对象访问<br><br>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：<br>　<center><strong>Object obj = new Object();</strong></center><br><br>假设这句代码出现在方法体中，那”Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而”new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。<br><br><strong>由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：</strong><font color="blue">使用句柄和直接指针。</font>  <font color="blue">如果使用</font><font color="red">句柄访问方式</font><font color="blue">，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息</font>，如下图所示：<br><br><img src="\image\JAVA学习\通过句柄访问对象.jpg" alt="通过句柄访问对象" title="通过句柄访问对象"><br><br>如果使用的是<font color="red">直接指针访问方式</font>，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：<br><br><img src="\image\JAVA学习\通过直接指针访问对象.jpg" alt="通过直接指针访问对象" title="通过直接指针访问对象"><br><br><br>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是<font color="red">reference中存储的是稳定的句柄地址</font>，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<font color="red">使用直接指针访问方式的最大好处就是速度更快</font>，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。<br><br><br>### 三：面向对象：★★★★★<br><br>#### 类<br><strong>匿名对象使用场景：</strong><br><br>1：当对方法只进行一次调用的时候，可以使用匿名对象。<br><br>2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。<br><br><br>类中怎么没有定义主函数呢？<br><br>注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。<br><br>主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。<br><br><br><strong>成员变量和局部变量的区别：</strong><br><br>1：成员变量直接定义在类中。<br><br>局部变量定义在方法中，参数上，语句中。<br><br>2：成员变量在这个类中有效。<br><br>局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。<br><br>3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。<br><br>局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。<br><br><strong>构造函数：</strong>用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。<br><br><strong>特点：</strong><br><br>1. 该函数的名称和所在类的名称相同。<br><br>2. 不需要定义返回值类型。<br><br>3. 该函数没有具体的返回值。<br><br>记住：所有对象创建时，都需要初始化才可以使用。<br><br><strong>注意事项：</strong>一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。<br><br>一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，<strong>一个类中如果出现多个构造函数。它们的存在是以重载体现的。</strong><br><br><strong>构造代码块和构造函数有什么区别？</strong><br><br>构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。<br><br>构造函数：是给与之对应的对象进行初始化。它具有针对性。<br><br><img src="\image\JAVA学习\构造代码块和构造函数.png" alt="构造代码块和构造函数" title="构造代码块和构造函数"><br><br>1. 执行顺序：（优先级从高到低。）静态代码块&gt;mian方法&gt;构造代码块&gt;构造方法。其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。<br><br>2. 静态代码块的作用：比如我们在调用C语言的动态库时会可把.so文件放在此处。<br><br>3. 构造代码块的功能：（可以把不同构造方法中相同的共性的东西写在它里面）。例如：比如不论任何机型的电脑都有开机这个功能，此时我们就可以把这个功能定义在构造代码块内。<br>  <br><br>  <br><br>  <br><br>  <br><br><br><strong>Person p = new Person();</strong><br><br><font color="red"><strong>创建一个对象都在内存中做了什么事情？</strong></font><p>1：先将硬盘上指定位置的Person.class文件加载进内存。</p><p>2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。</p><p>3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new</p><p>4：在该实体空间中进行属性的空间分配，并进行了默认初始化。</p><p>5：对空间中的属性进行显示初始化。</p><p>6：进行实体的构造代码块初始化。</p><p>7：调用该实体对应的构造函数，进行构造函数初始化。（）</p><p>8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)</p><p><br><br><br></p><font color="red"><strong>封 装（面向对象特征之一）：</strong></font>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。<br><br><strong>好处：</strong><font color="blue">将变化隔离；便于使用；提高重用性；安全性。</font><p><strong>封装原则：</strong>将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。<br><br><br><br></p><font color="red">this:</font>代表对象。就是所在函数所属对象的引用。<br><br>this到底代表什么呢？<strong>哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。</strong><br><br>开发时，什么时候使用this呢？<br><br>在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。<br><br><br><br><br><br><br>this 还可以用于构造函数间的调用。<br><br><strong>调用格式：this(实际参数)；</strong><br><br>this对象后面跟上 . 调用的是成员属性和成员方法(一般方法)；<br><br>this对象后面跟上 () 调用的是本类中的对应参数的构造函数。<br><br><font color="red">注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。</font> <font color="blue">否则编译失败。</font><font color="red">static：★★★</font> 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。<br><br>特点：<br><br>1、static变量<br>按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：<br><br>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br><br>对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。<br><br>2、静态方法<br><br>静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！<br><br>因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。<br><br>3、static代码块<br><br>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。<br><br>4、static和final一块用表示什么<br><br>static final用来修饰成员变量和成员方法，可简单理解为”全局常量”！<br><br>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br><br>对于方法，表示不可覆盖，并且可以通过类名直接访问。<br><br><br><font color="red"><strong>备注：</strong></font><p>1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。</p><p>2，<strong>静态方法只能访问静态成员，不可以访问非静态成员。</strong></p><p>(这句话是针对同一个类环境下的，比如说，一个类有多个成员（属性，方法，字段），<font color="blue">静态方法</font>A，那么可以访问同类名下其他<font color="blue">静态成员</font>，你如果访问<font color="blue">非静态成员</font>就不行)</p><p>因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。</p><p>3，<font color="red">静态方法中不能使用this，super关键字。</font></p><p>因为<font color="red">this代表对象</font>，而静态在时，有可能没有对象，所以this无法使用。</p><p>4，主函数是静态的。<br><br><br><br></p><font color="red"><strong>成员变量和静态变量的区别：</strong></font><p>1，成员变量所属于对象。所以也称为实例变量。</p><p>静态变量所属于类。所以也称为类变量。</p><p>2，成员变量存在于堆内存中。</p><p>静态变量存在于方法区中。</p><p>3，成员变量随着对象创建而存在。随着对象被回收而消失。</p><p>静态变量随着类的加载而存在。随着类的消失而消失。</p><p>4，成员变量只能被对象所调用 。</p><p>静态变量可以被对象调用，也可以被类名调用。</p><p><strong>所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</strong></p><p><br></p><font color="red">静态代码块：</font>就是一个有静态关键字标示的一个代码块区域。定义在类中。<br><br><strong>作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。</strong><br><br><br><br><font color="red">final</font><p>根据程序上下文环境，Java关键字final有”这是无法改变的”或者”终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变、设计或效率。</p><p><strong>final类不能被继承，没有子类，final类中的方法默认是final的。</strong></p><p><strong>final方法不能被子类的方法覆盖，但可以被继承。</strong></p><p><strong>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</strong></p><p><strong>final不能用于修饰构造方法。</strong></p><p>注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</p><p>1、final类</p><p>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</p><p>2、final方法</p><p>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。</p><p>使用final方法的原因有二：</p><p>第一、把方法锁定，防止任何继承类修改它的意义和实现。</p><p>第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。</p><p>3、final变量（常量）</p><p>　用final修饰的成员变量表示常量，值一旦给定就无法改变！</p><p>　final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。</p><p>　从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。</p><p>　另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p><p>4、final参数</p><p>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p><p><br><br><br></p><font color="red"><strong>生成Java帮助文档：</strong></font>命令格式：javadoc –d 文件夹名 –auther –version *.java<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/** //格式</span><br><span class="line"></span><br><span class="line">*类描述</span><br><span class="line"></span><br><span class="line">*@author 作者名</span><br><span class="line"></span><br><span class="line">*@version 版本号</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line">*方法描述</span><br><span class="line"></span><br><span class="line">*@param 参数描述</span><br><span class="line"></span><br><span class="line">*@return 返回值描述</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><br><br>#### 继 承（面向对象特征之一）<br>java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是可实现多接口。<br><br>##### 1：成员变量。<br><br>当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。<br><br>如果想要调用父类中的属性值，需要使用一个关键字：<font color="red">super</font><font color="red">This：</font>代表是本类类型的对象引用。<br><br><font color="red">Super：</font>代表是子类所属的父类中的内存空间引用。<br><br>注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。<br><br>##### 2：成员函数。<br><br>当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：<font color="red">重写</font><h5 id="3：构造函数。"><a href="#3：构造函数。" class="headerlink" title="3：构造函数。"></a>3：构造函数。</h5><p>发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?</p><p>原因：<font color="red">子类的所有构造函数中的第一行，其实都有一条隐身的语句super();</font></p><p><strong>super():</strong> 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。</p><p>为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)</p><p>因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是<strong>子类的实例化过程。</strong></p><p><br></p><font color="red">注意：</font><br><font color="blue">子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();<br><br>如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。<br><br>如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。<br></font><p><strong>问题：</strong></p><p><strong>super()和this()是否可以同时出现的构造函数中？</strong></p><p>两个语句只能有一个定义在第一行，所以只能出现其中一个。</p><p><strong>super()或者this():为什么一定要定义在第一行？</strong></p><p>因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。</p><p><strong>在方法覆盖时，注意两点：</strong></p><p>1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。（举个例子，在父类中是public的方法，如果子类中将其降低访问权限为private，那么子类中重写以后的方法对于外部对象就不可访问了，这个就破坏了继承的含义）</p><p>2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)</p><p><br><br>继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。</p><p>这时如何解决问题呢？介绍一个关键字，final。</p><p><br></p><font color="red">final特点：（详细解释见前面）</font><p>1：这个关键字是一个修饰符，可以修饰类，方法，变量。</p><p>2：被final修饰的类是一个最终类，不可以被继承。</p><p>3：被final修饰的方法是一个最终方法，不可以被覆盖。</p><p>4：被final修饰的变量是一个常量，只能赋值一次。</p><font color="red">抽象类: abstract</font><font color="red">抽象类的特点：</font><font color="blue"><br>1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。<br><br>2：抽象方法只定义方法声明，并不定义方法实现。<br><br>3：抽象类不可以被创建对象(实例化)。<br><br>4：只有通过子类继承抽象类并覆盖了抽象类中的<font color="red">所有</font>抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。<br></font><p><br></p><font color="red">抽象类的细节：</font><p><strong>1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。</strong></p><p><strong>2：抽象类中是否可以定义非抽象方法？</strong></p><p>可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。</p><p><strong>3：抽象关键字abstract和哪些不可以共存？final ,    private , static</strong></p><p><strong>4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。</strong></p><p><br><br><br></p><h5 id="接-口：★★★★★"><a href="#接-口：★★★★★" class="headerlink" title="接 口：★★★★★"></a>接 口：★★★★★</h5><p>1：是用关键字interface定义的。</p><p>2：接口中包含的成员，最常见的有全局常量、抽象方法。</p><p>注意：接口中的成员都有固定的修饰符。</p><p>&emsp;&emsp;<font color="blue">成员变量：public static final</font></p><p>&emsp;&emsp;<font color="blue">成员方法：public abstract</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Inter&#123;</span><br><span class="line"></span><br><span class="line">public static final int x = 3;</span><br><span class="line"></span><br><span class="line">public abstract void show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3：接口中有抽象方法，说明<strong>接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</strong></p><p>4：类与类之间存在着继承关系，类与接口中间存在的是<font color="blue">实现关系。</font></p><p>&emsp;&emsp;<font color="blue">继承用extends ；实现用implements ；</font></p><p>5：接口和类不一样的地方，就是，<font color="red">接口可以被多实现</font>，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。</p><p>6：一个类在继承另一个类的同时，还可以实现多个接口。所以<font color="red">接口的出现避免了单继承的局限性。</font>还可以将类进行功能的扩展。</p><p>7：其实java中是有多继承的。接口与接口之间存在着继承关系，<font color="red">接口可以多继承接口。</font></p><p>java类是单继承的。classB Extends classA</p><p>java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……</p><p>不允许类多重继承的主要原因是，如果A同时继承B和C，而b和c同时有一个D方法，A如何决定该继承那一个呢？</p><p>但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。</p><p><br></p><font color="red">抽象类与接口：</font><p><strong>抽象类：</strong>一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的<strong>基本内容。</strong></p><p><strong>接口：</strong>一般用于定义对象的<font color="red">扩展功能</font>，是在继承之外还需这个对象具备的一些功能。</p><p><br><br><strong>抽象类和接口的共性：</strong>都是不断向上抽取的结果。</p><p><br></p><font color="red">抽象类和接口的区别：</font><font color="blue"><br>1：抽象类只能被继承，而且只能单继承。<br><br>接口需要被实现，而且可以多实现。<br><br>2：抽象类中可以定义非抽象方法，子类可以直接继承使用。<br><br>接口中都是抽象方法，需要子类去实现。<br><br>3：抽象类使用的是 is a 关系。<br><br>接口使用的 like a 关系。<br><br>4：抽象类的成员修饰符可以自定义。<br></font><font color="red">接口中的成员修饰符是固定的。全都是public的。</font><p><br><br><br></p><h5 id="多-态★★★★★"><a href="#多-态★★★★★" class="headerlink" title="多 态★★★★★"></a>多 态★★★★★</h5><font color="red"><strong>多 态★★★★★（面向对象特征之一）</strong></font>：函数本身就具备多态性，某一种事物有不同的具体的体现。<br><br><font color="red">体现：</font>父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();父类可以调用子类中覆写过的（父类中有的方法）<br><br><font color="red">多态的好处：</font>提高了程序的扩展性。继承的父类或接口一般是类库中的东西，（如果要修改某个方法的具体实现方式）只有通过子类去覆写要改变的某一个方法，这样在通过将父类的应用指向子类的实例去调用覆写过的方法就行了！<br><br><font color="red">多态的弊端：</font>当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)<br><br><font color="red">多态的前提：</font><ol><li><p>必须要有关系，比如继承、或者实现。</p></li><li><p>通常会有覆盖操作。</p></li></ol><p><strong>如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？</strong></p><p>可以可以通过一个关键字 <font color="red">instanceof ;//判断对象是否实现了指定的接口或继承了指定的类</font></p><p>格式：&lt;<strong>对象 instanceof 类型</strong>&gt; ，判断一个对象是否所属于指定的类型。</p><p>Student <font color="red"> instanceof </font> Person = true;//student继承了person类</p><p><br><br>-—————————————————————————<br>-———java.lang.Object</p><font color="red"><strong>Object：</strong></font>所有类的直接或者间接父类，Java认为所有的对象都具备一些基本的共性内容，这些内容可以不断的向上抽取，最终就抽取到了一个最顶层的类中的，该类中定义的就是所有对象都具备的功能。<br><br><strong>具体方法：</strong><br><br>1. <strong>boolean equals(Object obj)</strong>：用于比较两个对象是否相等，其实内部比较的就是两个对象地址。<br>2. <strong>String toString()：将对象变成字符串</strong>；默认返回的格式：类名@哈希值 = getClass().getName() + ‘@’ + Integer.toHexString(hashCode())<br><br>  为了对象对应的字符串内容有意义，可以通过复写，建立该类对象自己特有的字符串表现形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String toString()&#123;</span><br><span class="line"></span><br><span class="line">    return &quot;person : &quot;+age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>3. <strong> Class getClass()</strong>：获取任意对象运行时的所属字节码文件对象。<br><br>4. <strong>int hashCode()</strong>：返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。将该对象的内部地址转换成一个整数来实现的。<br><br><br><br><font color="blue">通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。</font><p>-—————————————————————————</p><p><br><br><br></p><font color="red">内部类：</font>如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为<font color="red">内部类</font>。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。<br><br>-————————————————————————–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123; </span><br><span class="line"></span><br><span class="line">int num = 4;    </span><br><span class="line"></span><br><span class="line">class Inner &#123;</span><br><span class="line"></span><br><span class="line">void show()&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;inner show run &quot;+num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method()&#123;</span><br><span class="line"></span><br><span class="line">        Inner in = new Inner();//创建内部类的对象。</span><br><span class="line"></span><br><span class="line">        in.show();//调用内部类的方法。 //内部类直接访问外部类成员，用自己的实例对象；</span><br><span class="line"></span><br><span class="line">    &#125;                                        //外部类访问内部类要定义内部类的对象；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>-—————————————————————————–<br><br><strong>当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。</strong><br><br>1：默认修饰符。<br><br><font color="red">直接访问内部类格式：外部类名.内部类名 变量名 = 外部类对象.内部类对象;</font><pre><code>Outer.Inner in = new Outer.new Inner();//这种形式很少用。</code></pre><p>但是这种应用不多见，因为内部类之所以定义在内部就是为了封装。<strong>想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。</strong></p><p>2：私有修饰符。</p><p>通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。</p><p>3：静态修饰符。</p><p><strong>如果内部类被静态修饰，相当于外部类</strong>，会出现访问局限性，只能访问外部类中的静态成员。</p><p>注意；<strong>如果内部类中定义了静态成员，那么该内部类必须是静态的。</strong></p><p><br><br><strong>内部类编译后的文件名为：”外部类名$内部类名.java”；</strong></p><p><br><br><strong>为什么内部类可以直接访问外部类中的成员呢？</strong></p><p>那是因为内部中都持有一个外部类的引用。这个是引用是 <font color="red"><strong>外部类名.this</strong></font></p><p>内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。</p><font color="red"><strong>当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。</strong></font><font color="red"><strong>匿名内部类（对象）</strong></font>：没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。<font color="blue">想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。</font><p><br></p><font color="red"><strong>匿名内部类的格式：</strong></font><font color="blue">new 父类名&amp;接口名(){ 定义子类成员或者覆盖父类方法 }.方法。</font><p><br></p><font color="red"><strong>匿名内部类的使用场景：</strong></font><p>当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。</p><p>其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。</p><p>-—————————————————————————-<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//面试</span><br><span class="line"></span><br><span class="line">      //1</span><br><span class="line"></span><br><span class="line">      new Object()&#123;</span><br><span class="line"></span><br><span class="line">          void show()&#123;</span><br><span class="line"></span><br><span class="line">              System.out.println(&quot;show run&quot;);                </span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;.show();                                    //写法和编译都没问题</span><br><span class="line"></span><br><span class="line">      //2</span><br><span class="line"></span><br><span class="line">      Object obj = new Object()&#123;</span><br><span class="line"></span><br><span class="line">          void show()&#123;</span><br><span class="line"></span><br><span class="line">              System.out.println(&quot;show run&quot;);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      obj.show();                                //写法正确，编译会报错</span><br></pre></td></tr></table></figure></p><p>1和2的写法正确吗？有区别吗？说出原因。</p><p>写法是正确，1和2都是在通过匿名内部类建立一个Object类的子类对象。</p><p>区别：</p><p>第一个可是编译通过，并运行。</p><font color="red">第二个编译失败，因为匿名内部类是一个子类对象，当用Object的obj引用指向时，就被提升为了Object类型，而编译时会检查Object类中是否有show方法，此时编译失败。</font><h5 id="异-常：★★★★"><a href="#异-常：★★★★" class="headerlink" title="异 常：★★★★"></a>异 常：★★★★</h5><font color="red"><strong>–java.lang.Throwable：</strong></font><font color="red">Throwable</font>：可抛出的。<br><br>&emsp;&emsp;<font color="red">|–Error</font>：错误，一般情况下，不编写针对性的代码进行处理，通常是jvm发生的，需要对程序进行修正。<br><br>&emsp;&emsp;<font color="red">|–Exception</font>：异常，可以有针对性的处理方式<br><br><br><br><strong>这个体系中的所有类和对象都具备一个独有的特点；<font color="red">就是可抛性</font>。</strong><br><br><font color="red">可抛性的体现</font>：就是这个体系中的类和对象都可以被throws和throw两个关键字所操作。<br><br><br><br><strong>throw与throws区别：</strong><br><br>throws是用来声明一个方法可能抛出的所有异常信息，而throw则是指抛出的一个具体的异常类型。此外throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。<br><br>throw用于抛出异常对象，后面跟的是异常对象；throw用在函数<strong>内</strong>。<br><br>throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数<strong>上</strong>。<br><br><br>throws格式：方法名（参数）throws 异常类1，异常类2，…..<br><br>throw：就是自己进行异常处理，处理的时候有两种方式，要么自己捕获异常（也就是try catch进行捕捉），要么声明抛出一个异常（就是throws 异常~~）。<br><br><br><strong>处理方式有两种：1、捕捉；2、抛出。</strong><br><br>对于捕捉：java有针对性的语句块进行处理。<br><br>    try {<br><br>        需要被检测的代码；<br><br>    }<br><br>    catch(异常类 变量名){<br><br>        异常处理代码；<br><br>    }<br><br>    fianlly{<br><br>        一定会执行的代码；<br><br>    }<br><br><font color="red">定义异常处理时，什么时候定义try，什么时候定义throws呢？</font><br><font color="red">定义异常处理时，什么时候定义try，什么时候定义throws呢？</font><p><strong>功能内部如果出现异常，如果内部可以处理，就用try；</strong></p><p><strong>如果功能内部处理不了，就必须声明出来，让调用者处理。使用throws抛出，交给调用者处理。谁调用了这个功能谁就是调用者；</strong></p><p><br></p><font color="red"><strong>自定义异常的步骤：</strong></font><p>1：定义一个子类继承Exception或RuntimeException，让该类具备可抛性(既可以使用throw和throws去调用此类)。</p><p>2：通过throw 或者throws进行操作。</p><p><br></p><font color="red"><strong>异常的转换思想：</strong></font>当出现的异常是调用者处理不了的，就需要将此异常转换为一个调用者可以处理的异常抛出。<br><br><br><br><font color="red">try catch finally的几种结合方式：</font><ol><li><p>try<br>catch<br>finally</p></li><li><p>try<br>catch</p></li><li><p>try<br>finally</p></li></ol><p>这种情况，如果出现异常，并不处理，但是资源一定关闭，所以<font color="red"><strong>try finally集合只为关闭资源。</strong></font></p><font color="red"><strong>记住：</strong></font>finally很有用，主要用户关闭资源。无论是否发生异常，资源都必须进行关闭。<br><br><font color="red">System.exit(0);</font> //退出jvm，只有这种情况finally不执行。<br><br><br><br><br><strong>注意：</strong><br><br><strong>如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，<font color="red">如果子类的覆盖的方法中出现了异常，只能try不能throws。</font></strong><br><br><strong>如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，这样，子类的方法上是不需要throws声明的。</strong><br><br><br><br><br><br><br>##### 多线程：★★★★<br><br>返回当前线程的名称：<font color="red">Thread.currentThread().getName()</font><p>线程的名称是由：Thread-编号定义的。编号从0开始。</p><p>线程要运行的代码都统一存放在了<font color="red">run方法</font>中。</p><p><br><br>线程要运行必须要通过类中指定的方法开启。<font color="">start方法</font>。（启动后，就多了一条执行路径）</p><font color="">start方法</font>：1）、启动了线程；2）、让jvm调用了run方法。<br><br><br><br><strong>Thread类中run()和start()方法的区别：</strong><br><br>start()：用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。<br><br>run()：run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。<br><br>总结：start()方法最本质的功能是从CPU中申请另一个线程空间来执行 run()方法中的代码,它和当前的线程是两条线,在相对独立的线程空间运行,也就是说,如果你直接调用线程对象的run()方法,当然也会执行,但那是 在当前线程中执行,run()方法执行完成后继续执行下面的代码.而调用start()方法后,run()方法的代码会和当前线程并发(单CPU)或并行 (多CPU)执行。所以请记住一句话：调用线程对象的run方法不会产生一个新的线程，虽然可以达到相同的执行结果,但执行过程和执行效率不同<br><br><br><br><font color="red">创建线程的第一种方式：继承Thread ，由子类复写run方法。</font><p>步骤：</p><p>&emsp;&emsp;1，定义类继承Thread类；</p><p>&emsp;&emsp;2，目的是复写run方法，将要让线程运行的代码都存储到run方法中；</p><p>&emsp;&emsp;3，通过创建Thread类的子类对象，创建线程对象；</p><p>&emsp;&emsp;4，调用线程的start方法，开启线程，并执行run方法。</p><p><br></p><font color="red"><strong>线程状态：</strong></font><p><strong>被创建：</strong>start()</p><p><strong>运行：</strong>具备执行资格，同时具备执行权；</p><p><strong>冻结：</strong>sleep(time),wait()—notify()唤醒；线程释放了执行权，同时释放执行资格；</p><p><strong>临时阻塞状态：</strong>线程具备cpu的执行资格，没有cpu的执行权；</p><p><strong>消亡：</strong>stop()</p><p><img src="\image\JAVA学习\线程状态转换图.png" alt="线程状态转换图" title="线程状态转换图"></p><font color="red"><strong>创建线程的第二种方式：实现一个接口Runnable。</strong></font><p>步骤：</p><p>&emsp;&emsp;1，定义类实现Runnable接口。</p><p>&emsp;&emsp;2，覆盖接口中的run方法（用于封装线程要运行的代码）。</p><p>&emsp;&emsp;3，通过Thread类创建线程对象；</p><p>&emsp;&emsp;4，<font color="red"><strong>将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。</strong></font></p><p>&emsp;&emsp;为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。</p><p>&emsp;&emsp;5，调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。</p><pre><code>Ticket t = new Ticket();/*直接创建Ticket对象，并不是创建线程对象。因为创建对象只能通过new Thread类，或者new Thread类的子类才可以。所以最终想要创建线程。既然没有了Thread类的子类，就只能用Thread类。*/Thread t1 = new Thread(t); //创建线程。/*只要将t作为Thread类的构造函数的实际参数传入即可完成线程对象和t之间的关联为什么要将t传给Thread类的构造函数呢？其实就是为了明确线程要运行的代码run方法。*/t1.start();</code></pre><p><br></p><font color="red"><strong>为什么要有Runnable接口的出现？</strong></font><p><strong>1：</strong>通过继承Thread类的方式，可以完成多线程的建立。但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承Thread类，因为<strong>java单继承</strong>的局限性。</p><p>可是该类中的还有部分代码需要被多个线程同时执行。这时怎么办呢？</p><p>只有对该类进行额外的功能扩展，java就提供了一个接口Runnable。这个接口中定义了run方法，其实run方法的定义就是为了存储多线程要运行的代码。</p><p>所以，通常创建线程都用第二种方式。</p><font color="red"><strong>因为实现Runnable接口可以避免单继承的局限性。</strong></font><p><br><br>2：其实是将不同类中需要被多线程执行的代码进行抽取。将多线程要运行的代码的位置单独定义到接口中。为其他类进行功能扩展提供了前提。</p><p>所以Thread类在描述线程时，内部定义的run方法，也来自于Runnable接口。</p><p><br><br><strong>实现Runnable接口可以避免单继承的局限性。</strong>而且，继承Thread，是可以对Thread类中的方法，进行子类复写的。但是不需要做这个复写动作的话，只为定义线程代码存放位置，实现Runnable接口更方便一些。所以<strong>Runnable接口将线程要执行的任务封装成了对象。</strong></p><p>-——————————————————</p><pre><code>//面试    new Thread(new Runnable(){ //匿名        public void run(){            System.out.println(&quot;runnable run&quot;);            }    })</code></pre><p>​<br>        {</p><pre><code>    public void run(){        System.out.println(&quot;subthread run&quot;);    }}.start(); //结果：subthread run</code></pre><p>-——————————————————–</p><p><br></p><font color="red"><strong>synchronized关键字（一）</strong></font><p>一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p><p>二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p><p>三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p><p>四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p><p>五、以上规则对其它对象锁同样适用.</p><pre><code>package ths;public class Thread1 implements Runnable {    public void run() {        synchronized(this) {            for (int i = 0; i &lt; 5; i++) {            System.out.println(Thread.currentThread().getName()+&quot;synchronized loop &quot; + i);            }        }    }}</code></pre><p><br></p><font color="red"><strong>synchronized关键字（二）</strong></font><p>synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。</p><p>1. synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：</p><pre><code>public synchronized void accessVal(int newVal);</code></pre><p>synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。</p><p>在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。</p><p>synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized 块。</p><p>2. synchronized 块：通过 synchronized关键字来声明synchronized 块。语法如下：</p><pre><code>synchronized(syncObject) {//允许访问控制的代码}</code></pre><p>synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。</p><p>对synchronized(this)的一些理解</p><p>一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p><p>二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p><p>三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p><p>四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p><p>五、以上规则对其它对象锁同样适用</p><p><br></p><font color="red"><strong>解决安全问题的原理：</strong></font><p>只要将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。</p><p>如何保障共享数据的线程安全呢？</p><p><strong>java中提供了一个解决方式：<font color="red">就是同步代码块。</font></strong></p><p>格式：</p><pre><code>synchronized(对象) { //任意对象都可以。这个对象就是共享数据。    需要被同步的代码；}</code></pre><p>-————————————————————–<br>-————————————————————–</p><center><font color="red"><strong>同步：★★★★★</strong></font></center><p><strong>好处：</strong>解决了线程安全问题。Synchronized</p><p><strong>弊端：</strong>相对降低性能，因为判断锁需要消耗资源，产生了死锁。</p><p><br><br>同步的第二种表现形式：        <strong>//对共享资源的方法定义同步</strong></p><font color="red">同步函数：</font>其实就是将同步关键字定义在函数上，让函数具备了同步性。<br><br><br><br><strong><font color="red">同步函数是用的哪个锁呢？</font>        //synchronized(this)用以定义需要进行同步的某一部分代码块</strong><br><br>通过验证，函数都有自己所属的对象this，所以同步函数所使用的锁就是this锁。<font color="red">This.方法名</font><p><br></p><font color="red"><strong>当同步函数被static修饰时，这时的同步用的是哪个锁呢？</strong></font><p>静态函数在加载时所属于类，这时有可能还没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了对象，这个对象就是<strong>该类的字节码文件对象。</strong></p><p>所以静态加载时，只有一个对象存在，那么静态同步函数就使用的这个对象。</p><p>这个对象就是 <font color="red">类名.class</font></p><p><br></p><font color="red"><strong>同步代码块和同步函数的区别？</strong></font><p>同步代码块使用的锁可以是任意对象。</p><p><strong>同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。</strong></p><p><br><br><strong>在一个类中只有一个同步的话，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。</strong></p><p>-——————————————————</p><font color="red"><strong>★考点问题：请写一个延迟加载的单例模式？写懒汉式；当出现多线程访问时怎么解决？加同步，解决安全问题；效率高吗？不高；怎样解决？通过双重判断的形式解决。</strong></font><p>//懒汉式：延迟加载方式。</p><p>当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。</p><font color="red">为了效率问题，通过双重判断的形式解决。</font><pre><code>class Single{    private static Single s = null;    private Single(){}    public static Single getInstance(){ //锁是谁？字节码文件对象；        if(s == null){            synchronized(Single.class){                if(s == null)                    s = new Single();            }        }        return s;    }}</code></pre><p>-——————————————————–</p><font color="red"><strong>等待唤醒机制：</strong></font>涉及的方法：<br><br><font color="red">wait:</font>将同步中的线程处于冻结状态。释放了执行权，释放了资格。同时将线程对象存储到线程池中。<br><br><font color="red">notify：</font>唤醒线程池中某一个等待线程。<br><br><font color="red">notifyAll:</font>唤醒的是线程池中的所有线程。<br><br><br><br><br>注意：<br><br>1：<strong>这些方法都需要定义在同步中。</strong><br><br>2：因为这些方法必须要标示所属的锁。<br><br>你要知道 A锁上的线程被wait了,那这个线程就相当于处于A锁的线程池中，只能A锁的notify唤醒。<br><br>3：这三个方法都定义在Object类中。为什么操作线程的方法定义在Object类中？<br><br>因为这三个方法都需要定义同步内，并标示所属的同步锁，既然被锁调用，而锁又可以是任意对象，那么能被任意对象调用的方法一定定义在Object类中。<br><br><br><br><br><font color="red"><strong>wait和sleep区别：</strong></font> 分析这两个方法：从执行权和锁上来分析：<br><br>wait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyAll来唤醒。<br><br>sleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。<br><br><strong>wait：线程会释放执行权，而且线程会释放锁。</strong><br><br><strong>sleep：线程会释放执行权，但是不释放锁。</strong><br><br><br><br><br><font color="red"><strong>线程的停止</strong></font>：通过stop方法就可以停止线程。但是这个方式过时了。<br><br>停止线程：原理就是：让线程运行的代码结束，也就是结束run方法。<br><br>怎么结束run方法？一般run方法里肯定定义循环。所以只要结束循环即可。<br><br>第一种方式：<strong>定义循环的结束标记。</strong><br><br>第二种方式：如果线程处于了冻结状态，是不可能读到标记的，这时就需要<strong>通过Thread类中的interrupt方法，将其冻结状态强制清除</strong>。让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。<br><br><br><br><br><font color="red">———&lt; java.lang.Thread &gt;———-</font><font color="red">interrupt()：</font>中断线程。<br><br><font color="red">setPriority(int newPriority)：</font>更改线程的优先级。<br><br><font color="red">getPriority()：</font>返回线程的优先级。<br><br><font color="red">toString()：</font>返回该线程的字符串表示形式，包括线程名称、优先级和线程组。<br><br><font color="red">Thread.yield()：</font>暂停当前正在执行的线程对象，并执行其他线程。<br><br><font color="red">setDaemon(true)：</font>将该线程标记为守护线程或用户线程。将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，<strong>Java 虚拟机退出</strong>。该方法必须在启动线程前调用。<br><br><font color="red">join：</font>临时加入一个线程的时候可以使用join方法。<br><br>当A线程执行到了B线程的join方式。A线程处于冻结状态，释放了执行权，B开始执行。A什么时候执行呢？只有当B线程运行结束后，A才从冻结状态恢复运行状态执行。<br><br><br><br><br><br><br><strong><font color="red">LOCK的出现替代了同步：</font>lock.lock();………lock.unlock();</strong><br><br><strong><font color="">Lock接口：</font>多线程在JDK1.5版本升级时，推出一个接口<font color="red">Lock接口</font>。</strong><br><br>解决线程安全问题使用同步的形式，(同步代码块，要么同步函数)其实最终使用的都是锁机制。<br><br><br><br><br>到了后期版本，直接将锁封装成了对象。线程进入同步就是具备了锁，执行完，离开同步，就是释放了锁。<br><br>在后期对锁的分析过程中，发现，获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。<br><br><br><br><br>所以<font color="red"><strong>同步是隐示的锁操作，而Lock对象是显示的锁操作</strong></font>，它的出现就替代了同步。<br><br><br><br><br>在之前的版本中使用Object类中wait、notify、notifyAll的方式来完成的。那是因为同步中的锁是任意对象，所以操作锁的等待唤醒的方法都定义在Object类中。<br><br><br><br><br>而现在锁是指定对象Lock。所以查找等待唤醒机制方式需要通过Lock接口来完成。而Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。这个对象就是<font color="red"><strong>Condition</strong></font>，将Object中的三个方法进行单独的封装。并提供了功能一致的方法<font color="red"> <strong>await()、signal()、signalAll()</strong></font>体现新版本对象的好处。<br><br>&lt; java.util.concurrent.locks &gt; Condition接口：await()、signal()、signalAll()；<br><br>-——————————————————-<br><br>    class BoundedBuffer {<br><br>        final Lock lock = new ReentrantLock();<br><br>        final Condition notFull = lock.newCondition();<br><br>        final Condition notEmpty = lock.newCondition();<br><br>        final Object[] items = new Object[100];<br><br>        int putptr, takeptr, count;<br><br>        public void put(Object x) throws InterruptedException {<br><br>            lock.lock();<br><br>            try {<br><br>                while (count == items.length)<br><br>                notFull.await();<br><br>                items[putptr] = x;<br><br>                if (++putptr == items.length) putptr = 0;<br><br>                ++count;<br><br>                notEmpty.signal();<br><br>            }finally {<br><br>                lock.unlock();<br><br>            }<br><br>        }<br><br>        public Object take() throws InterruptedException {<br><br>            lock.lock();<br><br>            try {<br><br>                while (count == 0)<br><br>                notEmpty.await();<br><br>                Object x = items[takeptr];<br><br>                if (++takeptr == items.length) takeptr = 0;<br><br>                –count;<br><br>                notFull.signal();<br><br>                return x;<br><br>            }finally {<br><br>                lock.unlock();<br><br>            }<br><br>        }<br><br>    }<br><br><br><br><br><br><br><br><br><br><br><br><br>### 四、集合框架<br><br><strong>集合框架：★★★★★</strong>，用于存储数据的容器。<br><br>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。<br><br>集合容器在不断向上抽取过程中。出现了集合体系。<br><br><font color="red"><strong>在使用一个体系时，原则：参阅顶层内容。建立底层对象。</strong></font><p><img src="\image\JAVA学习\java中集合类的关系图.png" alt="java中集合类的关系图" title="java中集合类的关系图"></p><p>-———————————————————–</p><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><font color="red">--&lt; java.util &gt;– List接口：</font><p>List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。</p><p><br></p><font color="blue">List：</font>有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。<br><br>&emsp;&emsp;<font color="blue">|–ArrayList：</font><font color="red">底层的数据结构是数组</font>,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。<br><br>&emsp;&emsp;<font color="blue">|–LinkedList：<font color="red">底层的数据结构是链表</font>，线程不同步，增删元素的速度非常快。</font><p>&emsp;&emsp;<font color="blue">|–Vector：</font>底层的数据结构就是数组，<font color="red">线程同步的</font>，Vector无论查询和增删都巨慢。</p><p><br><br><strong>变长度数组的原理：</strong></p><p>当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。</p><p>ArrayList：是按照原数组的50%延长。构造一个初始容量为 10 的空列表。</p><p>Vector：是按照原数组的100%延长。</p><p>-———————————————————–</p><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><font color="red">–&lt; java.util &gt;– Set接口：</font><p>数据结构：数据的存储方式；</p><p>Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种，<strong>迭代器。</strong></p><p>&emsp;&emsp;<font color="blue">|–HashSet：</font>底层数据结构是哈希表，线程是<strong>不同步的。无序，高效；</strong></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;当元素的hashCode值相同时，才继续判断元素的equals是否为true。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;如果为true，那么视为相同元素，不存。如果为false，那么存储。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。</p><p>&emsp;&emsp;<font color="blue">|–LinkedHashSet：</font>有序，hashset的子类。</p><p>&emsp;&emsp;&emsp;&emsp;<font color="blue">|–TreeSet：</font>对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。</p><p><strong>对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。</strong></p><p><strong>对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。</strong></p><p><br><br>-———————————————————–</p><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><font color="red"><strong>Map集合：</strong></font><font color="blue">|–Hashtable：</font>底层是哈希表数据结构，是<font color="red"><strong>线程同步</strong></font>的。不可以存储null键，null值。<br><br><font color="blue">|–HashMap：</font>底层是哈希表数据结构，是<font color="red">线程不同步</font>的。可以存储null键，null值。替代了Hashtable.<br><br><font color="blue">|–TreeMap：</font>底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。<br><br><br><br><br>Map集合存储和Collection有着很大不同：<br><br>Collection一次存一个元素；Map一次存一对元素。<br><br>Collection是单列集合；Map是双列集合。<br><br>Map中的存储的一对元素：一个是键，一个是值，<strong>键与值之间有对应(映射)关系</strong>。<br><br><font color="red"><strong>特点：要保证map集合中键的唯一性。</strong></font><p><br></p><font color="red">5，<strong>想要获取map中的所有元素：</strong></font><font color="purple"><strong>原理：</strong></font>map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。<br><br><font color="red"><strong>把map集合转成set的方法：</strong></font><br>​<br>    Set keySet();<br><br>    Set entrySet();//取的是键和值的映射关系。<br><br>Entry就是Map接口中的内部接口；<br>Entry就是Map接口中的内部接口；<br><br>为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。<br><br>-————————————————————————-<br><br><font color="red"><strong>取出map集合中所有元素的方式一：keySet()方法。</strong></font><p>可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。</p><pre><code>Set keySet = map.keySet();Iterator it = keySet.iterator();while(it.hasNext()) {    Object key = it.next();    Object value = map.get(key);    System.out.println(key+&quot;:&quot;+value);}</code></pre><p>-—————————————————————————</p><font color="red"><strong>取出map集合中所有元素的方式二：entrySet()方法。</strong></font><pre><code>Set entrySet = map.entrySet();    Iterator it = entrySet.iterator();    while(it.hasNext()) {        Map.Entry me = (Map.Entry)it.next();        System.out.println(me.getKey()+&quot;::::&quot;+me.getValue());    }</code></pre><p>-————————————————————————</p><p><br></p><h4 id="将非同步集合转成同步集合的方法"><a href="#将非同步集合转成同步集合的方法" class="headerlink" title="将非同步集合转成同步集合的方法"></a>将非同步集合转成同步集合的方法</h4><font color="red"><strong>将非同步集合转成同步集合的方法：</strong></font><strong>Collections中的</strong> XXX synchronizedXXX(XXX);<br><br>    List synchronizedList(list);<br><br>    Map synchronizedMap(map);<br><br>    public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {<br><br>    return new SynchronizedMap&lt;K,V&gt;(m);<br><br>    }<br><br><strong>原理：定义一个类，将集合所有的方法加同一把锁后返回。</strong><br><br>    List list = Collections.synchronizedList(new ArrayList());<br><br>    Map&lt;String,String&gt; synmap = Collections.synchronizedMap(map);<br><br><br><br><br><br><br>#### Collection 和 Collections的区别<br><font color="red"><strong>Collection 和 Collections的区别：</strong></font><p>Collections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。</p><p>Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。</p><p>-———————————————————————</p><h3 id="五、自动拆装箱"><a href="#五、自动拆装箱" class="headerlink" title="五、自动拆装箱"></a>五、自动拆装箱</h3><font color="red"><strong>自动拆装箱：</strong></font>java中数据类型分为两种 ： 基本数据类型 引用数据类型(对象)<br><br>在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：<br><br>    int –&gt; Integer<br><br>    byte –&gt; Byte<br><br>    short –&gt; Short<br><br>    long –&gt; Long<br><br>    char –&gt; Character<br><br>    double –&gt; Double<br><br>    float –&gt; Float<br><br>    boolean –&gt; Boolean<br><br><br><br><br><br>jdk5以前基本数据类型和包装类之间需要互转：<br><br>基本—引用 Integer x = new Integer(x);<br><br>引用—基本 int num = x.intValue();<br><br>1)、Integer x = 1; x = x + 1; 经历了什么过程？<strong>装箱 -&gt; 拆箱 -&gt; 装箱；</strong><br><br>2)、为了优化，虚拟机为包装类提供了缓冲池，<font color="red"><strong>Integer池的大小 -128~127 一个字节的大小；</strong></font><p>3)、<font color="red"><strong>String池：</strong></font>Java为了优化字符串操作 提供了一个缓冲池；</p><p>-——————————————————————————-</p><h3 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h3><font color="red"><strong>泛型：</strong></font>jdk1.5版本以后出现的一个安全机制。<font color="red">表现格式：&lt; &gt;</font><font color="purpule"><br>好处：<br><br>1：将运行时期的问题ClassCastException问题转换成了编译失败，体现在编译时期，程序员就可以解决问题。<br><br>2：避免了强制转换的麻烦。<br></font><font color="red"><strong>泛型中的通配符：</strong></font>可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。<br><br>-——————————————————————————<br><br><br>### 七、反射技术<br><br><font color="red"><strong>反射技术：</strong></font>其实就是动态加载一个指定的类，并获取该类中的所有的内容。并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：<strong>反射技术可以对一个类进行解剖。</strong><br><br><br><br><br><strong>反射的好处：</strong>大大的增强了程序的扩展性。<br><br><br><br><br>#### 反射的基本步骤：<br><br><font color="purpule"><br><strong>1、获得Class对象，就是获取到指定的名称的字节码文件对象。</strong><br><br><strong>2、实例化对象，获得类的属性、方法或构造函数。</strong><br><br><strong>3、访问属性、调用方法、调用构造函数创建对象。</strong><br></font><p><br></p><h4 id="获取这个Class对象，有三种方式："><a href="#获取这个Class对象，有三种方式：" class="headerlink" title="获取这个Class对象，有三种方式："></a><font color="red">获取这个Class对象，有三种方式：</font></h4><p>1：通过每个对象都具备的方法getClass来获取。弊端：必须要创建该类对象，才可以调用getClass方法。</p><p>2：每一个数据类型(基本数据类型和引用数据类型)都有一个<strong>静态的属性class</strong>。弊端：必须要先明确该类。</p><p>  前两种方式不利于程序的扩展，因为都需要在程序使用具体的类来完成。</p><p>3：使用的Class类中的方法，静态的forName方法。</p><p>  指定什么类名，就获取什么类字节码文件对象，这种方式的扩展性最强，只要将类名的字符串传入即可。</p><pre><code>// 1. 根据给定的类名来获得 用于类加载String classname = &quot;cn.itcast.reflect.Person&quot;;// 来自配置文件Class clazz = Class.forName(classname);// 此对象代表Person.class// 2. 如果拿到了对象，不知道是什么类型 用于获得对象的类型Object obj = new Person();Class clazz1 = obj.getClass();// 获得对象具体的类型// 3. 如果是明确地获得某个类的Class对象 主要用于传参Class clazz2 = Person.class;    </code></pre><p><br><br><br></p><h4 id="反射的用法："><a href="#反射的用法：" class="headerlink" title="反射的用法："></a><font color="red">反射的用法：</font></h4><p>1）、需要获得java类的各个组成部分，首先需要获得类的Class对象，获得Class对象的三种方式：</p><pre><code>Class.forName(classname)    用于做类加载obj.getClass()                用于获得对象的类型类名.class             用于获得指定的类型，传参用</code></pre><p>2)、反射类的成员方法：<br>2)、反射类的成员方法：<br>2)、反射类的成员方法：</p><pre><code>Class clazz = Person.class;Method method = clazz.getMethod(methodName, new Class[]{paramClazz1, paramClazz2});method.invoke();</code></pre><p>​    </p><p>3)、反射类的构造函数：</p><pre><code>Constructor con = clazz.getConstructor(new Class[]{paramClazz1, paramClazz2,...})con.newInstance(params...)</code></pre><p>4)、反射类的属性：</p><pre><code>Field field = clazz.getField(fieldName);field.setAccessible(true);field.setObject(value);</code></pre><p><strong>获取了字节码文件对象后，最终都需要创建指定类的对象：</strong><br><strong>获取了字节码文件对象后，最终都需要创建指定类的对象：</strong></p><p><strong>创建对象的两种方式(其实就是对象在进行实例化时的初始化方式)：</strong></p><p>1，调用空参数的构造函数：使用了Class类中的<font color="red">newInstance()</font>方法。</p><p>2，调用带参数的构造函数：先要获取指定参数列表的构造函数对象，然后通过该构造函数的<font color="red"><strong>对象的newInstance(实际参数)</strong></font> 进行对象的初始化。</p><p>综上所述，第二种方式，必须要先明确具体的构造函数的参数类型，不便于扩展。<font color="red"><strong>所以一般情况下，被反射的类，内部通常都会提供一个公有的空参数的构造函数。</strong></font></p><p>-—————————————————–</p><pre><code>// 如何生成获取到字节码文件对象的实例对象。Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);//类加载// 直接获得指定的类型clazz = Person.class;// 根据对象获得类型Object obj = new Person(&quot;zhangsan&quot;, 19);clazz = obj.getClass();</code></pre><p>​<br>​<br>    Object obj = clazz.newInstance();<br>    //该实例化对象的方法调用就是指定类中的空参数构造函数，给创建对象进行初始化。<br>    //当指定类中没有空参数构造函数时，该如何创建该类对象呢？请看method_2();</p><pre><code>public static void method_2() throws Exception {    Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);    //既然类中没有空参数的构造函数,那么只有获取指定参数的构造函数,用该函数来进行实例化。    //获取一个带参数的构造器。    Constructor constructor = clazz.getConstructor(String.class,int.class);    //想要对对象进行初始化，使用构造器的方法newInstance();    Object obj = constructor.newInstance(&quot;zhagnsan&quot;,30);    //获取所有构造器。    Constructor[] constructors = clazz.getConstructors();//只包含公共的    constructors = clazz.getDeclaredConstructors();//包含私有的    for(Constructor con : constructors) {        System.out.println(con);    }}</code></pre><p>-—————————————————–</p><p><br></p><h4 id="反射指定类中的方法："><a href="#反射指定类中的方法：" class="headerlink" title="反射指定类中的方法："></a><font color="red">反射指定类中的方法：</font></h4><pre><code>//获取类中所有的方法。public static void method_1() throws Exception {    Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);    Method[] methods = clazz.getMethods();//获取的是该类中的公有方法和父类中的公有方法。    methods = clazz.getDeclaredMethods();//获取本类中的方法，包含私有方法。    for(Method method : methods) {        System.out.println(method);    }} //获取指定方法； //获取指定方法；public static void method_2() throws Exception {    Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);    //获取指定名称的方法。    Method method = clazz.getMethod(&quot;show&quot;, int.class,String.class);    //想要运行指定方法，当然是方法对象最清楚，为了让方法运行，调用方法对象的invoke方法即可，    //但是方法运行必须要明确所属的对象和具体的实际参数。    Object obj = clazz.newInstance();    method.invoke(obj, 39,&quot;hehehe&quot;);//执行一个方法}//想要运行私有方法。public static void method_3() throws Exception {    Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);    //想要获取私有方法。必须用getDeclearMethod();    Method method = clazz.getDeclaredMethod(&quot;method&quot;, null);    // 私有方法不能直接访问，因为权限不够。非要访问，可以通过暴力的方式。    method.setAccessible(true);//一般很少用，因为私有就是隐藏起来，所以尽量不要访问。} //反射静态方法。public static void method_4() throws Exception {    Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);    Method method = clazz.getMethod(&quot;function&quot;,null);    method.invoke(null,null);}</code></pre><p>参考网址:<br>参考网址:<br><a href="https://www.cnblogs.com/BYRans/p/Java.html" title="Java基础知识总结" target="_blank" rel="noopener">Java基础知识总结</a></p><h2 id="java-线程同步和等待唤醒机制"><a href="#java-线程同步和等待唤醒机制" class="headerlink" title="java 线程同步和等待唤醒机制"></a>java 线程同步和等待唤醒机制</h2><h3 id="java-等待唤醒机制"><a href="#java-等待唤醒机制" class="headerlink" title="java 等待唤醒机制"></a>java 等待唤醒机制</h3><p><strong>涉及的方法：</strong>  </p><ol><li>wait();让线程处于冻结状态，被wait的线程会被存储到线程池中。  </li><li>notify();唤醒线程池中一个线程（任意）。  </li><li>notifyAll()：唤醒线程池中的所有线程。</li></ol><p>这些方法都必须定义在同步中。因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。</p><p>为什么操作线程的方法wait notify notifyAll 定义在了Object类中。因为这些方法时监视器的方法。监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。 </p><p>wait()和notify()的使用注意点</p><ol><li><p>wait方法与notify方法必须要在同步代码块或者是同步函数中才能使用。<br>理由：如果不存在同步代码块和同步函数则没有锁对象这个概念，而这两个方法必须由锁对象调用。</p></li><li><p>wait方法与notify方法必需要由锁对象调用。<br>理由：因为需要以锁对象为标识符建立一个线程池，生产者与消费者必须用同一个锁，不同的锁会建立不同的线程池。且不用锁对象调用是报错的，要求就是以锁对象调用，否则就会报错</p></li></ol><p>参考资料：</p><p>下面这篇知识点写的很好！</p><p><a href="http://blog.csdn.net/huaxun66/article/details/77942389" title="没加载出来" target="_blank" rel="noopener">Java并发编程（二）线程同步和等待唤醒机制 </a></p><h2 id="Java-快速失败-fail-fast-安全失败-fail-safe"><a href="#Java-快速失败-fail-fast-安全失败-fail-safe" class="headerlink" title="Java 快速失败( fail-fast ) 安全失败( fail-safe )"></a>Java 快速失败( fail-fast ) 安全失败( fail-safe )</h2><p><strong>一.  快速失败( fail-fast )</strong></p><p>​    先了解一下并发修改</p><p><strong>1. 什么是并发修改？</strong></p><p>​    当一个或多个线程正在遍历一个集合Collection，此时另一个线程修改了这个集合的内容（添加，删除或者修改）。</p><p>这就是并发修改</p><p><strong>2.什么是 fail-fast 机制?</strong></p><p>1.7的jdk这么写到</p><p>​    if the map is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove</p><p>​    method, the iterator will throw a <a href="https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/java/util/ConcurrentModificationException.html" target="_blank" rel="noopener">ConcurrentModificationException</a>. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</p><p>​    Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException</p><p>​    on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: <em>the fail-fast behavior of iterators should be used only to detect bugs.</em></p><p>​    大概意思是:如果map在迭代的时候被修改了结构,除了使用迭代器本身的remove方法之外,否则就会扔出一个异常.因此面对并发的场景下map的迭代很快就会抛出异常.<br>fail-fast的表现不是能够保证一定发生,只是尽最大努力抛出异常.因此编写依赖于此异常的程序的做法是错误的。</p><p>​    fail-fast机制在遍历一个集合时，当集合结构被修改，会抛出Concurrent Modification Exception。</p><p>​    fail-fast会在以下两种情况下抛出ConcurrentModificationException</p><p>​    （1）单线程环境</p><p>​    集合被创建后，在遍历它的过程中修改了结构。</p><p>​    注意 ：迭代器的remove()方法会让expectModcount和modcount 相等，所以是不会抛出这个异常。</p><p>​    （2）多线程环境</p><p>​        当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。</p><p>​    <strong>注意</strong>，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p><p><strong>3. fail-fast机制是如何检测的？</strong></p><p>​    迭代器在遍历过程中是直接访问内部数据的，因此内部的数据在遍历的过程中无法被修改。为了保证不被修改，迭代器内部维护了一个标记 “mode” ，当集合结构改变（添加删除或者修改），标记”mode”会被修改，而迭代器每次的hasNext()和next()方法都会检查该”mode”是否被改变，当检测到被修改时，抛出Concurrent Modification Exception。下面看看ArrayList迭代器部分的源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> cursor;    </span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">int</span> expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.cursor != ArrayList.<span class="keyword">this</span>.size);    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        checkForComodification();    </span><br><span class="line">        <span class="comment">/** 省略此处代码 */</span>    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lastRet &lt; <span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();    </span><br><span class="line">        checkForComodification();    </span><br><span class="line">        <span class="comment">/** 省略此处代码 */</span>    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount == <span class="keyword">this</span>.expectedModCount)    </span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    可以看到它的标记“mode”为 expectedModeCount</p><p><strong>二. fail-safe机制</strong></p><p>​    fail-safe任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException</p><p>​    fail-safe机制有两个问题</p><p>​    （1）需要复制集合，产生大量的无效对象，开销大</p><p>​    （2）无法保证读取的数据是目前原始<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>中的数据。</p><p>​    </p><p><strong>三、fail-fast 和 fail-safe的例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;    </span><br><span class="line"><span class="keyword">import</span> java.util.Map;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFastExample</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    </span><br><span class="line">        Map&lt;String,String&gt; premiumPhone = <span class="keyword">new</span> HashMap&lt;String,String&gt;();    </span><br><span class="line">        premiumPhone.put(<span class="string">"Apple"</span>, <span class="string">"iPhone"</span>);    </span><br><span class="line">        premiumPhone.put(<span class="string">"HTC"</span>, <span class="string">"HTC one"</span>);    </span><br><span class="line">        premiumPhone.put(<span class="string">"Samsung"</span>,<span class="string">"S5"</span>);    </span><br><span class="line"></span><br><span class="line">        Iterator iterator = premiumPhone.keySet().iterator();    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;    </span><br><span class="line">            System.out.println(premiumPhone.get(iterator.next()));    </span><br><span class="line">            premiumPhone.put(<span class="string">"Sony"</span>, <span class="string">"Xperia Z"</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iPhone </span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">        at java.util.HashMap$HashIterator.nextEntry(Unknown Source)</span><br><span class="line">        at java.util.HashMap$KeyIterator.next(Unknown Source)</span><br><span class="line">        at FailFastExample.main(FailFastExample.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;    </span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailSafeExample</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    </span><br><span class="line">        ConcurrentHashMap&lt;String,String&gt; premiumPhone =     </span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;String,String&gt;();    </span><br><span class="line">        premiumPhone.put(<span class="string">"Apple"</span>, <span class="string">"iPhone"</span>);    </span><br><span class="line">        premiumPhone.put(<span class="string">"HTC"</span>, <span class="string">"HTC one"</span>);    </span><br><span class="line">        premiumPhone.put(<span class="string">"Samsung"</span>,<span class="string">"S5"</span>);    </span><br><span class="line"></span><br><span class="line">        Iterator iterator = premiumPhone.keySet().iterator();          </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;          System.out.println(premiumPhone.get(iterator.next()));    </span><br><span class="line">             premiumPhone.put(<span class="string">"Sony"</span>, <span class="string">"Xperia Z"</span>);    </span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S5</span><br><span class="line">HTC one</span><br><span class="line">iPhone</span><br></pre></td></tr></table></figure><p>​    Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常.</p><p><strong>四、fail-fast和 fail-safe 的区别</strong></p><table><thead><tr><th></th><th>Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td>Yes</td><td>No</td></tr><tr><td>Clone object</td><td>No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td>No</td><td>Yes</td></tr><tr><td>Examples</td><td>HashMap,Vector,<br>ArrayList,HashSet</td><td>CopyOnWriteArrayList,<br>ConcurrentHashMap</td></tr></tbody></table><p>参考资料：<a href="https://www.jianshu.com/p/e68b059e98d7" target="_blank" rel="noopener">Java集合中 fail-fast机制</a></p><p>​          <a href="https://blog.csdn.net/bigtree_3721/article/details/67095084" target="_blank" rel="noopener">夜谈　Java中　Fail-fast 和 Fail-safe　的原理与使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA学习&quot;&gt;&lt;a href=&quot;#JAVA学习&quot; class=&quot;headerlink&quot; title=&quot;JAVA学习&quot;&gt;&lt;/a&gt;&lt;center&gt;JAVA学习&lt;center&gt;&lt;/center&gt;&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;Java常用知识&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="编程语法" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://yoursite.com/2018/03/02/%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/02/算法/</id>
    <published>2018-03-02T12:03:11.000Z</published>
    <updated>2018-07-04T12:25:12.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a><center>算法</center></h1><h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>(1)  基本思想 ： 枚举，递归，分治，模拟，贪心，动态规划，剪枝，回溯</p><p>(2)   *图算法： 深度优先遍历与广度优先遍历，最短路径，最小生成树，拓扑排序</p><p>(3)   字符串算法：字符串查找，hash查找，KMP算法</p><p>(4)   排序算法： 冒泡，插入，选择，快排，归并排序，堆排序，桶排序</p><p>(5)   查找算法： 顺序查找、折半查找、插入查找以及Fibonacci查找</p><p>(6)   动态规划：背包问题，最长公共子序列，最优二分检索树</p><p>(7)  *数论问题：素数问题，整数问题，进制转换，同余模运算</p><p>(8)  排列组合：排列和组合算法</p><p>(9)  其他：LCA与RMQ问题</p><p>参考资料：<a href="http://dongxicheng.org/structure/structure-algorithm-summary/" target="_blank" rel="noopener">数据结构与算法汇总</a></p><h2 id="一、排序算法"><a href="#一、排序算法" class="headerlink" title="一、排序算法"></a>一、排序算法</h2><h3 id="0-约定"><a href="#0-约定" class="headerlink" title="0.   约定"></a>0.   约定</h3><p>​    待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法。</p><p>​    研究排序算法的成本模型时，计算的是比较和交换的次数。</p><p>​    使用辅助函数 less() 和 exch() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Comparable t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.   冒泡排序"></a>1.   冒泡排序</h3><p>​    冒泡排序（Bubble Sort）是最经典也是最简单的排序算法之一。</p><p><strong>原理</strong>： </p><p>​    比较两个相邻元素，将值大的元素交换到右边（降序则相反）。其实可以想象瓶子底部的泡泡，它比较轻，就会慢慢的向上浮，冒泡排序也是一个类似的过程。</p><p><strong>步骤</strong>:</p><p>​    比较相邻的元素。如果前一个比后一个大，就交换他们。第一趟冒泡排序 可以将最大的数放置到最后，第二趟可以将次大的元素放置到倒数第二的位置。以此类推，经过n-1趟，就可以排序完成。</p><p><strong>分析</strong></p><p>​    时间复杂度为O(n^2)，其实就是需要比较的次数为n(n-1)/2。空间复杂度为O(1)，因为只需要一个临时的空间作为交换时用。</p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.  插入排序"></a>2.  插入排序</h3><p>​    插入排序从左到右进行，每次都将当前元素插入到左部已经排序的数组中，使得插入之后左部数组依然有序。</p><p><img src="\image\算法\插入排序--示意图.png" alt="入排序--示意"></p><p><strong>代码实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">                exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>总结：</strong></p><p>​    插入排序的复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么插入排序会很快。平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换，最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是逆序的；而最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</p><p>​    插入排序对于部分有序数组和小规模数组特别高效。</p><p><strong>选择排序和插入排序的比较：</strong></p><p>​    对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比是一个较小的常数。</p><h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h3><p>​    对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，如果要把元素从一端移到另一端，就需要很多次操作。</p><p>​    希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，使得元素更快的移到正确的位置上。</p><p>​    希尔排序使用插入排序对间隔 h 的序列进行排序，如果 h 很大，那么元素就能很快的移到很远的地方。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><p><img src="\image\算法\希尔排序--示意图.png" alt="尔排序--示意"></p><p><strong>实现代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">            h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</span><br><span class="line">                    exch(a, j, j - h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。</p><h3 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4.  选择排序"></a>4.  选择排序</h3><p>​    找到数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p><p><img src="\image\算法\选择排序-示意图.jpg" alt="择排序-示意"></p><p><strong>实现代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    选择排序需要 $O(\frac{N^2}{2})$ 次比较和 $O(N)$ 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.   快速排序"></a>5.   快速排序</h3><p><strong>(1). 基本算法</strong></p><p>​    归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。（<u><strong>快速排序就是用一个元素进行切分</strong></u>）</p><p><img src="\image\算法\快速排序--示意图.png" alt="速排序--示意"></p><p><strong>实现代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        shuffle(a);</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(a, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(2).  切分</strong></p><p>​    取 a[lo] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于等于它的元素，交换这两个元素，并不断继续这个过程，就可以保证左指针的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[lo] 和左子数组最右侧的元素 a[j] 交换然后返回 j 即可。</p><p><img src="\image\算法\快速排序--切分过程.png" alt="速排序--切分过"></p><p><strong>实现代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (less(v, a[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3). 性能分析</strong></p><p>​    快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p><p>​    快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 C~N~=2C~N/2~+N，也就是复杂度为 O(NlogN)。</p><p>​    最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N^2^/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><p><strong>(4).  算法改进</strong></p><p><strong>(4.1)  切换到插入排序</strong></p><p>​    因为快速排序在小数组中也会调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。</p><p><strong>(4.2) 三取样</strong></p><p>​    最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。人们发现取 3 个元素并将大小居中的元素作为切分元素的效果最好。</p><p><strong>(4.3) 三向切分</strong><br>    对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。三向切分快速排序对于只有若干不同主键的随机数组可以在线性时间内完成排序。</p><p><img src="\image\算法\快速排序-优化-三向切分.png" alt="速排序-优化-三向切"></p><p><strong>三向切分快速排序实现代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3Way</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) exch(a, lt++, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) exch(a, i, gt--);</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h3><p>​    归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。</p><p><img src="\image\算法\归并排序--示意图.png" alt="并排序--示意"></p><p><strong>(1)   归并方法</strong></p><p>​    归并方法将数据中两个已经排序好的部分归并成一个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            aux[k] = a[k]; <span class="comment">// 将数据复制到辅助数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[i].compareTo(a[j]) &lt; <span class="number">0</span>) a[k] = aux[i++]; <span class="comment">// 先进行这一步，保证稳定性</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>(2)  自顶向下归并排序</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    sort(a, lo, mid);</span><br><span class="line">    sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(a, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="\image\算法\归并排序-自顶向下示意图.png" alt="并排序-自顶向下示意"></p><p><img src="\image\算法\归并排序-自顶向下示意图2.png" alt="并排序-自顶向下示意图"></p><p>​    因为每次都将问题对半分成两个子问题，而这种对半分的算法复杂度一般为 O(NlogN)，因此该归并排序方法的时间复杂度也为 O(NlogN)。</p><p>​    因为小数组的递归操作会过于频繁，因此使用插入排序来处理小数组将会获得更高的性能。</p><p><strong>(3)  自底向上归并排序</strong></p><p>​    先归并那些微型数组，然后成对归并得到的子数组。</p><p><img src="\image\算法\归并排序-自底向上归并排序.png" alt="并排序-自底向上归并排"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">busort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz += sz) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz) &#123;</span><br><span class="line">            merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    其实，自底向上归并排序就是从小数组往大数组归并。自顶向下归并排序就是有一个划分的过程，其实也是要从小数组往大数组进行归并的。</p><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.  堆排序"></a>7.  堆排序</h3><p><strong>堆排序</strong></p><p>　    堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序</strong>，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><p><strong>堆</strong></p><p>　　堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p><p><img src="\image\算法\大顶堆于小顶堆.png" alt="顶堆于小顶"></p><p>​    同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p><p><img src="\image\算法\堆结构--映射到数组.png" alt="结构--映射到数"></p><p>​    该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p>​    <strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p>​    <strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p>​    ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p><p><strong>堆排序基本思想及步骤</strong></p><p>​    堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p>(1) 构建初始堆</p><p>​    初始化堆的时候是对所有的非叶子结点进行筛选。</p><p>　　    假设有n个元素的堆，那么最后一个非叶子元素的下标是[n/2]-1（向下取整），所以筛选只需要从第[n/2]-1个元素开始，从后往前进行调整。</p><p>　　    比如，给定一个数组，首先根据该数组元素构造一个完全二叉树。</p><p>　　    然后从最后一个非叶子结点开始，每次都是从父结点、左孩子、右孩子中进行比较交换，<strong>交换可能会引起孩子结点不满足堆的性质</strong>，所以每次交换之后需要重新对被交换的孩子结点进行调整。</p><p>（2）进行堆排序</p><p>　　堆排序是一种选择排序。建立的初始堆为初始的无序区。</p><p>　　排序开始，首先输出堆顶元素（因为它是最值），将堆顶元素和最后一个元素交换，这样，第n-1个位置（即最后一个位置）作为有序区，前n-2个位置仍是无序区，对无序区进行调整，得到堆之后，再交换堆顶和最后一个元素，这样有序区长度变为2。。。</p><p>　　不断进行此操作，将剩下的元素重新调整为堆，然后输出堆顶元素到有序区。每次交换都导致无序区-1，有序区+1。不断重复此过程直到有序区长度增长为n-1，排序完成。</p><p><strong>实现代码(zhg)</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.建立初始堆(大顶堆)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (end - start + <span class="number">1</span>)/<span class="number">2</span> -<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            updateHeap(nums, i, nums.length -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.进行堆排序（升序）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            exch(nums, <span class="number">0</span>, i);</span><br><span class="line">            updateHeap(nums, <span class="number">0</span>, i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对堆中的某一个元素进行一个从上到下的调整</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateHeap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> end_index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*index + <span class="number">1</span> &gt; end_index)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; nums[<span class="number">2</span>*index+<span class="number">1</span>])&#123;</span><br><span class="line">                exch(nums, index, <span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">                updateHeap(nums, <span class="number">2</span>*index+<span class="number">1</span>, end_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*index+<span class="number">2</span> &gt; end_index)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; nums[<span class="number">2</span>*index+<span class="number">2</span>])&#123;</span><br><span class="line">                exch(nums, index, <span class="number">2</span>*index+<span class="number">2</span>);</span><br><span class="line">                updateHeap(nums, <span class="number">2</span>*index+<span class="number">2</span>, end_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换数组中两个元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>分析</strong></p><p>​    一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p><p>​    对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p><p>​    堆排序时一种原地排序，没有利用额外的空间。</p><p>​    现代操作系统很少使用堆排序，因为它无法利用缓存，也就是数组元素很少和相邻的元素进行比较。</p><p>参考资料：<a href="http://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></p><p>​                 <a href="http://www.cnblogs.com/Kevin-mao/p/5903234.html" target="_blank" rel="noopener">堆排序算法</a></p><h3 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h3><p><strong>基本思想</strong></p><p>​    不进行关键字的比较,而是<strong>利用”分配”和”收集”</strong>。</p><p>​    PS：以十进制为例，基数指的是数的位，如个位，十位百位等。而以十六进制为例，0xB2，就有两个radices（radix的复数）。</p><p><strong>Least significant digit（LSD）</strong><br>    短的关键字被认为是小的，排在前面，然后相同长度的关键字再按照词典顺序或者数字大小等进行排序。比如1，2，3，4，5，6，7，8，9，10，11或者”b, c, d, e, f, g, h, i, j, ba” 。</p><p><strong>Most significance digit（MSD）</strong><br>    直接按照字典的顺序进行排序，对于字符串、单词或者是长度固定的整数排序比较合适。比如：1, 10, 2, 3, 4, 5, 6, 7, 8, 9和 “b, ba, c, d, e, f, g, h, i, j”。</p><p><strong>基数排序图示</strong></p><p><img src="\image\算法\基数排序图示.jpg" alt="数排序图"></p><p><img src="\image\算法\基数排序图示2.jpg" alt="数排序图示"></p><p>​    从图示中可以看出基数排序（LSD）的基本流程为如下节。</p><p><strong>基数排序流程</strong></p><p>​    将根据整数的最右边数字将其扔进相应的0~9号的篮子里，对于相同的数字要保持其原来的相对顺序（确保排序算法的稳定性），然后将篮子里的数如图所示的串起来，然后再进行第二趟的收集（按照第二位的数字进行收集），就这样不断的反复，当没有更多的位时，串起来的数字就是排好序的数字。</p><p><strong>时间复杂度分析</strong></p><p>上图示中每个数计有2 位，因此执行2 次分配和收集就可以了。在一般情况下，每个结点有d 位关键字，必须执行d 次分配和收集操作。</p><ul><li>每次分配的代价：O(n)O(n)</li><li>每次收集的代价：O(radix)O(radix)</li><li>总的代价为：O(d×(n+radix))</li></ul><p><strong>算法实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">    Arrays.setAll(buckets, index -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">int</span> i=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(buckets[<span class="number">0</span>].size() != nums.length)&#123;</span><br><span class="line">        Arrays.stream(buckets).forEach(List::clear);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//进行分配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (num/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i))%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(buckets[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                buckets[index] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buckets[index].add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行收集</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Integer num : list)&#123;</span><br><span class="line">                    nums[t++] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="9-桶排序-BucketSort"><a href="#9-桶排序-BucketSort" class="headerlink" title="9.  桶排序(BucketSort)"></a>9.  桶排序(BucketSort)</h3><p>​    假设你有五百万份试卷，每份试卷的满分都是100分，如果要你对这些试卷按照分数进行排序，天噜啦，五百万份试卷啊，快速排序？堆排序？归并排序？面对这么多的数据，平均下来上面的每一种一种算法至少都要花费nlogn=5000000log5000000=111267433nlogn=5000000log5000000=111267433单位时间啊，将近一亿多，太慢了。</p><p>​    要是我们这样来做呢，首先买101只桶回来，分别为每一只桶编上0-100标号,我们就只管遍历一边所有的试卷，将分数为n的试卷丢入到编号为n的桶里面，当所有的试卷都放入到相应的桶里面时，我们就已经将所有的试卷按照分数进行排序了。遍历一遍所有数据的时间也就是五百万次，相比与一亿多次，那可是省了不少时间。这里所用到的就是桶排序的思想。</p><p><strong>桶排序的思想</strong></p><p>​    桶排序，顾名思义就是运用桶的思想来将数据放到相应的桶内，再将每一个桶内的数据进行排序，最后把所有桶内数据按照顺序取出来，得到的就是我们需要的有序数据</p><p>​    比如我们有下面的一些数据</p><blockquote><p>​    49 43 11 61 31 71 53 51 71 84</p></blockquote><p>​    下面我们按照这些数的十位将他们放入桶内</p><blockquote><p><strong>将数据放入桶内</strong></p><p>bucket#.0 +++<br>bucket#.1 +++ <code>11</code><br>bucket#.2 +++<br>bucket#.3 +++ <code>31</code><br>bucket#.4 +++ <code>49</code> <code>43</code><br>bucket#.5 +++ <code>53</code> <code>51</code><br>bucket#.6 +++ <code>61</code><br>bucket#.7 +++ <code>71</code> <code>71</code><br>bucket#.8 +++ <code>84</code><br>bucket#.9 +++</p></blockquote><p>​    注意一点，上面的各个桶内的数据是无序的，现在运用一个快速的排序算法对每一个桶内的数据进行排序，可以是快速排序，插入排序，归并排序里面的任何一种</p><blockquote><p><strong>对桶内数据进行排序</strong></p><p>bucket#.0 +++<br>bucket#.1 +++ 11<br>bucket#.2 +++<br>bucket#.3 +++ 31<br>==bucket#.4 +++== 43 49<br>==bucket#.5 +++== 51 53<br>bucket#.6 +++ 61<br>bucket#.7 +++ 71 71<br>bucket#.8 +++ 84<br>bucket#.9 +++</p></blockquote><p>​    注意观察上面的红色标示的桶里面的数据顺序已经发生改变，在将各个桶里面的元素进行排序以后，我们需要按照顺序遍历每一个桶，将桶里面的数据按照顺序取出来，得到已经排序的有序序列</p><blockquote><p><strong>组合各个桶内的元素 </strong><br>11 31 43 49 51 53 61 71 71 84</p></blockquote><p>总之，桶排序的的步骤为：</p><ul><li><strong>申请</strong>一定数量的桶</li><li>按照一个设定好的<strong>映射函数</strong>，将序列里面的元素映射到对应的桶里（上面例子的映射函数为BUCKET(i)=i/10）</li><li><strong>遍历</strong>一遍所有的桶，将各个桶内的元素进行<strong>排序</strong>，排序算法可以采用冒泡排序，插入排序，快速排序，归并排序等等适合的算法</li><li>将所有桶内的元素按照顺序<strong>组合</strong>起来就是我们需要的有序序列</li></ul><p><strong>时间复杂度</strong></p><p>​    如果桶的数量和序列元素的数量相等的话，那么算法将达到最优的效率$O(N)$，但是这个时候也是空间占用最大的时候。</p><p>​    如果桶内元素分布不平衡的，将会导致桶排序的算法效率大大降低，我们考虑最坏的情况，映射函数将所有的元素映射到同一个桶里面，再对桶里面元素进行插入排序，运行时间将升$O(N^2)$,所以设计一个性能优良的映射函数尤为重要。</p><h3 id="10-应用"><a href="#10-应用" class="headerlink" title="10.  应用"></a>10.  应用</h3><p><strong>(1) 排序算法的比较</strong></p><p><img src="\image\算法\排序算法的比较.png" alt="序算法的比"></p><p>​    快速排序时最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其他线性对数级别的排序算法都要小。使用三向切分之后，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p><p><strong>(2).  Java 的排序算法实现</strong><br>    Java 系统库中的主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。</p><p><strong>(3).  基于切分的快速选择算法</strong></p><p>​    快速排序的 partition() 方法，会返回一个整数 j 使得 a[lo..j-1] 小于等于 a[j]，且 a[j+1..hi] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。</p><p>​    可以利用这个特性找出数组的第 k 个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">select</span><span class="params">(Comparable[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (hi &gt; lo) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partion(a, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) <span class="keyword">return</span> a[k];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) hi = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> lo = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    该算法是线性级别的，因为每次正好将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。</p><h2 id="二、基本思想"><a href="#二、基本思想" class="headerlink" title="二、基本思想"></a>二、基本思想</h2><p><strong>八大算法：枚举、递推、递归、分治、贪心、试探法、动态迭代和模拟算法思想。</strong></p><h3 id="1、枚举算法思想（暴力算法）"><a href="#1、枚举算法思想（暴力算法）" class="headerlink" title="1、枚举算法思想（暴力算法）"></a>1、枚举算法思想（暴力算法）</h3><p>　　将问题的所有可能答案一一列举，根据判断条件判断此答案是否合适，一般用循环实现。</p><p>　　<strong>经典运用：</strong>百钱买百鸡、填写运算符</p><h3 id="2、递推算法思想"><a href="#2、递推算法思想" class="headerlink" title="2、递推算法思想"></a>2、递推算法思想</h3><p>　　1.顺推法：从已知条件出发，逐步推算出要解决问题的方法。</p><p>　　2.逆推法：从已知结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。</p><p>　　<strong>经典运用：</strong>斐波那契数列（顺推法）、银行存款（逆推法）</p><h3 id="3、递归算法思想"><a href="#3、递归算法思想" class="headerlink" title="3、递归算法思想"></a>3、递归算法思想</h3><p>　　1.递归过程一般通过函数或子过程实现；</p><p>　　2.递归算法在函数或子过程的内部，直接或间接调用自己的算法</p><p>　　3.递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解</p><p>　　注意：必须有一个明确的递归结束条件；如果递归次数过多，容易造成栈溢出。</p><p>　　<strong>经典运用：</strong>汉诺塔问题、阶乘问题</p><h3 id="4、分治算法思想"><a href="#4、分治算法思想" class="headerlink" title="4、分治算法思想"></a>4、分治算法思想</h3><p>　　将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。只要求出子问题的解，就可得到原问题的解。</p><p>　　一般步骤：</p><p>　　　　1.分解，将要解决的问题划分成若干个规模较小的同类问题</p><p>　　　　2.求解，当子问题划分得足够小时，用较简单的方法解决</p><p>　　　　3.合并，按原问题的要求，将子问题的解逐层合并构成原问题的解</p><p>　　<strong>经典运用：</strong>大数相乘问题、比赛日程安排</p><h3 id="5、贪心算法思想"><a href="#5、贪心算法思想" class="headerlink" title="5、贪心算法思想"></a>5、贪心算法思想</h3><p>　　从问题的某一个初始解出发，逐步逼近给定的目标，以便尽快求出更好的解。</p><p>　　局限：</p><p>　　　　不能保证最后的解是最优的；</p><p>　　　　不能求最大最小解问题；</p><p>　　　　只能求满足某些约束条件的可行解范围。</p><p>　　基本过程：</p><p>　　　　1.从问题的某一初始解出发</p><p>　　　　2.while能向给定总目标前进一步</p><p>　　　　3.求出可行解的一个解元素</p><p>　　　　4.由所有解元素组合成问题的一个可行解</p><p>　　<strong>经典运用：</strong>装箱问题、找零方案</p><h3 id="6、试探算法（回溯法）"><a href="#6、试探算法（回溯法）" class="headerlink" title="6、试探算法（回溯法）"></a>6、试探算法（回溯法）</h3><p>　　在试探算法中，放弃当前候选解，并继续寻找下一个候选解的过程称为回溯。扩大当前候选解的规模，以继续试探的过程称为向前试探。</p><p>　　（为求得问题的正确解，会先委婉地试探某一种可能情况。在进行试探过程中，一旦发现原来选择的假设情况是不正确的，马上会自觉地退回一步重新选择，然后继续向前试探。反复进行，直到得到解或证明无解时才死心）</p><p>　　基本步骤：</p><p>　　　　1.针对所给问题，定义问题的解空间</p><p>　　　　2.确定易于搜索的解空间结构</p><p>　　　　3.以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索</p><p>　　<strong>经典运用：</strong>八皇后问题、29选7彩票组合</p><h3 id="7、迭代算法（辗转法）"><a href="#7、迭代算法（辗转法）" class="headerlink" title="7、迭代算法（辗转法）"></a>7、迭代算法（辗转法）</h3><p>　　是一种不断用变量的旧值递推新值的过程，解决问题时总是重复利用一种方法。</p><p>　　1.确定迭代变量：直接或间接地不断由旧值递推出新值的变量</p><p>　　2.建立迭代关系式：新值与旧值的公式或关系。（解决迭代问题的关系）</p><p>　　3.对迭代过程进行控制：确定迭代过程什么时候结束</p><p>　　　　所需的迭代次数是个确定值，可以计算出来：可以构建一个固定次数的循环来实现对迭代过程的控制；</p><p>　　　　所需的迭代次数无法确定：需要进一步分析出用来结束迭代过程的条件。</p><p>　　<strong>经典运用：</strong>求平方根问题</p><h3 id="8、模拟算法思想"><a href="#8、模拟算法思想" class="headerlink" title="8、模拟算法思想"></a>8、模拟算法思想</h3><p>　　对真实事物或者过程的虚拟。</p><p>　　<strong>经典运用：</strong>猜数字游戏、掷骰子问题</p><h3 id="9、剪枝算法"><a href="#9、剪枝算法" class="headerlink" title="9、剪枝算法"></a>9、剪枝算法</h3><p><strong>一：剪枝策略的寻找的方法</strong></p><p>1）微观方法：从问题本身出发，发现剪枝条件</p><p>2）宏观方法：从整体出发，发现剪枝条件。</p><p>3）注意提高效率，这是关键，最重要的。</p><p>总之，剪枝策略，属于算法优化范畴；通常应用在DFS 和 BFS 搜索算法中；剪枝策略就是寻找过滤条件，提前减少不必要的搜索路径。</p><p><strong>二：剪枝算法(算法优化)</strong></p><p>1、简介</p><p>​    在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。</p><p>2、剪枝优化三原则: 正确、准确、高效.原则</p><p>​    搜索算法,绝大部分需要用到剪枝.然而,不是所有的枝条都可以剪掉,这就需要通过设计出合理的判断方法,以决定某一分支的取舍. 在设计判断方法的时候,需要遵循一定的原则.</p><p>剪枝的原则</p><p>  1） 正确性</p><pre><code>正如上文所述,枝条不是爱剪就能剪的. 如果随便剪枝,把带有最优解的那一分支也剪掉了的话,剪枝也就失去了意义. 所以,剪枝的前提是一定要保证不丢失正确的结果.</code></pre><p>  2）准确性</p><pre><code>在保证了正确性的基础上,我们应该根据具体问题具体分析,采用合适的判断手段,使不包含最优解的枝条尽可能多的被剪去,以达到程序“最优化”的目的. 可以说,剪枝的准确性,是衡量一个优化算法好坏的标准.</code></pre><p> 3）高效性</p><p>​    设计优化程序的根本目的,是要减少搜索的次数,使程序运行的时间减少. 但为了使搜索次数尽可能的减少,我们又必须花工夫设计出一个准确性较高的优化算法,而当算法的准确性升高,其判断的次数必定增多,从而又导致耗时的增多,这便引出了矛盾. 因此,如何在优化与效率之间寻找一个平衡点,使得程序的时间复杂度尽可能降低,同样是非常重要的. 倘若一个剪枝的判断效果非常好,但是它却需要耗费大量的时间来判断、比较,结果整个程序运行起来也跟没有优化过的没什么区别,这样就太得不偿失了.</p><p>3、分类</p><pre><code>剪枝算法按照其判断思路可大致分成两类:可行性剪枝及最优性剪枝.</code></pre><p>3.1 可行性剪枝 —— 该方法判断继续搜索能否得出答案，如果不能直接回溯。</p><p>3.2 最优性剪枝</p><p>​    最优性剪枝，又称为上下界剪枝，是一种重要的搜索剪枝策略。它记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯。</p><h2 id="三、查找算法"><a href="#三、查找算法" class="headerlink" title="三、查找算法"></a>三、查找算法</h2><h3 id="1、顺序查找"><a href="#1、顺序查找" class="headerlink" title="1、顺序查找"></a>1、顺序查找</h3><p>​    顺序查找就是从第一个元素比较到最后一个元素，如果找到目标元素，则查找成功，否则失败。</p><pre><code>顺序查找平均关键字匹配次数为表长的一半，其时间复杂度为O(n)。</code></pre><p>​    顺序查找的优点是对表无要求，插入数据可在O(1)内完成。缺点是时间复杂度较大，数据规模较大时，效率较低。</p><p><strong>算法伪代码</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为</span></span><br><span class="line">    <span class="comment">//该元素在表中的位置，否则为0</span></span><br><span class="line">    ST.elem[<span class="number">0</span>].key = key;<span class="comment">//哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;  !EQ(ST.elem[i].key, key); --i);<span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">return</span> i;<span class="comment">//找不到时，i为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、折半查找"><a href="#2、折半查找" class="headerlink" title="2、折半查找"></a>2、折半查找</h3><p>​    折半查找的<strong>查找过程</strong>是：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到该记录为止。</p><p>​    折半查找又称为二分查找，它的前提是线性表中的记录必须是有序的（通常从小到大有序），线性表必须采用顺序存储．</p><p>　　折半查找的<strong>基本思想</strong>是　：　在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找.不断重复上述过程，直到查找成功　或所有查找区域无记录，查找失败。</p><p><strong>算法伪代码</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span> <span class="params">( SSTable ST, KeyType key )</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在有序表ST中折半査找其关键字等于key的数据元素。若找到，则函数值为 </span></span><br><span class="line">    <span class="comment">//该元素在表中的位置，否则为0。注意：在整个表中，o号元素时空着的。</span></span><br><span class="line">    low = <span class="number">1</span>； high = ST.length；<span class="comment">// 置区间初值</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123; </span><br><span class="line">        raid = (low + high) / <span class="number">2</span>；</span><br><span class="line">        <span class="keyword">if</span> (EQ (key, ST. elem[mid].key)) <span class="keyword">return</span> mid<span class="comment">// 找到待査元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (LT(key, ST.elem[mid].key)) high = mid - <span class="number">1</span>; <span class="comment">//继续在前半区间进行査找</span></span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>；<span class="comment">//继续在后半区间进行査找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//顺序表中不存在待查元素</span></span><br><span class="line">&#125;<span class="comment">// Search_Bin</span></span><br></pre></td></tr></table></figure></p><h3 id="3、插入查找"><a href="#3、插入查找" class="headerlink" title="3、插入查找"></a>3、插入查找</h3><p>​    插值查找是根据给定值key来确定进行比较的关键字ST. elem[i]. key的查找方法。 </p><p>​    令  $ i=\frac{key - ST.elem[1].key}{ST.elem[h].key - ST.elem[l]}(h - l + 1) $ ，其中ST.elem[l]和ST.elem[h] 别为有序表中具有最小关键字和最大关键字的记录。显然，这种插值查找只适于关键字均匀分布的表，在这种情况下，对表长较大的顺序表，其平均性能比折半査找好。</p><p>​    我的理解是，查值查找是在利用目标关键字在表中最小最大关键字之间的范围比例，来缺点要比较的元素的位置。</p><h3 id="4、Fibonacci查找"><a href="#4、Fibonacci查找" class="headerlink" title="4、Fibonacci查找"></a>4、Fibonacci查找</h3><p>​    斐波那契査找是根据斐波那契序列的特点对表进行分割的。假设开始时表中记录个数比某个裴波那契数小1，即$n = F_u - 1$ 然后将给定值key和ST. elem[$F_{u-1}$]. key进行比较，若相等，则査找成功；若key&lt;ST. elem[$F_{u-1}$]. key，则继续在自ST. elem[1]至 ST.elem[$F_{u-1} - 1$]的子表中进行査找，否则继续在自ST. elem[$F_{u-1} + 1$]至ST. elem[$F_u - 1$]的子表中进行査找，后一子表的长度为$F_{u-2} - 1$。斐波那契査找的平均性能比折 半査找好，但最坏情况下的性能（虽然仍是$O(\log n)$却比折半査找差。它还有一个优点 就是分割时只需进行加、减运算。</p><p>​    菲波那切序列可以定义为： $F_0 = 0, F_1 = 1, F_i = F_{i-1}+F_{i-2}, i\ge 2$</p><h2 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h2><h3 id="0-动态规划思想"><a href="#0-动态规划思想" class="headerlink" title="0.  动态规划思想"></a>0.  动态规划思想</h3><p>​    通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。</p><p><strong>动态规划中递推式的求解方法不是动态规划的本质。</strong></p><ol start="0"><li>动态规划的本质，是对问题状态的定义和状态转移方程的定义。<br>引自维基百科</li></ol><blockquote><p><strong>dynamic programming</strong> is a method for solving a complex problem by <strong>breaking it down into a collection of simpler subproblems</strong>.</p></blockquote><p>​    动态规划是通过<strong>拆分问题，</strong>定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>    本题下的其他答案(<em>这个资料搜集于知乎上的一个问题</em>)，大多都是在说递推的求解方法，但<strong>如何拆分问题</strong>，才是动态规划的核心。<br>    而<strong>拆分问题</strong>，靠的就是<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong>。</p><p>1.  什么是<strong>状态的定义？</strong></p><p>​    <strong>首先想说大家千万不要被下面的数学式吓到，这里只涉及到了函数相关的知识</strong>。我们先来看一个动态规划的教学必备题：</p><blockquote><p>给定一个数列，长度为N，<br>求这个数列的最长上升（递增）子数列（LIS）的长度.<br>以<br>1 7 2 8 3 4<br>为例。<br>这个数列的最长递增子数列是 1 2 3 4，长度为4；<br>次长的长度为3， 包括 1 7 8; 1 2 3 等.</p></blockquote><p>​    要解决这个问题，我们首先要<strong>定义这个问题</strong>和这个问题的子问题。<br>    有人可能会问了，题目都已经在这了，我们还需定义这个问题吗？需要，原因就是这个问题在字面上看，找不出子问题，而没有子问题，这个题目就没办法解决。</p><p>​    所以我们来重新定义这个问题：</p><blockquote><p>给定一个数列，长度为N，<br>设$F_{k}$为：以数列中第k项结尾的最长递增子序列的长度.<br>求$F_{1}..F_{N}$ 中的最大值.</p></blockquote><p>​    显然，这个新问题与原问题等价。<br>    而对于$F_{k}$来讲，$[F_{1} .. F_{k-1}$都是$F_{k}$的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第$1..k-1$中某项结尾的LIS。</p><p>​    上述的新问题$F_{k}$也可以叫做状态，定义中的$F_{k}$为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。<br>    之所以把$F_{k}$做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。</p><p>​    <strong>对状态的定义只有一种吗？<em>当然不是</em>。</strong><br>    我们甚至可以二维的，以完全不同的视角定义这个问题：</p><blockquote><p>给定一个数列，长度为N，<br>设$F_{i, k}$为：<br>在前i项中的，长度为k的最长递增子序列中，最后一位的最小值. $1\leq k\leq N$.<br>若在前i项中，不存在长度为k的最长递增子序列，则$F_{i, k}$为正无穷.<br>求最大的x，使得<strong>$F_{N,x}$</strong>不为正无穷。</p></blockquote><p>​    这个新定义与原问题的等价性也不难证明，请读者体会一下。<br>    上述的$F_{i, k}$就是状态，定义中的”$F_{i, k}$为：在前i项中，长度为k的最长递增子序列中，最后一位的最小值”就是对状态的定义。</p><p>2.  什么是<strong>状态转移方程</strong>？<br>    上述状态定义好之后，状态和状态之间的关系式，就叫做<strong>状态转移方程。</strong>比如，对于LIS问题，我们的第一种定义：</p><blockquote><p>设<img src="https://www.zhihu.com/equation?tex=F_%7Bk%7D" alt="F_{k}">为：以数列中第k项结尾的最长递增子序列的长度.</p></blockquote><p>设A为题中数列，状态转移方程为：</p><blockquote><p>$F_{1} = 1$ （根据状态定义导出边界情况）<br>$F_{k}=max(F_{i}+1 | A_{k}&gt;A_{i}, i\in (1..k-1)) (k&gt;1)$</p></blockquote><p>​    用文字解释一下是：<br>    以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。</p><p>​    第二种定义：</p><blockquote><p>设$F_{i, k}$为：在数列前i项中，长度为k的递增子序列中，最后一位的最小值</p></blockquote><p>​    设A为题中数列，状态转移方程为：</p><blockquote><p>若$A_{i}&gt;F_{i-1,k-1}$则$F_{i,k}=min(A_{i},F_{i-1,k})$<br>否则：$F_{i,k}=F_{i-1,k} $</p></blockquote><p>​    边界情况需要分类讨论较多，在此不列出，需要根据状态定义导出边界情况。）大家套着定义读一下公式就可以了，应该不难理解，就是有点绕。</p><p>​    这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。可以看出，状态转移方程就是带有条件的递推式。</p><p><strong>3. 动态规划迷思</strong><br>    本题下其他用户的回答跟动态规划都有或多或少的联系，我也讲一下与本答案的联系。</p><p>​    a. “缓存”，“重叠子问题”，“记忆化”：<br>    这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。<br>    上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。<strong>都不是动态规划的本质，**</strong>不是动态规划的核心。**</p><p>​    b. “递归”：<br>    递归是递推式求解的方法，连技巧都算不上。</p><p>​    c. “无后效性”，“最优子结构”：<br>    上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是”无后效性”的通俗上的数学定义，符合这种定义的状态定义，我们可以说它具有“最优子结构”的性质，在动态规划中我们要做的，就是找到这种“最优子结构”。</p><p>​    <strong>在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。对状态和“最优子结构”的关系的进一步解释，<a href="https://www.zhihu.com/question/23995189/answer/35429905" target="_blank" rel="noopener">什么是动态规划？动态规划的意义是什么？ - 王勐的回答</a> 写的很好，可以去读一下。</strong></p><p>​    需要注意的是，一个问题可能有多种不同的状态定义和状态转移方程定义，存在一个有后效性的定义，<strong>不代表该问题不适用动态规划</strong>。这也是其他几个答案中出现的逻辑误区：<br>    动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义<strong>，</strong>在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。</p><p>​    文艺的说，<strong>动态规划是寻找一种对问题的观察角度，让问题能够以递推（或者说分治）的方式去解决</strong>。寻找看问题的角度，才是动态规划中最耀眼的宝石！（大雾）</p><p>​    一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！</p><p>​    每个阶段只有一个状态-&gt;递推；<br>    每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>    每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>    每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p><blockquote><p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到</p></blockquote><p>这个性质叫做最优子结构；</p><blockquote><p>而不管之前这个状态是如何得到的</p></blockquote><p>这个性质叫做无后效性。</p><p>​    另：其实动态规划中的最优状态的说法容易产生误导，以为只需要计算最优状态就好，LIS问题确实如此，转移时只用到了每个阶段“选”的状态。但实际上有的问题往往需要对每个阶段的所有状态都算出一个最优值，然后根据这些最优值再来找最优状态。比如背包问题就需要对前i个包（阶段）容量为j时（状态）计算出最大价值。然后在最后一个阶段中的所有状态种找到最优值。</p><p><strong>优化动态规划的方法：</strong></p><ol><li>递归求解</li><li>备忘录算法（记忆法）</li><li>逆向递推</li></ol><p><strong>总结：</strong>动态规划主要在于拆分问题，也就是说怎样定义子问题（<strong>定义状态</strong>），还有就是定义<strong>状态转移方程</strong>。</p><p>参考资料： <a href="https://www.zhihu.com/question/23995189" target="_blank" rel="noopener">什么是动态规划？动态规划的意义是什么？</a></p><p>​          <a href="http://www.sohu.com/a/153858619_466939" target="_blank" rel="noopener">漫画：什么是动态规划？</a></p><h3 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.  背包问题"></a>1.  背包问题</h3><p><strong>题目</strong></p><p>​    有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p><p><strong>实际题目</strong></p><p>​    01背包问题描述：有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，每件物品数量只有一个，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？</p><p><strong>基本思路</strong></p><p>​    这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p><p>​    用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：<br>$$<br>f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}<br>$$</p><p>​    这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只牵扯前$i-1$件物品的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为v的背包中”，价值为$f[i-1][v]$；如果放第i件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-c[i]$的背包中”，此时能获得的最大价值就是$f[i-1][v-c[i]]$再加上通过放入第i件物品获得的价值$w[i]$。</p><p><strong>优化空间复杂度</strong></p><p>以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。</p><p>先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：</p><p>for i=1..N</p><p>​    for v=V..0</p><p>​        f[v]=max{f[v],f[v-c[i]]+w[i]};</p><p>​    其中的f[v]=max{f[v],f[v-c[i]]+w[i]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题<a href="http://www.cnblogs.com/yangcl/admin/Pack/Pack/P02.html" target="_blank" rel="noopener">P02</a>最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。</p><p>​    事实上，使用一维数组解01背包的程序在后面会被多次用到，所以这里抽象出一个处理一件01背包中的物品过程，以后的代码中直接调用不加说明。</p><p>​    过程ZeroOnePack，表示处理一件01背包中的物品，两个参数cost、weight分别表明这件物品的费用和价值。</p><p>procedure ZeroOnePack(cost,weight)</p><p>​    for v=V..cost</p><p>​        f[v]=max{f[v],f[v-cost]+weight}</p><p>​    注意这个过程里的处理与前面给出的伪代码有所不同。前面的示例程序写成v=V..0是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。费用为cost的物品不会影响状态f[0..cost-1]，这是显然的。</p><p>​    有了这个过程以后，01背包问题的伪代码就可以这样写：</p><p>for i=1..N</p><p>​    ZeroOnePack(c[i],w[i]);</p><p><strong>初始化的细节问题</strong></p><p>​    我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</p><p>​    如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。</p><p>​    如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。</p><p>​    为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。</p><p>​    这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。</p><p><strong>小结</strong></p><p>​    01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><p>参考资料以及其他类型的背包问题参见：<a href="https://blog.csdn.net/u011439362/article/details/9612127" target="_blank" rel="noopener">dd_engi 的背包九讲</a></p><h3 id="2-最长公共子序列（不连续）-LCS-Longest-Common-Subsequence-，"><a href="#2-最长公共子序列（不连续）-LCS-Longest-Common-Subsequence-，" class="headerlink" title="2.  最长公共子序列（不连续）(LCS, Longest Common Subsequence)，"></a>2.  最长公共子序列（不连续）(LCS, Longest Common Subsequence)，</h3><p>找两个字符串的最长公共子串，这个子串要求在原字符串中是连续的。而最长公共子序列则并不要求连续。</p><p>cnblogs与belong，最长公共子序列为blog（cnblogs, belong），最长公共子串为lo（cnblogs, belong）</p><p>这两个问题都是用空间换空间，创建一个二维数组来记录之前的每个状态</p><p>参考：<a href="http://www.cnblogs.com/en-heng/p/3963803.html" target="_blank" rel="noopener">【动态规划】最长公共子序列与最长公共子串</a></p><p>​           <a href="http://blog.csdn.net/chengonghao/article/details/51913108" target="_blank" rel="noopener">C++实现最长公共子序列和最长公共子串</a></p><p><strong>状态转移方程：</strong></p><p>​    用i，j遍历两个子串x,y，如果两个元素相等就+1 ，不等就用上一个状态最大的元素<br>$$<br>c[i, j] = \begin{cases}<br>        0,    &amp;  i=0 \mbox{ or } j=0 \<br>        c[i-1,  j-1]+1  &amp;   i,j \gt 0 \mbox{ and } x_i = y_i   \<br>        \max (c[i, j-1], c[i-1, j])  &amp;  i,j \gt 0 \mbox{ and } x_i \ne y_i<br>    \end{cases}<br>$$<br><strong>实现代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">    <span class="keyword">int</span> c[][] = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                c[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str1.charAt(i-<span class="number">1</span>) == str2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c[i][j] = max(c[i - <span class="number">1</span>][j], c[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-最长公共子串（连续）"><a href="#3-最长公共子串（连续）" class="headerlink" title="3.  最长公共子串（连续）"></a>3.  最长公共子串（连续）</h3><p>​    区别就是因为是连续的，如果两个元素不等，那么就要=0了而不能用之前一个状态的最大元素</p><p>​    状态转移方程如下：<br>$$<br>c[i, j] = \begin{cases}<br>        0    &amp;    i = 0 \mbox{ or } j =0 \<br>        c[i-1, j-1] + 1   &amp; x_i = u_j \<br>        0    &amp;    x_i \ne y_i<br>    \end{cases}<br>$$</p><p><strong>实现代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs2</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">    <span class="keyword">int</span> max_long = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_long_i = -<span class="number">1</span>;    <span class="comment">//记录找到最长公共子串时的坐标</span></span><br><span class="line">    <span class="keyword">int</span> max_long_j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2+<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                c[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1.charAt(i-<span class="number">1</span>) == str2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c[i][j] &gt; max_long)&#123; <span class="comment">//更新最长记录</span></span><br><span class="line">                        max_long = c[i][j];</span><br><span class="line">                        max_long_i = i;</span><br><span class="line">                        max_long_j = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    c[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>((max_long_i&gt;<span class="number">0</span> &amp;&amp; max_long_j&gt;<span class="number">0</span>)&amp;&amp;c[max_long_i][max_long_j] != <span class="number">0</span>)&#123;</span><br><span class="line">        sb.append(str1.charAt(max_long_i-<span class="number">1</span>));</span><br><span class="line">        max_long_i --;</span><br><span class="line">        max_long_j --;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"找到的最长公共子串为 ： "</span>+sb.reverse().toString());</span><br><span class="line">    <span class="keyword">return</span> max_long;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-最优二分检索树"><a href="#4-最优二分检索树" class="headerlink" title="4.   最优二分检索树"></a>4.   最优二分检索树</h3><p><strong>问题描述</strong></p><p>​    首先看个例子，如果有S = {5,7,10,12,14,15,18}，我们可以构建一个二分搜索树，所谓二分搜索树（Binary Search Tree），就或者是一棵空树，或者是具有下列性质的二分树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二分搜索树。现在，我们可以构建一下两种树：</p><p><img src="\image\算法\最优二分搜索树-问题描述图.gif" alt="优二分搜索树-问题描述"></p><p>​    现在问题来了，如果在我们的搜索中15~18范围搜索的次数为80%，节点5的搜索次数为10%，其余的节点和节点以外的范围搜索次数频率相等，共计10%。显而易见，两种不同结构的二分搜索树的效率大不一样。在此，结合每个搜索到的节点和范围的频率（记为p[1：n]，q[0：n]）我们给出搜索树的总耗费公式为：<br>$$<br>\sum_{l=i+1}^{j} \mathbf{p_l}(depth(\mathbf{a_l}) + 1) \mathbf{+} \sum_{l=i}^{j}\mathbf{q_l}(depth(\mathbf{b_l}))<br>$$<br>      这里depth(a~l~)为a~l~在该树中的深度，depth(b~l~)为b~l~在该树中的深度。</p><p>​    如今的问题就是，对于一个给定的序列，{b~0~，a~1~，b~1~……a~n~，b~n~}，其中a~1~，a~2~……a~n~是实节点，b~0~，b~1~，b~2~……b~n~是虚节点（就是二分搜索树最终找不到实节点的范围），如何找出并构建一个总耗费最小的二分搜索树？</p><p><strong>问题求解</strong></p><p>​    分析：</p><p>​    假定T~0~是棵最优二分搜索树，它的根是a~k~（第k小的数）。则a~k~的左子树中必然包含了{a~1~…a~k-1~， a~k~的右子树中必然包含了{a~k+1~…a~n~}。而且，左子树一定是关于{a~1~…a~k-1~的最优二分搜索树，右子树一定是关于{a~k+1~…a~n~}的最优二分搜索树。（否则，用更优的子树代替当前的子树，其总耗费比T~0~的更小，矛盾。）</p><p>​       现在考虑二分搜索树问题的性质，</p><p>​       ① 根据二分搜索树的性质，任何一棵子树中结点的编号都是连续的。而且，最优树中的任何一棵子树，也必然是关于子树中结点的最优树。因此，最优二分搜索树具有最优子结构性质。</p><p>​       ② 这样，若规模为m≤n-1的最优子树均已知，就可以通过逐一计算以a~1~，a~2~，…，a~n~为根的树的耗费，来确定（使耗费达到最小的）根a~k~并找出最优二分搜索树。</p><p>​       在上述计算中，规模较小的最优子树在计算中要多次被用到，故该问题具有高度重复性。</p><p>​       综合 ①和②的特性，我们就考虑动态规划来求解这个问题。</p><p>​    在所有由结点b~i~，a~i+1~，b~i+1~，…，a~j~，b~j~构成的树中，把耗费最小的树记为T~ij~。（注意该树中不含a~i~但含b~i~）。</p><p>​       若由结点b~i~，a~i+1~，b~i+1~，…，a~j~，b~j~构成的树以a~k~作为根 (i+1≤k≤j)，</p><p>​           则b~i~，a~i+1~，b~i+1~，…，a~k-1~，b~k-1~必然在其左子树中，</p><p>​           则b~k~，a~k+1~，b~k+1~，…，a~j~，b~j~必然在其右子树中，</p><p>​       以a~k~为根的树有很多，但其中耗费最小的树必然是以T~i,k-1~为其左子树，以T~k,j~为其右子树。</p><p>​       记c~ij~是最优子树T~ij~的耗费， 则c~i,k-1~是最优子树T~i,k-1~的耗费，c~k,j~是最优子树T~k,j~的耗费。</p><p>​       考察以a~k~ (i+1≤k≤j)为根、由结点b~i~，a~i+1~，b~i+1~，…，a~j~，b~j~构成的、耗费最小的树的总耗费：根据上述讨论，</p><p>该树的左子树必然是T~i,k-1~，右子树必然是T~k,j~ 。该树的总耗费可分为三部分：左子树、右子树和根所产生的耗费。</p><p>​       紧接着就将T~i,k-1~和T~k,j~接到a~k~上，此处与每个左右子树中节点来说，搜索的耗费都增加了，因为每个节点的深度都增加了1，因此，引入一个公式，来表示子树在接入根节点的时候增加的耗费，<br>$$<br>\bf \sum_{l=i+1}^{j}p_l + \sum_{l=i}^{j} q_l = q_i + p_{i+1}+q_{i+1}+…+(p_j + q_j)<br>$$<br>​    由于T~i,k-1~作为左子树接到结点a~k~之下时，其耗费增加w~i,k-1~，故左子树的耗费为：c~i,k-1~+ w~i,k-1~，</p><p>​    同理，右子树的耗费为：c~k,j~+w~k,j~，</p><p>​        由于根a~k~的深度为0，按定义，根的耗费为p~k~。</p><p>​        因此，以a~k~ 为根、耗费最小的树的总耗费为：c~i,k-1~+ w~i,k-1~+c~kj~+w~k,j~+p~k~。</p><p>​        注意到，</p><p>​                   w~i,k-1~=q~i~+p~i+1~+q~i+1~+…+p~k-1~+q~k-1~，</p><p>​                   w~k,j~=q~k~+p~k+1~+q~k+1~+…+p~j~+q~j~，</p><p>​        从而有w~i,k-1~+w~kj~+p~k~ = q~i~+p~i+1~+q~i+1~+…+p~k-1~+q~k-1~+ p~k~ +q~k~+p~k+1~+q~k+1~+…+p~j~+q~j~ = w~ij~。</p><p>​    由此得到, 以a~k~ 为根、耗费最小的树的总耗费为：c~i,k-1~+c~kj~+w~i,j~由于p~i~（i=1,2,…,n）和 q~j~（j=0,1,2,…,n）在初始时已经知道，因此若w~i,j-1~已知，则根据w~i,j~= w~i,j-1~+p~j~ + q~j~可以计算出w~ij~。故当c~i,k-1~与c~kj~已知时，以a~k~ 为根的树的最小总耗费在O(1)时间就可以计算出来。</p><p>​        这样，分别计算以a~i+1~，a~i+2~，…，a~j~为根、含有结点b~i~，a~i+1~，b~i+1~，…，a~j~，b~j~的树的最小总耗费，再从中选出耗费最小的树，即可得最优子树T~ij~。</p><p>​        因此，最优子树Tij的耗费c~ij~= {c~i,k-1~+c~kj~+w~ij~}, 其中k使得c~ij~最小。</p><p><strong>算法描述</strong></p><p> 递推求c~ij~及记录T~ij~的根的算法</p><p>​        初始时 w~ii~←q~i~(i=1,2,…,n)；c~ii~←0；/*∵空树T~ii~耗费为0（i=1,2,…,n）。*/</p><p>​        for l←1 to n do /*计算规模为l（树中真实结点个数）的最优二分搜索树，从含1个结点直算到含n个结点*/</p><p>​            { for i←0 to n-l do    /*真实结点个数为l个的树共有(n-l+1)个，i为树中结点起始下标，从0直到n-l。*/</p><p>​                 {   j←i+l;                     /* j为树中最后一个结点的下标*/</p><p>​                     w~i,j~←w~i,j-1~+p~j~ + q~j~ ;  /*计算出规模为l (l=j-i)、当前所需的w~i,j~*/</p><p>​                     c~ij~← {c~i,k-1~+c~kj~+w~ij~};    /*在前一轮或前几轮，规模小的c~i,k-1~和c~kj~已计算出来了*/</p><p>​                     r~ij~←k’;      /*k’为使得{c~i,k-1~+c~kj~+w~ij~}为最小的k值*/</p><p>​                  }                 /*即ak’是最优子树T~ij~的根，记录在案*/</p><p>​             }</p><p>构建最优二分搜索树，</p><p>​        设T~ij~的根为a~k~ (r~ij~记录到的值是k)，则从根开始建结点。</p><p>​        Build-tree(i,j,r,A)                    /*建立最优子树T~ij~*/</p><p>​        {</p><p>​           If i≥j return null;</p><p>​           pointer←newnode(nodetype);</p><p>​           k←r~ij~;                               /*必有i &lt; k ≤j*/</p><p>​           pointer_key-value←A[k];             /*A[k]即ak*/</p><p>​           pointer_leftson←Buildtree(i,k-1,r,A); /*建立最优左子树Ti,k-1*/</p><p>​           pointer_rightson←Buildertree(k,j,r,A); /*建立最优右子树Tk,j*/</p><p>​           return pointer;</p><p>​        }</p><p>​        调用Build-tree(0,n,r,A)则可以建成最优二分搜索树。</p><p> <strong>实现代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimalBinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span>[] A = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] P = &#123;<span class="number">0</span>,<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] Q = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        buildBinarySearchTree(A, P, Q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildBinarySearchTree</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] p, <span class="keyword">int</span>[] q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] W = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] C = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] T = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//initial tabs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            W[i][i]=q[i];</span><br><span class="line">            C[i][i]= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意：W[i][j]代表是b[i],a[i+1],b[i+1],...,a[j],b[j]构成的最优二分搜索树，两头一定是虚节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>; l&lt;=n; l++)&#123;<span class="comment">//L代表子最优二分搜索树的元素个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-l; i++) &#123; <span class="comment">//最优二分搜索树的起始位置</span></span><br><span class="line">                <span class="keyword">int</span> j = i+l;</span><br><span class="line">                <span class="comment">//找到最小的代价的那个根节点</span></span><br><span class="line">                W[i][j] = W[i][j-<span class="number">1</span>] + p[j] + q[j];</span><br><span class="line">                <span class="keyword">int</span> index = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp_cost = C[i][i] + C[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">2</span>; k&lt;= j; k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = C[i][k-<span class="number">1</span>] + C[k][j];</span><br><span class="line">                    <span class="keyword">if</span>( tmp &lt; tmp_cost)&#123;</span><br><span class="line">                        tmp_cost = tmp;</span><br><span class="line">                        index = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                T[i][j] = index;</span><br><span class="line">                C[i][j] =tmp_cost + W[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"cost=%d,root=%d\n"</span>,C[<span class="number">0</span>][n],T[<span class="number">0</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-最优子结构"><a href="#5-最优子结构" class="headerlink" title="5.   最优子结构"></a>5.   最优子结构</h3><p>​    最优子结构是<strong>依赖特定问题</strong>和<strong>子问题的分割方式</strong>而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。</p><p>​    比如求广州到北京的最短距离，假设这个路径必经过中间的南京，那么先把路径分割为（广州，南京）和（南京，北京）。分别求出子路径的最短距离然后再连接，就可以得到广州到北京的最短路径。</p><p>​    因此，寻求最短路径的问题可以利用子路径的最优解获得整个问题的最优解。这样就可以证明，最短路径具有最优子结构。</p><ul><li>当然最长递增（LIS）</li></ul><p>​    反之，<strong>如果不能利用子问题的最优解获得整个问题的最优解，那么这种问题就不具有最优子结构。</strong></p><p>​    很多问题的最优子结构都表现出<strong>非常直观</strong>的形式，以至于都不需要另外的证明过程。不过，遇到结构不是很直观的问题时，则需要用<strong>反证法</strong>证明（假设子问题的最优解不是整个问题的最优解 ⇒ ?）。</p><h2 id="五、数论问题"><a href="#五、数论问题" class="headerlink" title="五、数论问题"></a>五、数论问题</h2><h3 id="1-素数问题"><a href="#1-素数问题" class="headerlink" title="1.  素数问题"></a>1.  素数问题</h3><p><strong>(1) 朴素判断素数算法</strong></p><p>​    就判断素数而言，事实上是非常简单的了。根据定义，判断一个整数n是否是素数，只需要去判断在整数区间[2, n-1]之内，是否具有某个数m，使得n % m == 0。代码可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;<span class="comment">//如果在1和n之间还找到了另外一个约数，那么n就不是素数</span></span><br><span class="line">            retrun <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    事实上，假如n除了1和它本身外还有约数a*b=n，那么a或者b一定是小于等于$\sqrt{n}$的，不可能两个约数都大于$\sqrt{n}$，所以只需要检查到$i=\sqrt{n}$就行了。时间复杂度可以从O(n)降低到$O(\sqrt{n})$。代码可以写成下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    原理很巧妙，也仅仅是把代码的i &lt; n变成了i * i &lt;= n而已，但是优化却是极其高的。可能你会注意到，在上一份代码里面，我定义的n为int类型，而后面一份代码，我却定义成了long long，这是因为在1s内，上一份代码能判断出来的数量级为1e8，而后面一份代码判断出来的数量级却几乎可以达到1e16</p><p>​    这个方法也可以称作试除法。</p><p><strong>(2) 筛选法</strong></p><p>​    上面介绍的一些素数判断的算法，在某些问题是基本可以适用的了。但是对于另外一类问题却十分尴尬。比如问你整数区间[1, n]内的素数个数是多少。这个时候如果一个个枚举，一个个判断，对于朴素方法来说，最优也是O(nsqrt(n))，即使是Miller_Rabin算法也无法在O(n)的时间内得到结果。于是就有了埃氏筛选法（埃拉托斯特尼筛法）。</p><p>​    对于筛选整数n以内的素数，算法是这么描述的：先把素数2的倍数全部删除，剩下的数第一个为3，再把素数3的倍数全部删除，剩下的第一个数为5，再把素数5的倍数全部删除······直到把n以内最后一个素数的倍数删除完毕，得到n以内的所有素数。代码可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span>[] prime = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index_prime = <span class="number">0</span>;    <span class="comment">//用于在prime中记录找到的素数</span></span><br><span class="line">    prime[<span class="number">1</span>] = -<span class="number">1</span>;<span class="comment">//-1表示不是素数，0表示是素数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i] == -<span class="number">1</span>) &#123;<span class="comment">//不是素数</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//是素数</span></span><br><span class="line">            prime[index_prime++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= n; j++) &#123;</span><br><span class="line">                prime[i * j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index_prime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    而事实上，观察可以发现，上面的这种写法有很多次重复计算，这样显然无法做到线性筛选，而另外一种写法却可以得到线性筛选，达到时间复杂度为O(n)，代码可以这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] prime = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//-1表示是合数，0表示素数</span></span><br><span class="line"><span class="keyword">int</span> index_prime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(prime[i] != -<span class="number">1</span>)&#123;<span class="comment">//i不是合数，即i是素数</span></span><br><span class="line">        prime[index_prime++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; index_prime &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">        prime[i*prime[j]] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)&#123;  <span class="comment">//这if判断是为了确保对于一个合数，只会有一种乘积方式来求得。主要是为了避免重复计算</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> index_prime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​    上面这段代码主要优化的地方在于去除重复计算，可以坐到对于每一个数字都只会扫描并判断一次，所以才能达到线性时间复杂度O(n)。</p><h3 id="2-整数问题"><a href="#2-整数问题" class="headerlink" title="2.  整数问题"></a>2.  整数问题</h3><h3 id="3-进制转换"><a href="#3-进制转换" class="headerlink" title="3. 进制转换"></a>3. 进制转换</h3><p>​    各种进制之间相互转换，一个基本的方法就是，就是先把原来的进制数据转换成为十进制数，然后再从十进制数据转换成为目标进制数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> old_scale, <span class="keyword">final</span> String old_value, <span class="keyword">final</span> <span class="keyword">int</span> new_scale)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[]  num_2_char = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    StringBuilder new_value = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//1. 先把旧的进制数据转换成十进制表示</span></span><br><span class="line">    <span class="keyword">int</span> old_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; old_value.length(); i++) &#123;</span><br><span class="line">        old_num = old_num*old_scale + digit(old_value.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println("解析到的旧数值（十进制）为："+old_num);</span></span><br><span class="line">    <span class="comment">//2. 将十进制表示的数据再转换成目进制数据</span></span><br><span class="line">    <span class="keyword">while</span>(old_num!=<span class="number">0</span>)&#123;</span><br><span class="line">        new_value.append(num_2_char[old_num%new_scale]);</span><br><span class="line">        old_num = old_num/new_scale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_value.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">digit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'0'</span> : c_value = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'1'</span> : c_value = <span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'2'</span> : c_value = <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'3'</span> : c_value = <span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'4'</span> : c_value = <span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'5'</span> : c_value = <span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'6'</span> : c_value = <span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'7'</span> : c_value = <span class="number">7</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'8'</span> : c_value = <span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'9'</span> : c_value = <span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'A'</span> : <span class="keyword">case</span> <span class="string">'a'</span> : c_value = <span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'B'</span> : <span class="keyword">case</span> <span class="string">'b'</span> : c_value = <span class="number">11</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span> : <span class="keyword">case</span> <span class="string">'c'</span> : c_value = <span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span> : <span class="keyword">case</span> <span class="string">'d'</span> : c_value = <span class="number">13</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'E'</span> : <span class="keyword">case</span> <span class="string">'e'</span> : c_value = <span class="number">14</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'F'</span> : <span class="keyword">case</span> <span class="string">'f'</span> : c_value = <span class="number">15</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"字符非法"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同余模运算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;&lt;center&gt;算法&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;常见算法&quot;&gt;&lt;a href=&quot;#常见算法&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="编程高级知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程思想" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统</title>
    <link href="http://yoursite.com/2018/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/02/16/计算机操作系统/</id>
    <published>2018-02-16T14:45:31.000Z</published>
    <updated>2018-07-04T12:01:41.972Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一-概述">一、 概述</a><ul><li><a href="#操作系统基本特征">操作系统基本特征</a></li><li><a href="#操作系统基本功能">操作系统基本功能</a></li><li><a href="#系统调用">系统调用</a></li><li><a href="#大内核和微内核">大内核和微内核</a></li><li><a href="#中断分类">中断分类</a></li></ul></li><li><a href="#二进程管理">二、进程管理</a><ul><li><a href="#进程与线程">进程与线程</a></li><li><a href="#进程状态的切换">进程状态的切换</a></li><li><a href="#调度算法">调度算法</a></li><li><a href="#进程同步">进程同步</a></li><li><a href="#经典同步问题">经典同步问题</a></li><li><a href="#进程通信">进程通信</a></li></ul></li><li><a href="#三死锁">三、死锁</a><ul><li><a href="#死锁的必要条件">死锁的必要条件</a></li><li><a href="#死锁的处理方法">死锁的处理方法</a></li></ul></li><li><a href="#四内存管理">四、内存管理</a><ul><li><a href="#虚拟内存">虚拟内存</a></li><li><a href="#分页与分段">分页与分段</a></li><li><a href="#分页系统地址映射">分页系统地址映射</a></li><li><a href="#页面置换算法">页面置换算法</a></li></ul></li><li><a href="#五设备管理">五、设备管理</a><ul><li><a href="#磁盘调度算法">磁盘调度算法</a></li></ul></li><li><a href="#六链接">六、链接</a><ul><li><a href="#编译系统">编译系统</a></li><li><a href="#目标文件">目标文件</a></li><li><a href="#静态链接">静态链接</a></li><li><a href="#动态链接">动态链接</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h1><h2 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><p>并发性是指宏观上在一段时间内能同时运行多个程序，而并行性则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线或者多处理器。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><p>共享是指系统中的资源可以供多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。</p><h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时分复用技术和空分复用技术。例如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</p><h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h2 id="操作系统基本功能"><a href="#操作系统基本功能" class="headerlink" title="操作系统基本功能"></a>操作系统基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><p>内存分配、地址映射、内存保护与共享和内存扩充等功能。</p><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><p>文件存储空间的管理、目录管理及文件读写管理和保护等。</p><h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虛拟设备等功能。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><div align="center"> <img src="/image/pics//tGPV0.png" width="600"> </div><br></p><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th style="text-align:center">Task</th><th>Commands</th></tr></thead><tbody><tr><td style="text-align:center">进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td style="text-align:center">进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td style="text-align:center">文件操作</td><td>open(); read(); write();</td></tr><tr><td style="text-align:center">设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td style="text-align:center">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td style="text-align:center">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><h3 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h3><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><p><div align="center"> <img src="/image/pics//2_14_microkernelArchitecture.jpg"> </div><br></p><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 结束中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p><h1 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>进程是资源分配的基本单位。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><div align="center"> <img src="/image/pics//a6ac2b08-3861-4e85-baa8-382287bfee9f.png"> </div><br></p><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>线程是独立调度的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p><div align="center"> <img src="/image/pics//3cd630ea-017c-488d-ad1d-732b4efeddf5.png"> </div><br></p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><ul><li><p>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p></li><li><p>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p></li><li><p>通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p></li></ul><p>举例：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><div align="center"> <img src="/image/pics//ProcessState.png" width="500"> </div><br></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>需要针对不同环境来讨论调度算法。</p><h3 id="1-批处理系统中的调度"><a href="#1-批处理系统中的调度" class="headerlink" title="1. 批处理系统中的调度"></a>1. 批处理系统中的调度</h3><h4 id="1-1-先来先服务"><a href="#1-1-先来先服务" class="headerlink" title="1.1 先来先服务"></a>1.1 先来先服务</h4><blockquote><p>first-come first-serverd（FCFS）</p></blockquote><p>调度最先进入就绪队列的作业。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><h4 id="1-2-短作业优先"><a href="#1-2-短作业优先" class="headerlink" title="1.2 短作业优先"></a>1.2 短作业优先</h4><blockquote><p>shortest job first（SJF）</p></blockquote><p>调度估计运行时间最短的作业。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><h4 id="1-3-最短剩余时间优先"><a href="#1-3-最短剩余时间优先" class="headerlink" title="1.3 最短剩余时间优先"></a>1.3 最短剩余时间优先</h4><blockquote><p>shortest remaining time next（SRTN）</p></blockquote><h3 id="2-交互式系统中的调度"><a href="#2-交互式系统中的调度" class="headerlink" title="2. 交互式系统中的调度"></a>2. 交互式系统中的调度</h3><h4 id="2-1-优先级调度"><a href="#2-1-优先级调度" class="headerlink" title="2.1 优先级调度"></a>2.1 优先级调度</h4><p>除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。</p><p>响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间</p><p>这种调度算法主要是为了解决短作业优先调度算法长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。</p><h4 id="2-2-时间片轮转"><a href="#2-2-时间片轮转" class="headerlink" title="2.2 时间片轮转"></a>2.2 时间片轮转</h4><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系。因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</p><h4 id="2-3-多级反馈队列"><a href="#2-3-多级反馈队列" class="headerlink" title="2.3 多级反馈队列"></a>2.3 多级反馈队列</h4><p><div align="center"> <img src="/image/pics//042cf928-3c8e-4815-ae9c-f2780202c68f.png"> </div><br></p><p>如果一个进程需要执行 100 个时间片，如果采用轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><h3 id="3-实时系统中的调度"><a href="#3-实时系统中的调度" class="headerlink" title="3. 实时系统中的调度"></a>3. 实时系统中的调度</h3><p>实时系统要求一个服务请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul><li>同步：多个进程按一定顺序执行；</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong>  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了  <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="3">  <strong>使用信号量实现生产者-消费者问题</strong>  </font> <br></p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 up(empty) 操作，empty 永远都为 0，那么生产者和消费者就会一直等待下去，造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。</p><p>管程引入了  <strong>条件变量</strong>  以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><p><font size="3"> <strong>使用管程实现生成者-消费者问题</strong> </font><br></p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><p>生产者和消费者问题前面已经讨论过了。</p><h3 id="1-读者-写者问题"><a href="#1-读者-写者问题" class="headerlink" title="1. 读者-写者问题"></a>1. 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-哲学家进餐问题"><a href="#2-哲学家进餐问题" class="headerlink" title="2. 哲学家进餐问题"></a>2. 哲学家进餐问题</h3><p><div align="center"> <img src="/image/pics//a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"> </div><br></p><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止死锁的发生，可以设置两个条件：</p><ol><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat();</span><br><span class="line">        put_tow(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    test(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_tow</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    test(LEFT);</span><br><span class="line">    test(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span> </span>&#123;         <span class="comment">// 尝试拿起两把筷子</span></span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="1-进程同步与进程通信的区别"><a href="#1-进程同步与进程通信的区别" class="headerlink" title="1. 进程同步与进程通信的区别"></a>1. 进程同步与进程通信的区别</h3><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><p>在进程同步中介绍的信号量也属于进程通信的一种方式，但是属于低级别的进程通信，因为它传输的信息非常小。</p><h3 id="2-进程通信方式"><a href="#2-进程通信方式" class="headerlink" title="2. 进程通信方式"></a>2. 进程通信方式</h3><h4 id="2-1-消息传递"><a href="#2-1-消息传递" class="headerlink" title="2.1 消息传递"></a>2.1 消息传递</h4><p>操作系统提供了用于通信的通道（Channel），进程可以通过读写这个通道进行通信。</p><p><div align="center"> <img src="/image/pics//037c3a0b-332d-434d-a374-f343ef72c8e1.jpg" width="400"> </div><br></p><p><font size="3">  <strong>（一）管道</strong>  </font><br></p><p>写进程在管道的尾端写入数据，读进程在管道的首端读出数据。管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</p><p>Linux 中管道通过空文件实现。</p><p>管道有三种：</p><ol><li>普通管道：有两个限制，一是只能单向传输；二是只能在父子进程之间使用；</li><li>流管道：去除第一个限制，支持双向传输；</li><li>命名管道：去除第二个限制，可以在不相关进程之间进行通信。</li></ol><p><div align="center"> <img src="/image/pics//7f642a65-b167-4c8f-b382-8322c6322b2c.jpg" width="400"> </div><br></p><p><font size="3">  <strong>（二）消息队列</strong>  </font><br></p><p>消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p><div align="center"> <img src="/image/pics//d49466db-fdd3-4d36-8a86-47dc45c07a1e.jpg" width="400"> </div><br></p><p><font size="3">  <strong>（三）套接字</strong>  </font><br></p><p>套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><p><div align="center"> <img src="/image/pics//699b4f96-d63f-46ea-a581-2b3d95eceb6a.jpg" width="400"> </div><br></p><h4 id="2-2-共享内存"><a href="#2-2-共享内存" class="headerlink" title="2.2 共享内存"></a>2.2 共享内存</h4><p>操作系统建立一块共享内存，并将其映射到每个进程的地址空间上，进程就可以直接对这块共享内存进行读写。</p><p>共享内存是最快的进程通信方式。</p><p><div align="center"> <img src="/image/pics//7be0abf9-687c-4451-becd-626b0be7ec22.jpg" width="400"> </div><br></p><h1 id="三、死锁"><a href="#三、死锁" class="headerlink" title="三、死锁"></a>三、死锁</h1><h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><p><div align="center"> <img src="/image/pics//c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"> </div><br></p><ol><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li><li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ol><h2 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h2><h3 id="1-鸵鸟策略"><a href="#1-鸵鸟策略" class="headerlink" title="1. 鸵鸟策略"></a>1. 鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="2-死锁检测与死锁恢复"><a href="#2-死锁检测与死锁恢复" class="headerlink" title="2. 死锁检测与死锁恢复"></a>2. 死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p><strong>（一）每种类型一个资源的死锁检测</strong> </p><p><div align="center"> <img src="/image/pics//b1fa0453-a4b0-4eae-a352-48acca8fff74.png"> </div><br></p><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>（二）每种类型多个资源的死锁检测</strong> </p><p><div align="center"> <img src="/image/pics//e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"> </div><br></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><p><strong>（三）死锁恢复</strong> </p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h3 id="3-死锁预防"><a href="#3-死锁预防" class="headerlink" title="3. 死锁预防"></a>3. 死锁预防</h3><p>在程序运行之前预防发生死锁。</p><p><strong>（一）破坏互斥条件</strong> </p><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><p><strong>（二）破坏占有和等待条件</strong> </p><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><p><strong>（三）破坏不可抢占条件</strong> </p><p><strong>（四）破坏环路等待</strong> </p><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h3 id="4-死锁避免"><a href="#4-死锁避免" class="headerlink" title="4. 死锁避免"></a>4. 死锁避免</h3><p>在程序运行时避免发生死锁。</p><p><strong>（一）安全状态</strong> </p><p><div align="center"> <img src="/image/pics//ed523051-608f-4c3f-b343-383e2d194470.png"> </div><br></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><p><strong>（二）单个资源的银行家算法</strong> </p><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><div align="center"> <img src="/image/pics//d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"> </div><br></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><p><strong>（三）多个资源的银行家算法</strong> </p><p><div align="center"> <img src="/image/pics//62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"> </div><br></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，也需要拒绝进入这个状态。</p><h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到一部分不在物理内存中的地址空间时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><h2 id="分页与分段"><a href="#分页与分段" class="headerlink" title="分页与分段"></a>分页与分段</h2><h3 id="1-分页"><a href="#1-分页" class="headerlink" title="1. 分页"></a>1. 分页</h3><p>大部分虚拟内存系统都使用分页技术。把由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。例如有一台计算机可以产生 16 位地址，它的虚拟地址空间为 0~64K，然而计算机只有 32KB 的物理内存，因此虽然可以编写 64KB 的程序，但它们不能被完全调入内存运行。</p><p><div align="center"> <img src="/image/pics//7b281b1e-0595-402b-ae35-8c91084c33c1.png"> </div><br></p><p>虚拟地址空间划分成固定大小的页，在物理内存中对应的单元称为页框，页和页框大小通常相同，它们之间通过页表进行映射。</p><p>程序最开始只将一部分页调入页框中，当程序引用到没有在页框的页时，产生缺页中断，进行页面置换，按一定的原则将一部分页框换出，并将页调入。</p><h3 id="2-分段"><a href="#2-分段" class="headerlink" title="2. 分段"></a>2. 分段</h3><p><div align="center"> <img src="/image/pics//22de0538-7c6e-4365-bd3b-8ce3c5900216.png"> </div><br></p><p>上图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><div align="center"> <img src="/image/pics//e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"> </div><br></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><p>每个段都需要程序员来划分。</p><h3 id="3-段页式"><a href="#3-段页式" class="headerlink" title="3. 段页式"></a>3. 段页式</h3><p>用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。</p><p>用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。</p><p>程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护。</p><h3 id="4-分页与分段区别"><a href="#4-分页与分段区别" class="headerlink" title="4. 分页与分段区别"></a>4. 分页与分段区别</h3><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p></li><li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p></li></ul><h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><ul><li>内存管理单元（MMU）：管理着虚拟地址空间和物理内存的转换。</li><li>页表（Page table）：页（虚拟地址空间）和页框（物理内存空间）的映射表。例如下图中，页表的第 0 个表项为 010，表示第 0 个页映射到第 2 个页框。页表项的最后一位用来标记页是否在内存中。</li></ul><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。因此对于虚拟地址（0010 000000000100），前 4 位是用来存储页面号，而后 12 位存储在页中的偏移量。</p><p>（0010 000000000100）根据前 4 位得到页号为 2，读取表项内容为（110 1），它的前 3 为为页框号，最后 1 位表示该页在内存中。最后映射得到物理内存地址为（110 000000000100）。</p><p><div align="center"> <img src="/image/pics//cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"> </div><br></p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h3 id="1-最佳"><a href="#1-最佳" class="headerlink" title="1. 最佳"></a>1. 最佳</h3><blockquote><p>Optimal</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1"></div> <br></p><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h3 id="2-先进先出"><a href="#2-先进先出" class="headerlink" title="2. 先进先出"></a>2. 先进先出</h3><blockquote><p>FIFO, First In First Out</p></blockquote><p>所选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p><h3 id="3-最近最久未使用"><a href="#3-最近最久未使用" class="headerlink" title="3. 最近最久未使用"></a>3. 最近最久未使用</h3><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>可以用栈来实现该算法，栈中存储页面的页面号。当进程访问一个页面时，将该页面的页面号从栈移除，并将它压入栈顶。这样，最近被访问的页面总是在栈顶，而最近最久未使用的页面总是在栈底。</p><p><div align="center"><img src="https://latex.codecogs.com/gif.latex?4，7，0，7，1，0，1，2，1，2，6"></div> <br></p><p><div align="center"> <img src="/image/pics//eb859228-c0f2-4bce-910d-d9f76929352b.png"> </div><br></p><h3 id="4-时钟"><a href="#4-时钟" class="headerlink" title="4. 时钟"></a>4. 时钟</h3><blockquote><p>Clock</p></blockquote><p>需要用到一个访问位，当一个页面被访问时，将访问位置为 1。</p><p>首先，将内存中的所有页面链接成一个循环队列，当缺页中断发生时，检查当前指针所指向页面的访问位，如果访问位为 0，就将该页面换出；否则将该页的访问位设置为 0，给该页面第二次的机会，移动指针继续检查。</p><p><div align="center"> <img src="/image/pics//5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"> </div><br></p><h1 id="五、设备管理"><a href="#五、设备管理" class="headerlink" title="五、设备管理"></a>五、设备管理</h1><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>当多个进程同时请求访问磁盘时，需要进行磁盘调度来控制对磁盘的访问。</p><p>磁盘调度的主要目标是使磁盘的平均寻道时间最少。</p><h3 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1. 先来先服务"></a>1. 先来先服务</h3><blockquote><p>FCFS, First Come First Served</p></blockquote><p>根据进程请求访问磁盘的先后次序来进行调度。优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h3 id="2-最短寻道时间优先"><a href="#2-最短寻道时间优先" class="headerlink" title="2. 最短寻道时间优先"></a>2. 最短寻道时间优先</h3><blockquote><p>SSTF, Shortest Seek Time First</p></blockquote><p>要求访问的磁道与当前磁头所在磁道距离最近的优先进行调度。这种算法并不能保证平均寻道时间最短，但是比 FCFS 好很多。</p><h3 id="3-扫描算法"><a href="#3-扫描算法" class="headerlink" title="3. 扫描算法"></a>3. 扫描算法</h3><blockquote><p>SCAN</p></blockquote><p>SSTF 会出现饥饿现象。考虑以下情况，新进程请求访问的磁道与磁头所在磁道的距离总是比一个在等待的进程来的近，那么等待的进程会一直等待下去。</p><p>SCAN 算法在 SSTF 算法之上考虑了磁头的移动方向，要求所请求访问的磁道在磁头当前移动方向上才能够得到调度。因为考虑了移动方向，那么一个进程请求访问的磁道一定会得到调度。</p><p>当一个磁头自里向外移动时，移到最外侧会改变移动方向为自外向里，这种移动的规律类似于电梯的运行，因此又常称 SCAN 算法为电梯调度算法。</p><h3 id="4-循环扫描算法"><a href="#4-循环扫描算法" class="headerlink" title="4. 循环扫描算法"></a>4. 循环扫描算法</h3><blockquote><p>CSCAN</p></blockquote><p>CSCAN 对 SCAN 进行了改动，要求磁头始终沿着一个方向移动。</p><h1 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h1><h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>以下是一个 hello.c 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure><p>这个过程大致如下：</p><p><div align="center"> <img src="/image/pics//b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"> </div><br></p><ol><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编程序；</li><li>汇编阶段：将汇编程序翻译可重定向目标程序，它是二进制的；</li><li>链接阶段：将可重定向目标程序和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标程序。</li></ol><h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><ol><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定向目标文件：可与其他可重定向目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：可以在运行时被动态加载进内存并链接；</li></ol><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态连接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ol><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：编译器和汇编器生成从地址 0 开始的代码和数据节，链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ol><p><div align="center"> <img src="/image/pics//47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"> </div><br></p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ol><li>在给定的文件系统中一个库只有一个 .so 文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。</li></ol><p><div align="center"> <img src="/image/pics//76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"> </div><br></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014.</li><li>汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.</li><li>Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统.</li><li><a href="https://applied-programming.github.io/Operating-Systems-Notes/" target="_blank" rel="noopener">Operating System Notes</a></li><li><a href="http://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></li><li><a href="https://www.cs.uic.edu/\~jbell/CourseNotes/OperatingSystems/2_Structures.html" target="_blank" rel="noopener">Operating-System Structures</a></li><li><a href="http://cse.csusb.edu/tongyu/courses/cs460/notes/process.php" target="_blank" rel="noopener">Processes</a></li><li><a href="https://www.slideshare.net/rkolahalam/inter-process-communication-presentation1" target="_blank" rel="noopener">Inter Process Communication Presentation[1]</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-概述&quot;&gt;一、 概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统基本特征&quot;&gt;操作系统基本特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统基本功能&quot;&gt;操作系统基本功能&lt;/a&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔</title>
    <link href="http://yoursite.com/2018/02/13/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/13/数据库/MySQL学习笔记/</id>
    <published>2018-02-13T02:35:21.000Z</published>
    <updated>2018-07-04T15:01:16.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a><center>MySQL学习笔记</center></h1><p>需要补充的知识：Java操作MySQL数据库</p><h2 id="一、安装与启动MySQL"><a href="#一、安装与启动MySQL" class="headerlink" title="一、安装与启动MySQL"></a>一、安装与启动MySQL</h2><h3 id="1-使用zip文件安装"><a href="#1-使用zip文件安装" class="headerlink" title="1. 使用zip文件安装"></a>1. 使用zip文件安装</h3><p>Windows 上安装 MySQL 相对来说会较为简单，你需要在 <a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL 下载</a>中下载 Windows 版本的 MySQL 安装包 </p><p><img src="\image\MySQL学习笔记\windows-下载MySQL安装包.png" alt="windows-下载MySQL安装包"></p><p><img src="\image\MySQL学习笔记\windows-下载MySQL安装包——2.png" alt="windows-下载MySQL安装包——2"></p><p>下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在 <strong>C:\web\mysql-8.0.11</strong> 下。</p><p><strong>接下来我们需要配置下 MySQL 的配置文件</strong></p><p>打开刚刚解压的文件夹 <strong>C:\web\mysql-8.0.11</strong> ，里面有一个系统自带的配置文件 <strong>my-default.ini</strong>，复制该文件，并粘贴在同一目录下，设置新的文件为 <strong>my.ini</strong>，编辑 <strong>my.ini</strong> 配置以下基本信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"> </span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=C:\wamp-all\mysql-<span class="number">5.7</span>.<span class="number">13</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=C:\wamp-all\sqldata</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">20</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br></pre></td></tr></table></figure><p><strong>接下来我们来启动下 MySQL 数据库：</strong></p><p>以管理员身份打开 cmd 命令行工具，切换目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\web\mysql-8.0.11\bin</span><br></pre></td></tr></table></figure><p>输入以下安装命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld install</span><br></pre></td></tr></table></figure><p>启动输入以下命令即可： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>注意: 在 5.7 需要初始化 data 目录： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\web\mysql-8.0.11\bin </span><br><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure><p>参考资料：<a href="http://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">MySQL安装|菜鸟教程</a></p><h3 id="2-使用msi安装程序安装MySQL"><a href="#2-使用msi安装程序安装MySQL" class="headerlink" title="2. 使用msi安装程序安装MySQL"></a>2. 使用msi安装程序安装MySQL</h3><p>这个主要参考教程：<a href="https://blog.csdn.net/clouderpig/article/details/79556149" target="_blank" rel="noopener">mysql5.7.21 安装与使用 </a></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>在windows上的服务名称为：MySQL57</p><p>使用mysql -u mucao -p 连接上MySQL后会有一行很重要的提示：</p><p>Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.</p><h2 id="二、常见问题解决"><a href="#二、常见问题解决" class="headerlink" title="二、常见问题解决"></a>二、常见问题解决</h2><p><strong>1. 在mysql中无法插入中文字符</strong></p><p>参考网址：<a href="https://www.cnblogs.com/liushao/p/6370326.html" target="_blank" rel="noopener">https://www.cnblogs.com/liushao/p/6370326.html</a></p><p><strong>2. MySQL5.7.9，怎样永久设置client、connection、results这三项为utf8？</strong></p><p>[client]<br> default-character-set=utf8<br> [mysql]<br> default-character-set=utf8<br> [mysqld]<br> collation-server = utf8_unicode_ci<br> init-connect=’SET NAMES utf8′<br> character-set-server = utf8</p><p> <strong>3. MySQL为什么要set names </strong></p><p>大家都知道<br>SET NAMES x<br>相当于<br>SET character_set_client = x;<br>SET character_set_results = x;<br>SET character_set_connection = x;</p><p>参考资料：<a href="https://blog.csdn.net/y_h_t/article/details/17994335" target="_blank" rel="noopener">https://blog.csdn.net/y_h_t/article/details/17994335</a></p><p><strong>4. mysql导出或导出数据时出现： MySQL server is running with the –secure-file-priv </strong></p><p>​    出现这个异常的原因主要是MySQL有自己的默认文件路径(配置在my.ini文件中，“secure-file-priv ”)，如果导出文件路径不对，则就会报错。只要把导出文件配置在指定路径中就行，或者修改my.ini文件中的“secure-file-priv ”值改为””就行了。可以参考：<a href="https://blog.csdn.net/qq_31518899/article/details/75662090" target="_blank" rel="noopener">https://blog.csdn.net/qq_31518899/article/details/75662090</a></p><p><strong>5. 创建数据库时设置字符集合更改数据库字符集</strong></p><p>​    建立数据库时可以使用以下命令：</p><p>​    create database app_relation character set utf8; </p><p>​    use app_relation;</p><p>​    source app_relation.sql;</p><p>​    修改数据库编码的命令为：</p><p>​    alter database app_relation character set utf8; </p><h2 id="三、基本操作"><a href="#三、基本操作" class="headerlink" title="三、基本操作"></a>三、基本操作</h2><p>下面的内容来自参考资料：<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-tutorial.html</a></p><h3 id="1-连接"><a href="#1-连接" class="headerlink" title="1. 连接"></a>1. 连接</h3><p>​    可以使用下面的命令连接MySQL数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@host]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:******</span><br></pre></td></tr></table></figure><p>​    退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; exit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure><h3 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2. 创建数据库"></a>2. 创建数据库</h3><p>​    可以在登陆 MySQL 服务后，使用 creat 命令创建数据库，语法如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure><h3 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3. 删除数据库"></a>3. 删除数据库</h3><p>​    使用drop命令删除数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure></p><h3 id="4-选择数据库"><a href="#4-选择数据库" class="headerlink" title="4.  选择数据库"></a>4.  选择数据库</h3><p>​    在 mysql&gt; 提示窗口中可以很简单的选择特定的数据库。你可以使用SQL命令来选择指定的数据库。 </p><p>​    以下实例选取了数据库 RUNOOB:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@host]# mysql -u root -p</span><br><span class="line">Enter password:******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></p><p>​    执行以上命令后，你就已经成功选择了 RUNOOB 数据库，在后续的操作中都会在 RUNOOB 数据库中执行。</p><p>​    <strong>注意:</strong>所有的数据库名，表名，表字段都是区分大小写的。所以你在使用SQL命令时需要输入正确的名称。</p><h3 id="5-MySQL数据类型"><a href="#5-MySQL数据类型" class="headerlink" title="5. MySQL数据类型"></a>5. MySQL数据类型</h3><p>​    MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 </p><p><strong>数据类型</strong></p><p>​    MySQL支持所有标准SQL数值数据类型。</p><p>​    这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p><p>​    关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p><p>​    BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p><p>​    作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 字节</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 字节</td><td>(-32 768，32 767)</td><td>(0，65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 字节</td><td>(-8 388 608，8 388 607)</td><td>(0，16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 字节</td><td>(-2 147 483 648，2 147 483 647)</td><td>(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 字节</td><td>(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)</td><td>(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 字节</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度 浮点数值</td></tr><tr><td>DOUBLE</td><td>8 字节</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度 浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>小数值</td></tr></tbody></table><p><strong>日期和时间类型</strong></p><p>​    表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>​    每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>​    TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><table><thead><tr><th>类型</th><th>大小 (字节)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’/‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00/9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><p><strong>字符串类型</strong></p><p>​    字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 </p><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255字节</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 字节</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255字节</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535字节</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535字节</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215字节</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295字节</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295字节</td><td>极大文本数据</td></tr></tbody></table><p>​    CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>​    BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>​    BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>​    有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p><h3 id="6-MySQL-创建数据表"><a href="#6-MySQL-创建数据表" class="headerlink" title="6. MySQL 创建数据表"></a>6. MySQL 创建数据表</h3><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><p><strong>语法</strong></p><p>​    以下为创建MySQL数据表的SQL通用语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure><p>​    以下例子中我们将在 RUNOOB 数据库中创建数据表runoob_tbl： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@host# mysql -u root -p</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE runoob_tbl(</span><br><span class="line">   -&gt; runoob_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   -&gt; runoob_title VARCHAR(100) NOT NULL,</span><br><span class="line">   -&gt; runoob_author VARCHAR(40) NOT NULL,</span><br><span class="line">   -&gt; submission_date DATE,</span><br><span class="line">   -&gt; PRIMARY KEY ( runoob_id )</span><br><span class="line">   -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.16 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>​    <strong>注意</strong>: MySQL命令终止符为分号(;)。</p><p>实例解析：</p><ul><li>如果你不想字段为 <strong>NULL</strong> 可以设置字段的属性为 <strong>NOT NULL</strong>， 在操作数据库时如果输入该字段的数据为<strong>NULL</strong> ，就会报错。</li><li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</li><li>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</li><li>ENGINE 设置存储引擎，CHARSET 设置编码。</li></ul><h3 id="7-MySQL删除数据表"><a href="#7-MySQL删除数据表" class="headerlink" title="7. MySQL删除数据表"></a>7. MySQL删除数据表</h3><p>​    MySQL中删除数据表是非常容易操作的， 但是你再进行删除表操作时要非常小心，因为执行删除命令后所有数据都会消失。 </p><p><strong>语法</strong></p><p>​    以下为删除MySQL数据表的通用语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name ;</span><br></pre></td></tr></table></figure></p><p>​    例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE runoob_tbl</span><br></pre></td></tr></table></figure><h3 id="8-插入数据"><a href="#8-插入数据" class="headerlink" title="8. 插入数据"></a>8. 插入数据</h3><p>​    MySQL 表中使用 <strong>INSERT INTO</strong> SQL语句来插入数据。 </p><p><strong>语法</strong></p><p>​    以下为向MySQL数据表插入数据通用的 <strong>INSERT INTO</strong> SQL语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure><p>​    如果数据是字符型，必须使用单引号或者双引号，如：”value”。 </p><p><strong>实例</strong></p><p>​    以下实例中我们将向 runoob_tbl 表插入三条数据: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@host# mysql -u root -p password;</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; INSERT INTO runoob_tbl </span><br><span class="line">    -&gt; (runoob_title, runoob_author, submission_date)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());</span><br><span class="line">Query OK, 1 rows affected, 1 warnings (0.01 sec)</span><br><span class="line">mysql&gt; INSERT INTO runoob_tbl</span><br><span class="line">    -&gt; (runoob_title, runoob_author, submission_date)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; (&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW());</span><br><span class="line">Query OK, 1 rows affected, 1 warnings (0.01 sec)</span><br><span class="line">mysql&gt; INSERT INTO runoob_tbl</span><br><span class="line">    -&gt; (runoob_title, runoob_author, submission_date)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; (&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &apos;2016-05-06&apos;);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>​    <strong>注意：</strong> 使用箭头标记 -&gt; 不是 SQL 语句的一部分，它仅仅表示一个新行，如果一条SQL语句太长，我们可以通过回车键来创建一个新行来编写 SQL 语句，SQL 语句的命令结束符为分号 ;。</p><p>​    在以上实例中，我们并没有提供 runoob_id 的数据，因为该字段我们在创建表的时候已经设置它为 AUTO_INCREMENT(自动增加) 属性。 所以，该字段会自动递增而不需要我们去设置。实例中 NOW() 是一个 MySQL 函数，该函数返回日期和时间。</p><p>​    接下来我们可以通过以下语句查看数据表数据：</p><p>​    读取数据表：</p><p>​    select * from runoob_tbl;</p><p>​    输出结果：<br><img src="\image\MySQL学习笔记\读取数据表runoob_tb1输出结果.jpg" alt="读取数据表runoob_tb1输出结果"></p><h3 id="9-查询数据"><a href="#9-查询数据" class="headerlink" title="9. 查询数据"></a>9. 查询数据</h3><p>​    MySQL 数据库使用SQL SELECT语句来查询数据。 </p><p><strong>语法</strong></p><p>​    以下为在MySQL数据库中查询数据通用的 SELECT 语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M]</span><br></pre></td></tr></table></figure><ul><li>查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li><li>SELECT 命令可以读取一条或者多条记录。</li><li>你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li><li>你可以使用 WHERE 语句来包含任何条件。</li><li>你可以使用 LIMIT 属性来设定返回的记录数。</li><li>你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li></ul><p><strong>实例</strong></p><p>​    读取数据表：</p><p>​    select * from runoob_tbl; </p><p>​    输出结果：</p><p><img src="\image\MySQL学习笔记\DB742246-84F3-4447-BD43-6BAEADD7CA91.jpg" alt="DB742246-84F3-4447-BD43-6BAEADD7CA91"></p><h3 id="10-Where子句"><a href="#10-Where子句" class="headerlink" title="10. Where子句"></a>10. Where子句</h3><p>​    如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。</p><p><strong>语法 </strong></p><p>​    以下是 SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">[WHERE condition1 [AND [OR]] condition2.....</span><br></pre></td></tr></table></figure><ul><li><p>查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。</p></li><li><p>你可以在 WHERE 子句中指定任何条件。</p></li><li><p>你可以使用 AND 或者 OR 指定一个或多个条件。</p></li><li><p>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</p></li><li><p>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</p><p>以下为操作符列表，可用于 WHERE 子句中。</p><p>下表中实例假定 A 为 10, B 为 20</p></li></ul><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>等号，检测两个值是否相等，如果相等返回true</td><td>(A = B) 返回false。</td></tr><tr><td>&lt;&gt;, !=</td><td>不等于，检测两个值是否相等，如果不相等返回true</td><td>(A != B) 返回 true。</td></tr><tr><td>&gt;</td><td>大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td>(A &gt; B) 返回false。</td></tr><tr><td>&lt;</td><td>小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td>(A &lt; B) 返回 true。</td></tr><tr><td>&gt;=</td><td>大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td>(A &gt;= B) 返回false。</td></tr><tr><td>&lt;=</td><td>小于等于号，检测左边的值是否小于于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td>(A &lt;= B) 返回 true。</td></tr></tbody></table><p>​    如果我们想再 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。</p><p>​    使用主键来作为 WHERE 子句的条件查询是非常快速的。</p><p>​    如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。</p><p><strong>实例</strong></p><p>​    SELECT * from runoob_tbl WHERE runoob_author=’菜鸟教程’; </p><p>​    输出结果：</p><p><img src="\image\MySQL学习笔记\CED9CA9C-E4C7-4809-875C-A7E48F430059.jpg" alt="CED9CA9C-E4C7-4809-875C-A7E48F430059"></p><p>​    MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。 </p><p><img src="\image\MySQL学习笔记\Where关键字区分大小写.png" alt="Where关键字区分大小写"></p><p>​    实例中使用了 <strong>BINARY</strong> 关键字，是区分大小写的，所以 <strong>runoob_author=’runoob.com’</strong> 的查询条件是没有数据的。 </p><h3 id="11-Update-查询"><a href="#11-Update-查询" class="headerlink" title="11. Update 查询"></a>11. Update 查询</h3><p>​    如果需要修改或更新 MySQL 中的数据，可以使用 SQL UPDATE 命令来操作。. </p><p><strong>语法</strong></p><p>​    以下是 UPDATE 命令修改 MySQL 数据表数据的通用 SQL 语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2</span><br><span class="line">[WHERE Clause]</span><br></pre></td></tr></table></figure><ul><li><p>你可以同时更新一个或多个字段。</p></li><li><p>你可以在 WHERE 子句中指定任何条件。</p></li><li><p>你可以在一个单独表中同时更新数据。</p><p>当你需要更新数据表中指定行的数据时 WHERE 子句是非常有用的。 </p></li></ul><p><strong>实例</strong></p><p>SQL UPDATE 语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3;</span><br><span class="line">Query OK, 1 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3;</span><br><span class="line">+-----------+--------------+---------------+-----------------+</span><br><span class="line">| runoob_id | runoob_title | runoob_author | submission_date |</span><br><span class="line">+-----------+--------------+---------------+-----------------+</span><br><span class="line">| 3         | 学习 C++   | RUNOOB.COM    | 2016-05-06      |</span><br><span class="line">+-----------+--------------+---------------+-----------------+</span><br><span class="line">1 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p><p>​    从结果上看，runoob_id 为 3 的 runoob_title 已被修改。 </p><h3 id="12-Delete-语句"><a href="#12-Delete-语句" class="headerlink" title="12. Delete 语句"></a>12. Delete 语句</h3><p>​    可以使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。 </p><p><strong>语法</strong></p><p>​    以下是 SQL DELETE 语句从 MySQL 数据表中删除数据的通用语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure><ul><li>如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li><li>你可以在 WHERE 子句中指定任何条件</li><li>您可以在单个表中一次性删除记录。</li></ul><p>当你想删除数据表中指定的记录时 WHERE 子句是非常有用的。</p><p><strong>实例</strong></p><p>​    以下实例将删除 runoob_tbl 表中 runoob_id 为3 的记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3;</span><br><span class="line">Query OK, 1 row affected (0.23 sec)</span><br></pre></td></tr></table></figure></p><h3 id="13-Like字句"><a href="#13-Like字句" class="headerlink" title="13. Like字句"></a>13. Like字句</h3><p>​    我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。</p><p>​    WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。</p><p>​    但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。</p><p>​    SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。准确的讲，百分号%表示的任意多个任意字符。</p><p>​    如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。</p><p><strong>语法</strong></p><p>以下是 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos;</span><br></pre></td></tr></table></figure><ul><li>你可以在 WHERE 子句中指定任何条件。</li><li>你可以在 WHERE 子句中使用LIKE子句。</li><li>你可以使用LIKE子句代替等号 =。</li><li>LIKE 通常与 % 一同使用，类似于一个元字符的搜索。</li><li>你可以使用 AND 或者 OR 指定一个或多个条件。</li><li><p>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</p><p><strong>实例</strong></p></li></ul><p>​    以下是我们将 runoob_tbl 表中获取 runoob_author 字段中以 COM 为结尾的的所有记录： </p><p>​    <strong>SQL UPDATE 语句：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SELECT * from runoob_tbl  WHERE runoob_author LIKE &apos;%COM&apos;;</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |</span><br><span class="line">| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p><p>like 匹配/模糊匹配，会与 % 和 _ 结合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;%a&apos;     //以a结尾的数据</span><br><span class="line">&apos;a%&apos;     //以a开头的数据</span><br><span class="line">&apos;%a%&apos;    //含有a的数据</span><br><span class="line">&apos;_a_&apos;    //三位且中间字母是a的</span><br><span class="line">&apos;_a&apos;     //两位且结尾字母是a的</span><br><span class="line">&apos;a_&apos;     //两位且开头字母是a的</span><br></pre></td></tr></table></figure></p><h3 id="14-union操作符"><a href="#14-union操作符" class="headerlink" title="14. union操作符"></a>14. union操作符</h3><p><strong>描述</strong></p><p>​    MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 </p><p><strong>语法</strong></p><p>​    MySQL UNION 操作符语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">UNION [ALL | DISTINCT]</span><br><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions];</span><br></pre></td></tr></table></figure></p><p><strong>参数</strong></p><ul><li><strong>expression1, expression2, … expression_n</strong>: 要检索的列。</li><li><strong>tables:</strong> 要检索的数据表。</li><li><strong>WHERE conditions:</strong> 可选， 检索条件。</li><li><strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li><li><strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li></ul><p><strong>演示数据库</strong></p><p>​    下面使用RUNOOB样本数据库中”Websites”表的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM Websites;</span><br><span class="line">+----+--------------+---------------------------+-------+---------+</span><br><span class="line">| id | name         | url                       | alexa | country |</span><br><span class="line">+----+--------------+---------------------------+-------+---------+</span><br><span class="line">| 1  | Google       | https://www.google.cm/    | 1     | USA     |</span><br><span class="line">| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |</span><br><span class="line">| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |</span><br><span class="line">| 4  | 微博          | http://weibo.com/         | 20    | CN      |</span><br><span class="line">| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |</span><br><span class="line">| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |</span><br><span class="line">+----+---------------+---------------------------+-------+---------+</span><br></pre></td></tr></table></figure></p><p>​    下面是 “apps” APP 的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM apps;</span><br><span class="line">+----+------------+-------------------------+---------+</span><br><span class="line">| id | app_name   | url                     | country |</span><br><span class="line">+----+------------+-------------------------+---------+</span><br><span class="line">|  1 | QQ APP     | http://im.qq.com/       | CN      |</span><br><span class="line">|  2 | 微博 APP | http://weibo.com/       | CN      |</span><br><span class="line">|  3 | 淘宝 APP | https://www.taobao.com/ | CN      |</span><br><span class="line">+----+------------+-------------------------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p><strong>SQL UNION 实例</strong></p><p>​    下面的 SQL 语句从 “Websites” 和 “apps” 表中选取所有<strong>不同的</strong>country（只有不同的值）：</p><p> 实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT country FROM Websites</span><br><span class="line">UNION</span><br><span class="line">SELECT country FROM apps</span><br><span class="line">ORDER BY country;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| country |</span><br><span class="line">+---------+</span><br><span class="line">|  USA    |</span><br><span class="line">| CN      |</span><br><span class="line">| IND     |</span><br><span class="line">| USA     |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure></p><p>​    <strong>注释：</strong>UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！ </p><p>​    下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取<strong>所有的</strong>country（也有重复的值）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT country FROM Websites</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT country FROM apps</span><br><span class="line">ORDER BY country;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| country |</span><br><span class="line">+---------+</span><br><span class="line">|  USA    |</span><br><span class="line">| CN      |</span><br><span class="line">| CN      |</span><br><span class="line">| CN      |</span><br><span class="line">| CN      |</span><br><span class="line">| CN      |</span><br><span class="line">| CN      |</span><br><span class="line">| IND     |</span><br><span class="line">| USA     |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure></p><p><strong>带有 WHERE 的 SQL UNION ALL</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT country, name FROM Websites</span><br><span class="line">WHERE country=&apos;CN&apos;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT country, app_name FROM apps</span><br><span class="line">WHERE country=&apos;CN&apos;</span><br><span class="line">ORDER BY country;</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------+----------+</span><br><span class="line">| country | name     |</span><br><span class="line">+---------+----------+</span><br><span class="line">| CN      | 微博 APP |</span><br><span class="line">| CN      | 微博     |</span><br><span class="line">| CN      | 淘宝 APP |</span><br><span class="line">| CN      | 淘宝     |</span><br><span class="line">| CN      | QQ APP   |</span><br><span class="line">| CN      | 菜鸟教程 |</span><br><span class="line">+---------+----------+</span><br></pre></td></tr></table></figure></p><h3 id="15-排序"><a href="#15-排序" class="headerlink" title="15.  排序"></a>15.  排序</h3><p>​    如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 <strong>ORDER BY</strong> 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。 </p><p><strong>语法</strong></p><p>​    以下是 SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN table_name1, table_name2...</span><br><span class="line">ORDER BY field1, [field2...] [ASC [DESC]]</span><br></pre></td></tr></table></figure><ul><li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li><li>你可以设定多个字段来排序。</li><li>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li><li>你可以添加 WHERE…LIKE 子句来设置条件。</li></ul><p><strong>实例</strong></p><p>​    尝试以下实例，结果将按升序及降序排列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SELECT * from runoob_tbl ORDER BY submission_date ASC;</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |</span><br><span class="line">| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">| 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * from runoob_tbl ORDER BY submission_date DESC;</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></p><h3 id="16-GROUP-BY-分组-语句"><a href="#16-GROUP-BY-分组-语句" class="headerlink" title="16. GROUP BY (分组) 语句"></a>16. GROUP BY (分组) 语句</h3><p>​    GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</p><p><strong>GROUP BY 语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><p>​    本章节实例使用到了以下表结构及数据，使用前我们可以先将以下数据导入数据库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES utf8;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">--  Table structure for `employee_tbl`</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `employee_tbl`;</span><br><span class="line">CREATE TABLE `employee_tbl` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` char(10) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `date` datetime NOT NULL,</span><br><span class="line">  `singin` tinyint(4) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;登录次数&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">--  Records of `employee_tbl`</span><br><span class="line">-- ----------------------------</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO `employee_tbl` VALUES (&apos;1&apos;, &apos;小明&apos;, &apos;2016-04-22 15:25:33&apos;, &apos;1&apos;), (&apos;2&apos;, &apos;小王&apos;, &apos;2016-04-20 15:25:47&apos;, &apos;3&apos;), (&apos;3&apos;, &apos;小丽&apos;, &apos;2016-04-19 15:26:02&apos;, &apos;2&apos;), (&apos;4&apos;, &apos;小王&apos;, &apos;2016-04-07 15:26:14&apos;, &apos;4&apos;), (&apos;5&apos;, &apos;小明&apos;, &apos;2016-04-11 15:26:40&apos;, &apos;4&apos;), (&apos;6&apos;, &apos;小明&apos;, &apos;2016-04-04 15:26:54&apos;, &apos;2&apos;);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure></p><p>​    导入成功后，执行以下 SQL 语句： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set names utf8;</span><br><span class="line">mysql&gt; SELECT * FROM employee_tbl;</span><br><span class="line">+----+--------+---------------------+--------+</span><br><span class="line">| id | name   | date                | singin |</span><br><span class="line">+----+--------+---------------------+--------+</span><br><span class="line">|  1 | 小明 | 2016-04-22 15:25:33 |      1 |</span><br><span class="line">|  2 | 小王 | 2016-04-20 15:25:47 |      3 |</span><br><span class="line">|  3 | 小丽 | 2016-04-19 15:26:02 |      2 |</span><br><span class="line">|  4 | 小王 | 2016-04-07 15:26:14 |      4 |</span><br><span class="line">|  5 | 小明 | 2016-04-11 15:26:40 |      4 |</span><br><span class="line">|  6 | 小明 | 2016-04-04 15:26:54 |      2 |</span><br><span class="line">+----+--------+---------------------+--------+</span><br></pre></td></tr></table></figure><p>​    接下来我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;</span><br><span class="line">+--------+----------+</span><br><span class="line">| name   | COUNT(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 小丽 |        1 |</span><br><span class="line">| 小明 |        3 |</span><br><span class="line">| 小王 |        2 |</span><br><span class="line">+--------+----------+</span><br></pre></td></tr></table></figure><p><strong>使用 WITH ROLLUP</strong></p><p>​    WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。</p><p>​    例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</span><br><span class="line">+--------+--------------+</span><br><span class="line">| name   | singin_count |</span><br><span class="line">+--------+--------------+</span><br><span class="line">| 小丽 |            2 |</span><br><span class="line">| 小明 |            7 |</span><br><span class="line">| 小王 |            7 |</span><br><span class="line">| NULL   |           16 |</span><br><span class="line">+--------+--------------+</span><br></pre></td></tr></table></figure><p>​    其中记录 NULL 表示所有人的登录次数。</p><p>​    我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select coalesce(a,b,c);</span><br></pre></td></tr></table></figure></p><p>​    参数说明：如果a\==null,则选择b；如果b\==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。</p><p>​    以下实例中如果名字为空我们使用总数代替：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT coalesce(name, &apos;总数&apos;), SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</span><br><span class="line">+--------------------------+--------------+</span><br><span class="line">| coalesce(name, &apos;总数&apos;) | singin_count |</span><br><span class="line">+--------------------------+--------------+</span><br><span class="line">| 小丽                   |            2 |</span><br><span class="line">| 小明                   |            7 |</span><br><span class="line">| 小王                   |            7 |</span><br><span class="line">| 总数                   |           16 |</span><br><span class="line">+--------------------------+--------------+</span><br></pre></td></tr></table></figure></p><h3 id="17-MySql-连接的使用"><a href="#17-MySql-连接的使用" class="headerlink" title="17. MySql 连接的使用"></a>17. MySql 连接的使用</h3><p>​    在真正的应用中经常需要从多个数据表中读取数据。本章节我们将向大家介绍如何使用 MySQL 的 JOIN 在两个或多个表中查询数据。</p><p>​    你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。</p><p>JOIN 按照功能大致分为如下三类：</p><ul><li><p><strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</p></li><li><p><strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</p></li><li><p><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</p><p>本章节使用的数据库结构及数据下载：<a href="http://static.runoob.com/download/runoob-mysql-join-test.sql" target="_blank" rel="noopener">runoob-mysql-join-test.sql</a>。</p></li></ul><h4 id="使用-INNER-JOIN"><a href="#使用-INNER-JOIN" class="headerlink" title="使用 INNER JOIN"></a>使用 INNER JOIN</h4><p>​    我们在RUNOOB数据库中有两张表 tcount_tbl 和 runoob_tbl。两张数据表数据如下： </p><p><strong>实例</strong></p><p>​    测试实例数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SELECT * FROM tcount_tbl;</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| 菜鸟教程  | 10           |</span><br><span class="line">| RUNOOB.COM    | 20           |</span><br><span class="line">| Google        | 22           |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * from runoob_tbl;</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |</span><br><span class="line">| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">| 5         | 学习 C      | FK            | 2017-04-05      |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br></pre></td></tr></table></figure></p><p>​    接下来我们就使用MySQL的<strong>INNER JOIN(也可以省略 INNER 使用 JOIN，效果一样)</strong>来连接以上两张表来读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值： </p><p><strong>INNER JOIN</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br></pre></td></tr></table></figure></p><p>​    以上 SQL 语句等价于： </p><p><strong>where 字句</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br></pre></td></tr></table></figure></p><p><img src="\image\MySQL学习笔记\img_innerjoin.gif" alt="img_innerjoin"></p><h4 id="MySQL-LEFT-JOIN"><a href="#MySQL-LEFT-JOIN" class="headerlink" title="MySQL LEFT JOIN"></a>MySQL LEFT JOIN</h4><p>​    MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。 </p><p><strong>实例</strong></p><p>​    尝试以下实例，以 <strong>runoob_tbl</strong> 为左表，<strong>tcount_tbl</strong> 为右表，理解 MySQL LEFT JOIN 的应用： </p><p>LEFT JOIN:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程   | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| 5           | FK              | NULL           |</span><br><span class="line">+-------------+-----------------+----------------+</span><br></pre></td></tr></table></figure></p><p>​    以上实例中使用了 LEFT JOIN，该语句会读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值。 </p><p><img src="\image\MySQL学习笔记\img_leftjoin.gif" alt="img_leftjoin"></p><h4 id="MySQL-RIGHT-JOIN"><a href="#MySQL-RIGHT-JOIN" class="headerlink" title="MySQL RIGHT JOIN"></a>MySQL RIGHT JOIN</h4><p>​    MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据</p><p><strong>实例</strong></p><p>​    尝试以下实例，以 <strong>runoob_tbl</strong> 为左表，<strong>tcount_tbl</strong> 为右表，理解MySQL RIGHT JOIN的应用： </p><p>RIGHT JOIN<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| NULL        | NULL            | 22             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br></pre></td></tr></table></figure></p><p>​    以上实例中使用了 RIGHT JOIN，该语句会读取右边的数据表 tcount_tbl 的所有选取的字段数据，即便在左侧表 runoob_tbl 中没有对应的runoob_author 字段值。 </p><p><img src="\image\MySQL学习笔记\img_rightjoin.gif" alt="img_rightjoin"></p><p>参考资料：<a href="http://www.runoob.com/mysql/mysql-join.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-join.html</a></p><h3 id="18-NULL值处理"><a href="#18-NULL值处理" class="headerlink" title="18. NULL值处理"></a>18. NULL值处理</h3><p>​    MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。</p><p>​    为了处理这种情况，MySQL提供了三大运算符:</p><ul><li><strong>IS NULL:</strong> 当列的值是 NULL,此运算符返回 true。</li><li><strong>IS NOT NULL:</strong> 当列的值不为 NULL, 运算符返回 true。</li><li><strong>&lt;=&gt;:</strong> 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</li></ul><p>​    关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。</p><p>​    在 MySQL 中，NULL 值与任何其它值比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。</p><p>​    MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。</p><p><strong>实例</strong></p><p>​    以下实例中假设数据库 RUNOOB 中的表 runoob_test_tbl 含有两列 runoob_author 和 runoob_count, runoob_count 中设置插入NULL值。 </p><p>创建数据表 runoob_test_tbl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@host# mysql -u root -p password;</span><br><span class="line">Enter password:*******</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table runoob_test_tbl</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; runoob_author varchar(40) NOT NULL,</span><br><span class="line">    -&gt; runoob_count  INT</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values (&apos;RUNOOB&apos;, 20);</span><br><span class="line">mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values (&apos;菜鸟教程&apos;, NULL);</span><br><span class="line">mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values (&apos;Google&apos;, NULL);</span><br><span class="line">mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values (&apos;FK&apos;, 20);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * from runoob_test_tbl;</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| RUNOOB        | 20           |</span><br><span class="line">| 菜鸟教程  | NULL         |</span><br><span class="line">| Google        | NULL         |</span><br><span class="line">| FK            | 20           |</span><br><span class="line">+---------------+--------------+</span><br></pre></td></tr></table></figure></p><p>​    以下实例中你可以看到 = 和 != 运算符是不起作用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count = NULL;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count != NULL;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure></p><p>​    查找数据表中 runoob_test_tbl 列是否为 NULL，必须使用 IS NULL 和 IS NOT NULL，如下实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| 菜鸟教程  | NULL         |</span><br><span class="line">| Google        | NULL         |</span><br><span class="line">+---------------+--------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL;</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| RUNOOB        | 20           |</span><br><span class="line">| FK            | 20           |</span><br><span class="line">+---------------+--------------+</span><br></pre></td></tr></table></figure></p><h3 id="19-MySQL-正则表达式"><a href="#19-MySQL-正则表达式" class="headerlink" title="19. MySQL 正则表达式"></a>19. MySQL 正则表达式</h3><p>​    在前面的章节我们已经了解到MySQL可以通过 <strong>LIKE …%</strong> 来进行模糊匹配。</p><p>​    MySQL 同样也支持其他正则表达式的匹配， MySQL中使用 REGEXP 操作符来进行正则表达式匹配。</p><p>​    如果您了解PHP或Perl，那么操作起来就非常简单，因为MySQL的正则表达式匹配与这些脚本的类似。</p><p>​    下表中的正则模式可应用于 REGEXP 操作符中。</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td>.</td><td>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td>[…]</td><td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td>[^…]</td><td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td></tr><tr><td>p1\</td><td>p2\</td><td>p3</td><td>匹配 p1 或 p2 或 p3。例如，’z\</td><td>food’ 能匹配 “z” 或 “food”。’(z\</td><td>f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td></tr></tbody></table><p><strong>实例</strong></p><p>​    了解以上的正则需求后，我们就可以根据自己的需求来编写带有正则表达式的SQL语句。以下我们将列出几个小实例(表名：person_tbl )来加深我们的理解：</p><p>​    查找name字段中以’st’为开头的所有数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;^st&apos;;</span><br></pre></td></tr></table></figure><p>​    查找name字段中以’ok’为结尾的所有数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;ok$&apos;;</span><br></pre></td></tr></table></figure><p>​    查找name字段中包含’mar’字符串的所有数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;mar&apos;;</span><br></pre></td></tr></table></figure><p>​    查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;^[aeiou]|ok$&apos;;</span><br></pre></td></tr></table></figure><h3 id="20-事务"><a href="#20-事务" class="headerlink" title="20. 事务"></a>20. 事务</h3><p>​    MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><ul><li><p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p></li><li><p>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p></li><li><p>事务用来管理 insert,update,delete 语句</p><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p></li><li><p><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。(参见这篇文章的第四章第1小节)</p></li><li><p><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><blockquote><p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p></blockquote><p><strong>事务控制语句：</strong></p><ul><li>BEGIN或START TRANSACTION；显式地开启一个事务；</li><li>COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；</li><li>ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li><li>SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；</li><li>RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li><li>ROLLBACK TO identifier；把事务回滚到标记点；</li><li>SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</li></ul><p><strong>MYSQL 事务处理主要有两种方法：</strong></p><p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p><ul><li><strong>BEGIN</strong> 开始一个事务</li><li><strong>ROLLBACK</strong> 事务回滚</li><li><strong>COMMIT</strong> 事务确认</li></ul><p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p><ul><li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li><li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li></ul><p><strong>事务测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from runoob_transaction_test;</span><br><span class="line">Empty set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;  # 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(5);</span><br><span class="line">Query OK, 1 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(6);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit; # 提交事务</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  select * from runoob_transaction_test;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;    # 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  insert into runoob_transaction_test values(7);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;   # 回滚</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="21-alter命令"><a href="#21-alter命令" class="headerlink" title="21. alter命令"></a>21. alter命令</h3><p>​    当我们需要<strong>修改数据表名或者修改数据表字段</strong>时，就需要使用到MySQL ALTER命令。</p><p>​    开始本章教程前让我们先创建一张表，表名为：testalter_tbl。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table testalter_tbl</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; i INT,</span><br><span class="line">    -&gt; c CHAR(1)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">mysql&gt; SHOW COLUMNS FROM testalter_tbl;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| i     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">| c     | char(1) | YES  |     | NULL    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure></p><p><strong>删除，添加或修改表字段</strong><br>    如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE testalter_tbl  DROP i;</span><br></pre></td></tr></table></figure></p><p>​    如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p><p>​    MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE testalter_tbl ADD i INT;</span><br></pre></td></tr></table></figure></p><p>​    执行以上命令后，i 字段会自动添加到数据表字段的末尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM testalter_tbl;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| c     | char(1) | YES  |     | NULL    |       |</span><br><span class="line">| i     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>​    如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p><p>​    尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE testalter_tbl DROP i;</span><br><span class="line">ALTER TABLE testalter_tbl ADD i INT FIRST;</span><br><span class="line">ALTER TABLE testalter_tbl DROP i;</span><br><span class="line">ALTER TABLE testalter_tbl ADD i INT AFTER c;</span><br></pre></td></tr></table></figure></p><p>​    FIRST 和 AFTER 关键字只占用于 ADD 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。</p><p><strong>修改字段类型及名称</strong></p><p>​    如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p><p>​    例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10);</span><br></pre></td></tr></table></figure><p>​    使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl CHANGE j j INT;</span><br></pre></td></tr></table></figure><p><strong>ALTER TABLE 对 Null 值和默认值的影响</strong></p><p>​    当你修改字段时，你可以指定是否包含值或者是否设置默认值。</p><p>​    以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl </span><br><span class="line">    -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100;</span><br></pre></td></tr></table></figure><p>​    如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p><p><strong>修改字段默认值</strong></p><p>​    你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;</span><br><span class="line">mysql&gt; SHOW COLUMNS FROM testalter_tbl;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| c     | char(1) | YES  |     | NULL    |       |</span><br><span class="line">| i     | int(11) | YES  |     | 1000    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>​    你也可以使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;</span><br><span class="line">mysql&gt; SHOW COLUMNS FROM testalter_tbl;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| c     | char(1) | YES  |     | NULL    |       |</span><br><span class="line">| i     | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line">Changing a Table Type:</span><br></pre></td></tr></table></figure><p>​    修改数据表类型，可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 testalter_tbl 的类型修改为 MYISAM ：</p><p>​    <strong>注意：</strong>查看数据表类型可以使用 SHOW TABLE STATUS 语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ENGINE = MYISAM;</span><br><span class="line">mysql&gt;  SHOW TABLE STATUS LIKE &apos;testalter_tbl&apos;\G</span><br><span class="line">*************************** 1. row ****************</span><br><span class="line">           Name: testalter_tbl</span><br><span class="line">           Type: MyISAM</span><br><span class="line">     Row_format: Fixed</span><br><span class="line">           Rows: 0</span><br><span class="line"> Avg_row_length: 0</span><br><span class="line">    Data_length: 0</span><br><span class="line">Max_data_length: 25769803775</span><br><span class="line">   Index_length: 1024</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: NULL</span><br><span class="line">    Create_time: 2007-06-03 08:04:36</span><br><span class="line">    Update_time: 2007-06-03 08:04:36</span><br><span class="line">     Check_time: NULL</span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>修改表名</strong></p><p>​    如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。</p><p>​    尝试以下实例将数据表 testalter_tbl 重命名为 alter_tbl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl RENAME TO alter_tbl;</span><br></pre></td></tr></table></figure><p>​    ALTER 命令还可以用来创建及删除MySQL数据表的索引，该功能我们会在接下来的章节中介绍。</p><h3 id="22-MySQL索引"><a href="#22-MySQL索引" class="headerlink" title="22. MySQL索引"></a>22. MySQL索引</h3><p>​    MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p><p>​    打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。</p><p>​    索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p><p>​    创建索引时，你需要确保该索引是应用在    SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p><p>​    实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p><p>​    上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p><p>​    建立索引会占用磁盘空间的索引文件。</p><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p><strong>创建索引</strong></p><p>​    这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure><p>​    如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p><p><strong>修改表结构(添加索引)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure><p><strong>创建表的时候直接指定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">INDEX [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>删除索引的语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable;</span><br></pre></td></tr></table></figure><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>​    它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p><p><strong>创建索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</span><br></pre></td></tr></table></figure><p><strong>修改表结构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure><p><strong>创建表的时候直接指定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(   </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line">UNIQUE [indexName] (username(length))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> <strong>使用ALTER 命令添加和删除索引</strong></p><p>​    有四种方式来添加数据表的索引： </p><ul><li><p><strong>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</strong> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 </p></li><li><p><strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</p></li><li><p><strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</p></li><li><p><strong>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):</strong>该语句指定了索引为 FULLTEXT ，用于全文索引。</p><p>以下实例为在表中添加索引。 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);</span><br></pre></td></tr></table></figure><p>​    你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c;</span><br></pre></td></tr></table></figure><p><strong>使用 ALTER 命令添加和删除主键</strong></p><p>​    主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;</span><br><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);</span><br></pre></td></tr></table></figure><p>​    你也可以使用 ALTER 命令删除主键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><p>​    删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p><p><strong>显示索引信息</strong></p><p>​    你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p><p>​    尝试以下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM table_name; \G</span><br></pre></td></tr></table></figure><h3 id="23-临时表"><a href="#23-临时表" class="headerlink" title="23. 临时表"></a>23. 临时表</h3><p>​    MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。</p><p>​    临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。</p><p>​    MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。</p><p>​    如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。</p><p><strong>实例</strong></p><p>​    以下展示了使用MySQL 临时表的简单实例，以下的SQL代码可以适用于PHP脚本的mysql_query()函数 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (</span><br><span class="line">    -&gt; product_name VARCHAR(50) NOT NULL</span><br><span class="line">    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00</span><br><span class="line">    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO SalesSummary</span><br><span class="line">    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; (&apos;cucumber&apos;, 100.25, 90, 2);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM SalesSummary;</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">| product_name | total_sales | avg_unit_price | total_units_sold |</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">| cucumber     |      100.25 |          90.00 |                2 |</span><br><span class="line">+--------------+-------------+----------------+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>​    当你使用 <strong>SHOW TABLES</strong>命令显示数据表列表时，你将无法看到 SalesSummary表。</p><p>​    如果你退出当前MySQL会话，再使用 <strong>SELECT</strong>命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。</p><p><strong>删除MySQL 临时表</strong></p><p>​    默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 <strong>DROP TABLE</strong> 命令来手动删除临时表。</p><p>​    以下是手动删除临时表的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP TABLE SalesSummary;</span><br><span class="line">mysql&gt;  SELECT * FROM SalesSummary;</span><br><span class="line">ERROR 1146: Table &apos;RUNOOB.SalesSummary&apos; doesn&apos;t exist</span><br></pre></td></tr></table></figure><h3 id="24-复制表"><a href="#24-复制表" class="headerlink" title="24. 复制表"></a>24. 复制表</h3><p>​    如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用<strong>CREATE TABLE … SELECT</strong> 命令，是无法实现的。</p><p>​    本章节将为大家介绍如何完整的复制MySQL数据表，步骤如下：</p><ul><li>使用 <strong>SHOW CREATE TABLE</strong> 命令获取创建数据表(<strong>CREATE TABLE</strong>) 语句，该语句包含了原数据表的结构，索引等。</li><li>复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。</li><li>如果你想复制表的内容，你就可以使用 <strong>INSERT INTO … SELECT</strong> 语句来实现。</li></ul><p><strong>实例</strong></p><p>​    尝试以下实例来复制表 runoob_tbl 。 </p><p><strong>步骤一：</strong></p><p>​    获取数据表的完整结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW CREATE TABLE runoob_tbl \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: runoob_tbl</span><br><span class="line">Create Table: CREATE TABLE `runoob_tbl` (</span><br><span class="line">  `runoob_id` int(11) NOT NULL auto_increment,</span><br><span class="line">  `runoob_title` varchar(100) NOT NULL default &apos;&apos;,</span><br><span class="line">  `runoob_author` varchar(40) NOT NULL default &apos;&apos;,</span><br><span class="line">  `submission_date` date default NULL,</span><br><span class="line">  PRIMARY KEY  (`runoob_id`),</span><br><span class="line">  UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)</span><br><span class="line">) ENGINE=InnoDB </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>步骤二：</strong></p><p>​    修改SQL语句的数据表名，并执行SQL语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `clone_tbl` (</span><br><span class="line">  -&gt; `runoob_id` int(11) NOT NULL auto_increment,</span><br><span class="line">  -&gt; `runoob_title` varchar(100) NOT NULL default &apos;&apos;,</span><br><span class="line">  -&gt; `runoob_author` varchar(40) NOT NULL default &apos;&apos;,</span><br><span class="line">  -&gt; `submission_date` date default NULL,</span><br><span class="line">  -&gt; PRIMARY KEY  (`runoob_id`),</span><br><span class="line">  -&gt; UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)</span><br><span class="line">-&gt; ) ENGINE=InnoDB;</span><br><span class="line">Query OK, 0 rows affected (1.80 sec)</span><br></pre></td></tr></table></figure><p><strong>步骤三：</strong></p><p>​    执行完第二步骤后，你将在数据库中创建新的克隆表 clone_tbl。 如果你想拷贝数据表的数据你可以使用 <strong>INSERT INTO… SELECT</strong> 语句来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO clone_tbl (runoob_id,</span><br><span class="line">    -&gt;                        runoob_title,</span><br><span class="line">    -&gt;                        runoob_author,</span><br><span class="line">    -&gt;                        submission_date)</span><br><span class="line">    -&gt; SELECT runoob_id,runoob_title,</span><br><span class="line">    -&gt;        runoob_author,submission_date</span><br><span class="line">    -&gt; FROM runoob_tbl;</span><br></pre></td></tr></table></figure><p>​     执行以上步骤后，你将完整的复制表，包括表结构及表数据。 </p><h3 id="25-元数据"><a href="#25-元数据" class="headerlink" title="25.  元数据"></a>25.  元数据</h3><p>你可能想知道MySQL以下三种信息：</p><ul><li><strong>查询结果信息：</strong> SELECT, UPDATE 或 DELETE语句影响的记录数。</li><li><strong>数据库和数据表的信息：</strong> 包含了数据库及数据表的结构信息。</li><li><strong>MySQL服务器信息：</strong> 包含了数据库服务器的当前状态，版本号等。</li></ul><p>在MySQL的命令提示符中，我们可以很容易的获取以上服务器信息。 但如果使用Perl或PHP等脚本语言，你就需要调用特定的接口函数来获取。 接下来我们会详细介绍。</p><p>​    元数据主要是为了其他语言了解mysql数据库和数据表信息而设置的。</p><p><strong>获取服务器元数据</strong></p><p>​    以下命令语句可以在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本。 </p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SELECT VERSION( )</td><td>服务器版本信息</td></tr><tr><td>SELECT DATABASE( )</td><td>当前数据库名 (或者返回空)</td></tr><tr><td>SELECT USER( )</td><td>当前用户名</td></tr><tr><td>SHOW STATUS</td><td>服务器状态</td></tr><tr><td>SHOW VARIABLES</td><td>服务器配置变量</td></tr></tbody></table><h3 id="26-序列使用"><a href="#26-序列使用" class="headerlink" title="26. 序列使用"></a>26. 序列使用</h3><p>​    MySQL序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。</p><p>​    本小节将介绍如何使用MySQL的序列。</p><p><strong>使用AUTO_INCREMENT</strong></p><p>​    MySQL中最简单使用序列的方法就是使用 MySQL AUTO_INCREMENT 来定义列。 </p><p><strong>实例</strong></p><p>​    以下实例中创建了数据表insect， insect中id无需指定值可实现自动增长。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE insect</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; PRIMARY KEY (id),</span><br><span class="line">    -&gt; name VARCHAR(30) NOT NULL, # type of insect</span><br><span class="line">    -&gt; date DATE NOT NULL, # date collected</span><br><span class="line">    -&gt; origin VARCHAR(30) NOT NULL # where collected</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">mysql&gt; INSERT INTO insect (id,name,date,origin) VALUES</span><br><span class="line">    -&gt; (NULL,&apos;housefly&apos;,&apos;2001-09-10&apos;,&apos;kitchen&apos;),</span><br><span class="line">    -&gt; (NULL,&apos;millipede&apos;,&apos;2001-09-10&apos;,&apos;driveway&apos;),</span><br><span class="line">    -&gt; (NULL,&apos;grasshopper&apos;,&apos;2001-09-10&apos;,&apos;front yard&apos;);</span><br><span class="line">Query OK, 3 rows affected (0.02 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; SELECT * FROM insect ORDER BY id;</span><br><span class="line">+----+-------------+------------+------------+</span><br><span class="line">| id | name        | date       | origin     |</span><br><span class="line">+----+-------------+------------+------------+</span><br><span class="line">|  1 | housefly    | 2001-09-10 | kitchen    |</span><br><span class="line">|  2 | millipede   | 2001-09-10 | driveway   |</span><br><span class="line">|  3 | grasshopper | 2001-09-10 | front yard |</span><br><span class="line">+----+-------------+------------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>获取AUTO_INCREMENT值</strong></p><p>​    在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。</p><p><strong>重置序列</strong></p><p>​    如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，如果在删除的同时又有新记录添加，有可能会出现数据混乱。操作如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE insect DROP id;</span><br><span class="line">mysql&gt; ALTER TABLE insect</span><br><span class="line">    -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,</span><br><span class="line">    -&gt; ADD PRIMARY KEY (id);</span><br></pre></td></tr></table></figure><p><strong>设置序列的开始值</strong></p><p>​    一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE insect</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt; PRIMARY KEY (id),</span><br><span class="line">    -&gt; name VARCHAR(30) NOT NULL, </span><br><span class="line">    -&gt; date DATE NOT NULL,</span><br><span class="line">    -&gt; origin VARCHAR(30) NOT NULL</span><br><span class="line">)engine=innodb auto_increment=100 charset=utf8;</span><br></pre></td></tr></table></figure><p>​    或者你也可以在表创建成功后，通过以下语句来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE t AUTO_INCREMENT = 100;</span><br></pre></td></tr></table></figure><h3 id="27-处理重复数据"><a href="#27-处理重复数据" class="headerlink" title="27. 处理重复数据"></a>27. 处理重复数据</h3><p>​    有些 MySQL 数据表中可能存在重复的记录，有些情况我们允许重复数据的存在，但有时候我们也需要删除这些重复的数据。</p><p>​    本章节我们将为大家介绍如何防止数据表出现重复数据及如何删除数据表中的重复数据。</p><p><strong>防止表中出现重复数据</strong></p><p>​    你可以在MySQL数据表中设置指定的字段为PRIMARY KEY（主键）或者 UNIQUE（唯一)索引来保证数据的唯一性。让我们尝试一个实例：下表中无索引及主键，所以该表允许出现多条重复记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_tbl(</span><br><span class="line">    first_name CHAR(20),</span><br><span class="line">    last_name CHAR(20),</span><br><span class="line">    sex CHAR(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​    如果你想设置表中字段first_name，last_name数据不能重复，你可以设置双主键模式来设置数据的唯一性， 如果你设置了双主键，那么那个键的默认值不能为NULL，可设置为NOT NULL。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_tbl(</span><br><span class="line">   first_name CHAR(20) NOT NULL,</span><br><span class="line">   last_name CHAR(20) NOT NULL,</span><br><span class="line">   sex CHAR(10),</span><br><span class="line">   PRIMARY KEY (last_name, first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​    如果我们设置了唯一索引，那么在插入重复数据时，SQL语句将无法执行成功,并抛出错。</p><p>​    INSERT IGNORE INTO与INSERT INTO的区别就是INSERT IGNORE会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。</p><p>​    以下实例使用了INSERT IGNORE INTO，执行后不会出错，也不会向数据表中插入重复数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">    -&gt; VALUES( &apos;Jay&apos;, &apos;Thomas&apos;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">    -&gt; VALUES( &apos;Jay&apos;, &apos;Thomas&apos;);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>​    INSERT IGNORE INTO当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而REPLACE INTO into如果存在primary 或 unique相同的记录，则先删除掉。再插入新记录。</p><p>​    另一种设置数据的唯一性方法是添加一个UNIQUE索引，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE person_tbl</span><br><span class="line">(</span><br><span class="line">   first_name CHAR(20) NOT NULL,</span><br><span class="line">   last_name CHAR(20) NOT NULL,</span><br><span class="line">   sex CHAR(10)</span><br><span class="line">   UNIQUE (last_name, first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>统计重复数据</strong></p><p>​    以下我们将统计表中 first_name 和 last_name的重复记录数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT COUNT(*) as repetitions, last_name, first_name</span><br><span class="line">    -&gt; FROM person_tbl</span><br><span class="line">    -&gt; GROUP BY last_name, first_name</span><br><span class="line">    -&gt; HAVING repetitions &gt; 1;</span><br></pre></td></tr></table></figure><p>​    以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作：</p><ul><li>确定哪一列包含的值可能会重复。</li><li>在列选择列表使用COUNT(*)列出的那些列。</li><li>在GROUP BY子句中列出的列。</li><li>HAVING子句设置重复数大于1。</li></ul><p><strong>过滤重复数据</strong></p><p>​    如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT DISTINCT last_name, first_name</span><br><span class="line">    -&gt; FROM person_tbl;</span><br></pre></td></tr></table></figure><p>​    你也可以使用 GROUP BY 来读取数据表中不重复的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT last_name, first_name</span><br><span class="line">    -&gt; FROM person_tbl</span><br><span class="line">    -&gt; GROUP BY (last_name, first_name);</span><br></pre></td></tr></table></figure><p><strong>删除重复数据</strong></p><p>​    如果你想删除数据表中的重复数据，你可以使用以下的SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE tmp SELECT last_name, first_name, sex FROM person_tbl  GROUP BY (last_name, first_name, sex);</span><br><span class="line">mysql&gt; DROP TABLE person_tbl;</span><br><span class="line">mysql&gt; ALTER TABLE tmp RENAME TO person_tbl;</span><br></pre></td></tr></table></figure><p>​    当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER IGNORE TABLE person_tbl</span><br><span class="line">    -&gt; ADD PRIMARY KEY (last_name, first_name);</span><br></pre></td></tr></table></figure><h3 id="28-SQL注入"><a href="#28-SQL注入" class="headerlink" title="28. SQL注入"></a>28. SQL注入</h3><p>​    如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题。</p><p>​    本章节将为大家介绍如何防止SQL注入，并通过脚本来过滤SQL中注入的字符。</p><p>​    所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><p>​    我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。</p><p>​    以下实例中，输入的用户名必须为字母、数字及下划线的组合，且用户名长度为 8 到 20 个字符之间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (preg_match(&quot;/^\w&#123;8,20&#125;$/&quot;, $_GET[&apos;username&apos;], $matches))</span><br><span class="line">&#123;</span><br><span class="line">   $result = mysqli_query($conn, &quot;SELECT * FROM users </span><br><span class="line">                          WHERE username=$matches[0]&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> else </span><br><span class="line">&#123;</span><br><span class="line">   echo &quot;username 输入异常&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    让我们看下在没有过滤特殊字符时，出现的SQL情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 设定$name 中插入了我们不需要的SQL语句</span><br><span class="line">$name = &quot;Qadir&apos;; DELETE FROM users;&quot;;</span><br><span class="line"> mysqli_query($conn, &quot;SELECT * FROM users WHERE name=&apos;&#123;$name&#125;&apos;&quot;);</span><br></pre></td></tr></table></figure><p>​    以上的注入语句中，我们没有对 $name 的变量进行过滤，$name 中插入了我们不需要的SQL语句，将删除 users 表中的所有数据。</p><p>​    在PHP中的 mysqli_query() 是不允许执行多个 SQL 语句的，但是在 SQLite 和 PostgreSQL 是可以同时执行多条SQL语句的，所以我们对这些用户的数据需要进行严格的验证。</p><p>​    防止SQL注入，我们需要注意以下几个要点：</p><ul><li>1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li><li>2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li><li>3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li><li>5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li><li>6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li></ul><h3 id="29-导出数据"><a href="#29-导出数据" class="headerlink" title="29.  导出数据"></a>29.  导出数据</h3><p>MySQL中你可以使用<strong>SELECT…INTO OUTFILE</strong>语句来简单的导出数据到文本文件上。</p><p><strong>使用 SELECT … INTO OUTFILE 语句导出数据</strong></p><p>以下实例中我们将数据表 runoob_tbl 数据导出到 /tmp/tutorials.txt 文件中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM runoob_tbl </span><br><span class="line">    -&gt; INTO OUTFILE &apos;/tmp/tutorials.txt&apos;;</span><br></pre></td></tr></table></figure><p>你可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM passwd INTO OUTFILE &apos;/tmp/tutorials.txt&apos;</span><br><span class="line">    -&gt; FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos;</span><br><span class="line">    -&gt; LINES TERMINATED BY &apos;\r\n&apos;;</span><br></pre></td></tr></table></figure><p>在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos;</span><br><span class="line">FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;</span><br><span class="line">LINES TERMINATED BY &apos;\n&apos;</span><br><span class="line">FROM test_table;</span><br></pre></td></tr></table></figure><p><strong>SELECT … INTO OUTFILE 语句有以下属性:</strong></p><ul><li>LOAD DATA INFILE是SELECT … INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT … INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。</li><li>SELECT…INTO OUTFILE ‘file_name’形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。</li><li>输出不能是一个已存在的文件。防止文件数据被篡改。</li><li>你需要有一个登陆服务器的账号来检索文件。否则 SELECT … INTO OUTFILE 不会起任何作用。</li><li><p>在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除。</p><p>上面这些方法只是基本的导出数据到文件的方式，还有其他导出数据方式，可以参考资料：<a href="http://www.runoob.com/mysql/mysql-database-export.html" target="_blank" rel="noopener">MySQL导出数据</a></p></li></ul><h3 id="30-导入数据"><a href="#30-导入数据" class="headerlink" title="30. 导入数据"></a>30. 导入数据</h3><p>​    MySQL中可以使用两种简单的方式来导入MySQL导出的数据。</p><p><strong>使用 LOAD DATA 导入数据</strong></p><p>​    MySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl;</span><br></pre></td></tr></table></figure><p>​    如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。</p><p>​    你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。</p><p>​    两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。</p><p>​    如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl</span><br><span class="line">  -&gt; FIELDS TERMINATED BY &apos;:&apos;</span><br><span class="line">  -&gt; LINES TERMINATED BY &apos;\r\n&apos;;</span><br></pre></td></tr></table></figure><p>​    LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。</p><p>​    如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; </span><br><span class="line">    -&gt; INTO TABLE mytbl (b, c, a);</span><br></pre></td></tr></table></figure><p><strong>使用 mysqlimport 导入数据</strong></p><p>​    mysqlimport客户端提供了LOAD DATA INFILEQL语句的一个命令行接口。mysqlimport的大多数选项直接对应LOAD DATA INFILE子句。</p><p>​    从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlimport -u root -p --local database_name dump.txt</span><br><span class="line">password *****</span><br></pre></td></tr></table></figure><p>​    mysqlimport命令可以指定选项来设置指定格式,命令语句格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlimport -u root -p --local --fields-terminated-by=&quot;:&quot; \</span><br><span class="line">   --lines-terminated-by=&quot;\r\n&quot;  database_name dump.txt</span><br><span class="line">password *****</span><br></pre></td></tr></table></figure><p>​    mysqlimport 语句中使用 –columns 选项来设置列的顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlimport -u root -p --local --columns=b,c,a \</span><br><span class="line">    database_name dump.txt</span><br><span class="line">password *****</span><br></pre></td></tr></table></figure><p><strong>mysqlimport的常用选项介绍</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d or –delete</td><td>新数据导入数据表中之前删除数据数据表中的所有信息</td></tr><tr><td>-f or –force</td><td>不管是否遇到错误，mysqlimport将强制继续插入数据</td></tr><tr><td>-i or –ignore</td><td>mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。</td></tr><tr><td>-l or -lock-tables</td><td>数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。</td></tr><tr><td>-r or -replace</td><td>这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。</td></tr><tr><td>–fields-enclosed- by= char</td><td>指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。</td></tr><tr><td>–fields-terminated- by=char</td><td>指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab）</td></tr><tr><td>–lines-terminated- by=str</td><td>此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。</td></tr></tbody></table><p>​    mysqlimport命令常用的选项还有-v 显示版本（version）， -p 提示输入密码（password）等。</p><h2 id="四、概念理解"><a href="#四、概念理解" class="headerlink" title="四、概念理解"></a>四、概念理解</h2><h3 id="1-事务的一致性理解"><a href="#1-事务的一致性理解" class="headerlink" title="1. 事务的一致性理解"></a>1. 事务的一致性理解</h3><p>　　一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。<br>　　举个粒子，张三给李四转账100元。事务要做的是从张三账户上减掉100元，李四账户上加上100元。一致性的含义是其他事务要么看到张三还没有给李四转账的状态，要么张三已经成功转账给李四的状态，而对于张三少了100元，李四还没加上100元这个中间状态是不可见的。<br>　　那么反驳的声音来了：<br>　　要么转账操作全部成功，要么全部失败，这是原子性。从例子上看全部成功，那么一致性就是原子性的一部分咯，为什么还要单独说一致性和原子性？<br>　　你说的不对。在未提交读的隔离级别下是事务内部操作是可见的，明显违背了一致性，怎么解释？<br>　　好吧，需要注意的是：<br>    原子性和一致性的的侧重点不同：<strong>原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。</strong>而<strong>一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见</strong>。但是因为某某性能的关系，对于一致性做了妥协</p><p>参考资料：<a href="http://www.cnblogs.com/bc8web/p/8116447.html" target="_blank" rel="noopener">MySQL事务一致性理解</a></p><h3 id="2-事务的隔离性理解"><a href="#2-事务的隔离性理解" class="headerlink" title="2. 事务的隔离性理解"></a>2. 事务的隔离性理解</h3><p>​    <strong>事务的ACID属性：</strong></p><p><strong>Atomicity</strong>: <em>Either all the changes from the transaction occur (writes, and messages sent), or none occur.</em></p><p><strong>Consistency</strong>: <em>The transaction preserves the integrity of stored information.</em> </p><p><strong>Isolation</strong>: <em>Concurrently executing transactions see the stored information as if they were running serially (one after another).</em> </p><p><strong>Durability</strong>: <em>Once a transaction commits, the changes it made (writes and messages sent) survive any system failures.</em> </p><p>​    在上述隔离性（Isolation）的定义中，我们可以发现其目标是使并发事务的执行效果与串行一致，但在具体技术实现上往往需要在并发能力和串行化效果之间进行平衡，很难两者兼顾。平衡的结果就是会出现违反串行效果的现象即异常现象（Phenomenon）。通常来说，隔离级别的提升伴随着并发能力的下降，两者负相关。各种数据库在谈到隔离级别时都会引用ANSI SQL-92标准隔离级别，我们来看看它的具体内容。 </p><p>​    <strong>ANSI SQL-92 Isolation Levels</strong></p><p>​    ANSI SQL-92可能是最早提出了基于异常现象来定义隔离级别的方法，同时没有将隔离级别与具体实现机制绑定，隔离的实现可以基于锁（lock-based）或者无锁（lock-free），兼容了后续的技术发展。该标准根据三种异常现象将隔离性定义为四个级别，具体如下。</p><p><img src="\image\MySQL学习笔记\事务隔离级别.png" alt="事务隔离级别"></p><blockquote><p><strong>脏读</strong>，事务（T1）中修改的数据项在尚未提交的情况下被其他事务（T2）读取到，而T1进行Rollback操作，则T2刚刚读取到的数据并没有实际存在。 </p><p><strong>不可重复读</strong>，T1读取数据项，T2对其中的数据进行了修改或删除且Commit成功。如果T1尝试再次读取这些数据，会得到T2修改后的数据或者发现数据已删除。这样T1在一个事务中两次同样条件的读取，且结果集内容变更或结果集数量减少。 </p><p><strong>幻读</strong>，T1使用特定的查询条件获得一个结果集，T2插入新的数据且这些数据符合T1刚刚操作的查询条件。T2 commit 成功后，T1再次执行同样的查询，此时得到的结果集增大。 </p></blockquote><p>​    上面这些介绍只是最简单的事务隔离级别，还有其他更严谨事务隔离级别分类，可以参考：<a href="https://www.cnblogs.com/ivan-uno/p/8274355.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivan-uno/p/8274355.html</a></p><p>参考资料：<a href="https://www.cnblogs.com/ivan-uno/p/8274355.html" target="_blank" rel="noopener">再谈数据库事务隔离性</a></p><h3 id="3-主键、外键和索引的区别"><a href="#3-主键、外键和索引的区别" class="headerlink" title="3. 主键、外键和索引的区别"></a>3. 主键、外键和索引的区别</h3><table><thead><tr><th></th><th>主键</th><th>外键</th><th>索引</th></tr></thead><tbody><tr><td>定义：</td><td>唯一标识一条记录，不能有重复的，不允许为空</td><td>表的外键是另一表的主键, 外键可以有重复的, 可以是空值</td><td>该字段没有重复值，但可以有一个空值</td></tr><tr><td>作用：</td><td>用来保证数据完整性</td><td>用来和其他表建立联系用的</td><td>是提高查询排序的速度</td></tr><tr><td>个数：</td><td>主键只能有一个</td><td>一个表可以有多个外键</td><td>一个表可以有多个惟一索引</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL学习笔记&quot;&gt;&lt;a href=&quot;#MySQL学习笔记&quot; class=&quot;headerlink&quot; title=&quot;MySQL学习笔记&quot;&gt;&lt;/a&gt;&lt;center&gt;MySQL学习笔记&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;需要补充的知识：Java操作MySQL数据库&lt;/p
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="编程基础知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java常用代码块</title>
    <link href="http://yoursite.com/2018/01/17/1_Java%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>http://yoursite.com/2018/01/17/1_Java常用代码块/</id>
    <published>2018-01-17T02:03:18.000Z</published>
    <updated>2018-07-03T11:53:46.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java常用代码块"><a href="#Java常用代码块" class="headerlink" title="Java常用代码块"></a><center>Java常用代码块<center></center></center></h1><h2 id="1-读取控制台的输入"><a href="#1-读取控制台的输入" class="headerlink" title="1. 读取控制台的输入"></a>1. 读取控制台的输入</h2><p><strong>第一种方式：BufferedReader</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.println(br.readLine());</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure></p><p>​    这种方式，利用字符流来读取控制台的输入，读到的数据全部都是字符串。</p><p><strong>第二种方式: Scanner</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String line = scanner.next();</span><br><span class="line">System.out.println(line);</span><br><span class="line">scanner.close();</span><br></pre></td></tr></table></figure><p>​    第二种方法利用了Scanner类，可以使用next读取字符串，nextInt等方法读取整型等基本类型数据，也就是说Scanner类具有一定的解析能力，如果是读取基本类型数据，推荐使用Scanner。</p><h2 id="2-使用迭代方式实现二叉树的中序遍历"><a href="#2-使用迭代方式实现二叉树的中序遍历" class="headerlink" title="2. 使用迭代方式实现二叉树的中序遍历"></a>2. 使用迭代方式实现二叉树的中序遍历</h2><p>​    实现二叉树的中序遍历，最简单的方式是采用递归。但是在有的题目中，或者一些场景下，不能使用递归，需要使用迭代的方式。这个时候就可以采用栈(Stack或LinkedList)来实现了，其实是对递归过程的一个模拟。下面是具体Java代码块：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * TreeNode left;</span></span><br><span class="line"><span class="comment"> * TreeNode right;</span></span><br><span class="line"><span class="comment"> * TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            list2.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-二叉树的3种遍历的6种实现方法"><a href="#3-二叉树的3种遍历的6种实现方法" class="headerlink" title="3. 二叉树的3种遍历的6种实现方法"></a>3. 二叉树的3种遍历的6种实现方法</h2><p>​    二叉树有先序遍历、中序遍历和后序遍历，对应的都有递归实现和循环实现。递归实现很简洁，但是如果遍历的深度太深的话，那么可能会发生递归栈溢出。循环实现麻烦一点，但是更健壮一些。循环实现的话，主要是使用栈来进行实现。==在六种实现当中一定要多注意一下，二叉树的后序遍历循环实现代码==。<br>    首先定义一个二叉树节点类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//下面的权限是包内可以访问</span></span><br><span class="line">    T val;<span class="comment">//当前节点值</span></span><br><span class="line">    TreeNode&lt;T&gt; left;<span class="comment">//左孩子</span></span><br><span class="line">    TreeNode&lt;T&gt; right;<span class="comment">//右孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-1-先序遍历"><a href="#3-1-先序遍历" class="headerlink" title="3.1 先序遍历"></a>3.1 先序遍历</h3><p>​        <strong>(1)递归实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">firstRootTraverse</span><span class="params">(TreeNode&lt;Integer&gt; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    firstRootTraverse(root.left);</span><br><span class="line">    firstRootTraverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        <strong>(2) 循环实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">firstRootTraverse2</span><span class="params">(TreeNode&lt;Integer&gt; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    LinkedList&lt;TreeNode&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root = stack.pop().right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-中序遍历"><a href="#3-2-中序遍历" class="headerlink" title="3.2 中序遍历"></a>3.2 中序遍历</h3><p>​        <strong>(1)递归实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">middleRootTraverse</span><span class="params">(TreeNode&lt;Integer&gt; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    middleRootTraverse(root.left);</span><br><span class="line">    System.out.println(root.val);<span class="comment">//注意访问root.val相对位置</span></span><br><span class="line">    middleRootTraverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>(2) 循环实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">middleRootTraverse2</span><span class="params">(TreeNode&lt;Integer&gt; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    LinkedList&lt;TreeNode&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            System.out.println(root.val);  <span class="comment">//注意访问 root.val的位置哦</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-后序遍历"><a href="#3-3-后序遍历" class="headerlink" title="3.3 后序遍历"></a>3.3 后序遍历</h3><p>​        <strong>(1)递归实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastRootTraverse</span><span class="params">(TreeNode&lt;Integer&gt; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    lastRootTraverse(root.left);</span><br><span class="line">    lastRootTraverse(root.right);</span><br><span class="line">    System.out.println(root.val);<span class="comment">//注意访问root.val的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <strong>(2) 循环实现</strong></p><p>​    二叉树的后序遍历非递归实现，一定要多注意一点，和前面几种实现相比还是有一定难度的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastRootTraverse2</span><span class="params">(TreeNode&lt;Integer&gt; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkedList&lt;TreeNode&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode&lt;Integer&gt; read_node = <span class="keyword">null</span>;<span class="comment">//记录当前访问的节点</span></span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span> || root.right == read_node)&#123;<span class="comment">//右子节点不存在或者已经访问过了</span></span><br><span class="line">                System.out.println(root.val);</span><br><span class="line">                read_node = stack.pop();</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java常用代码块&quot;&gt;&lt;a href=&quot;#Java常用代码块&quot; class=&quot;headerlink&quot; title=&quot;Java常用代码块&quot;&gt;&lt;/a&gt;&lt;center&gt;Java常用代码块&lt;center&gt;&lt;/center&gt;&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-读
      
    
    </summary>
    
      <category term="编程常用知识" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="代码块" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://yoursite.com/2017/12/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/"/>
    <id>http://yoursite.com/2017/12/18/数据库/Redis/</id>
    <published>2017-12-18T01:05:02.000Z</published>
    <updated>2018-07-04T14:59:01.891Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一redis-是什么">一、Redis 是什么</a></li><li><a href="#二五种基本类型">二、五种基本类型</a><ul><li><a href="#1-string">1. STRING</a></li><li><a href="#2-list">2. LIST</a></li><li><a href="#3-set">3. SET</a></li><li><a href="#4-hash">4. HASH</a></li><li><a href="#5-zset">5. ZSET</a></li></ul></li><li><a href="#三键的过期时间">三、键的过期时间</a></li><li><a href="#四发布与订阅">四、发布与订阅</a></li><li><a href="#五事务">五、事务</a></li><li><a href="#六持久化">六、持久化</a><ul><li><a href="#1-快照持久化">1. 快照持久化</a></li><li><a href="#2-aof-持久化">2. AOF 持久化</a></li></ul></li><li><a href="#七复制">七、复制</a><ul><li><a href="#从服务器连接主服务器的过程">从服务器连接主服务器的过程</a></li><li><a href="#主从链">主从链</a></li></ul></li><li><a href="#八处理故障">八、处理故障</a></li><li><a href="#九分片">九、分片</a><ul><li><a href="#1-客户端分片">1. 客户端分片</a></li><li><a href="#2-代理分片">2. 代理分片</a></li><li><a href="#3-服务器分片">3. 服务器分片</a></li></ul></li><li><a href="#十事件">十、事件</a><ul><li><a href="#事件类型">事件类型</a></li><li><a href="#事件的调度与执行">事件的调度与执行</a></li></ul></li><li><a href="#十一redis-与-memcached-的区别">十一、Redis 与 Memcached 的区别</a><ul><li><a href="#数据类型">数据类型</a></li><li><a href="#数据持久化">数据持久化</a></li><li><a href="#分布式">分布式</a></li><li><a href="#内存管理机制">内存管理机制</a></li></ul></li><li><a href="#十二redis-适用场景">十二、Redis 适用场景</a><ul><li><a href="#缓存">缓存</a></li><li><a href="#消息队列">消息队列</a></li><li><a href="#计数器">计数器</a></li><li><a href="#好友关系">好友关系</a></li></ul></li><li><a href="#十三数据淘汰策略">十三、数据淘汰策略</a></li><li><a href="#十四一个简单的论坛系统分析">十四、一个简单的论坛系统分析</a><ul><li><a href="#文章信息">文章信息</a></li><li><a href="#点赞功能">点赞功能</a></li><li><a href="#对文章进行排序">对文章进行排序</a></li></ul></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、Redis-是什么"><a href="#一、Redis-是什么" class="headerlink" title="一、Redis 是什么"></a>一、Redis 是什么</h1><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p><p>五种类型数据类型为：字符串、列表、集合、有序集合、散列表。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h1 id="二、五种基本类型"><a href="#二、五种基本类型" class="headerlink" title="二、五种基本类型"></a>二、五种基本类型</h1><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">可以存储的值</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">STRING</td><td style="text-align:center">字符串、整数或者浮点数</td><td style="text-align:center">对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">链表</td><td style="text-align:center">从两端压入或者弹出元素<br> 读取单个或者多个元素<br> 进行修剪，只保留一个范围内的元素</td></tr><tr><td style="text-align:center">SET</td><td style="text-align:center">无序集合</td><td style="text-align:center">添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">包含键值对的无序散列表</td><td style="text-align:center">添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td></tr><tr><td style="text-align:center">ZSET</td><td style="text-align:center">有序集合</td><td style="text-align:center">添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p></blockquote><h2 id="1-STRING"><a href="#1-STRING" class="headerlink" title="1. STRING"></a>1. STRING</h2><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//6019b2db-bc3e-4408-b6d8-96025f4481d6.png" width="400"> </div><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">"world"</span><br><span class="line">&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h2 id="2-LIST"><a href="#2-LIST" class="headerlink" title="2. LIST"></a>2. LIST</h2><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//fb327611-7e2b-4f2f-9f5b-38592d408f07.png" width="400"> </div><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item"</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">"item2"</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">"item"</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) "item2"</span><br><span class="line">2) "item"</span><br></pre></td></tr></table></figure><h2 id="3-SET"><a href="#3-SET" class="headerlink" title="3. SET"></a>3. SET</h2><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" width="400"> </div><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item3"</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item3"</span><br></pre></td></tr></table></figure><h2 id="4-HASH"><a href="#4-HASH" class="headerlink" title="4. HASH"></a>4. HASH</h2><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//7bd202a7-93d4-4f3a-a878-af68ae25539a.png" width="400"> </div><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br><span class="line">3) "sub-key2"</span><br><span class="line">4) "value2"</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">"value1"</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br></pre></td></tr></table></figure><h2 id="5-ZSET"><a href="#5-ZSET" class="headerlink" title="5. ZSET"></a>5. ZSET</h2><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//1202b2d6-9469-4251-bd47-ca6034fb6116.png" width="400"> </div><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line">3) "member0"</span><br><span class="line">4) "982"</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member0"</span><br><span class="line">2) "982"</span><br></pre></td></tr></table></figure><h1 id="三、键的过期时间"><a href="#三、键的过期时间" class="headerlink" title="三、键的过期时间"></a>三、键的过期时间</h1><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><p>过期时间对于清理缓存数据非常有用。</p><h1 id="四、发布与订阅"><a href="#四、发布与订阅" class="headerlink" title="四、发布与订阅"></a>四、发布与订阅</h1><p>订阅者订阅了频道之后，发布者向频道发送字符串消息会被所有订阅者接收到。</p><p>发布与订阅模式和观察者模式有以下不同：</p><ul><li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，发布者与订阅者不知道对方的存在，它们之间通过频道进行通信。</li><li>观察者模式是同步的，当事件触发时，主题会去调度观察者的方法；而发布与订阅模式是异步的；</li></ul><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//bee1ff1d-c80f-4b3c-b58c-7073a8896ab2.jpg" width="400"> </div><br></p><p>发布与订阅有一些问题，很少使用它，而是使用替代的解决方案。问题如下：</p><ol><li>如果订阅者读取消息的速度很慢，会使得消息不断积压在发布者的输出缓存区中，造成内存占用过多；</li><li>如果订阅者在执行订阅的过程中网络出现问题，那么就会丢失断线期间发送的所有消息。</li></ol><h1 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h1><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><p>MULTI 和 EXEC 中的操作将会一次性发送给服务器，而不是一条一条发送，这种方式称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><h1 id="六、持久化"><a href="#六、持久化" class="headerlink" title="六、持久化"></a>六、持久化</h1><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h2 id="1-快照持久化"><a href="#1-快照持久化" class="headerlink" title="1. 快照持久化"></a>1. 快照持久化</h2><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h2 id="2-AOF-持久化"><a href="#2-AOF-持久化" class="headerlink" title="2. AOF 持久化"></a>2. AOF 持久化</h2><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，然后由操作系统决定什么时候将该内容同步到硬盘，用户可以调用 file.flush() 方法请求操作系统尽快将缓冲区存储的数据同步到硬盘。</p><p>将写命令添加到 AOF 文件时，要根据需求来保证何时将添加的数据同步到硬盘上，有以下同步选项：</p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">同步频率</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">每个写命令都同步</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒同步一次</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">让操作系统来决定何时同步</td></tr></tbody></table><p>always 选项会严重减低服务器的性能；everysec 选项比较合适，可以保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；no 选项并不能给服务器性能带来多大的提升，而且也会增加系统奔溃时数据丢失的数量。</p><p>随着服务器写请求的增多，AOF 文件会越来越大；Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h1 id="七、复制"><a href="#七、复制" class="headerlink" title="七、复制"></a>七、复制</h1><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><h2 id="从服务器连接主服务器的过程"><a href="#从服务器连接主服务器的过程" class="headerlink" title="从服务器连接主服务器的过程"></a>从服务器连接主服务器的过程</h2><ol><li><p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p></li><li><p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p></li><li><p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p></li></ol><h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" width="600"> </div><br></p><h1 id="八、处理故障"><a href="#八、处理故障" class="headerlink" title="八、处理故障"></a>八、处理故障</h1><p>要用到持久化文件来恢复服务器的数据。</p><p>持久化文件可能因为服务器出错也有错误，因此要先对持久化文件进行验证和修复。对 AOF 文件就行验证和修复很容易，修复操作将第一个出错命令和其后的所有命令都删除；但是只能验证快照文件，无法对快照文件进行修复，因为快照文件进行了压缩，出现在快照文件中间的错误可能会导致整个快照文件的剩余部分无法读取。</p><p>当主服务器出现故障时，Redis 常用的做法是新开一台服务器作为主服务器，具体步骤如下：假设 A 为主服务器，B 为从服务器，当 A 出现故障时，让 B 生成一个快照文件，将快照文件发送给 C，并让 C 恢复快照文件的数据。最后，让 B 成为 C 的从服务器。</p><h1 id="九、分片"><a href="#九、分片" class="headerlink" title="九、分片"></a>九、分片</h1><p>Redis 中的分片类似于 MySQL 的分表操作，分片是将数据划分为多个部分的方法，对数据的划分可以基于键包含的 ID、基于键的哈希值，或者基于以上两者的某种组合。通过对数据进行分片，用户可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Reids 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… 等等，有不同的方式来选择一个指定的键存储在哪个实例中。最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</p><h2 id="1-客户端分片"><a href="#1-客户端分片" class="headerlink" title="1. 客户端分片"></a>1. 客户端分片</h2><p>客户端使用一致性哈希等算法决定键应当分布到哪个节点。</p><h2 id="2-代理分片"><a href="#2-代理分片" class="headerlink" title="2. 代理分片"></a>2. 代理分片</h2><p>将客户端请求发送到代理上，由代理转发请求到正确的节点上。</p><h2 id="3-服务器分片"><a href="#3-服务器分片" class="headerlink" title="3. 服务器分片"></a>3. 服务器分片</h2><p>Redis Cluster。</p><h1 id="十、事件"><a href="#十、事件" class="headerlink" title="十、事件"></a>十、事件</h1><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="1-文件事件"><a href="#1-文件事件" class="headerlink" title="1. 文件事件"></a>1. 文件事件</h3><p>服务器有许多套接字，事件产生时会对这些套接字进行操作，服务器通过监听套接字来处理事件。常见的文件事件有：客户端的连接事件；客户端的命令请求事件；服务器向客户端返回命令结果的事件；</p><h3 id="2-时间事件"><a href="#2-时间事件" class="headerlink" title="2. 时间事件"></a>2. 时间事件</h3><p>又分为两类：定时事件是让一段程序在指定的时间之内执行一次；周期性事件是让一段程序每隔指定时间就执行一次。</p><h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能监听太久，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据 remaind_ms 的值，创建 timeval</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">    procesFileEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化服务器</span></span><br><span class="line">    init_server()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一直处理事件，直到服务器关闭为止</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 服务器关闭，执行清理操作</span></span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure><p>从事件处理的角度来看，服务器运行流程如下：</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//dda1608d-26e0-4f10-8327-a459969b150a.png" width=""> </div><br></p><h1 id="十一、Redis-与-Memcached-的区别"><a href="#十一、Redis-与-Memcached-的区别" class="headerlink" title="十一、Redis 与 Memcached 的区别"></a>十一、Redis 与 Memcached 的区别</h1><p>两者都是非关系型内存键值数据库。有以下主要不同：</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis Cluster 实现了分布式的支持。</p><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</p><p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p><h1 id="十二、Redis-适用场景"><a href="#十二、Redis-适用场景" class="headerlink" title="十二、Redis 适用场景"></a>十二、Redis 适用场景</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>将热点数据放到内存中。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>List 类型是双向链表，很适合用于消息队列。</p><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>Redis 这种内存数据库能支持计数器频繁的读写操作。</p><h2 id="好友关系"><a href="#好友关系" class="headerlink" title="好友关系"></a>好友关系</h2><p>使用 Set 类型的交集操作很容易就可以知道两个用户的共同好友。</p><h1 id="十三、数据淘汰策略"><a href="#十三、数据淘汰策略" class="headerlink" title="十三、数据淘汰策略"></a>十三、数据淘汰策略</h1><p>可以设置内存最大使用量，当内存使用量超过时施行淘汰策略，具体有 6 种淘汰策略。</p><table><thead><tr><th style="text-align:center">策略</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">volatile-lru</td><td style="text-align:center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td style="text-align:center">volatile-ttl</td><td style="text-align:center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td style="text-align:center">volatile-random</td><td style="text-align:center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td style="text-align:center">allkeys-lru</td><td style="text-align:center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td style="text-align:center">allkeys-random</td><td style="text-align:center">从所有数据集中任意选择数据进行淘汰</td></tr><tr><td style="text-align:center">noeviction</td><td style="text-align:center">禁止驱逐数据</td></tr></tbody></table><p>如果使用 Redis 来缓存数据时，要保证所有数据都是热点数据，可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法（LRU、TTL）实际实现上并非针对所有 key，而是抽样一小部分 key 从中选出被淘汰 key。抽样数量可通过 maxmemory-samples 配置。</p><h1 id="十四、一个简单的论坛系统分析"><a href="#十四、一个简单的论坛系统分析" class="headerlink" title="十四、一个简单的论坛系统分析"></a>十四、一个简单的论坛系统分析</h1><p>该论坛系统功能如下：</p><ul><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示；</li></ul><h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//7c54de21-e2ff-402e-bc42-4037de1c1592.png" width="400"> </div><br></p><h2 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h2><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//485fdf34-ccf8-4185-97c6-17374ee719a0.png" width="400"> </div><br></p><h2 id="对文章进行排序"><a href="#对文章进行排序" class="headerlink" title="对文章进行排序"></a>对文章进行排序</h2><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p><p><div align="center"> <img src="G:/桌面文件和文件夹/学习/知识积累_md文件/image/pics//f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" width="800"> </div><br></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li><li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li><li><a href="https://redislabs.com/ebook/foreword/" target="_blank" rel="noopener">REDIS IN ACTION</a></li><li><a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener">论述 Redis 和 Memcached 的差异</a></li><li><a href="http://wiki.jikexueyuan.com/project/redis-guide" target="_blank" rel="noopener">Redis 3.0 中文版- 分片</a></li><li><a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">Redis 应用场景</a></li><li><a href="http://developers-club.com/posts/270339/" target="_blank" rel="noopener">Observer vs Pub-Sub</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一redis-是什么&quot;&gt;一、Redis 是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二五种基本类型&quot;&gt;二、五种基本类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-string&quot;&gt;1. STRI
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="编程基础知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="NOSQL" scheme="http://yoursite.com/tags/NOSQL/"/>
    
  </entry>
  
</feed>
