<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Math For Programmers]]></title>
    <url>%2F2018%2F06%2F24%2FMath%20For%20Programmers%2F</url>
    <content type="text"><![CDATA[Math For ProgrammersI’ve been working for the past 15 months on repairing my rusty math skills, ever since I read a biography of Johnny von Neumann. I’ve read a huge stack of math books, and I have an even bigger stack of unread math books. And it’s starting to come together. Let me tell you about it. Conventional Wisdom Doesn’t Add UpFirst: programmers don’t think they need to know math. I hear that so often; I hardly know anyone who disagrees. Even programmers who were math majors tell me they don’t really use math all that much! They say it’s better to know about design patterns, object-oriented methodologies, software tools, interface design, stuff like that. And you know what? They’re absolutely right. You can be a good, solid, professional programmer without knowing much math. But hey, you don’t really need to know how to program, either. Let’s face it: there are a lot of professional programmers out there who realize they’re not very good at it, and they still find ways to contribute. If you’re suddenly feeling out of your depth, and everyone appears to be running circles around you, what are your options? Well, you might discover you’re good at project management, or people management, or UI design, or technical writing, or system administration, any number of other important things that “programmers” aren’t necessarily any good at. You’ll start filling those niches (because there’s always more work to do), and as soon as you find something you’re good at, you’ll probably migrate towards doing it full-time. In fact, I don’t think you need to know anything, as long as you can stay alive somehow. So they’re right: you don’t need to know math, and you can get by for your entire life just fine without it. But a few things I’ve learned recently might surprise you: Math is a lot easier to pick up after you know how to program. In fact, if you’re a halfway decent programmer, you’ll find it’s almost a snap. They teach math all wrong in school. Way, WAY wrong. If you teach yourself math the right way, you’ll learn faster, remember it longer, and it’ll be much more valuable to you as a programmer. Knowing even a little of the right kinds of math can enable you do write some pretty interesting programs that would otherwise be too hard. In other words, math is something you can pick up a little at a time, whenever you have free time. Nobody knows all of math, not even the best mathematicians. The field is constantly expanding, as people invent new formalisms to solve their own problems. And with any given math problem, just like in programming, there’s more than one way to do it. You can pick the one you like best. Math is… ummm, please don’t tell anyone I said this; I’ll never get invited to another party as long as I live. But math, well… I’d better whisper this, so listen up: (it’s actually kinda fun.) The Math You Learned (And Forgot)Here’s the math I learned in school, as far as I can remember: Grade School: Numbers, Counting, Arithmetic, Pre-Algebra (“story problems”) High School: Algebra, Geometry, Advanced Algebra, Trigonometry, Pre-Calculus (conics and limits) College: Differential and Integral Calculus, Differential Equations, Linear Algebra, Probability and Statistics, Discrete Math How’d they come up with that particular list for high school, anyway? It’s more or less the same courses in most U.S. high schools. I think it’s very similar in other countries, too, except that their students have finished the list by the time they’re nine years old. (Americans really kick butt at monster-truck competitions, though, so it’s not a total loss.) Algebra? Sure. No question. You need that. And a basic understanding of Cartesian geometry, too. Those are useful, and you can learn everything you need to know in a few months, give or take. But the rest of them? I think an introduction to the basics might be useful, but spending a whole semester or year on them seems ridiculous. I’m guessing the list was designed to prepare students for science and engineering professions. The math courses they teach in and high school don’t help ready you for a career in programming, and the simple fact is that the number of programming jobs is rapidly outpacing the demand for all other engineering roles. And even if you’re planning on being a scientist or an engineer, I’ve found it’s much easier to learn and appreciate geometry and trig after you understand what exactly math is — where it came from, where it’s going, what it’s for. No need to dive right into memorizing geometric proofs and trigonometric identities. But that’s exactly what high schools have you do. So the list’s no good anymore. Schools are teaching us the wrong math, and they’re teaching it the wrong way. It’s no wonder programmers think they don’t need any math: most of the math we learned isn’t helping us. The Math They Didn’t Teach YouThe math computer scientists use regularly, in real life, has very little overlap with the list above. For one thing, most of the math you learn in grade school and high school is continuous: that is, math on the real numbers. For computer scientists, 95% or more of the interesting math is discrete: i.e., math on the integers. I’m going to talk in a future blog about some key differences between computer science, software engineering, programming, hacking, and other oft-confused disciplines. I got the basic framework for these (upcoming) insights in no small part from Richard Gabriel’s Patterns Of Software, so if you absolutely can’t wait, go read that. It’s a good book. For now, though, don’t let the term “computer scientist” worry you. It sounds intimidating, but math isn’t the exclusive purview of computer scientists; you can learn it all by yourself as a closet hacker, and be just as good (or better) at it than they are. Your background as a programmer will help keep you focused on the practical side of things. The math we use for modeling computational problems is, by and large, math on discrete integers. This is a generalization. If you’re with me on today’s blog, you’ll be studying a little more math from now on than you were planning to before today, and you’ll discover places where the generalization isn’t true. But by then, a short time from now, you’ll be confident enough to ignore all this and teach yourself math the way you want to learn it. For programmers, the most useful branch of discrete math is probability theory. It’s the first thing they should teach you after arithmetic, in grade school. What’s probability theory, you ask? Why, it’s counting. How many ways are there to make a Full House in poker? Or a Royal Flush? Whenever you think of a question that starts with “how many ways…” or “what are the odds…”, it’s a probability question. And as it happens (what are the odds?), it all just turns out to be “simple” counting. It starts with flipping a coin and goes from there. It’s definitely the first thing they should teach you in grade school after you learn Basic Calculator Usage. I still have my discrete math textbook from college. It’s a bit heavyweight for a third-grader (maybe), but it does cover a lot of the math we use in “everyday” computer science and computer engineering. Oddly enough, my professor didn’t tell me what it was for. Or I didn’t hear. Or something. So I didn’t pay very close attention: just enough to pass the course and forget this hateful topic forever, because I didn’t think it had anything to do with programming. That happened in quite a few of my comp sci courses in college, maybe as many as 25% of them. Poor me! I had to figure out what was important on my own, later, the hard way. I think it would be nice if every math course spent a full week just introducing you to the subject, in the most fun way possible, so you know why the heck you’re learning it. Heck, that’s probably true for every course. Aside from probability and discrete math, there are a few other branches of mathematics that are potentially quite useful to programmers, and they usually don’t teach them in school, unless you’re a math minor. This list includes: Statistics, some of which is covered in my discrete math book, but it’s really a discipline of its own. A pretty important one, too, but hopefully it needs no introduction. Algebra and Linear Algebra (i.e., matrices). They should teach Linear Algebra immediately after algebra. It’s pretty easy, and it’s amazingly useful in all sorts of domains, including machine learning. Mathematical Logic. I have a really cool totally unreadable book on the subject by Stephen Kleene, the inventor of the Kleene closure and, as far as I know, Kleenex. Don’t read that one. I swear I’ve tried 20 times, and never made it past chapter 2. If anyone has a recommendation for a better introduction to this field, please post a comment. It’s obviously important stuff, though. Information Theory and Kolmogorov Complexity. Weird, eh? I bet none of your high schools taught either of those. They’re both pretty new. Information theory is (veeery roughly) about data compression, and Kolmogorov Complexity is (also roughly) about algorithmic complexity. I.e., how small you can you make it, how long will it take, how elegant can the program or data structure be, things like that. They’re both fun, interesting and useful. There are others, of course, and some of the fields overlap. But it just goes to show: the math that you’ll find useful is pretty different from the math your school thought would be useful. What about calculus? Everyone teaches it, so it must be important, right? Well, calculus is actually pretty easy. Before I learned it, it sounded like one of the hardest things in the universe, right up there with quantum mechanics. Quantum mechanics is still beyond me, but calculus is nothing. After I realized programmers can learn math quickly, I picked up my Calculus textbook and got through the entire thing in about a month, reading for an hour an evening. Calculus is all about continuums — rates of change, areas under curves, volumes of solids. Useful stuff, but the exact details involve a lot of memorization and a lot of tedium that you don’t normally need as a programmer. It’s better to know the overall concepts and techniques, and go look up the details when you need them. Geometry, trigonometry, differentiation, integration, conic sections, differential equations, and their multidimensional and multivariate versions — these all have important applications. It’s just that you don’t need to know them right this second. So it probably wasn’t a great idea to make you spend years and years doing proofs and exercises with them, was it? If you’re going to spend that much time studying math, it ought to be on topics that will remain relevant to you for life. The Right Way To Learn MathThe right way to learn math is breadth-first, not depth-first. You need to survey the space, learn the names of things, figure out what’s what. To put this in perspective, think about long division. Raise your hand if you can do long division on paper, right now. Hands? Anyone? I didn’t think so. I went back and looked at the long-division algorithm they teach in grade school, and damn if it isn’t annoyingly complicated. It’s deterministic, sure, but you never have to do it by hand, because it’s easier to find a calculator, even if you’re stuck on a desert island without electricity. You’ll still have a calculator in your watch, or your dental filling, or something. Why do they even teach it to you? Why do we feel vaguely guilty if we can’t remember how to do it? It’s not as if we need to know it anymore. And besides, if your life were on the line, you know you could perform long division of any arbitrarily large numbers. Imagine you’re imprisoned in some slimy 3rd-world dungeon, and the dictator there won’t let you out until you’ve computed 219308862/103503391. How would you do it? Well, easy. You’d start subtracting the denominator from the numerator, keeping a counter, until you couldn’t subtract it anymore, and that’d be the remainder. If pressed, you could figure out a way to continue using repeated subtraction to estimate the remainder as decimal number (in this case, 0.1185678219, or so my Emacs ==M-x calc== tells me. Close enough!) You could figure it out because you know that division is just repeated subtraction. The intuitive notion of division is deeply ingrained now. The right way to learn math is to ignore the actual algorithms and proofs, for the most part, and to start by learning a little bit about all the techniques: their names, what they’re useful for, approximately how they’re computed, how long they’ve been around, (sometimes) who invented them, what their limitations are, and what they’re related to. Think of it as a Liberal Arts degree in mathematics. Why? Because the first step to applying mathematics is problem identification. If you have a problem to solve, and you have no idea where to start, it could take you a long time to figure it out. But if you know it’s a differentiation problem, or a convex optimization problem, or a boolean logic problem, then you at least know where to start looking for the solution. There are lots and lots of mathematical techniques and entire sub-disciplines out there now. If you don’t know what combinatorics is, not even the first clue, then you’re not very likely to be able to recognize problems for which the solution is found in combinatorics, are you? But that’s actually great news, because it’s easier to read about the field and learn the names of everything than it is to learn the actual algorithms and methods for modeling and computing the results. In school they teach you the Chain Rule, and you can memorize the formula and apply it on exams, but how many students really know what it “means”? So they’re not going to be able to know to apply the formula when they run across a chain-rule problem in the wild. Ironically, it’s easier to know what it is than to memorize and apply the formula. The chain rule is just how to take the derivative of “chained” functions — meaning, function x() calls function g(), and you want the derivative of x(g()). Well, programmers know all about functions; we use them every day, so it’s much easier to imagine the problem now than it was back in school. Which is why I think they’re teaching math wrong. They’re doing it wrong in several ways. They’re focusing on specializations that aren’t proving empirically to be useful to most high-school graduates, and they’re teaching those specializations backwards. You should learn how to count, and how to program, before you learn how to take derivatives and perform integration. I think the best way to start learning math is to spend 15 to 30 minutes a day surfing in Wikipedia. It’s filled with articles about thousands of little branches of mathematics. You start with pretty much any article that seems interesting (e.g. String theory, say, or the Fourier transform, or Tensors, anything that strikes your fancy. Start reading. If there’s something you don’t understand, click the link and read about it. Do this recursively until you get bored or tired. Doing this will give you amazing perspective on mathematics, after a few months. You’ll start seeing patterns — for instance, it seems that just about every branch of mathematics that involves a single variable has a more complicated multivariate version, and the multivariate version is almost always represented by matrices of linear equations. At least for applied math. So Linear Algebra will gradually bump its way up your list, until you feel compelled to learn how it actually works, and you’ll download a PDF or buy a book, and you’ll figure out enough to make you happy for a while. With the Wikipedia approach, you’ll also quickly find your way to the Foundations of Mathematics, the Rome to which all math roads lead. Math is almost always about formalizing our “common sense” about some domain, so that we can deduce and/or prove new things about that domain. Metamathematics is the fascinating study of what the limits are on math itself: the intrinsic capabilities of our formal models, proofs, axiomatic systems, and representations of rules, information, and computation. One great thing that soon falls by the wayside is notation. Mathematical notation is the biggest turn-off to outsiders. Even if you’re familiar with summations, integrals, polynomials, exponents, etc., if you see a thick nest of them your inclination is probably to skip right over that sucker as one atomic operation. However, by surveying math, trying to figure out what problems people have been trying to solve (and which of these might actually prove useful to you someday), you’ll start seeing patterns in the notation, and it’ll stop being so alien-looking. For instance, a summation sign (capital-sigma) or product sign (capital-pi) will look scary at first, even if you know the basics. But if you’re a programmer, you’ll soon realize it’s just a loop: one that sums values, one that multiplies them. Integration is just a summation over a continuous section of a curve, so that won’t stay scary for very long, either. Once you’re comfortable with the many branches of math, and the many different forms of notation, you’re well on your way to knowing a lot of useful math. Because it won’t be scary anymore, and next time you see a math problem, it’ll jump right out at you. “Hey,” you’ll think, “I recognize that. That’s a multiplication sign!” And then you should pull out the calculator. It might be a very fancy calculator such as R, Matlab, Mathematica, or a even C library for support vector machines. But almost all useful math is heavily automatable, so you might as well get some automated servants to help you with it. When Are Exercises Useful?After a year of doing part-time hobbyist catch-up math, you’re going to be able to do a lot more math in your head, even if you never touch a pencil to a paper. For instance, you’ll see polynomials all the time, so eventually you’ll pick up on the arithmetic of polynomials by osmosis. Same with logarithms, roots, transcendentals, and other fundamental mathematical representations that appear nearly everywhere. I’m still getting a feel for how many exercises I want to work through by hand. I’m finding that I like to be able to follow explanations (proofs) using a kind of “plausibility test” — for instance, if I see someone dividing two polynomials, I kinda know what form the result should take, and if their result looks more or less right, then I’ll take their word for it. But if I see the explanation doing something that I’ve never heard of, or that seems wrong or impossible, then I’ll dig in some more. That’s a lot like reading programming-language source code, isn’t it? You don’t need to hand-simulate the entire program state as you read someone’s code; if you know what approximate shape the computation will take, you can simply check that their result makes sense. E.g. if the result should be a list, and they’re returning a scalar, maybe you should dig in a little more. But normally you can scan source code almost at the speed you’d read English text (sometimes just as fast), and you’ll feel confident that you understand the overall shape and that you’ll probably spot any truly egregious errors. I think that’s how mathematically-inclined people (mathematicians and hobbyists) read math papers, or any old papers containing a lot of math. They do the same sort of sanity checks you’d do when reading code, but no more, unless they’re intent on shooting the author down. With that said, I still occasionally do math exercises. If something comes up again and again (like algebra and linear algebra), then I’ll start doing some exercises to make sure I really understand it. But I’d stress this: don’t let exercises put you off the math. If an exercise (or even a particular article or chapter) is starting to bore you, move on. Jump around as much as you need to. Let your intuition guide you. You’ll learn much, much faster doing it that way, and your confidence will grow almost every day. How Will This Help Me?Well, it might not — not right away. Certainly it will improve your logical reasoning ability; it’s a bit like doing exercise at the gym, and your overall mental fitness will get better if you’re pushing yourself a little every day. For me, I’ve noticed that a few domains I’ve always been interested in (including artificial intelligence, machine learning, natural language processing, and pattern recognition) use a lot of math. And as I’ve dug in more deeply, I’ve found that the math they use is no more difficult than the sum total of the math I learned in high school; it’s just different math, for the most part. It’s not harder. And learning it is enabling me to code (or use in my own code) neural networks, genetic algorithms, bayesian classifiers, clustering algorithms, image matching, and other nifty things that will result in cool applications I can show off to my friends. And I’ve gradually gotten to the point where I no longer break out in a cold sweat when someone presents me with an article containing math notation: n-choose-k, differentials, matrices, determinants, infinite series, etc. The notation is actually there to make it easier, but (like programming-language syntax) notation is always a bit tricky and daunting on first contact. Nowadays I can follow it better, and it no longer makes me feel like a plebian when I don’t know it. Because I know I can figure it out. And that’s a good thing. And I’ll keep getting better at this. I have lots of years left, and lots of books, and articles. Sometimes I’ll spend a whole weekend reading a math book, and sometimes I’ll go for weeks without thinking about it even once. But like any hobby, if you simply trust that it will be interesting, and that it’ll get easier with time, you can apply it as often or as little as you like and still get value out of it. Math every day. What a great idea that turned out to be! 转载自：https://blog.csdn.net/rideronstorm/article/details/629178]]></content>
      <categories>
        <category>编程知识扩展</category>
        <category>文章摘抄</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
        <tag>编程知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程]]></title>
    <url>%2F2018%2F05%2F23%2F1_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[java多线程进程与线程的概念1、进程 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。 进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。 2、线程 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组 成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个 进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程 在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。 ​ 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位，是运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 参考资料：进程、线程、协程之概念理解 多线程​ 写在前面的话：此文只能说是java多线程的一个入门，其实Java里头线程完全可以写一本书了，但是如果最基本的你都学掌握好，又怎么能更上一个台阶呢？如果觉得此文很简单，可以看看Java并发包的的线程池（Java并发编程与技术内幕:线程池深入理解），或者看这个专栏：Java并发编程与技术内幕。将会对Java里头的高并发场景下的线程有更加深刻的理解。 ​ 本文主要讲了java中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别： ​ 进程： 每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位） ​ 线程： 同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位 ） 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。 ​ 在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用，此文这里不讲这个，有兴趣看这里Java并发编程与技术内幕:Callable、Future、FutureTask、CompletionService ) 一、扩展java.lang.Thread类​ 这里继承Thread类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用Thread.（推荐使用Runable，后头会说明为什么）。下面来看一个简单的实例。 1234567891011121314151617181920212223242526272829303132333435package com.multithread.learning; /** *@functon 多线程学习 *@author 林炳文 *@time 2015.3.9 */ class Thread1 extends Thread&#123; private String name; public Thread1(String name) &#123; this.name=name; &#125; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + "运行 : " + i); try &#123; sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; Thread1 mTh1=new Thread1("A"); Thread1 mTh2=new Thread1("B"); mTh1.start(); mTh2.start(); &#125; &#125; 输出： A运行 : 0B运行 : 0A运行 : 1A运行 : 2A运行 : 3A运行 : 4B运行 : 1B运行 : 2B运行 : 3B运行 : 4 再运行一下： A运行 : 0 B运行 : 0 B运行 : 1 B运行 : 2 B运行 : 3 B运行 : 4 A运行 : 1 A运行 : 2 A运行 : 3 A运行 : 4 说明：​ 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。 注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。 ​ 从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。 ​ Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。 ​ 实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。 ​ 但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。 1234Thread1 mTh1=new Thread1("A");Thread1 mTh2=mTh1;mTh1.start();mTh2.start(); 输出：123Exception in thread "main" java.lang.IllegalThreadStateExceptionat java.lang.Thread.start(Unknown Source)at com.multithread.learning.Main.main(Main.java:31) A运行 : 0A运行 : 1A运行 : 2A运行 : 3A运行 : 4 二、实现java.lang.Runnable接口​ 采用Runnable也是非常常见的一种，我们只需要重写run方法即可。下面也来看个实例。 123456789101112131415161718192021222324252627282930313233343536/** *@functon 多线程学习 *@author 林炳文 *@time 2015.3.9 */ package com.multithread.runnable; class Thread2 implements Runnable&#123; private String name; public Thread2(String name) &#123; this.name=name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + "运行 : " + i); try &#123; Thread.sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; new Thread(new Thread2("C")).start(); new Thread(new Thread2("D")).start(); &#125; &#125; 输出： C运行 : 0D运行 : 0D运行 : 1C运行 : 1D运行 : 2C运行 : 2D运行 : 3C运行 : 3D运行 : 4C运行 : 4 说明： ​ Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 ​ 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 ​ 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 三、Thread和Runnable的区别​ 如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 总结： ​ 实现Runnable接口比继承Thread类所具有的优势： ​ 1）：适合多个相同的程序代码的线程去处理同一个资源 ​ 2）：可以避免java中的单继承的限制 ​ 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 ​ 4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类 ​ 提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。 ​ 在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实习在就是在操作系统中启动了一个进程。 四、线程状态转换​ 下面的这个图非常重要！你如果看懂了这个图，那么对于多线程的理解将会更加深刻！ 1、新建状态（New）：新创建了一个线程对象。 2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： （一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁) （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 （三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁） 5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 五、线程调度线程的调度 1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。 Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量： 123456static int MAX_PRIORITY 线程可以具有的最高优先级，取值为10。 static int MIN_PRIORITY 线程可以具有的最低优先级，取值为1。 static int NORM_PRIORITY 分配给线程的默认优先级，取值为5。 ​ Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。 ​ 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。 ​ 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。 ​ JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。 2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。 3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。 4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。 六、常用函数说明①sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）②join():指等待t线程终止。 使用方式。 ​ join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。 ​ Thread t = new AThread(); t.start(); t.join(); 为什么要用join()方法 ​ 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 不加join。 12345678910111213141516171819202122232425262728293031323334353637383940/** *@functon 多线程学习,join *@author 林炳文 *@time 2015.3.9 */ package com.multithread.join; class Thread1 extends Thread&#123; private String name; public Thread1(String name) &#123; super(name); this.name=name; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + " 线程运行开始!"); for (int i = 0; i &lt; 5; i++) &#123; System.out.println("子线程"+name + "运行 : " + i); try &#123; sleep((int) Math.random() * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + " 线程运行结束!"); &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()+"主线程运行开始!"); Thread1 mTh1=new Thread1("A"); Thread1 mTh2=new Thread1("B"); mTh1.start(); mTh2.start(); System.out.println(Thread.currentThread().getName()+ "主线程运行结束!"); &#125; &#125; 输出结果：main主线程运行开始!main主线程运行结束!B 线程运行开始!子线程B运行 : 0A 线程运行开始!子线程A运行 : 0子线程B运行 : 1子线程A运行 : 1子线程A运行 : 2子线程A运行 : 3子线程A运行 : 4A 线程运行结束!子线程B运行 : 2子线程B运行 : 3子线程B运行 : 4B 线程运行结束! 发现主线程比子线程早结束 加join1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()+"主线程运行开始!"); Thread1 mTh1=new Thread1("A"); Thread1 mTh2=new Thread1("B"); mTh1.start(); mTh2.start(); try &#123; mTh1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; mTh2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+ "主线程运行结束!"); &#125; &#125; 运行结果：main主线程运行开始!A 线程运行开始!子线程A运行 : 0B 线程运行开始!子线程B运行 : 0子线程A运行 : 1子线程B运行 : 1子线程A运行 : 2子线程B运行 : 2子线程A运行 : 3子线程B运行 : 3子线程A运行 : 4子线程B运行 : 4A 线程运行结束!主线程一定会等子线程都结束了才结束 ③yield():暂停当前正在执行的线程对象，并执行其他线程。 ​ Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。 ​ yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 ​ 结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。 123456789101112131415161718192021222324252627282930313233343536/** *@functon 多线程学习 yield *@author 林炳文 *@time 2015.3.9 */ package com.multithread.yield; class ThreadYield extends Thread&#123; public ThreadYield(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 1; i &lt;= 50; i++) &#123; System.out.println("" + this.getName() + "-----" + i); // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行） if (i ==30) &#123; this.yield(); &#125; &#125; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; ThreadYield yt1 = new ThreadYield("张三"); ThreadYield yt2 = new ThreadYield("李四"); yt1.start(); yt2.start(); &#125; &#125; 运行结果： 第一种情况：李四（线程）当执行到30时会CPU时间让掉，这时张三（线程）抢到CPU时间并执行。 第二种情况：李四（线程）当执行到30时会CPU时间让掉，这时李四（线程）抢到CPU时间并执行。 sleep()和yield()的区别 sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 ​ sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程 ​ 另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield() 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 ④setPriority(): 更改线程的优先级。 MIN_PRIORITY = 1 NORM_PRIORITY = 5​ MAX_PRIORITY = 10 用法： 1234Thread4 t1 = new Thread4("t1");Thread4 t2 = new Thread4("t2");t1.setPriority(Thread.MAX_PRIORITY);t2.setPriority(Thread.MIN_PRIORITY); ⑤interrupt():不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！ ⑥wait() ​ Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。 ​ 单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对Object.wait()、Object.notify()的应用最经典的例子，应该是三线程打印ABC的问题了吧，这是一道比较经典的面试题，题目要求如下： ​ 建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * wait用法 * @author DreamSea * @time 2015.3.9 */ package com.multithread.wait; public class MyThreadPrinter2 implements Runnable &#123; private String name; private Object prev; private Object self; private MyThreadPrinter2(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); MyThreadPrinter2 pa = new MyThreadPrinter2("A", c, a); MyThreadPrinter2 pb = new MyThreadPrinter2("B", a, b); MyThreadPrinter2 pc = new MyThreadPrinter2("C", b, c); new Thread(pa).start(); Thread.sleep(100); //确保按顺序A、B、C执行 new Thread(pb).start(); Thread.sleep(100); new Thread(pc).start(); Thread.sleep(100); &#125; &#125; 输出结果： ABCABCABCABCABCABCABCABCABCABC ​ 先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。 wait和sleep区别 共同点： 1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。 ​ 需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 不同点： 1. Thread类的方法：sleep(),yield()等 Object的方法：wait()和notify()等 2. 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 3. wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用，所以sleep()和wait()方法的最大区别是： ​ sleep()睡眠时，保持对象锁，仍然占有该锁； ​ 而wait()睡眠时，释放对象锁。 ​ 但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。 sleep（）方法 ​ sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会; ​ sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。 ​ 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 wait（）方法 ​ wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问； ​ wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 ​ wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitor StateException“异常。 七、常见线程名词解释​ 主线程：JVM调用程序main()所产生的线程。 ​ 当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。 ​ 后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束 ​ 前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。 ​ 线程类的一些常用方法： sleep(): 强迫一个线程睡眠Ｎ毫秒。 isAlive(): 判断一个线程是否存活。 join(): 等待线程终止。 activeCount(): 程序中活跃的线程数。 enumerate(): 枚举程序中的线程。 ​ currentThread(): 得到当前线程。 isDaemon(): 一个线程是否为守护线程。 setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) setName(): 为线程设置一个名称。 wait(): 强迫一个线程等待。 notify(): 通知一个线程继续运行。 setPriority(): 设置一个线程的优先级。 八、线程同步1、synchronized关键字的作用域有二种： 1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法； 2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象； 3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法； ​ Java对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了synchronized关键字就可以轻松地解决多线程共享数据同步问题。到底如何？――还得对synchronized关键字的作用进行深入了解才可定论。 ​ 总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。 ​ 在进一步阐述之前，我们需要明确几点： ​ A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。 ​ B．每个对象只有一个锁（lock）与之相关联。 ​ C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。 接着来讨论synchronized用到不同地方对代码产生的影响： ​ 假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。 1． 把synchronized当作函数修饰符时，示例代码如下：1234Public synchronized void methodAAA() &#123; //…. &#125; ​ 在上面的这个同步方法中，其实锁定的对象是调用这个方法的对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。 ​ 上边的示例代码等同于如下代码：123456public void methodAAA() &#123; synchronized (this) &#123; // (1) //….. &#125; &#125; (1) 处的this指的是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱。 2．同步块，示例代码如下：12345public void method3(SomeObject so)&#123; synchronized(so)&#123; //….. &#125; &#125; ​ 这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：123456789class Foo implements Runnable &#123; private byte[] lock = new byte[0]; // 特殊的instance变量 Public void methodA()&#123; synchronized(lock)&#123; //… &#125; &#125; //….. &#125; ​ 注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。 3．将synchronized作用于static 函数，示例代码如下：12345678Class Foo &#123; public synchronized static void methodAAA()&#123; // 同步的static 函数 //…. &#125; public void methodBBB()&#123; synchronized(Foo.class) // class literal(类名称字面常量) &#125; &#125; ​ 代码中的methodBBB()方法是把Foo类的字节码class对象作为锁，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。 ​ 记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。 ​ 可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。 总结一下： 1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。 2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法 3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。 4、对于同步，要时刻清醒在哪个对象上同步，这是关键。 5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。 6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。 7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使。但是，一旦程序发生死锁，程序将死掉。 九、线程数据传递​ 在传统的同步开发模式下，当我们调用一个函数时，通过这个函数的参数将数据传入，并通过这个函数的返回值来返回最终的计算结果。但在多线程的异步开发模式下，数据的传递和返回和同步开发模式有很大的区别。由于线程的运行和结束是不可预料的，因此，在传递和返回数据时就无法象函数一样通过函数参数和return语句来返回数据。 9.1、通过构造方法传递数据 ​ 在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用(其实就是在run方法中使用)。下面的代码演示了如何通过构造方法来传递数据：12345678910111213141516package mythread; public class MyThread1 extends Thread &#123; private String name; public MyThread1(String name)&#123; this.name = name; &#125; public void run()&#123; System.out.println("hello " + name); &#125; public static void main(String[] args)&#123; Thread thread = new MyThread1("world"); thread.start(); &#125; &#125; ​ 由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 9.2、通过变量和方法传递数据 ​ 向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对MyThread1类的改版，使用了一个setName方法来设置 name变量： 1234567891011121314151617181920package mythread; public class MyThread2 implements Runnable &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public void run() &#123; System.out.println("hello " + name); &#125; public static void main(String[] args) &#123; MyThread2 myThread = new MyThread2(); myThread.setName("world"); Thread thread = new Thread(myThread); thread.start(); &#125; &#125; 9.3、通过回调函数传递数据 ​ 上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个 value是无法事先就传入线程类的。 123456789101112131415161718192021222324252627282930313233343536package mythread; class Data &#123; public int value = 0; &#125; class Work &#123; public void process(Data data, Integer numbers) &#123; for (int n : numbers) &#123; data.value += n; &#125; &#125; &#125; public class MyThread3 extends Thread &#123; private Work work; public MyThread3(Work work) &#123; this.work = work; &#125; public void run() &#123; java.util.Random random = new java.util.Random(); Data data = new Data(); int n1 = random.nextInt(1000); int n2 = random.nextInt(2000); int n3 = random.nextInt(3000); work.process(data, n1, n2, n3); // 使用回调函数 System.out.println(String.valueOf(n1) + "+" + String.valueOf(n2) + "+" + String.valueOf(n3) + "=" + data.value); &#125; public static void main(String[] args) &#123; Thread thread = new MyThread3(new Work()); thread.start(); &#125; &#125; 好了，Java多线程的基础知识就讲到这里了，有兴趣研究多线程的推荐直接看java的源码，你将会得到很大的提升！ 参考资料: Java多线程学习（吐血超详细总结） 并行与并发的概念 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 高级多线程监视器synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们 monitor ​ 他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 ​ wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 ​ 当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 volatile关键字​ 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。 ​ 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。 关于中断​ 它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。 ​ Thread.interrupted()检查当前线程是否发生中断，返回boolean ​ synchronized在获锁的过程中是不能被中断的。 ​ 中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体 Thread类最佳实践​ 写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。 高级多线程控制类​ Java1.5提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。 1.ThreadLocal类​ 用处：保存线程的独立变量。对一个线程类（继承自Thread)。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。 ​ 实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。 ​ 主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。 2.原子类（AtomicInteger、AtomicBoolean……）​ 如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized。 12//返回值为booleanAtomicInteger.compareAndSet(int expect,int update) ​ 该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为： 123456if(b.value.compareAndSet(old, value))&#123; return ;&#125;else&#123; //try again // if that fails, rollback and log&#125; AtomicReference ​ 对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。 ​ 这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号。 3.Lock类 ​ lock: 在java.util.concurrent包内。共有三个实现： 123ReentrantLockReentrantReadWriteLock.ReadLockReentrantReadWriteLock.WriteLock ​ 主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。 ​ 区别如下： ​ lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序），提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。 ​ 本质上和监视器锁（即synchronized是一样的），能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。和Condition类的结合，性能更高，对比如下图： ReentrantLock 可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。 使用方法是： 1.先new一个实例 1static ReentrantLock r=new ReentrantLock(); 2.加锁 1r.lock()或r.lockInterruptibly(); ​ 此处也是个不同，后者可被打断。当a线程lock后，b线程阻塞，此时如果是lockInterruptibly，那么在调用b.interrupt()之后，b线程退出阻塞，并放弃对资源的争抢，进入catch块。（如果使用后者，必须throw interruptable exception 或catch） 3.释放锁 1r.unlock() ​ 必须做！何为必须做呢，要放在finally里面。以防止异常跳出了正常流程，导致灾难。这里补充一个小知识点，finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。 ReentrantReadWriteLock ​ 可重入读写锁（读写锁的一个实现): 123ReentrantReadWriteLock lock = new ReentrantReadWriteLock() ReadLock r = lock.readLock(); WriteLock w = lock.writeLock(); ​ 两者都有lock,unlock方法。写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码 4.容器类​ 这里就讨论比较常用的两个： 12BlockingQueueConcurrentHashMap BlockingQueue ​ 阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管 道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列），有兴趣可以研究 ​ BlockingQueue在队列的基础上添加了多线程协作的功能： ​ 除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队 列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。 常见的阻塞队列有： 1234ArrayListBlockingQueueLinkedListBlockingQueueDelayQueueSynchronousQueue ConcurrentHashMap 高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap 线程池深入理解参考资料：Java并发编程与技术内幕:线程池深入理解 ​ 摘要： 本文主要讲了Java当中的线程池的使用方法、注意事项及其实现源码实现原理，并辅以实例加以说明,对加深Java线程池的理解有很大的帮助。 ​ 首先，讲讲什么是线程池？照笔者的简单理解，其实就是一组线程实时处理休眠状态，等待唤醒执行。那么为什么要有线程池这个东西呢？可以从以下几个方面来考虑：其一、减少在创建和销毁线程上所花的时间以及系统资源的开销 。其二、2将当前任务与主线程隔离，能实现和主线程的异步执行，特别是很多可以分开重复执行的任务。但是，一味的开线程也不一定能带来性能上的，线池休眠也是要占用一定的内存空间，所以合理的选择线程池的大小也是有一定的依据。 一、Executors的API介绍Java类库提供了许多静态方法来创建一个线程池： a、newFixedThreadPool 创建一个固定长度的线程池，当到达线程最大数量时，线程池的规模将不再变化。 b、newCachedThreadPool 创建一个可缓存的线程池，如果当前线程池的规模超出了处理需求，将回收空的线程；当需求增加时，会增加线程数量；线程池规模无限制。 c、newSingleThreadPoolExecutor 创建一个单线程的Executor，确保任务对了，串行执行 d、newScheduledThreadPool 创建一个固定长度的线程池，而且以延迟或者定时的方式来执行，类似Timer； 小结一下：在线程池中执行任务比为每个任务分配一个线程优势更多，通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊线程创建和销毁产生的巨大的开销。当请求到达时，通常工作线程已经存在，提高了响应性；通过配置线程池的大小，可以创建足够多的线程使CPU达到忙碌状态，还可以防止线程太多耗尽计算机的资源。 创建线程池基本方法： (1)定义线程类 12class Handler implements Runnable&#123; &#125; (2)建立ExecutorService线程池 1ExecutorService executorService = Executors.newCachedThreadPool(); 或者 12int cpuNums = Runtime.getRuntime().availableProcessors(); //获取当前系统的CPU 数目 ExecutorService executorService =Executors.newFixedThreadPool(cpuNums * POOL_SIZE); //ExecutorService通常根据系统资源情况灵活定义线程池大小 (3)调用线程池操作循环操作，成为daemon,把新实例放入Executor池中 1234567while(true)&#123; executorService.execute(new Handler(socket)); // class Handler implements Runnable&#123; 或者 executorService.execute(createTask(i)); //private static Runnable createTask(final int taskID) &#125; execute(Runnable对象)方法其实就是对Runnable对象调用start()方法（当然还有一些其他后台动作，比如队列，优先级，IDLE timeout，active激活等） 二、几种不同的ExecutorService线程池对象 不同线程池对象 线程池对象的特点 1.newCachedThreadPool() -缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse.如果没有，就建一个新的线程加入池中-缓存型池子通常用于执行一些生存期很短的异步型任务 因此在一些面向连接的daemon型SERVER中用得不多。-能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。 2.newFixedThreadPool -newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程-其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子-和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器-从方法的源代码看，cache池和fixed 池调用的是同一个底层池，只不过参数不同:fixed池线程数固定，并且是0秒IDLE（无IDLE）cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE 3.ScheduledThreadPool -调度型线程池-这个池子里的线程可以按schedule依次delay执行，或周期执行 4.SingleThreadExecutor -单例线程，任意时间池中只能有一个线程-用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE） 应用实例： 1.CachedThreadPool ​ CachedThreadPool首先会按照需要创建足够多的线程来执行任务(Task)。随着程序执行的过程，有的线程执行完了任务，可以被重新循环使用时，才不再创建新的线程来执行任务。我们采用《Thinking In Java》中的例子来分析。客户端线程和线程池之间会有一个任务队列。当程序要关闭时，你需要注意两件事情：入队的这些任务的情况怎么样了以及正在运行的这个任务执行得如 何了。令人惊讶的是很多开发人员并没能正确地或者有意识地去关闭线程池。正确的方法有两种：一个是让所有的入队任务都执行完毕（shutdown()）， 再就是舍弃这些任务（shutdownNow())——这完全取决于你。比如说如果我们提交了N多任务并且希望等它们都执行完后才返回的话，那么就使用 shutdown()： 1234567891011121314151617181920212223242526272829303132333435import java.util.Date; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledThreadPoolExecutor; import java.util.concurrent.TimeUnit; /** * 功能概要：缓冲线程池实例-execute运行 * * @author linbingwen * @since 2016年5月24日 */ class Handle implements Runnable &#123; private String name; public Handle(String name) &#123; this.name = "thread"+name; &#125; @Override public void run() &#123; System.out.println( name +" Start. Time = "+new Date()); processCommand(); System.out.println( name +" End. Time = "+new Date()); &#125; private void processCommand() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public String toString()&#123; return this.name; &#125; &#125; 验证实例：123456789public static void testCachedThreadPool() &#123; System.out.println("Main: Starting at: "+ new Date()); ExecutorService exec = Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE for(int i = 0; i &lt; 10; i++) &#123; exec.execute(new Handle(String.valueOf(i))); &#125; exec.shutdown(); //执行到此处并不会马上关闭线程池,但之后不能再往线程池中加线程，否则会报错 System.out.println("Main: Finished all threads at"+ new Date()); &#125; 执行结果： 从上面的结果可以看出：1、主线程的执行与线程池里的线程分开，有可能主线程结束了，但是线程池还在运行2、放入线程池的线程并不一定会按其放入的先后而顺序执行 2.FixedThreadPool​ FixedThreadPool模式会使用一个优先固定数目的线程来处理若干数目的任务。规定数目的线程处理所有任务，一旦有线程处理完了任务就会被用来处理新的任务(如果有的话)。这种模式与上面的CachedThreadPool是不同的，CachedThreadPool模式下处理一定数量的任务的线程数目是不确定的。而FixedThreadPool模式下最多 的线程数目是一定的。 应用实例：123456789public static void testFixThreadPool() &#123; System.out.println("Main Thread: Starting at: "+ new Date()); ExecutorService exec = Executors.newFixedThreadPool(5); for(int i = 0; i &lt; 10; i++) &#123; exec.execute(new Handle(String.valueOf(i))); &#125; exec.shutdown(); //执行到此处并不会马上关闭线程池 System.out.println("Main Thread: Finished at:"+ new Date()); &#125; 运行结果： 上面创建了一个固定大小的线程池，大小为5.也就说同一时刻最多只有5个线程能运行。并且线程执行完成后就从线程池中移出。它也不能保证放入的线程能按顺序执行。这要看在等待运行的线程的竞争状态了。 3、newSingleThreadExecutor 其实这个就是创建只能运行一条线程的线程池。它能保证线程的先后顺序执行，并且能保证一条线程执行完成后才开启另一条新的线程 123456789public static void testSingleThreadPool() &#123; System.out.println("Main Thread: Starting at: "+ new Date()); ExecutorService exec = Executors.newSingleThreadExecutor(); //创建大小为1的固定线程池 for(int i = 0; i &lt; 10; i++) &#123; ![SingleThreadPool运行示意图]( \image\Java多线程\SingleThreadPool运行示意图.jpg) exec.execute(new Handle(String.valueOf(i))); &#125; exec.shutdown(); //执行到此处并不会马上关闭线程池 System.out.println("Main Thread: Finished at:"+ new Date()); &#125; 运行结果： 其实它也等价于以下： ExecutorService exec = Executors.newFixedThreadPool(1); 4、newScheduledThreadPool 这是一个计划线程池类，它能设置线程执行的先后间隔及执行时间等，功能比上面的三个强大了一些。 以下实例：12345678910111213public static void testScheduledThreadPool() &#123; System.out.println("Main Thread: Starting at: "+ new Date()); ScheduledThreadPoolExecutor exec = (ScheduledThreadPoolExecutor) Executors.newScheduledThreadPool(10); //创建大小为10的线程池 for(int i = 0; i &lt; 10; i++) &#123; exec.schedule(new Handle(String.valueOf(i)), 10, TimeUnit.SECONDS);//延迟10秒执行 &#125; exec.shutdown(); //执行到此处并不会马上关闭线程池 while(!exec.isTerminated())&#123; //wait for all tasks to finish &#125; System.out.println("Main Thread: Finished at:"+ new Date()); &#125; 实现每个放入的线程延迟10秒执行。结果： ScheduledThreadPoolExecutor的定时方法主要有以下四种： 下面将主要来具体讲讲scheduleAtFixedRate和scheduleWithFixedDelay scheduleAtFixedRate 按指定频率周期执行某个任务 解释：启动第一个任务后，间隔指定的时间，立马启动第二个任务。 public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); command：执行线程 initialDelay：初始化延时 period：两次开始执行最小间隔时间 unit：计时单位 scheduleWithFixedDelay 周期定时执行某个任务/按指定频率间隔执行某个任务(注意) 解释：启动第一个任务，等到第一个任务结束后，再间隔指定的时间，才启动第二个任务。 public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit); command：执行线程 initialDelay：初始化延时 period：前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间） unit：计时单位 使用实例：1234567891011121314class MyHandle implements Runnable &#123; @Override public void run() &#123; System.out.println(System.currentTimeMillis()); try &#123; Thread.sleep(1 * 1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 1.按指定频率周期执行某个任务 下面实现每隔2秒执行一次，注意，如果上次的线程还没有执行完成，那么会阻塞下一个线程的执行。即使线程池设置得足够大。1234567891011121314/** * 初始化延迟0ms开始执行，每隔2000ms重新执行一次任务 * @author linbingwen * @since 2016年6月6日 */ public static void executeFixedRate() &#123; ScheduledExecutorService executor = Executors.newScheduledThreadPool(10); executor.scheduleAtFixedRate( new MyHandle(), 0, 2000, TimeUnit.MILLISECONDS); &#125; 间隔指的是连续两次任务开始执行的间隔。对于scheduleAtFixedRate方法，当执行任务的时间大于我们指定的间隔时间时，它并不会在指定间隔时开辟一个新的线程并发执行这个任务。而是等待该线程执行完毕。 2、按指定频率间隔执行某个任务12345678910111213/** * 以固定延迟时间进行执行 * 本次任务执行完成后，需要延迟设定的延迟时间，才会执行新的任务 */ public static void executeFixedDelay() &#123; ScheduledExecutorService executor = Executors.newScheduledThreadPool(10); executor.scheduleWithFixedDelay( new MyHandle(), 0, 2000, TimeUnit.MILLISECONDS); &#125; 间隔指的是连续上次执行完成和下次开始执行之间的间隔。 3.周期定时执行某个任务 周期性的执行一个任务，可以使用下面方法设定每天在固定时间执行一次任务。12345678910111213141516171819202122232425262728293031323334/** * 每天晚上9点执行一次 * 每天定时安排任务进行执行 */ public static void executeEightAtNightPerDay() &#123; ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); long oneDay = 24 * 60 * 60 * 1000; long initDelay = getTimeMillis("21:00:00") - System.currentTimeMillis(); initDelay = initDelay &gt; 0 ? initDelay : oneDay + initDelay; executor.scheduleAtFixedRate( new MyHandle(), initDelay, oneDay, TimeUnit.MILLISECONDS); &#125; /** * 获取指定时间对应的毫秒数 * @param time "HH:mm:ss" * @return */ private static long getTimeMillis(String time) &#123; try &#123; DateFormat dateFormat = new SimpleDateFormat("yy-MM-dd HH:mm:ss"); DateFormat dayFormat = new SimpleDateFormat("yy-MM-dd"); Date curDate = dateFormat.parse(dayFormat.format(new Date()) + " " + time); return curDate.getTime(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return 0; &#125; 三、线程池一些常用方法1、submit() ​ 将线程放入线程池中，除了使用execute，也可以使用submit，它们两个的区别是一个使用有返回值，一个没有返回值。submit的方法很适应于生产者-消费者模式，通过和Future结合一起使用，可以起到如果线程没有返回结果，就阻塞当前线程等待线程 池结果返回。 它主要有三种方法： 一般用第一种比较多 如下实例。注意，submit中的线程要实现接口Callable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.func.axc.executors; import java.util.ArrayList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; /** * 功能概要：缓冲线程池实例-submit运行 * * @author linbingwen * @since 2016年5月25日 */ class TaskWithResult implements Callable&lt;String&gt; &#123; private int id; public TaskWithResult(int id) &#123; this.id = id; &#125; /** * 任务的具体过程，一旦任务传给ExecutorService的submit方法，则该方法自动在一个线程上执行。 * * @return * @throws Exception */ public String call() throws Exception &#123; System.out.println("call()方法被自动调用,干活！！！ " + Thread.currentThread().getName()); //一个模拟耗时的操作 for (int i = 999999; i &gt; 0; i--) ; return"call()方法被自动调用，任务的结果是：" + id + " " + Thread.currentThread().getName(); &#125; &#125; public class ThreadPool2 &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); List&lt;Future&lt;String&gt;&gt; resultList = new ArrayList&lt;Future&lt;String&gt;&gt;(); //创建10个任务并执行 for (int i = 0; i &lt; 10; i++) &#123; //使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中 Future&lt;String&gt; future = executorService.submit(new TaskWithResult(i)); //将任务执行结果存储到List中 resultList.add(future); &#125; //启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。 executorService.shutdown(); //遍历任务的结果 for (Future&lt;String&gt; fs : resultList) &#123; try &#123; System.out.println(fs.get()); //打印各个线程（任务）执行的结果 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; &#125; &#125; &#125; 结果如下： 方法调用示意图.jpg) 从上面可以看到，输出结果的依次的。说明每次get都 阻塞了的。 看了下它的源码，其实它最终还是调用 了execute方法1234567public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask; &#125; 2、execute() 表示往线程池添加线程，有可能会立即运行，也有可能不会。无法预知线程何时开始，何时线束。 主要源码如下：12345678910111213public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); &#125; else if (!addIfUnderMaximumPoolSize(command)) reject(command); // is shutdown or saturated &#125; &#125; 3、shutdown() 通常放在execute后面。如果调用 了这个方法，一方面，表明当前线程池已不再接收新添加的线程，新添加的线程会被拒绝执行。另一方面，表明当所有线程执行完毕时，回收线程池的资源。注意，它不会马上关闭线程池！ 4、shutdownNow() 不管当前有没有线程在执行，马上关闭线程池！这个方法要小心使用，要不可能会引起系统数据异常！ 四、ThreadPoolExecutor技术内幕经过上面的过程，基本上可以掌握线程池的一些基本用法。下面再来看看JAVA中线程池的源码实现。 首先是其继承关系如下： 通过观察上面四种线程池的源码： 如：newFixedThreadPool123456public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 如：newCachedThreadPool123456public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 如：newSingleThreadExecutor1234567public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; ​ 可以发现，其实它们调用的都是同一个接口ThreadPoolExecutor方法，只不过传入参数不一样而已。下面就来看看这个神秘的ThreadPoolExecutor。 ​ 首先来看看它的一些基本参数：123456789101112131415161718192021222324252627282930313233343536public class ThreadPoolExecutor extends AbstractExecutorService &#123; //运行状态标志位 volatile int runState; static final int RUNNING = 0; static final int SHUTDOWN = 1; static final int STOP = 2; static final int TERMINATED = 3; //线程缓冲队列，当线程池线程运行超过一定线程时并满足一定的条件，待运行的线程会放入到这个队列 private final BlockingQueue&lt;Runnable&gt; workQueue; //重入锁，更新核心线程池大小、最大线程池大小时要加锁 private final ReentrantLock mainLock = new ReentrantLock(); //重入锁状态 private final Condition termination = mainLock.newCondition(); //工作都set集合 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); //线程执行完成后在线程池中的缓存时间 private volatile long keepAliveTime; //核心线程池大小 private volatile int corePoolSize; //最大线程池大小 private volatile int maximumPoolSize; //当前线程池在运行线程大小 private volatile int poolSize; //当缓冲队列也放不下线程时的拒绝策略 private volatile RejectedExecutionHandler handler; //线程工厂，用来创建线程 private volatile ThreadFactory threadFactory; //用来记录线程池中曾经出现过的最大线程数 private int largestPoolSize; //用来记录已经执行完毕的任务个数 private long completedTaskCount; ................ &#125; 初始化线程池大小 有以下四种方法： 从源码中可以看到其实最终都是调用了以下的方法：12345678910111213141516171819202122public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 这里很简单，就是设置一下各个参数，并校验参数是否正确，然后抛出对应的异常。 接下来我们来看看最重要的方法execute，其源码如下：12345678910111213public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; // 判断1 if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; // 判断2 if (runState != RUNNING || poolSize == 0) // 判断3 ensureQueuedTaskHandled(command); &#125; else if (!addIfUnderMaximumPoolSize(command)) // 判断4 reject(command); // is shutdown or saturated &#125; &#125; 笔者在上面加了点注释。下面我们一个一个判断来看 首先判断1 if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) （1）当poolSize &gt;= corePoolSize 不成立时，表明当前线程数小于核心线程数目，左边返回fasle.接着执行右边判断!addIfUnderCorePoolSize(command) 它做了如下操作12345678910111213private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123; Thread t = null; final ReentrantLock mainLock = this.mainLock;//加锁 mainLock.lock(); try &#123; if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)//线程池在运行且当前线程小于核心线程（外面已做了一次相同的判断，确保和外面的一样） t = addThread(firstTask);//加入线程 &#125; finally &#123; mainLock.unlock(); &#125; return t != null; &#125; 发现它又调用addTread123456789101112131415161718192021222324private Thread addThread(Runnable firstTask) &#123; //调用这个方法之前加锁 Worker w = new Worker(firstTask);//线程包装成一个work Thread t = threadFactory.newThread(w);//线程工厂从work创建线程 boolean workerStarted = false; if (t != null) &#123; if (t.isAlive()) // 线程应该是未激活状态 throw new IllegalThreadStateException(); w.thread = t; workers.add(w);//全局set添加一个work int nt = ++poolSize;//当前运行线程数目加1 if (nt &gt; largestPoolSize) largestPoolSize = nt; try &#123; t.start();//注意，这里线程执行了，但是其实真正调用的是&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;Worker类的run方法！！！！！！！！！&lt;/span&gt; workerStarted = true; &#125; finally &#123; if (!workerStarted) workers.remove(w); &#125; &#125; return t; &#125; 其实Work是真实去调用线程方法的地方,它是对Thread类的一个包装，每次Thread类调用其start方法时，就会调用到work的run方法。其代码如下， private void runTask(Runnable task) { //真正发起线程方法的地方12345678910111213141516171819202122232425262728293031323334353637383940 final ReentrantLock runLock = this.runLock; runLock.lock(); try &#123; if ((runState &gt;= STOP || //判断的判断 (Thread.interrupted() &amp;&amp; runState &gt;= STOP)) &amp;&amp; hasRun) thread.interrupt(); boolean ran = false; beforeExecute(thread, task);//处理前 try &#123; task.run();//执行真正的原始线程的run方法 ran = true; afterExecute(task, null);//处理后 ++completedTasks; &#125; catch (RuntimeException ex) &#123; if (!ran) afterExecute(task, ex); throw ex; &#125; &#125; finally &#123; runLock.unlock(); &#125; &#125; //这里执行线程的方法 public void run() &#123; try &#123; hasRun = true; Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) &#123; runTask(task); task = null; &#125; &#125; finally &#123; workerDone(this); &#125; &#125; 发现要执行一个线程真的很不容易，如果addIfUnderCorePoolSize返回true，刚表明成功添加一条线程，并调用了其start方法，那么整个调用到此结束。如果返回fasle.那么就进入判断2.（2）当poolSize &gt;= corePoolSize成立时，整个判断返回true。接着执行判断2 判断21if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123; // 判断2 如果当前线程池在运行状态，并且将当前线程加入到缓冲队列中。workQueue的offer是一个非阻塞方法。如查缓冲队列满了的话，返回为false.否则返回true;如果上面两个都 为true，表明线程被成功添加到缓冲队列中，并且当前线程池在运行。进入判断3 判断312if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); ​ 当线程被加入到线程池中，进入判断3.如果这时线程池没有在运行或者运行的线程为为0。那么就调用ensureQueuedTaskHandled，它做的其实是判断下是否在拒绝这个线程的执行。1234567891011121314151617181920private void ensureQueuedTaskHandled(Runnable command) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); boolean reject = false; Thread t = null; try &#123; int state = runState; if (state != RUNNING &amp;&amp; workQueue.remove(command)) //线程池没有在运行，且缓冲队列中有这个线程 reject = true; else if (state &lt; STOP &amp;&amp; poolSize &lt; Math.max(corePoolSize, 1) &amp;&amp; !workQueue.isEmpty()) t = addThread(null); &#125; finally &#123; mainLock.unlock(); &#125; if (reject) reject(command); //根据拒绝策略处理线程 &#125; 判断412else if (!addIfUnderMaximumPoolSize(command)) reject(command); // is shutdown or saturated 在判断2为false时执行，表明当前线程池没有在运行或者该线程加入缓冲队列中失败，那么就会尝试再启动下该线程，如果还是失败，那就根据拒绝策略来处理这个线程。其源码如下：12345678910111213private boolean addIfUnderMaximumPoolSize(Runnable firstTask) &#123; Thread t = null; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING) //如果当前运行线程数目 小于最大线程池大小 并且 线程池在运行，那么启动该线程 t = addThread(firstTask); &#125; finally &#123; mainLock.unlock(); &#125; return t != null; &#125; ​ 一般调用这个方法是发生在缓冲队列已满了，那么线程池会尝试直接启动该线程。当然，它要保存当前运行的poolSize一定要小于maximumPoolSize。否则，最后。还是会拒绝这个线程！以上大概就是整个线程池启动一条线程的整体过程。 总结： ​ ThreadPoolExecutor中，包含了一个任务缓存队列和若干个执行线程，任务缓存队列是一个大小固定的缓冲区队列，用来缓存待执行的任务，执行线程用来处理待执行的任务。每个待执行的任务，都必须实现Runnable接口，执行线程调用其run()方法，完成相应任务。ThreadPoolExecutor对象初始化时，不创建任何执行线程，当有新任务进来时，才会创建执行线程。 ​ 构造ThreadPoolExecutor对象时，需要配置该对象的核心线程池大小和最大线程池大小：当目前执行线程的总数小于核心线程大小时，所有新加入的任务，都在新线程中处理当目前执行线程的总数大于或等于核心线程时，所有新加入的任务，都放入任务缓存队列中当目前执行线程的总数大于或等于核心线程，并且缓存队列已满，同时此时线程总数小于线程池的最大大小，那么创建新线程，加入线程池中，协助处理新的任务。 ​ 当所有线程都在执行， 线程池大小已经达到上限，并且缓存队列已满时，就rejectHandler拒绝新的任务。 五、自定义线程池再来看看它的方法12345678public ThreadPoolExecutor(int corePoolSize,//核心线程大小 int maximumPoolSize,//最大线程大小 long keepAliveTime,//线程缓存时间 TimeUnit unit,//前面keepAlive BlockingQueue&lt;Runnable&gt; workQueue,//缓存队列 ThreadFactory threadFactory,//线程工大 RejectedExecutionHandler handler)//拒绝策略 block queue有以下几种实现：1234ArrayBlockingQueue : 有界的数组队列 LinkedBlockingQueue : 可支持有界/无界的队列，使用链表实现 PriorityBlockingQueue : 优先队列，可以针对任务排序 SynchronousQueue : 队列长度为1的队列，和Array有点区别就是：client thread提交 到block queue会是一个阻塞过程，直到有一个worker thread连接上来poll task。当线 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 比如定义如下一个线程池：1ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 4, 3,TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(3),Executors.defaultThreadFactory(),new ThreadPoolExecutor.DiscardOldestPolicy()); 这里核心线程数为2，最大线程数为4，线程缓存时间为3秒，缓冲队列的容量设置为3。线程工厂设置为默认 下面是一个具体实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.func.axc.executors; import java.io.Serializable; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.Executors; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; /** * 功能概要： * * @author linbingwen * @since 2016年6月7日 */ public class MyThreadPoolTest &#123; private static int produceTaskSleepTime = 2; private static int produceTaskMaxNumber = 10; public static void main(String[] args) &#123; // 构造一个线程池 ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 4, 3,TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(3),Executors.defaultThreadFactory(),new ThreadPoolExecutor.DiscardOldestPolicy()); for (int i = 1; i &lt;= produceTaskMaxNumber; i++) &#123; try &#123; // 产生一个任务，并将其加入到线程池 String task = "task@ " + i; System.out.println("put " + task); threadPool.execute(new ThreadPoolTask(task)); // 便于观察，等待一段时间 Thread.sleep(produceTaskSleepTime); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 线程池执行的任务 */ class ThreadPoolTask implements Runnable, Serializable &#123; private static final long serialVersionUID = 0; private static int consumeTaskSleepTime = 2000; // 保存任务所需要的数据 private Object threadPoolTaskData; ThreadPoolTask(Object tasks) &#123; this.threadPoolTaskData = tasks; &#125; public void run() &#123; // 处理一个任务，这里的处理方式太简单了，仅仅是一个打印语句 System.out.println(Thread.currentThread().getName()); System.out.println("start .." + threadPoolTaskData); try &#123; // //便于观察，等待一段时间 Thread.sleep(consumeTaskSleepTime); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; threadPoolTaskData = null; &#125; public Object getTask() &#123; return this.threadPoolTaskData; &#125; &#125; 线程池今天就说到这里，下一节我们再来讨论技术细节吧~~ 参考资料：Java并发编程与技术内幕:线程池深入理解]]></content>
      <categories>
        <category>Java高级知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F05%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构0. 常见数据结构线性：数组，链表，队列，堆栈，hash表，双端队列，==位图(bitmap)== 树：堆（大顶堆、小顶堆），trie树（字母树or字典树），后缀树，后缀树组，二叉排序/查找树，B+/B-树，AVL树，Treap，红黑树，splay树，线段树，树状数组 图：图 其他：并查表 参考资料：数据结构与算法汇总 一、数组​ 数据结构中最基本的一个结构就是线性结构，而线性结构又分为连续存储结构和离散存储结构。所谓的连续存储结构其实就是数组。 ​ 在内存中，数组中的数据是以一组连续的数据集合的形式存在于内存中。当我们访问存在于内存中的数组时，我们应该找到其在内存中的地址，当我们找到数据的地址后我们就可以找到对应的数据。 ​ 数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 ​ 数组的特点是： 元素类型是固定的、长度是固定的、通过下标查询，查询快，增删慢。 二、线性表​ 线性表的定义：一个线性表是n个数据元素的==有限==序列。（注意：线性表中元素的个数是有限的）。 ​ 线性表中元素的个数是n(n&gt;=0)称作线性表的长度。线性表中的元素可以是各种各样的，如数字，符号，一页书等。但同一个线性表中的元素类型必须是相同的。n=0时称线性表为空表。 ​ 在稍复杂的线性表中，一个数据元素可以由若干个数据项（item）组成，此时称数据元素为记录，含有大量记录的线性表称作文件。 1. 线性表的顺序表示和实现​ 顺序表指的是用一组地址连续的存储单元依次存储线性表的数据元素，按照这种存储结构存储的机制称作线性表的顺序存储结构或顺序映像。 ​ 顺序表的特点、优点和缺点如下表1所示： ​ 表1：顺序表的特点、优点和缺点表 项目 内容 特点 ⑴ 线性表中相邻的元素在物理上存储位置相邻。即以元素在计算机内物理位置相邻来表示线性表中数据元素之间的逻辑关系。⑵ 随机存取⑶ 通常对应高级程序语言中的一维数组 优点 ⑴ 不需要额外的存储空间来表示元素间的逻辑关系⑵ 可随机存取 缺点 ⑴ 插入和删除元素时需要移动大量的元素⑵ 必须先进行空间分配，而且还需要考虑空间的扩充 2. 线性表的链式表示和实现​ 线性表的链式表示主要有三种：单链表、循环链表和双向链表。 2.1 单链表 ​ 单链表指的是用一组任意的存储单元存储线性表的数据元素。使用单链表的时候，关心的只是它所表示的线性表中数据元素之间的逻辑顺序，而不是它所表示的线性表中数据元素之间的物理顺序。 ​ 单链表的特点、优点和缺点表如下表2所示： ​ 表2：单链表的特点、优点和缺点表 项目 内容 特点 ⑴ 存储单链表的存储单元地址可以连续也可以不连续。⑵ 建立链表的过程就是一个动态生成链表的过程。 优点 (1) 在单链表中插入或删除一个节点时，仅需修改指针而不需要移动元素。⑵ 根据需要申请空间，且不要求连续的存储空间。 缺点 ⑴ 用指针指示元素之间的逻辑关系，存储空间利用率低。⑵ 对表中元素只能按照顺序存取，不可随机访问。 ​ 单链表中关键字解释表如表3所示： ​ 表3：单链表中名词解释表 名词 解释 结点(node) 单链表中存储的每个元素ai。每个节点都包括两个域，数据域和指针域。 数据域 存储的内容是数据信息 指针域 存储的是直接后继存储位置 头指针 头指针指示链表中第一个结点（即第一个数据元素的存储映像）的存储位置。 头结点 在单链表的第一个结点之前附设的结点 2.2 循环链表 ​ 单链表中最后一个结点的指针域指向头结点。整个链表形成一个环，从表中任一点出发均可找到表中其他节点。 2.3 双向链表 ​ 双向链表中的节点都有两个指针域，其一指向该结点的直接前趋，另一个指针域指向该结点的直接后继结点。 与单链表的循环链表类似，双向链表也可以有循环双向链表。 在双向链表中插入和删除节点时，需要同时修改两个方向上的指针。 三、栈和队列​ 从数据结构角度看，栈和队列是操作受限的线性表。 从数据类型角度看，栈和队列与线性表又有所不同。 1. 栈​ 栈是限定仅在表尾进行插入和删除操作的线性表。所以栈的最大特点是先进后出（last in first out）。 栈的表示形式有两种：顺序栈和链栈。 ​ 栈的引用举例：数制转换、括号匹配的检验、行编辑程序、迷宫求解和表达式求值。 ​ 一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作是递归函数。 2. 队列​ 队列是一种先进先出的线性表，只允许在表的一端进行插入，而在另外一端删除元素。 ​ 允许插入的一端叫做队尾（rear），允许删除的一端则叫做队头(front)。 3. 双端队列​ 除了栈和队列之外，还有一种限定性数据结构是双端队列，尽管双端队列看起来比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用。 4. 链队列​ 用链表表示的队列。 5. 循环队列​ 循环队列是用顺序表表示的队列，在非空队列中，头指针指向队列元素，而尾指针始终指向队列尾元素的下一个位置。如果用户程序中设有循环队列，则必须为它设定一个最大队列长度，若用户无法预估所用队列的最大长度，则宜采用链队列。 四、串1. 串(string)(或字符串)是由零个或多个字符组成的有限序列。 2. 字符串有3种机内表示方法：①定长顺序存储表示；②堆存储表示；③串的块链存储表示。 3. 串的模式匹配算法 子串的定位操作通常称做串的模式匹配，是各种串处理系统中最重要的操作之一。 4. 字符串模式匹配 给定字符串S(匹配串)和T(模式串)，求字符串T在S中首次出现的下标。 注意：对于字符串S来说，其S[0]存放的是字符串的长度。如S=”abcd”,则S[0]=4. KMP算法：12345678910111213int index_KMP(String S, String T)&#123; int i = 1; int j = 1; while(i&lt;=S[0] &amp;&amp; j &lt;=T[0])&#123;//注意：字符串的T[0]存储的是字符串长度 /*如果j == 0 || S[i] == T[j]，则向后移动继续比较*/ if( j == 0 || S[i] == T[j])&#123; i++; j++; &#125;else&#123;//否则j回溯 j = next[j]; &#125; &#125;&#125; ​ 如何得到模式串T的next数组。此时T即是匹配串，也是模式串。1234567891011121314int get_next(SString T)&#123; int i = 1; int j = 0;//注意这个地方j初始化为0 next[1] = 0; while(i&lt;T[0])&#123; if( j == 0 || S[i] == T[j])&#123;//由S[i] == T[j]是否相等，来得出next[i+1] i++; j++; next[i] = j; &#125;else&#123;//否则j回溯 j = next[j]; &#125; &#125;&#125; ​ 如何得到模式串T的nextval数组。123456789101112131415161718int get_nextval(SString T)&#123; int i = 1; int j = 0;//注意这个地方j初始化为0 nextval[1] = 0; while(i&lt;T[0])&#123; if( j == 0 || S[i] == T[j])&#123;//由S[i] == T[j]是否相等，来得出next[i+1] i++; j++; if(T[i] == T[j])&#123; nextval[i] = nextval[j]; &#125;else&#123; nextval[i] = j; &#125; &#125;else&#123;//否则j回溯 j = next[j]; &#125; &#125;&#125; 四、树和二叉树1. 树(Tree)是n(n&gt;=0)个结点的有限集。 2. 森林(Forest)是m(m&gt;=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。 3. 结点拥有的子树数称为该结点的度(Degree). 4. 二叉树(BinaryTree)是另一种树型结构，它的特点是每个结点至多只有两颗子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。 5. 二叉树的性质 ​ ① 在二叉树的第i层上至多有2i-1个结点(i&gt;=1)； ​ ② 深度为k的二叉树至多有2k-1个结点； ​ 证明：深度为k，说明是有k层，结点个数最多为2k-1个 ​ ③ 对任何一棵二叉树T，如果终端结点数为n0，度为2的结点数为n2，则n0 = n2+1. ​ ④ 具有N个结点的完全二叉树的深度为log2N+1。(log2N是向下取整) 6. 二叉树的存储结构 ​ ① 顺序存储结构 ​ 用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在如上定义的一维数组中下标为i-1的分量中。 ​ ② 链式存储结构 ​ 二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表的节点至少包含3个域：数据域和左右指针域。 ​ 在有n个结点的二叉链表中必定存在n+1个空链域。(原因是，对于n个结点共有2n个链域，root结点不需要有指针指向，其他n-1个指针需要n-1个链域，所以还剩下2n-(n-1)=n+1) ​ 有时为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。 ​ 利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表。 ​ 在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需要进行何种操作。 7. 树的存储结构 ① 双亲表示法 ​ 以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置。 ​ 这种存储结构利用了每个结点(根结点除外)只有唯一的双亲的性质。可以利用O(1)的时间复杂度找到每个结点的父亲结点，但是如果要找结点的孩子结点则需要遍历整个结构。 ​ ②孩子表示法 把每个结点的孩子排列起来，看成一个线性表，且以单链表作为存储结构，则n个结点有n个孩子链表。n个头指针又组成一个线性表，为了便于查找，可以采用顺序存储结构。 与双亲表示法相反，孩子表示法方便找到孩子结点，但是不方便找到双亲结点。不过可以把双亲表示法和孩子表示法结合起来。 ③ 孩子兄弟表示法 ​ 又称二叉树表示法，或二叉链表表示法，即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点(左孩子右兄弟)，分别命名为firstchild和nextsibling域。 ​ 从firstchild域找到第一个孩子结点，然后沿着孩子结点的nextsibling域连续走i-1步，便可找到x的第i个孩子。此外，也可以为每一个结点增设一个PARENT域，则同样能方便地实现找某个结点的双亲结点。 8. 森林与二叉树的转换 ​ ==给定一棵树，可以找到唯一的一棵二叉树与之对应。== ​ 可以把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可以导出森林与二叉树的对应关系。 ​ 先序遍历森林，相当于其对应二叉树的先序遍历，相当于依次对森林中的每棵树的先序遍历。 ​ 中序遍历森林，相当于其对应二叉树的中序遍历，相当于依次对森林中的每棵树做后续遍历。 六、哈希表1. 定义​ 根据设定的哈希函数H(key)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（空间）上，并以关键字在地址集中的“像”作为记录在表中存储位置。这种表则称为hash表。这个映射过程称为哈希造表或散列，所得存储位置称为哈希地址或散列地址。 ​ 一般情况下，冲突只可能尽量少，但是不能避免。所以，在建造hash表的时候，选择好的hash构造函数和解决冲突的办法至关重要。 2. 哈希函数的构造函数。若对于关键字集合中的任意一个关键字，经哈希函数映像到地址集合中的任意一个位置的概率是相等的，则称此类哈希函数是均匀的。也就是说可以使任意一个关键字可被随机地映射到地址中，以便使一组关键字均匀地散列到地址集合中，以便减少冲突。 ​ 散列函数有一个共同性质，即函数值应按==同等概率==取其值域的每一个值。 ​ 常见的构造hash函数有： 编号 名称 定义 冲突 备注 适用场景 1 直接定义法 取关键字或关键字的某个线性函数值为hash地址。H(key)=key或者H(key) = a*key+b 不会 实际中使用很少。该方法关键字集合和地址集合大小相等 ，不会发生冲突。 适合查找表较小且连续的情况。 2 数字分析法 假设关键字是以r为基的数（如以10为基的十进制数），并且hash表中可能出现的关键字都是事先知道的，则可以取关键字的若干数位组成哈希地址 会 不常用 关键字位数比较大，就需要事先知道关键字的分布且关键字的若干位分布较均匀 3 平方取中法 取关键字平方之后的中间几位为哈希地址。取的位数由表长决定。 会 较常用 不知道关键字的分布，而位数又不是很大的情况 4 折叠法 将关键字分割成位数相同的几部分（最后一部分的位数可不同），然后取这几部分的叠加和（舍去最高进位）作为hash地址。 如04 4220 5864 可做04+4220+5864=0088，舍弃最高进位 会 一般常用， 事先不需要知道关键字的分布，适合关键字位数较多的情况。 5 除留余数法 取关键字被某个不大于hash表表长m的数p除后所得余数为哈希地址。H(key)=key mod p;p&lt;=m 一般取p为小于m的质数或不包含小于20的质因数的合数。 会 最简单，最常用的构造hash函数的方法。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模 关键在于p的选择，选择较好的p则有效减少冲突。一般取p为小于m的质数或不包含小于20的质因数的合数。 6 随机数法 选择一个随机函数，取关键字的随机函数值作为它的哈希地址 ，H(key)=random(key) 会 通常当关键字长度不等时采用此法，构造哈希函数较恰当 当关键字的长度不等时 7 相乘取整法 首先用关键字key乘上某个常数A(0&lt;A&lt;1)，并抽取出key.A的小数部分；然后用m乘以该小数后取整 ​ 实际中根据不同情况采用不同哈希方法，考虑的因素主要有： ​ 1) 计算hash方法所需时间；2）关键字长度；3）哈希表的大小；4）关键字的分布情况；5）记录的查找频率。 ​ 总之，设计哈希构造函数的时候主要要考虑计算简单和散列地址分布均匀这两个特点。 3. 处理冲突的方法​ 既然在构造hash表的过程中出现冲突不可避免，那么就需要有处理冲突的方法。下面介绍几种常用的处理冲突的方法。 类别 详细方法 开放地址法 线性探测再散列 线性补偿探测法 二次探测再散列 伪随机探测再散列 再哈希法 链地址法（拉链法） 建立公共溢出区 3.1 开放地址法 ​ 开放地址法主要包括线性探测再散列、线性补偿探测法、二次探测再散列和伪随机探测再散列。 ​ Hi = (H(key)+di)%m ​ 其中H(key)为哈希函数，m为哈希表表长，di为增量序列。 ​ (1) di = 1,2,3..m-1称线性探测再散列； ​ (2) 将线性探测的步长从1 改为 Q ，即将上述算法中的 j ＝ (j ＋ 1) % m 改为： j ＝ (j ＋ Q) % m ，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。（线性补偿探测法） ​ (3) di = 12,-12,22,-22….k2,-k2称作二次探测再散列。 ​ (4) di = 伪随机序列，称作伪随机探测再散列。 ​ 在处理冲突的过程中，两个hash地址不同的关键字争夺同一个后继哈希地址的现象称作是“二次聚集”，即在处理同义词的冲突过程中又添加了非同义词的冲突。 ​ 对于线性探测再查找，在哈希表未填满的状态下总能找到一个不发生冲突的地址。对于二次探测再散列，只有哈希表的长度m为形如$4*j+3$($j$是整数)的素数时，才可以保证哈希表未满情况下总能找到一个不发生冲突的地址。随机探测再散列，则取决于伪随机数列。 3.2 再哈希法 ​ $$ Hi = RH_i (key) i=1,2,3…k $$ ​ $RH_i$均是不同的hash函数，即在同义词产生冲突时计算另一个哈希函数地址，直到不产生冲突为止。该方法虽然不容易产生聚集，但是会增加计算的时间。 3.3 链地址法（拉链法） ​ 将关键字为同义词的记录存储在同一线性表中，在链表的插入为可以在表头或表尾，也可以在中间，以保持同义词在同一线性链表中按关键字有序。 3.4 建立公共溢出区 ​ 所有关键字和哈希表中已有的记录发生冲突的，就把这个关键字填入到溢出表中。（溢出表是另建立的一张新表，专门放那些在确定其hash地址的时候产生冲突的记录） 3.5 拉链法和开放地址法比较 与开放定址法相比，拉链法有如下几个优点： ① 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； ② 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； ③ 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； ④ 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 拉链法的缺点 ==拉链法的缺点是：指针需要额外的空间==。故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。 4. 哈希表的查找及分析​ 哈希表的查找过程与哈希表的构造过程一致，给定k值，根据哈希函数计算得到哈希地址，若此位置上为空，则查找不成功；否则与关键字进行比较，若相等，则查找成功，否则根据处理冲突的方法查找下一个槽位上的记录。直到找到查找成功或者哈希表中某个位置为空。 ​ 哈希表的平均查找长度与哈希表的装载因子有关，与关键字集合包含元素个数无关 。因此，不管n多大，我们总可以选择一个合适的装载因子，以便将平均查找长度限定在一个范围内。 5. 哈希表的适用​ 散列技术既是一种存储方法，也是一种查找方法。散列技术最适合的求解问题是查找与给定值相等的记录。 ​ 散列表不适合范围查找；散列表也不能获得表中记录的顺序，如获得表中最大值和最小值是不可行的。 七、图1. 图的深度遍历DFS可采用递归和循环两种方式实现。 ​ 方法一：采用递归的方式。 定义一个标志数组表示某个结点是否已经被访问过。以邻接矩阵的形式表示图。依次对深度遍历图中的每个未被遍历过的结点，然后针对该结点未被遍历过的邻接点再进行深度遍历，每个结点被遍历后加入到结果中，并且设定该结点已经被访问过。 ​ 方法二：不采用递归的方式而是采用栈保存已经遍历过并且还有其孩子结点可能还没有遍历过的结点。与递归方式中一样，也是定义一个标志数组表示某个结点是否已经被访问过。始化栈内存放第一个结点。判断栈顶元素的第一个还未被访问邻接点，把它压入到栈中，每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。循环直到栈空。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 方法一：采用递归的方式。 * 定义一个标志数组表示某个结点是否已经被访问过。 * 以邻接矩阵的形式表示图。 * 依次对深度遍历图中的每个未被遍历过的结点，针对该结点未被遍历过的邻接点再进行深度遍历，每个结点被遍历后加入到结果中，并且设定该结点已经被访问过。 */public static boolean visited[];public static ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();public static ArrayList&lt;Integer&gt; DFS_Graph1(int graph[][])&#123; int size = graph.length;//求得结点的个数 visited = new boolean[size]; /*Step1：依次遍历树中还未被遍历的结点*/ for(int i=0;i&lt;size;i++)&#123; if(visited[i] == false)&#123; visited[i] = true; list.add(i); /*Step2:深度遍历以结点i为开始的路径上的结点*/ DFS(graph,i); &#125; &#125; return list; &#125;/** * 深度递归遍历以图中node结点为起点的结点。 * @param graph * @param node */public static void DFS(int graph[][],int i)&#123; int size = graph.length; for(int j=0;j&lt;size;j++)&#123; /*这个当前结点可达且未被访问的结点j才可以*/ if(graph[i][j] == 1 &amp;&amp; visited[j] == false)&#123; visited[j] = true; list.add(j); DFS(graph,j); &#125; &#125;&#125;/** * 方法二：不采用递归的方式而是采用栈保存已经遍历过并且还有其孩子结点可能还没有遍历过的结点。 * 与递归方式中一样，也是定义一个标志数组表示某个结点是否已经被访问过。 * 初始化栈内存放第一个结点。 * 判断栈顶元素的第一个还未被访问邻接点，把它压入到栈中，每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。 * 如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。 * 一直循环直到栈空。 * * @param graph * @return */public static ArrayList&lt;Integer&gt; DFS_Graph2(int graph[][])&#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int size = graph.length; visited = new boolean[size]; /*Step1:把初始第一个结点放到栈内*/ stack.push(0); visited[0] = true; list.add(0); /* * Step2:找栈顶元素的第一个还未被访问邻接点，把它压入到栈中， * 每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。 * 如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。 * 循环结束的条件是栈为空。 */ while(!stack.isEmpty())&#123; int i = stack.peek();//读栈顶元素 int j = 0; /*找栈顶元素的第一个未被访问的邻接点*/ for(;j&lt;size;j++)&#123; if(graph[i][j] == 1 &amp;&amp; visited[j] == false)&#123; break; &#125; &#125; if(j&lt;size)&#123;//说明找到了 visited[j] = true; list.add(j); stack.push(j); &#125;else&#123;//只有当前栈顶元素不存在未被访问的邻接点时才弹出栈顶元素 stack.pop(); &#125; &#125; return list;&#125; 2. 图的广度优先遍历BFS​ 借助队列实现，同时设置一个包含结点个数的visited数组表示某个结点是否已经被遍历过。 初始化时把第一个结点加入到结果list中，并且把visited[0]设置为true。 循环开始时队列中存储的是图中的第一个结点，循环结束的条件是队列变成空。 循环体内取出队列的第一个元素，并且把这个元素的所有未被访问过的邻接点都加入到队列中、加入到结果list中、设置其对应的状态为已访问。 ​ 类似于树的层次遍历.12345678910111213141516171819202122232425262728293031/** * 图的广度优先遍历。 * 借助队列实现，同时设置一个包含结点个数的visited数组表示某个结点是否已经被遍历过。 * 初始化时把第一个结点加入到结果list中，并且把visited[0]设置为true。 * 循环开始时队列中存储的是图中的第一个结点，循环结束的条件是队列变成空。 * 循环体内取出队列的第一个元素，并且把这个元素的所有未被访问过的邻接点都加入到队列中、加入到结果list中、设置其对应的状态为已访问。 */ public static boolean visited[]; public static ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public static ArrayList&lt;Integer&gt; BFS_Graph(int graph[][])&#123; Queue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(10); int size = graph.length; visited = new boolean[size]; /*Step1:把初始第一个结点放到栈内。*/ queue.add(0); visited[0] = true; list.add(0); int i ; /*Step2:循环队列中的元素直到队列为空。*/ while(!queue.isEmpty())&#123; i = queue.poll(); for(int j =0;j&lt;size;j++)&#123;//找刚刚被弹出队列的队头元素可达的点 if(graph[i][j] ==1 &amp;&amp; visited[j] == false)&#123; visited[j] = true; list.add(j); queue.add(j); &#125; &#125; &#125; return list; &#125; 八、海量数据处理​ 通过对海量数据的挖掘能有效地揭示用户的行为模式，加深对用户需求的理解，提取用户的集体智慧，从而为研发人员决策提供依据，提升产品用户体验，进而占领市场。 ​ 海量处理的基本方法： 1. Hash法 构造hash表和处理冲突的方法和上面介绍的一样。 在处理海量数据的过程中，使用Hash方法一般可以快速存取、统计某些数据，将大量数据进行分类，例如提取某日访问网站次数最多的ip。 2. BitMap法 BitMap(位图)法的基本原理是使用数组来表示某些元素是否存在。 BitMap(位图)法的时间复杂度为O(n)，比一般的排序都快，但它是以空间换时间，而且又一些限制，即数据状态不是很多，例如排序前集合大小最好已知，而且集合中元素的最大重复次数必须已知。 3. Bloom Filter 法（适用于对低错误率可以容忍的场合） Bloom Filter是一种空间效率和时间效率都很高的随机数据结构，可用来检测一个元素是否属于一个集合。其基本原理是位数组与Hash函数的联合使用。首先，Bloom Filter是一个包含m位的位数组，数组的每一位都初始化为0；其次定义k个不同的hash函数，每个函数都可以将集合中的元素映射到位数组中的某一位，这样k个hash函数就将某个元素映射到了位数组中的k个位。查询的时候，根据k个hash函数可以得到数组中的k个位，判断这个k个位是否全为1，若是则说明该元素可不存在。插入的时候，把k个hash函数就将某个元素映射到了位数组中的k个位全部置为1。 Bloom Filter的难点是如何根据输入元素个数n确定m和hash函数。 特点：确定不存在的元素一定不存在，确定存在的数据不一定存在。Bloom Filter只能插入不能删除元素。 优点：具有很好的空间效率和时间效率，它的插入和查询时间都是常数，另外它不保存元素本身，具有良好的安全性。 缺点：牺牲了正确率，当它判断一个元素已存在于集合中时可能不正确。因为可能该元素对应的k个1位可能是被其他多个元素导致的。 4. 数据库优化法 互联网上的数据一般都是被存储到数据库中，如何从数据库中存储的海量信息中提取对自己有用的信息就涉及到了数据的查询技术等相关内容。 常见的数据库优化方法有数据分区、索引、缓存机制、分批处理、优化查询语句、使用采样数据进行数据挖掘等。 5. 倒排索引法 倒排索引是目前搜索引擎公司对搜索引擎最常用的存储方式，也是搜索引擎的核心内容。按照关键字建立索引，关键字指向了包含它的文档。优点是在处理复杂的多关键字时，可在倒排表中完成查询的并、交等逻辑运算，得到结果后再对结果进行存取，这样把记录的查询转换为地址集合的运算，不必对每个记录随机存取，从而提高查找速度。 6. 外排序法 外排序是相对于内部排序而言的，它是大文件的排序，由于内存限制，不能一下子把所有的待排内容都读到内存中进行排序，需要在内存和外部存储器之间进行多次数据交换才能达到对整个文件进行排序的目的。 一般采用归并排序等方式进行外部排序，首先生成若干个子文件，分别对这些子文件进行排序，然后对这些子文件进行多次归并，使得有序的归并段主键扩大，最后在外存上形成整个文件的单一归并段。 外排序适用于大数据的排序以及去重，但外排序的缺陷是会消耗大量的IO，效率不高。 7. Trie树 Trie树是一种用于快速字符串检索的多叉树结果 ，原理是利用字符串的公共前缀来减少空间开销。经常被搜索引擎系统用于文件词频统计。优点是：最大限度地减少无谓的字符串比较，查询效率比散列表高。适合用于数据量大，重复多，但是数据种类小可以放入内存的情况。 但是当系统中存在大量字符串且字符串基本没有公共前缀，则相应的Trie树会非常消耗内存。 8. 堆 堆类别 作用 最大堆 求前k小 最小堆 求前k大 双堆 中位数 ​ 比如用最小堆求前k个最大的元素： 先从待找的n个数字中找出前k个建成小顶堆，然后依次读后面的元素并与小顶堆的堆顶进行比较，如果当前元素小或相等（这个相等是自己加的，需要进一步验证，应该是正确的，因为此时的堆顶元素是前k个里面最小的。如果遇到相等的即使该元素在最后前k个里面，也可以不要那个元素因为之前的已经够k个了，不需要再进行替换了），则继续读后面的元素；如果当前的元素大，则用当前元素替换堆顶元素，然后调整小顶堆。 9. 双层桶法 双层桶不是一种数据结构 ，而是一种算法思想，类似于分治思想。因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。 桶排序一般适用于寻找第k个大的数，寻找中位数、寻找不重复或重复的数字。 如：1）在一个文件中有10G个整数，乱序排列，要求找出中位数，内存限制是2GB； 2）现在有一个0~30000的随机数生成器。请根据这个随机数生成器，设计一个抽奖范围是0~350000彩票中奖号码列表，其中要包含20000个中奖号码 10. MapReduce法 ​ MapReduce是云计算的核心技术之一，是一种简化并行计算的分布式编程模型，主要目的是为了大型集群的系统能在大数据集上进行并行工作，并用于大规模数据的并行运算。 海量数据处理的最大难题在于数据规模巨大，使得传统处理方式面临计算能力不和存储能力不足的瓶颈问题，而基于Hadoop可以非常轻松和方便完成处理海量数据的分布式并行程序，并运行在大规模集群上。 九、红黑树1. 性质 红黑树是一棵二叉搜索树，它在每个结点上增加了一个存储位来表示结点的颜色，是黑色还是红色。 通过任何一条从根到叶子的简单路径上各个结点的颜色进行约束，==红黑树确保没有一条路径会比其他路径长出两倍==，因此也是近似于平衡的。一棵红黑树是确保满足下面红黑性质的二叉搜索树。 ① 每个节点要么是红色的要么是黑色的； ② 根节点是黑色的； ③ 每个叶节点(NIL)是黑色的； ④ 若一个结点是红色的，则它的两个孩子结点都是黑色的； ⑤ 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。 2. 黑高 从某个结点x(不包含该结点)出发到达一个叶结点的任意一条简单路径的黑色结点个数称为该结点的黑高(black-height)，记为bh(x)。 定义红黑树的黑高为其根结点的黑高。 对于给定的黑色高度为n的红黑树，从根到叶结点的简单路径的最短长度为(n-1)，从根到叶结点的简单路径的最大长度为2(n-1). 3. 定理一个有n个内部结点的红黑树的高度至多为2lg(n+1). 4. 操作 默认插入的节点颜色都是红色，因为插入黑色节点会破坏根路径上的黑色节点总数，但即使如此，也会出现连续红色节点的情况。因此在一般的插入操作之后，出现红黑树约束条件不满足的情况（称为失去平衡）时，就必须要根据当前的红黑树的情况做相应的调整其他。 5. 其他 红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求。降低了对旋转的要求，从而提高了性能。 红黑树能够以O(lgn)的时间复杂度进行搜索，插入和删除操作，此外，由于红黑树的设计，任何不平衡都会要求在三次旋转之间解决。 红黑树并不应用所有应用树的领域。如果数据基本上是静态的，那么让数据待在能够插入，并且不影响平衡的地方具有更好的性能。如果数据是完全静态的，例如，做一个hash表，性能可能会更好一点。 在实际的系统中，需要使用动态规划的防火墙系统，使用红黑树而不是散列表，被实践证明具有更好的伸缩性。 参考资料：最容易懂得红黑树 https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md 十、数据结构——位图（bitmap）定义 ​ 位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。 先了解一下位运算的基础知识： ​ 所有比特的编号方法是：从低字节的低位比特位开始，第一个bit为0，最后一个bit为 n-1。 ​ 比如，给出一个数组：int[] array = new int[4]。那么： ​ a[0] – a[4] 的比特位分别为：0–31,32–63,64–95,96–127 ​ 下面我们依据一个程序探究数组比特位的编号：123456789101112public class BitNumber &#123; public static void main(String[] args) &#123; int[] array = new int[4]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = 16; &#125; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = array[i] &gt;&gt; 4; System.out.println(array[i]); &#125; &#125;&#125; ​ 结果是输出了4个1，也就是说刚开始比特位编排为：0000 0000 0001 0000，使用位运算，使其右移了4位，变为：0000 0000 0000 0001. 利用位运算&amp; 进行取模 ​ 位运算跟取模运算之间联系微妙，具体可从下面的例子中看出来： ​ 100%32；100&amp;31 ​ 上述公式的结果是一样的，让我们探究一下他们的原理： ​ 100%32 的取余运算，将取到一百减去3个32之后的余数为4。 100&amp;31是进行按位与运算，31=0001 1111；100=0110 0100，当他们进行按位与时，大于等于32的那部分将给消去，留下的便是余数。 ​ 当然上述运算成立的条件便是做取模运算的后一个数字必须是2的N次幂，也就是32对应位置的数必须是2的N次幂。 特定位的设置与清除 ​ 假如现在 int a = 0; 现在a的编码全部为0，现在要将其从右往左第5个位置设置为1，然后再清除上述操作1234567static int a = 0;public static void main(String[] args) &#123; a |= (1&lt;&lt;5); // | 按位或操作 ,双目运算符 a = a|(1&lt;&lt;5); System.out.println(a); a &amp;= ~(1&lt;&lt;5); // &amp; 按位与操作，双目运算符， ~ 按位非操作，单目运算符 System.out.println(a);&#125; ​ 上述运算的结果分别为32 0. 字节位置与位位置 一个int是4个字节，每个字节有32bit，我们可以将数据存储在这些位内。比如我们要存储100这个数，我们只需在位置100存储一个1。将第100位置为1，也就是说最少需要有100个位置，每个位置1bit，100个位置需要12.5字节，因为一个int型是4字节，所以我们需要定义一个数组 int[4]。 ​ 现在我们要对这个数组的100位进行操作，首先要知道100在这个数组中的第几个元素，每个数组元素都是32位，那么100所在的位置就是100/32，也就是 100&gt;&gt;5。然后在元素中的位置也就是：100%32，也就是100&amp;31，也就是100&amp;0x1F。 给一个例子： ​ 给40亿个不重复的unsigned int的整数，没有排过序，然后再给一个数，如果快速判断这个数是否在那40亿个数当中。 ​ 因为unsigned int数据的最大范围在在40亿左右（需要40亿bit），4010^8/10241024*8=476，因此只需申请512M的内存空间，每个bit位表示一个unsigned int。读入40亿个数，并设置相应的bit位为1.然后读取要查询的数，查看该bit是否为1，是1则存在，否则不存在。 优缺点 (1) 可读性差 (2) 位图存储的元素个数虽然比一般做法多，但是存储的元素大小受限于存储空间的大小。位图存储性质：存储的元素个数等于元素的最大值。比如， 1K 字节内存，能存储 8K 个值大小上限为 8K 的元素。（元素值上限为 8K ，这个局限性很大！）比如，要存储值为 65535 的数，就必须要 65535/8=8K 字节的内存。要就导致了位图法根本不适合存 unsigned int 类型的数（大约需要 2^32/8=5 亿字节的内存）。 (3 )位图对有符号类型数据的存储，需要 2 位来表示一个有符号元素。这会让位图能存储的元素个数，元素值大小上限减半。 比如 8K 字节内存空间存储 short 类型数据只能存 8K*4=32K 个，元素值大小范围为 -32K~32K 。 总结 ​ Bitmap是一种非常简洁快速的数据结构，他能同使证存储空间和速度最优化（而不必空间换时间）。 参考资料：【数据结构】中的位图详解 ​ 数据结构–位图 ​ 编程珠玑——位图数据结构 十二、二叉排序/查找树定义: ​ 二叉排序树（Binary Sort Tree）又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不为空，则左子树上所有结点的值均小于它的根结构的值； 若它的右子树不为空，则右子树上所有结点的值均大于它的根结构的值； 它的左、右子树也分别为二叉排序树（递归）。 ​ zhg 口诀： 左小右大 ​ 说的直白一点，就是具有左子树上的值&lt;根节点的值&lt;右子树上的值的二叉树，我们称之为二叉排序树。 ​ 基于二叉排序树的特点，又结合着中序遍历的特点（中序遍历是先遍历左子树，再遍历根节点，然后遍历右子树），我们不难发现，二叉排序树的中序遍历的结果是从小到大有序的。下方我们会先给出二叉排序树的创建，然后给出二叉排序树的节点删除的代码。 1. 二叉排序树的创建​ 上面也简单的提了一下，二叉排序树的创建无非就是不断查找和插入的过程，当我们查找某个值没有找到时，我们就会将该值插入到二叉排序树中。因为再查找的过程中可以确定该结点要插入的合适位置，所以插入就显得比较简单了。 (1) 二叉排序树的查找与插入的示意图 ​ 我们要将集合{62, 88, 58, 47, 35, 73, 51, 99, 37, 93}中的元素放入到我们的二叉排序树中去存储，如果对我们创建好的二叉排序树进行中序搜索的话，输出的结果就是上面集合的有序序列。下方就是我们二叉排序树从无到有的完整创建过程。 ​ （1）、在初始化状态下我们二叉排序树的根节点为空，我们依次将集合中的元素通过搜索插入到二叉排序树中合适的位置。 ​ （2）、首先在二叉排序中进行搜索62的位置，树为空，所以将62存入到二叉排序树的根节点中，及root=(62)。 ​ （3）、从集合中取出88，然后查找我们的二叉排序树，发现88大于我们的根节点62，所以将88插入到62节点的右子树中，即(62)-&gt;rightChild=(88)。 ​ （4）、从集合中取出58，然后从根节点开始查找我们现有的二叉排序树，发现55\&lt;62，将55作为62的左结点，即(62)-&gt;leftChild=(55)。 ​ （5）、从集合中取出47，然后对二叉排序树进行搜索，发现47\&lt;55, 所以(55)-&gt;leftChild=(47)。 ​ （6）、从集合中取出35，再次对二叉排序树进行搜索，发现35又小于47，所以(47)-&gt;leftChild=(35) ​ （7）、从集合中取出73，再次对二叉排序树进行搜索，发现62\&lt;73\&lt;88, 所以有(88)-&gt;leftChild=(73)。 ​ 以此类推，要做的事情就是不断从集合中取值，然后对二叉排序树进行查找，找到合适的插入点，然后将相应的节点进行插入，具体步骤就不做过多赘述了。 (2) 二叉排序树的查找 ​ 查找过程中要保存当前节点的父节点，如果查找失败，即在二叉排序树中没有查找到给定的元素，那么就要返回插入的位置。要注意父节点为空的情况，那表明现在二叉排序树为空树。插入的时候在和父节点的数据比较一下大小，给定元素小，那么就插入到左孩子，否则就插入到右孩子。 (3) 二叉排序树的插入 ​ 插入操作比较简单，只要通过查找操作找到元素的插入位置，那么就可以根据插入位置进行插入操作了。 2. 二叉排序树结点的删除​ 二叉排序树的结点删除要比二叉排序树结点的插入要复杂一些，不过也并不难，要分为几种情况进行讨论。二叉排序树结点的插入与删除都是在查找的基础上来做的。 ​ 下面分为3种情况进行讨论： ​ (1) 若*p结点为叶子节点，即$P_L$和$P_R$均为空树。由于删除叶子节点不会破坏整棵树的结构，则只需要修改其双亲节点的指针即可。 ​ (2) 若P结点只有左子树$P_L$或者只有右子树$P_R$，此时只要令$P_L$或$P_R$直接成为双亲节点\f的左子树即可。显然，做此修改也不破坏二叉排序树的特性。 ​ (3) 若p结点的左子树和右子树均不为空。显然此时不能像上面一样简单处理。因为二叉排序树的中序遍历是从小到大有序的，所以我们只需要让\P的前驱或者后继来替代*P就可以了。 ​ 在随机的情况下，二叉排序树的平均查找长度和$\log_2 n$是等数量级的。然而，在某些情况下（有人研究证明，这种情况出现的概率约为46.5%），尚需要在构成二叉排序树的过程中进行“平衡化”处理，成为二叉平衡树。 ​ 参考资料：二叉排序树（二叉查找树）- 数据结构和算法73 ​ 算法与数据结构(十) 二叉排序树的查找、插入与删除(Swift版) 十三、平衡二叉树(AVL)​ 在平衡树上进行查找的时间复杂度为$O(\log n)$。 ​ 平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。若将二叉树上节点的平衡因子BF（Balance Factor）定义为该结点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。如图9.11(a)所示为两颗平衡二叉树，而图9.11（b）所示为两颗不平衡的二叉树，结点中的值为该结点的平衡因子。 ​ 对于序列（13，24, 37，90，53 ）插入过程如下图所示： ​ ​ 一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指 针为a(即a是离插入结点最近，且平衡因子绝对值超过1的祖先结点），则失去平衡后进 行调整的规律可归纳为下列4种情况： ​ (1) 单向右旋平衡处理：由于在 a的左子树根结点的左子树上插入结点， a的平 衡因子由1增至2，致使以* a为根的子树失去平衡，则需进行一次向右的顺时针旋转操 作，如图9. 13(a)所示。 ​ (2) 单向左旋平衡处理：由于在 a的右子树根结点的右子树上插入结点， a的平 衡因子由-1变为-2,致使以*a为根结点的子树失去平衡，则需进行一次向左的逆时针旋转操作。如图9. 13(c)所示。 ​ (3) 双向旋转（先左后右）平衡处理：由于在 a的左子树根结点的右子树上插入结点， a的平衡因子由1增至2，致使以*a为根结点的子树失去平衡，则需进行两次旋转(先左旋后右旋)操作。如图9. 13(b)所示。 ​ (4) 双向旋转（先右后左）平衡处理：由于在 a的右子树根结点的左子树上插人结点， a的平衡因子由-1变为-2，致使以* a为根结点的子树失去平衡，则需进行两次 旋转（先右旋后左旋)操作。如图9. 13(d)所示。 ​ 图9.13 二叉排序树的平衡旋转图例 ​ (a) LL型； (b) LR型； (c) RR型 ； (d) RL型； ​ 上述4种情况中，（1）和（2）对称，（3)和（4）对称。旋转操作的正确性容易由“保持二叉排序树的特性：中序遍历所得关键字序列自小至大有序”证明之。同时，从图9. 13可 见，无论哪一种情况，在经过平衡旋转处理之后，以*b或*C为根的新子树为平衡二叉 树，而且它的深度和插人之前以* a为根的子树相同。因此，当平衡的二叉排序树因插人结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。因为经过旋转处理之后的子树深度和插入之前相同，因而不影响插人路径上所有祖先结点的平衡度。 参考资料：数据结构-C语言版（P233 平衡二叉树） 十四、并查集 (Disjoint Set Union (DSU) data structure) Disjoint Set Union (DSU) data structure ​ 这个是摘自LeetCode上684题的题解，对于并查集描述的很清晰。 A DSU data structure can be used to maintain knowledge of the connected components of a graph, and query for them quickly. In particular, we would like to support two operations: dsu.find(node x), which outputs a unique id so that two nodes have the same id if and only if they are in the same connected component, and: dsu.union(node x, node y), which draws an edge (x, y) in the graph, connecting the components with id find(x) and find(y) together. To achieve this, we keep track of parent, which remembers the id of a smaller node in the same connected component. If the node is it’s own parent, we call this the leader of that connected component. A naive implementation of a DSU structure would look something like this: Psuedocode12345678# parent initialized as (x -&gt; x)function find(x): while parent[x] != x: #While x isn't the leader x = parent[x] return xfunction union(x, y): parent[find(x)] = find(y) We use two techniques to improve the run-time complexity: path compression, and union-by-rank. Path compression involves changing the x = parent[x] in the find function to parent[x] = find(parent[x]). Basically, as we compute the correct leader for x, we should remember our calculation. Union-by-rank involves distributing the workload of find across leaders evenly. Whenever we dsu.union(x, y), we have two leaders xr, yr and we have to choose whether we want parent[x] = yr or parent[y] = xr. We choose the leader that has a higher following to pick up a new follower.Specifically, the meaning of rank is that there are less than 2 ^ rank[x] followers of x. This strategy can be shown to give us better bounds for how long the recursive loop in dsu.find could run for.1234567891011121314151617181920212223242526272829class DSU(object): def __init__(self): self.par = range(1001) self.rnk = [0] * 1001 def find(self, x): if self.par[x] != x: self.par[x] = self.find(self.par[x]) return self.par[x] def union(self, x, y): xr, yr = self.find(x), self.find(y) if xr == yr: return False elif self.rnk[xr] &lt; self.rnk[yr]: self.par[xr] = yr elif self.rnk[xr] &gt; self.rnk[yr]: self.par[yr] = xr else: self.par[yr] = xr self.rnk[xr] += 1 return Trueclass Solution(object): #求解的题目是leetCode的684题 def findRedundantConnection(self, edges): dsu = DSU() for edge in edges: if not dsu.union(*edge): return edge Alternate Implementation of DSU without Union-By-Rank123456789class DSU: def __init__(self): self.par = range(1001) def find(self, x): if self.par[x] != x: self.par[x] = self.find(self.par[x]) return self.par[x] def union(self, x, y): self.par[self.find(x)] = self.find(y) Java语言实现的求解123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; int MAX_EDGE_VAL = 1000; public int[] findRedundantConnection(int[][] edges) &#123; DSU dsu = new DSU(MAX_EDGE_VAL + 1); for (int[] edge: edges) &#123; if (!dsu.union(edge[0], edge[1])) return edge; &#125; throw new AssertionError(); &#125;&#125;class DSU &#123; int[] parent; int[] rank; public DSU(int size) &#123; parent = new int[size]; for (int i = 0; i &lt; size; i++) parent[i] = i; rank = new int[size]; &#125; public int find(int x) &#123; if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; &#125; public boolean union(int x, int y) &#123; int xr = find(x), yr = find(y); if (xr == yr) &#123; return false; &#125; else if (rank[xr] &lt; rank[yr]) &#123; parent[xr] = yr; &#125; else if (rank[xr] &gt; rank[yr]) &#123; parent[yr] = xr; &#125; else &#123; parent[yr] = xr; rank[xr]++; &#125; return true; &#125;&#125; Complexity Analysis Time Complexity: $O(Nα(N))≈O(N)$, where $N$ is the number of vertices (and also the number of edges) in the graph, and α\alphaα is the Inverse-Ackermann function. We make up to $N$ queries of dsu.union, which takes (amortized) $O(\alpha(N))$ time. Outside the scope of this article, it can be shown why dsu.union has $O(\alpha(N))$ complexity, what the Inverse-Ackermann function is, and why $O(\alpha(N))$ is approximately $O(1)$. Space Complexity: $O(N)$. The current construction of the graph (embedded in our dsu structure) has at most $N$ nodes. 一个生动的例子讲解 例子就是杭电上的畅通工程：http://acm.hdu.edu.cn/showproblem.php?pid=1232 ​ 首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。 ​ 如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路…… ​ 以下面这组数据输入数据来说明 ​ 4 2 1 3 4 3 ​ 第一行告诉你，一共有4个点，2条路。下面两行告诉你，1、3之间有条路，4、3之间有条路。那么整幅图就被分成了1-3-4和2两部分。只要再加一条路，把2和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。 这可如何是好？ ​ 我以前也不会呀，自从用了并查集之后，嗨，效果还真好！我们全家都用它！ ​ 并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。12345678910111213141516171819202122232425int pre[1010]; //存放第i个元素的父节点int unionsearch(int root) //查找根结点&#123; int son, tmp; son = root; while(root != pre[root]) //寻找根结点 root = pre[root]; while(son != root) //路径压缩 &#123; tmp = pre[son]; pre[son] = root; son = tmp; &#125; return root;&#125;void join(int root1, int root2) //判断是否连通，不连通就合并&#123; int x, y; x = unionsearch(root1); y = unionsearch(root2); if(x != y) //如果不连通，就把它们所在的连通分支合并 pre[x] = y;&#125; ​ 为了解释并查集的原理，我将举一个更有爱的例子。 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？ ​ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。 ​ 下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 ​ find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。1234567891011121314int unionsearch(int root) //查找根结点&#123; int son, tmp; son = root; while(root != pre[root]) //我的上级不是掌门 root = pre[root]; while(son != root) //我就找他的上级，直到掌门出现 &#123; tmp = pre[son]; pre[son] = root; son = tmp; &#125; return root; //掌门驾到~~&#125; ​ 再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？12345678void join(int root1, int root2) //虚竹和周芷若做朋友&#123; int x, y; x = unionsearch(root1);//我老大是玄慈 y = unionsearch(root2);//我老大是灭绝 if(x != y) pre[x] = y; //打一仗，谁赢就当对方老大&#125; ​ 再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低，以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。 ​ 于是，问题圆满解决。。。。。。。。。 ​ 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# include&lt;iostream&gt;# include&lt;cstdio&gt;# include&lt;cstring&gt;# include&lt;cmath&gt;# include&lt;algorithm&gt;using namespace std;int pre[1010]; //里面全是掌门int unionsearch(int root)&#123; int son, tmp; son = root; while(root != pre[root]) //寻找掌门ing…… root = pre[root]; while(son != root) //路径压缩 &#123; tmp = pre[son]; pre[son] = root; son = tmp; &#125; return root; //掌门驾到~&#125;int main()&#123; int num, road, total, i, start, end, root1, root2; while(scanf("%d%d", &amp;num, &amp;road) &amp;&amp; num) &#123; total = num - 1; //共num-1个门派 for(i = 1; i &lt;= num; ++i) //每条路都是掌门 pre[i] = i; while(road--) &#123; scanf("%d%d", &amp;start, &amp;end); //他俩要结拜 root1 = unionsearch(start); root2 = unionsearch(end); if(root1 != root2) //掌门不同？踢馆！~ &#123; pre[root1] = root2; total--; //门派少一个，敌人（要建的路）就少一个 &#125; &#125; printf("%d\n", total);//天下局势：还剩几个门派 &#125; return 0;&#125; 参考资料：超有爱的并查集~]]></content>
      <categories>
        <category>编程基础知识</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash Shell学习]]></title>
    <url>%2F2018%2F05%2F16%2F2_Bash%20Shell%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Bash Shell学习bash shell 小知识点数组取值 对于一个数组，在直接使用数组变量名取值得时候，其实是取得第一个元素值，如果想要取所有的元素值，要用符号@。例如： 12345NAMES=(Joe Jenny Sara Tony)echo $&#123;NAMES&#125; #输出：Joeecho $&#123;NAMES[0]&#125; #输出：Joeecho $&#123;NAMES[1]&#125; #输出：Jennyecho $&#123;NAMES[@] #输出：Joe Jenny Sara Tony 表达式求值 在bash shell中，表达式求值的方式是：$$((数学表达式))，例如：12count=4count=$(($count - 1)) 条件判断式中的中括号[]问题 注意，在条件判断式中，中括号和后面的内容要有空格，否则可能shell识别不了。 例如 if [78 &gt; 45 ]; then 可能就会报”[78 识别不了这个命令”，正确的写法是 if [ 78 &gt; 45 ]; then。 在单引号中解析变量值 本来在单引号中的字符串中是不会解析变量值的，比如echo ‘\$2 is “\$2” ‘，输出结果就是”\$2 is “\$2” “ ，要想在单引号中解析变量值，需要在变量周围再使用单引号括起来，比如 echo ‘\$2 is ‘\$2’ ‘ 学习参考网址：https://www.learnshell.org/en/Hello%2C_World%21 基本了解对于Shell 脚本，其中第一行的”#!”不是一个注释，后面要跟上一个Shell解释器的全路径。这个路径可以告诉操作系统，这么文件中的内容是由解释器中的许多命令组成的。 一般Shell脚本都是”.sh”结尾。第一行的示例如下： #!/bin/bash “#”后面的跟的内容被认为是注释。 想查看当前活跃的Shell，并且查看它路径是什么，可以在命令行键入下面的命令： ps | grep $$ 987 tty1 00:00:00 bash 上面展示了你正在使用的是哪种类型的’bash’，下面的操作会找出Shell 脚本的全路径 which bash /bin/bash 变量在bash中定义变量就直接使用“=”赋值，要注意一点就是”=”号两边是不能有空格的。 使用反斜杠”\”可以逃脱特殊字符。 使用单引号括起来的字符串，不会保留中间的任意空白字符，但是使用双引号括起来的字符串，是会保留任意的空白字符的。 可以使用命令的执行结果给变量赋值，但是执行的命令要使用反引号括起来，或者使用$()。 传递参数到脚本可以给脚本传递参数，通过在执行脚本的时候，在脚本名字后面使用空格分隔参数，形成一个参数列表。 在脚本里面变量$1就是第一个参数，\$2就是第二个参数，以此类推。注意，变量\$0指向的是当前脚本。 ==zhg:== 可以将脚本名字以及后面的参数看做是一个完整的数组，这样就和数组的下标编号对应上了。 变量’$#’保存的是参数个数。 变量‘$@’保存的是包含所有参数和空格的字符串。 数组数组名和变量名一样，后面的初始化值使用（）括起来，值之间使用空格分隔。 12my_array=(apple banana "Fruit Basket" orange)new_array[2]=apricot 可以使用${ #arrayname[@]}获取数组的长度，即元素个数。 12my_array=(apple banana "Fruit Basket" orange)echo $&#123; #my_array[@]&#125; 数组元素可以通过下标访问，下标从0开始的。 123456my_array=(apple banana "Fruit Basket" orange)echo $&#123;my_array[3]&#125; # orange - note that curly brackets are needed# adding another array elementmy_array[4]="carrot" # value assignment without a $ and curly bracketsecho $&#123; #my_array[@]&#125; # 5echo $&#123;my_array[$&#123; #my_array[@]&#125;-1]&#125; # carrot 基本操作(Basic Operators)算数运算 在变量上的简单数学运算可以使用算法表达式：$((expression)) The basic operators are: a + b addition (a plus b) a - b substraction (a minus b) a * b multiplication (a times b) a / b division (integer) (a divided by b) a % b modulo (the integer remainder of a divided by b) ==a ** b exponentiation (a to the power of b)== 基础字符串操作字符串长度 123# 1234567890123456STRING="this is a string"echo $&#123; #STRING&#125; # 16 抽取子串 1234STRING="this is a string"POS=1LEN=3echo $&#123;STRING:$POS:$LEN&#125; # his 子串替换 123# 替换第一次出现的地方STRING="to be or not to be"echo $&#123;STRING[@]/be/eat&#125; # to eat or not to be 123# 替换所有出现的地方STRING="to be or not to be"echo $&#123;STRING[@]//be/eat&#125; # to eat or not to eat 123# 删除所有子串出现的地方（替换为空串）STRING="to be or not to be"echo $&#123;STRING[@]// not/&#125; # to be or to be 123# Replace occurrence of substring if at the beginning of $STRINGSTRING="to be or not to be"echo $&#123;STRING[@]/#to be/eat now&#125; # eat now or not to be 123# Replace occurrence of substring if at the end of $STRINGSTRING="to be or not to be"echo $&#123;STRING[@]/%be/eat&#125; # to be or not to eat 123# replace occurrence of substring with shell command outputSTRING="to be or not to be"echo $&#123;STRING[@]/%be/be on $(date +%Y-%m-%d)&#125; # to be or not to be on 2012-06-14 逻辑判断基本条件判断结构为： if [ expression ]; then code if ‘expression’ is true fi 1234NAME="John"if [ "$NAME" = "John" ]; then echo "True - my name is indeed John"fi if-else 1234567NAME="Bill"if [ "$NAME" = "John" ]; then echo "True - my name is indeed John"else echo "False" echo "You must mistaken me for $NAME"fi else-if 12345678NAME="George"if [ "$NAME" = "John" ]; then echo "John Lennon"elif [ "$NAME" = "George" ]; then echo "George Harrison"else echo "This leaves us with Paul and Ringo"fi A empty string or a string consisting of spaces or an undefined variable name, are evaluated as false. The expression can be a logical combination of comparisons: negation is denoted by ! , logical AND (conjunction) is denoted by &amp;&amp;, and logical OR (disjunction) is denoted by ||. Conditional expressions should be surroun-ded by double brackets [[ ]]. 数学类型的比较 1234567comparison Evaluated to true when$a -lt $b $a &lt; $b$a -gt $b $a &gt; $b$a -le $b $a &lt;= $b$a -ge $b $a &gt;= $b$a -eq $b $a is equal to $b$a -ne $b $a is not equal to $b 字符串类型的比较 12345comparison Evaluated to true when"$a" = "$b" $a is the same as $b"$a" == "$b" $a is the same as $b"$a" != "$b" $a is different from $b-z "$a" $a is empty 注意，“=”号两边的空格符是需要的，还有字符串变量周围要有双引号””，以避免shell识别特殊字符。 在shell中，单引号’’内的变量是不解析的，例如12n=3echo '$n' # 输出：$n 但是，双引号括起来的变量是会进行解析的，例如：12n=3echo "$n" #输出：3 case-in结构 12345678case "$variable" in "$condition1" ) command... ;; "$condition2" ) command... ;;esac 简单的case结构示例： 12345678mycase=1case $mycase in 1) echo "You selected bash";; 2) echo "You selected perl";; 3) echo "You selected phyton";; 4) echo "You selected c++";; 5) exitesac 注意：case 后面的每一条语句都是以两个分号结尾的。 循环bash中基本的for循环结构 12345# basic constructfor arg in [list]do command(s)...done 简单for循环例子： 12345678910# loop on array memberNAMES=(Joe Jenny Sara Tony)for N in $&#123;NAMES[@]&#125; ; do echo "My name is $N"done# loop on command output resultsfor f in $( ls prog.sh /etc/localtime ) ; do echo "File is: $f"done bash中基本的while循环结构 12345# basic constructwhile [ condition ]do command(s)...done 简单的while循环例子 The while construct tests for a condition, and if true, executes commands. It keeps looping as long as the condition is true.12345COUNT=4while [ $COUNT -gt 0 ]; do echo "Value of count is: $COUNT" COUNT=$(($COUNT - 1)) #计算一个表达式 $((数学表达式))done bash中基本的until循环结构 12345# basic constructuntil [ condition ]do command(s)...done until循环的简单例子 The until construct tests for a condition, and if false, executes commands. It keeps looping as long as the condition is false (opposite of while construct) 12345COUNT=1until [ $COUNT -gt 5 ]; do echo "Value of count is: $COUNT" COUNT=$(($COUNT + 1))done break 和 continue 语句 break和continue用于控制for，while和until循环结构。continue用于跳过剩下的特殊循环迭代，但是break是用于跳过整个剩下的循环。下面是例子： 123456789101112131415161718192021# Prints out 0,1,2,3,4COUNT=0while [ $COUNT -ge 0 ]; do echo "Value of COUNT is: $COUNT" COUNT=$((COUNT+1)) if [ $COUNT -ge 5 ] ; then break fidone# Prints out only odd numbers - 1,3,5,7,9COUNT=0while [ $COUNT -lt 10 ]; do COUNT=$((COUNT+1)) # Check if COUNT is even if [ $(($COUNT % 2)) = 0 ] ; then continue fi echo $COUNTdone shell 函数shell中的函数就是一个子程序，实现了一些功能和操作。基本的函数结构如下： 1234# basic constructfunction_name &#123; command...&#125; 简单例子： Functions are called simply by writing their names. A function call is equivalent to a command. Parameters may be passed to a function, by specifying them after the function name. The first parameter is referred to in the function as $1, the second as $2 etc. 12345678910111213141516function function_B &#123; echo "Function B."&#125;function function_A &#123; echo "$1"&#125;function adder &#123; echo "$(($1 + $2))"&#125;# FUNCTION CALLS# Pass parameter to function Afunction_A "Function A." # Function A.function_B # Function B.# Pass two parameters to function adderadder 12 56 # 68 特殊变量(Special Variables)In last tutorial about shell function, you use “$1” represent the first argument passed to function_A. Moreover, here are some special variables in shell: $0 - The filename of the current script.| $n - The Nth argument passed to script was invoked or function was called.| $# - The number of argument passed to script or function.| $@ - All arguments passed to script or function.| $* - All arguments passed to script or function.| $? - The exit status of the last command executed.| $$ - The process ID of the current shell. For shell scripts, this is the process ID under which they are executing.| $! - The process number of the last background command.|1234567891011# !/bin/bashecho "Script Name: $0"function func &#123; for var in $* do let i=i+1 echo "The \$$&#123;i&#125; argument is: $&#123;var&#125;" done echo "Total count of arguments: $#"&#125;func We are argument 执行结果为： Script Name: ./prog.shThe $1 argument is: WeThe $2 argument is: areThe $3 argument is: argumentTotal count of arguments: 3 $@ and $* have different behavior when they were enclosed in double quotes. 123456789101112131415# !/bin/bashfunction func &#123; echo "--- \"\$*\"" for ARG in "$*" do echo $ARG done echo "--- \"\$@\"" for ARG in "$@" do echo $ARG done&#125;func We are argument $@会将参数分开，而$*会将参数组成的字符串看做是一个整体。 上面脚本的执行结果为： — “$*”We are argument— “$@”Weareargument Bash陷阱命令 (Bash Trap Command)这一小节主要参看：https://www.learnshell.org/en/Bash_trap_command It often comes the situations that you want to catch a special signal/interruption/user input in your script to prevent the unpredictables. Trap is your command to try: trap &lt;arg/function&gt; &lt;signal&gt; 上面语句的意思是，只要捕捉到指定的信号(signal)，然后就执行前面的命令或者函数功能。 example1234567891011121314# !/bin/bash# traptest.sh# notice you cannot make Ctrl-C work in this shell, # try with your local one, also remeber to chmod +x # your local .sh file so you can execute it!trap "echo Booh!" SIGINT SIGTERMecho "it's going to run until you hit Ctrl+Z"echo "hit Ctrl+C to be blown away!"while true: do sleep 60 done Surely you can substitute the &quot;echo Booh!&quot; with a function: 123function booh &#123; echo "booh!"&#125; and call it in trap: 1trap booh SIGINT SIGTERM Some of the common signal types you can trap: SIGINT: user sends an interrupt signal (Ctrl + C) SIGQUIT: user sends a quit signal (Ctrl + C) SIGFPE: attempted an illegal mathematical operation You can check out all signal types by entering the following command: 1kill -l Notice the numbers before each signal name, you can use that number to avoid typing long strings in trap: 12# 2 corresponds to SIGINT and 15 corresponds to SIGTERMtrap booh 2 15 文件测试(File Testing)Often you will want to do some file tests on the file system you are running. In this case, shell will provide you with several useful commands to achieve it. The command looks like the following -&lt;command&gt; [filename] [filename1] -&lt;command&gt; [filename2] We will briefly introduce some common commands you might encounter in your daily life. Example use “-e” to test if file exist 12345# !/bin/bashfilename="sample.md"if [ -e "$filename" ]; then echo "$filename exists as a file"fi use “-d” to test if directory exists 12345# !/bin/bashdirectory_name="test_directory"if [ -d "$directory_name" ]; then echo "$directory_name exists as a directory"fi use “-r” to test if file has read permission for the user running the script/test 12345678910# !/bin/bashfilename="sample.md"if [ ! -f "$filename" ]; then # -f 判断 该『档名』是否存在且为文件(file)？ touch "$filename"fiif [ -r "$filename" ]; then echo "you are allowed to read $filename"else echo "you are not allowed to read $filename"fi 具体的文件判断命令，可以参考《鸟哥的Linux私房菜》的第十二章学习Shell Scripts的第12.3小节善用判断式。]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Bash Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[机器学习一. 入门1. 可以参考的路线1、去Coursera上Andrew Ng的《机器学习》，完成所有作业，最好能全部拿满分。2、找一个项目或者找一门稍微具体点的关于机器学习的书。3、修炼内功。话说自己发现光应用不行，还得整明白其背后的东东后，就想四处找人请教4、走到这里，路已经比较清晰了。剩下的就是耐住寂寞与妹纸的诱惑，与实验室的电脑和灯光度过一个个中秋吧。 2. 简单理解参考网址：https://www.cnblogs.com/hellochennan/p/5423740.html 机器学习是一种让计算机利用数据而不是指令来进行各种工作的方法。 机器学习方法是计算机利用已有的数据(经验)，得出了某种模型(迟到的规律)，并利用此模型预测未来(是否迟到)的一种方法。 3. 机器学习方法(1)、回归算法在大部分机器学习课程中，回归算法都是介绍的第一个算法。原因有两个：一.回归算法比较简单，介绍它可以让人平滑地从统计学迁移到机器学习中。二.回归算法是后面若干强大算法的基石，如果不理解回归算法，无法学习那些强大的算法。回归算法有两个重要的子类：即线性回归和逻辑回归。线性回归预测的是数值，例如预测以后的房价。逻辑回归预测的是离散值，例如，预测肿瘤是良性的还是恶性的。 (2)、神经网络神经网络(也称之为人工神经网络，ANN)算法是80年代机器学习界非常流行的算法，不过在90年代中途衰落。现在，携着“深度学习”之势，神经网络重装归来，重新成为最强大的机器学习算法之一。神经网络的学习机理简单来说，就是分解与整合。 (3)、SVM（支持向量机）支持向量机算法从某种意义上来说是逻辑回归算法的强化：通过给予逻辑回归算法更严格的优化条件，支持向量机算法可以获得比逻辑回归更好的分类界线。但是如果没有某类函数技术，则支持向量机算法最多算是一种更好的线性分类技术。 支持向量机是一种数学成分很浓的机器学习算法（相对的，神经网络则有生物科学成分）。在算法的核心步骤中，有一步证明，即将数据从低维映射到高维不会带来最后计算复杂性的提升。于是，通过支持向量机算法，既可以保持计算效率，又可以获得非常好的分类效果。因此支持向量机在90年代后期一直占据着机器学习中最核心的地位，基本取代了神经网络算法。直到现在神经网络借着深度学习重新兴起，两者之间才又发生了微妙的平衡转变。 (4)、聚类算法前面的算法中的一个显著特征就是我的训练数据中包含了标签，训练出的模型可以对其他未知数据预测标签。在下面的算法中，训练数据都是不含标签的，而算法的目的则是通过训练，推测出这些数据的标签。这类算法有一个统称，即无监督算法(前面有标签的数据的算法则是有监督算法)。无监督算法中最典型的代表就是聚类算法。 让我们还是拿一个二维的数据来说，某一个数据包含两个特征。我希望通过聚类算法，给他们中不同的种类打上标签，我该怎么做呢？简单来说，聚类算法就是计算种群中的距离，根据距离的远近将数据划分为多个族群。 聚类算法中最典型的代表就是K-Means算法。 (5)、降维算法降维算法也是一种无监督学习算法，其主要特征是将数据从高维降低到低维层次。在这里，维度其实表示的是数据的特征量的大小，例如，房价包含房子的长、宽、面积与房间数量四个特征，也就是维度为4维的数据。可以看出来，长与宽事实上与面积表示的信息重叠了，例如面积=长 × 宽。通过降维算法我们就可以去除冗余信息，将特征减少为面积与房间数量两个特征，即从4维的数据压缩到2维。于是我们将数据从高维降低到低维，不仅利于表示，同时在计算上也能带来加速。 刚才说的降维过程中减少的维度属于肉眼可视的层次，同时压缩也不会带来信息的损失(因为信息冗余了)。如果肉眼不可视，或者没有冗余的特征，降维算法也能工作，不过这样会带来一些信息的损失。但是，降维算法可以从数学上证明，从高维压缩到的低维中最大程度地保留了数据的信息。因此，使用降维算法仍然有很多的好处。 降维算法的主要作用是压缩数据与提升机器学习其他算法的效率。通过降维算法，可以将具有几千个特征的数据压缩至若干个特征。另外，降维算法的另一个好处是数据的可视化，例如将5维的数据压缩至2维，然后可以用二维平面来可视。降维算法的主要代表是PCA算法(即主成分分析算法)。 (6)、推荐算法推荐算法是目前业界非常火的一种算法，在电商界，如亚马逊，天猫，京东等得到了广泛的运用。推荐算法的主要特征就是可以自动向用户推荐他们最感兴趣的东西，从而增加购买率，提升效益。推荐算法有两个主要的类别： 一类是基于物品内容的推荐，是将与用户购买的内容近似的物品推荐给用户，这样的前提是每个物品都得有若干个标签，因此才可以找出与用户购买物品类似的物品，这样推荐的好处是关联程度较大，但是由于每个物品都需要贴标签，因此工作量较大。 另一类是基于用户相似度的推荐，则是将与目标用户兴趣相同的其他用户购买的东西推荐给目标用户，例如小A历史上买了物品B和C，经过算法分析，发现另一个与小A近似的用户小D购买了物品E，于是将物品E推荐给小A。 两类推荐都有各自的优缺点，在一般的电商应用中，一般是两类混合使用。推荐算法中最有名的算法就是协同过滤算法。 (7)、其他除了以上算法之外，机器学习界还有其他的如高斯判别，朴素贝叶斯，决策树等等算法。但是上面列的六个算法是使用最多，影响最广，种类最全的典型。机器学习界的一个特色就是算法众多，发展百花齐放。 下面做一个总结，按照训练的数据有无标签，可以将上面算法分为监督学习算法和无监督学习算法，但推荐算法较为特殊，既不属于监督学习，也不属于非监督学习，是单独的一类。 监督学习算法：线性回归，逻辑回归，神经网络，SVM 无监督学习算法：聚类算法，降维算法 特殊算法：推荐算法 除了这些算法以外，有一些算法的名字在机器学习领域中也经常出现。但他们本身并不算是一个机器学习算法，而是为了解决某个子问题而诞生的。你可以理解他们为以上算法的子算法，用于大幅度提高训练过程。其中的代表有：梯度下降法，主要运用在线型回归，逻辑回归，神经网络，推荐算法中；牛顿法，主要运用在线型回归中；BP算法，主要运用在神经网络中；SMO算法，主要运用在SVM中。 4.机器学习的应用–大数据说完机器学习的方法，下面要谈一谈机器学习的应用了。无疑，在2010年以前，机器学习的应用在某些特定领域发挥了巨大的作用，如车牌识别，网络攻击防范，手写字符识别等等。但是，从2010年以后，随着大数据概念的兴起，机器学习大量的应用都与大数据高度耦合，几乎可以认为大数据是机器学习应用的最佳场景。 大数据的核心是利用数据的价值，机器学习是利用数据价值的关键技术，对于大数据而言，机器学习是不可或缺的。相反，对于机器学习而言，越多的数据会越 可能提升模型的精确性，同时，复杂的机器学习算法的计算时间也迫切需要分布式计算与内存计算这样的关键技术。因此，机器学习的兴盛也离不开大数据的帮助。 大数据与机器学习两者是互相促进，相依相存的关系。 1.大数据，小分析：即数据仓库领域的OLAP分析思路，也就是多维分析思想。2.大数据，大分析：这个代表的就是数据挖掘与机器学习分析法。3.流式分析：这个主要指的是事件驱动架构。4.查询分析：经典代表是NoSQL数据库。 机器学习与大数据的结合产生了巨大的价值。基于机器学习技术的发展，数据能够“预测”。对人类而言，积累的经验越丰富，阅历也广泛，对未来的判断越准确。例如常说的“经验丰富”的人比“初出茅庐”的小伙子更有工作上的优势，就在于经验丰富的人获得的规律比他人更准确。而在机器学习领域，根据著名的一个实验，有效的证实了机器学习界一个理论：即机器学习模型的数据越多，机器学习的预测的效率就越好。 5.机器学习的子类–深度学习近来，机器学习的发展产生了一个新的方向，即“深度学习”。 虽然深度学习这四字听起来颇为高大上，但其理念却非常简单，就是传统的神经网络发展到了多隐藏层的情况。 在上文介绍过，自从90年代以后，神经网络已经消寂了一段时间。但是BP算法的发明人Geoffrey Hinton一直没有放弃对神经网络的研究。由于神经网络在隐藏层扩大到两个以上，其训练速度就会非常慢，因此实用性一直低于支持向量机。2006年，Geoffrey Hinton在科学杂志《Science》上发表了一篇文章，论证了两个观点： 1.多隐层的神经网络具有优异的特征学习能力，学习得到的特征对数据有更本质的刻画，从而有利于可视化或分类； 2.深度神经网络在训练上的难度，可以通过“逐层初始化” 来有效克服。 通过这样的发现，不仅解决了神经网络在计算上的难度，同时也说明了深层神经网络在学习上的优异性。从此，神经网络重新成为了机器学习界中的主流强大学习技术。同时，具有多个隐藏层的神经网络被称为深度神经网络，基于深度神经网络的学习研究称之为深度学习。 由于深度学习的重要性质，在各方面都取得极大的关注，按照时间轴排序，有以下四个标志性事件值得一说： 2012年6月，《纽约时报》披露了Google Brain项目，这个项目是由Andrew Ng和Map-Reduce发明人Jeff Dean共同主导，用16000个CPU Core的并行计算平台训练一种称为“深层神经网络”的机器学习模型，在语音识别和图像识别等领域获得了巨大的成功。Andrew Ng就是文章开始所介绍的机器学习的大牛(图1中左者)。 2012年11月，微软在中国天津的一次活动上公开演示了一个全自动的同声传译系统，讲演者用英文演讲，后台的计算机一气呵成自动完成语音识别、英中机器翻译，以及中文语音合成，效果非常流畅，其中支撑的关键技术是深度学习； 2013年1月，在百度的年会上，创始人兼CEO李彦宏高调宣布要成立百度研究院，其中第一个重点方向就是深度学习，并为此而成立深度学习研究院(IDL)。 2013年4月，《麻省理工学院技术评论》杂志将深度学习列为2013年十大突破性技术(Breakthrough Technology)之首。 6.机器学习的父类–人工智能人工智能是机器学习的父类。深度学习则是机器学习的子类。如果把三者的关系用图来表明的话，则是下图： 图19. 深度学习、机器学习、人工智能三者关系 毫无疑问，人工智能(AI)是人类所能想象的科技界最突破性的发明了，某种意义上来说，人工智能就像游戏最终幻想的名字一样，是人类对于科技界的最终梦想。从50年代提出人工智能的理念以后，科技界，产业界不断在探索，研究。这段时间各种小说、电影都在以各种方式展现对于人工智能的想象。人类可以发明类似于人类的机器，这是多么伟大的一种理念！但事实上，自从50年代以后，人工智能的发展就磕磕碰碰，未有见到足够震撼的科学技术的进步。 总结起来，人工智能的发展经历了如下若干阶段，从早期的逻辑推理，到中期的专家系统，这些科研进步确实使我们离机器的智能有点接近了，但还有一大段距离。直到机器学习诞生以后，人工智能界感觉终于找对了方向。基于机器学习的图像识别和语音识别在某些垂直领域达到了跟人相媲美的程度。机器学习使人类第一次如此接近人工智能的梦想。 事实上，如果我们把人工智能相关的技术以及其他业界的技术做一个类比，就可以发现机器学习在人工智能中的重要地位不是没有理由的。 人类区别于其他物体，植物，动物的最主要区别，作者认为是“智慧”。而智慧的最佳体现是什么？ 是计算能力么，应该不是，心算速度快的人我们一般称之为天才。是反应能力么，也不是，反应快的人我们称之为灵敏。是记忆能力么，也不是，记忆好的人我们一般称之为过目不忘。是推理能力么，这样的人我也许会称他智力很高，类似“福尔摩斯”，但不会称他拥有智慧。是知识能力么，这样的人我们称之为博闻广，也不会称他拥有智慧。 想想看我们一般形容谁有大智慧？圣人，诸如庄子，老子等。智慧是对生活的感悟，是对人生的积淀与思考，这与我们机器学习的思想何其相似？通过经验获取规律，指导人生与未来。没有经验就没有智慧。 那么，从计算机来看，以上的种种能力都有种种技术去应对。 例如计算能力我们有分布式计算，反应能力我们有事件驱动架构，检索能力我们有搜索引擎，知识存储能力我们有数据仓库，逻辑推理能力我们有专家系统，但是，唯有对应智慧中最显著特征的归纳与感悟能力，只有机器学习与之对应。这也是机器学习能力最能表征智慧的根本原因。 让我们再看一下机器人的制造，在我们具有了强大的计算，海量的存储，快速的检索，迅速的反应，优秀的逻辑推理后我们如果再配合上一个强大的智慧大脑，一个真正意义上的人工智能也许就会诞生，这也是为什么说在机器学习快速发展的现在，人工智能可能不再是梦想的原因。 人工智能的发展可能不仅取决于机器学习，更取决于前面所介绍的深度学习，深度学习技术由于深度模拟了人类大脑的构成，在视觉识别与语音识别上显著性的突破了原有机器学习技术的界限，因此极有可能是真正实现人工智能梦想的关键技术。无论是谷歌大脑还是百度大脑，都是通过海量层次的深度学习网络所构成的。也许借助于深度学习技术，在不远的将来，一个�� 二、开始学习1. 制定路线(1）吴恩达的机器学习课程(2) 《机器学习实战》(3) 周志华的《机器学习》，李航的《统计学习方法》 2014斯坦福大学机器学习——学习笔记学习视频位置：F:\2014斯坦福大学机器学习mkv视频，主讲是吴恩达 第一课 简单介绍1.1机器学习的介绍机器学习可以在计算机视觉，图片分类，网页检索中应用，它其实是一个技术核心，可以应用在多个领域。除了了解基本的算法外，还必须要会应用。 机器学习的一个很实际的应用，让直升飞机自己飞行，识别信封上的手写体，自然语言处理，计算机视觉，理解语言和理解图像处理。 1.2机器学习的正式定义，以及算法目前各种不同类型的学习算法，主要分为两类：监督学习和非监督学习。学习的重点是如何使用机器学习算法。 1.3监督学习(Supervised Learing)一个例子，假设你要预测房屋价格。 监督学习是指我们给算法一个数据集，并且给定正确答案，算法的目的是给出更多的正确答案。这其实是一个回归问题，回归是指我们设法预测连续值的属性。 另外一个例子，估计肿瘤是良性的还是恶性的。 分类是为了预测离散的值。 1.4非监督学习(Unsupervised Learning)在无监督学习中，数据是没有标签和属性的。无监督学习算法会把数据分成不同的聚类，实际上就是聚类算法。对于数据，我们没有给出一个正确的答案。聚类只是无监督学习的一种。 实现机器学习的算法，可以用Octave或者matkab，可以很方便。使用Octave写出算法原型，会非常的快。可以将Octave作为开发原型和学习的工具。 End at 2018/1/1 第二课 建立模型与梯度下降算法2.1 模型代表下面图是训练集与学习算法之间的关系。 自己的理解：就拿线性规划来说，最终的目标是找到一个直线函数h(x),机器学习算法的功能，就是通过数据集去帮助我们找到一个好的h(x)。 2.2 代价函数平方误差代价函数对于线性回归问题来说，一般都是最好的选择。 2.3 代价函数的内涵I要理解的两个重要函数，一个是假设函数，另外一个是代价函数。 2.4 代价函数的内涵II使用等高线在二维平面中刻画三维曲面图。 拥有一个自变量的线性规划模型，是针对房价预测例子的。 2.5 梯度下降法在梯度下降法中，要同时更新两个参数，即参数的更新要同步。同步更新是梯度下降中的一种常用方法，同步更新是非常自然的方法。 2.6 梯度下降法的内涵梯度下降算法 repeat until convergence\(\{ \\ \theta_j = \theta_j - \alpha\frac{\partial}{\partial\theta_j}\mathbf{J}(\theta_0,\theta_1) \\ \}\) 其中，偏导数数那一项可以判断出前进的方向，并且也可以让收敛速率不断变小，所以就不用再去减少\( \alpha \)了。 2.7 梯度下降法求解线性规划对于一个凸函数，任何局部最优都是全局最有。 批处理梯度下降：就是在梯度下降的每一个步骤中都使用所有的数据集。 2.8 一些概念的重要扩展 End at 2018/1/3 第三课 线性代数知识自己修过线性代数，所以就不再看了！ 第四课 梯度下降法与标准方程法4.1 多特征在多个特征的情况下，可以使用矩阵和向量来简化假设h(x)的表示。 4.2 梯度下降法应用于多变量可以类比用于一个变量的情况，其实是一样的。 4.3 梯度下降算法实践技巧I在有多个特征的情况下，如果每个特征的取值范围相似，那么梯度下降算法会收敛的比较快。例如，现在对于房屋价格预测，有两个特征： \( x_1 = size (0-2000 feet^2) \) \( x_2 = number of bedrooms(1-5) \) 在现在这个情况下，代价函数J在平面(\( \theta_1 \), \( \theta_2 \))中的等高线图是一个很瘦的椭圆。如果做出如下改变： \( x_1 = \frac{size(feet^2)}{2000} \) \( x_2 = \frac{number of bedrooms}{5} \) 那么现在的代价函数J的等高线图，就是一个圆，梯度下降法会收敛的比较快。在特征值放缩中，通常将特征值约束在 \( -1 \leq x_i \leq 1 \)的范围。总结：就是两个特征值的范围不要相差太大。 均值归一化(mean normalization)用\( x_i - \mu_i \)来代替\( x_i \)，使得有接近0的均值（不能应用于\( x_0=1 \)）E.g. \( x_1 = \frac{size - 1000}{2000} \) \( x_2 = \frac{\#bedrooms - 2}{5} \)$$ -0.5 \leq x_1 \leq 0.5, -0.5 \leq x_2 \leq 0.5 $$ 4.4 梯度下降算法实践技巧II问题： 怎样验证梯度下降法正确工作了？ 怎样设置下降速率\( \alpha \) 如果梯度下降法正确工作了，那么每一次迭代，代价函数的值都应该下降。 Summary: If \( \alpha \) is too small: slow convergence. If \( \alpha \) is too large: may not decrease on every iteration; may not converge. To choose , try…, 0.001, …, 0.01, …, 0.1, …, 1, …. 4.5 特征和多项式回归可以通过已有的特征创造新的特征。在多项式回归中，将高次项看作是一个特征就好了，这样子就可以继续使用线性回归来求解。 4.6 标准方程法。标准方程法就是用代价函数\( J(\theta) \)对\( \theta \)求偏导，并设其为0, 然后求出的\( \theta \)可以使得代价函数最小。设置\( \theta \)为下面的值，可以使得代价函数最小化： $$ \theta = (X^TX)^{-1}X^Ty $$ 如果使用标准方程法，那么就不再需要归一化特征变量。 4.7 正规方程不可逆性(Normal Equation Noninvertibility)对于标准方程法，如果\( X^TX \)不可逆，那么将无法求解。但是很少有不可逆的情况发生，并且Octave中的pinv()方法在矩阵不可逆的情况下，会求出来一个伪逆，所以仍然可以正确的计算出\( \theta \)。 第五课可以参考http://www.cnblogs.com/leezx/p/5635056.html，里面记录了这节课的内容。 5.1 简单介绍Octave的基本操作先用Octave实现机器学习算法原型，然后在使用C++或者Java实现。 5.2 Octave中移动数据5.3 在数据上进行计算A = magic(3)会返回一个3X3的魔方矩阵，其行列和对角线上的元素和都是相等的。 忘记函数怎么用的时候，使用help命令就可以了，例如：help find 会显示find命令的帮助文档。 5.4 数据可视化(Plotting Data)主要有plot subplot 命令，axis改变坐标轴的刻度。 5.5 控制语句，for, while, if5.6 向量化向量化有利于提高计算效率，并且可以简化代码。 5.7 作业提交和编程训练。第六课6.1 分类问题逻辑回归实际上是一种分类算法。 6.2 表征假设(the Hypothesis Representation)逻辑回归模型：$$ 0 \leq h_{\theta}(x) \leq 1 $$ 6.3 决策边界(Decision Boundary)决策边界是假设函数的一个属性，并不是训练数据集的属性。 6.4 代价函数(Cost Function)怎样确定假设函数的参数。 6.5 简单代价函数和梯度下降法6.6 高级优化6.7 多类分类(Multiclass Classification)多分类其实分解成多个二分类问题，可以先分出一个类和其余的类，重复这个动作分区所有的类别。然后，对于一个\( x \)选择出概率最大的那个分类就好了。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌机器学习速成课程——笔记]]></title>
    <url>%2F2018%2F05%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E8%B0%B7%E6%AD%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90%E8%AF%BE%E7%A8%8B%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[谷歌机器学习速成课程——笔记参考网址：机器学习速成课程 第一课、机器学习简介机器学习的三个好处： 可以让你在更短的时间编写更可靠的程序，例如，拼写错误检查 更容易迁移到不同的环境中，例如，拼写检查程序迁移到其他的语言上。 可以完成以前不能完成的工作，例如，面部识别 第二课、框架处理什么是（监督式）机器学习？ 机器学习系统 通过学习如何组合输入信息 来对从未见过的数据 做出有用的预测 术语：标签和特征 标签是指我们要预测的真实事物：y 基本线性回归中的 y 变量 第三课、深入了解机器学习常用的损失函数： 平方损失 第四课、降低损失理想的学习速率 一维空间中的理想学习速率是$\frac{1}{f(x)^{‘’}}$（f(x) 对 x 的二阶导数的倒数）。 二维或多维空间中的理想学习速率是海森矩阵（由二阶偏导数组成的矩阵）的倒数。 广义凸函数的情况则更为复杂。 done! 2018-4-23 第五课、使用TF的基本步骤TensorFlow是基于图表的通用计算框架，可用于编写你想到的任何东西。 TensorFlow.org的API页面中提供了可在代码中使用的低级TensorFlow运算的完整列表。 图 1. TensorFlow 工具包层次结构。 下表总结了不同层的用途： 工具包 说明 Estimator (tf.estimator) 高级 OOP API。 tf.layers/tf.losses/tf.metrics 用于常见模型组件的库。 TensorFlow 低级 API TensorFlow 由以下两个组件组成： 图协议缓冲区 执行（分布式）图的运行时 这两个组件类似于 Java 编译器和 JVM。正如 JVM 会实施在多个硬件平台（CPU 和 GPU）上一样，TensorFlow 也是如此。 您应该使用哪个 API？您应该使用能够解决问题的最高级抽象层。较高级别的抽象层更易于使用，但（设计方面）不够灵活。我们建议您先从最高级 API 入手，让所有组件正常运作起来。如果您希望在某些特殊建模方面能够更加灵活一些，则可以降低一个级别。请注意，每个级别都是使用低级 API 构建的，因此降低层次结构级别应该比较直观。 tf.estimator API 我们将使用 tf.estimator 来完成机器学习速成课程中的大部分练习。您在练习中所做的一切都可以在较低级别（原始）的 TensorFlow 中完成，但使用 tf.estimator 会大大减少代码行数。 tf.estimator 与 scikit-learn API 兼容。 scikit-learn 是极其热门的 Python 开放源代码机器学习库，拥有超过 10 万名用户，其中包括许多 Google 员工。 概括而言，以下是在 tf.estimator 中实现的线性回归程序的格式： 12345678910import tensorflow as tf# Set up a linear classifier.classifier = tf.estimator.LinearClassifier()# Train the model on some example data.classifier.train(input_fn=train_input_fn, steps=2000)# Use it to predict.predictions = classifier.predict(input_fn=predict_input_fn) 张量 (Tensor) TensorFlow 程序中的主要数据结构。张量是 N 维（其中 N 可能非常大）数据结构，最常见的是标量、向量或矩阵。张量的元素可以包含整数值、浮点值或字符串值。 Estimatortf.Estimator 类的一个实例，用于封装负责构建 TensorFlow 图并运行 TensorFlow 会话的逻辑。您可以创建自己的自定义 Estimator（如需相关介绍，请点击此处），也可以将其他人预创建的 Estimator 实例化。]]></content>
      <categories>
        <category>课程笔记</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode编程分析]]></title>
    <url>%2F2018%2F04%2F28%2FleetCode%E7%BC%96%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LeetCode编程分析459. Repeated Substring Pattern | 步骤 | 操作 | 匹配状态 || —- | ———————— | ——– || 1 | 0-&gt;19 | 匹配 || 2 | 找到子串，开始验证 1-&gt;19 | 失败 || 3 | 重新找子串”aba” | 找到 || 4 | 验证子串”aba” | 失败 || 5 | 找到子串“ababa” | 找到 || 6 | 验证子串”ababa” | 失败 || 7 | 找到子串“abababa” | 找到 || 8 | 验证子串“abababa” | 验证成功 || 10 | 返回true | |]]></content>
      <categories>
        <category>编程实战</category>
        <category>练习题</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据库</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、事务 概念 四大特性 AUTOCOMMIT 二、并发一致性问题 问题 解决方法 三、封锁 封锁粒度 封锁类型 封锁协议 MySQL 隐式与显示锁定 四、隔离级别 五、多版本并发控制 版本号 Undo 日志 实现过程 快照读与当前读 六、Next-Key Locks Record Locks Grap Locks Next-Key Locks 七、关系数据库设计理论 函数依赖 异常 范式 八、数据库系统概述 基本术语 数据库的三层模式和两层映像 九、关系数据库建模 ER 图 十、约束 1. 键码 2. 单值约束 3. 引用完整性约束 4. 域约束 5. 一般约束 参考资料 一、事务概念 事务指的是满足 ACID 特性的一系列操作。在数据库中，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 四大特性1. 原子性（Atomicity）事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 2. 一致性（Consistency）数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 3. 隔离性（Isolation）一个事务所做的修改在最终提交以前，对其它事务是不可见的。 4. 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来保证持久性。 AUTOCOMMITMySQL 默认采用自动提交模式。也就是说，如果不显示使用START TRANSACTION语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。 二、并发一致性问题在并发环境下，一个事务如果受到另一个事务的影响，那么事务操作就无法满足一致性条件。 问题1. 丢失修改T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 2. 读脏数据T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 3. 不可重复读T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 4. 幻影读T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 解决方法产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。 在没有并发的情况下，事务以串行的方式执行，互不干扰，因此可以保证隔离性。在并发的情况下，如果能通过并发控制，让事务的执行结果和某一个串行执行的结果相同，就认为事务的执行结果满足隔离性要求，也就是说是正确的。把这种事务执行方式称为 可串行化调度 。 并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。 三、封锁封锁粒度 MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作，包括获取锁，检查锁是否已经解除、释放锁，都会增加系统开销。因此封锁粒度越小，系统开销就越大。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 封锁类型1. 读写锁 排它锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 有以下两个规定： 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 锁的兼容关系如下： - X S X NO NO S NO YES 2. 意向锁使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 各种锁的兼容关系如下： - X IX S IS X NO NO NO NO IX NO YES NO YES S NO NO YES YES IS NO NO YES YES 解释如下： 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁； S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。 封锁协议1. 三级封锁协议一级封锁协议 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么一个事务的修改就不会被覆盖。 T1 T1 lock-x(A) read A=20 lock-x(A) wait write A=19 . commit . unlock-x(A) . obtain read A=19 write A=21 commit unlock-x(A) 二级封锁协议 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 T1 T1 lock-x(A) read A=20 write A=19 lock-s(A) wait rollback . A=20 . unlock-x(A) . obtain read A=20 commit unlock-s(A) 三级封锁协议 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 T1 T1 lock-s(A) read A=20 lock-x(A) wait read A=20 . commit . unlock-s(A) . obtain read A=20 write A=19 commit unlock-X(A) 2. 两段锁协议加锁和解锁分为两个阶段进行。事务 T 对数据 A 进行读或者写操作之前，必须先获得对 A 的封锁，并且在释放一个封锁之后，T 不能再获得任何的其它锁。 事务遵循两段锁协议是保证并发操作可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。 1lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B) 但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。 1lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C) MySQL 隐式与显示锁定MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定： 12SELECT ... LOCK In SHARE MODE;SELECT ... FOR UPDATE; 四、隔离级别 1. 未提交读（READ UNCOMMITTED） 事务中的修改，即使没有提交，对其它事务也是可见的。 2. 提交读（READ COMMITTED） 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 3. 可重复读（REPEATABLE READ） 保证在同一个事务中多次读取同样数据的结果是一样的。 4. 可串行化（SERIALIXABLE） 强制事务串行执行。 四个隔离级别的对比 隔离级别 脏读 不可重复读 幻影读 未提交读 YES YES YES 提交读 NO YES YES 可重复读 NO NO YES 可串行化 NO NO NO 五、多版本并发控制多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC；可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。 版本号 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。 事务版本号：事务开始时的系统版本号。 InooDB 的 MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号： 创建版本号：指示创建一个数据行的快照时的系统版本号； 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。 Undo 日志InnoDB 的 MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。 实现过程以下过程针对可重复读（REPEATABLE READ）隔离级别。 1. SELECT当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。 多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。 把没对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。 除了上面的要求，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。 2. INSERT将当前系统版本号作为数据行快照的创建版本号。 3. DELETE将当前系统版本号作为数据行快照的删除版本号。 4. UPDATE将当前系统版本号作为更新后的数据行快照的创建版本号，同时将当前系统版本号作为更新前的数据行快照的删除版本号。可以理解为先执行 DELETE 后执行 INSERT。 快照读与当前读1. 快照读这是 MVCC 的一种方式，读取的是快照中的数据，可以减少加锁所带来的开销。 1select * from table ...; 2. 当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。 12345select * from table where ? lock in share mode;select * from table where ? for update;insert;update;delete; 六、Next-Key LocksNext-Key Locks 也是 MySQL 的 InnoDB 存储引擎的一种锁实现。MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。 Record Locks锁定的对象是索引，而不是数据。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚集索引，因此 Record Locks 依然可以使用。 Grap Locks锁定一个范围内的索引，例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。 1SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE; Next-Key Locks它是 Record Locks 和 Gap Locks 的结合。在 user 中有以下记录： 12345678| id | last_name | first_name | age ||------|-------------|--------------|-------|| 4 | stark | tony | 21 || 1 | tom | hiddleston | 30 || 3 | morgan | freeman | 40 || 5 | jeff | dean | 50 || 2 | donald | trump | 80 |+------|-------------|--------------|-------+ 那么就需要锁定以下范围： 123456(-∞, 21](21, 30](30, 40](40, 50](50, 80](80, ∞) 七、关系数据库设计理论函数依赖记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。 如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。 对于 W-&gt;A，如果能找到 W 的真子集 W’，使得 W’-&gt; A，那么 W-&gt;A 就是部分函数依赖，否则就是完全函数依赖； 异常以下的学生课程关系的函数依赖为 Sno, Cname -&gt; Sname, Sdept, Mname, Grade，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。 Sno Sname Sdept Mname Cname Grade 1 学生-1 学院-1 院长-1 课程-1 90 2 学生-2 学院-2 院长-2 课程-2 80 2 学生-2 学院-2 院长-2 课程-1 100 不符合范式的关系，会产生很多异常，主要有以下四种异常： 冗余数据：例如 学生-2 出现了两次。 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常：删除一个信息，那么也会丢失其它信息。例如如果删除了 课程-1，需要删除第一行和第三行，那么 学生-1 的信息就会丢失。 插入异常，例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。 范式范式理论是为了解决以上提到四种异常。高级别范式的依赖于低级别的范式。 1. 第一范式 (1NF)属性不可分； 2. 第二范式 (2NF)每个非主属性完全函数依赖于键码。 可以通过分解来满足。 分解前 Sno Sname Sdept Mname Cname Grade 1 学生-1 学院-1 院长-1 课程-1 90 2 学生-2 学院-2 院长-2 课程-2 80 2 学生-2 学院-2 院长-2 课程-1 100 以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖： Sno -&gt; Sname, Sdept Sdept -&gt; Mname Sno, Cname-&gt; Grade Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。 Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。 分解后 关系-1 Sno Sname Sdept Mname 1 学生-1 学院-1 院长-1 2 学生-2 学院-2 院长-2 有以下函数依赖： Sno -&gt; Sname, Sdept, Mname Sdept -&gt; Mname 关系-2 Sno Cname Grade 1 课程-1 90 2 课程-2 80 2 课程-1 100 有以下函数依赖： Sno, Cname -&gt; Grade 3. 第三范式 (3NF)非主属性不传递依赖于键码。 上面的 关系-1 中存在以下传递依赖：Sno -&gt; Sdept -&gt; Mname，可以进行以下分解： 关系-11 Sno Sname Sdept 1 学生-1 学院-1 2 学生-2 学院-2 关系-12 Sdept Mname 学院-1 院长-1 学院-2 院长-2 4. BC 范式（BCNF）所有属性不传递依赖于键码。 关系 STC(Sname, Tname, Cname, Grade) 的四个属性分别为学生姓名、教师姓名、课程名和成绩，它的键码为 (Sname, Cname, Tname)，有以下函数依赖： Sname, Cname -&gt; Tname Sname, Cname -&gt; Grade Sname, Tname -&gt; Cname Sname, Tname -&gt; Grade Tname -&gt; Cname 存在着以下函数传递依赖： Sname -&gt; Tname -&gt; Cname 可以分解成 SC(Sname, Cname, Grade) 和 ST(Sname, Tname)，对于 ST，属性之间是多对多关系，无函数依赖。 八、数据库系统概述基本术语1. 数据模型由数据结构、数据操作和完整性三个要素组成。 2. 数据库系统数据库系统包含所有与数据库相关的内容，包括数据库、数据库管理系统、应用程序以及数据库管理员和用户，还包括相关的硬件和软件。 数据库的三层模式和两层映像 外模式：局部逻辑结构 模式：全局逻辑结构 内模式：物理结构 1. 外模式又称用户模式，是用户和数据库系统的接口，特定的用户只能访问数据库系统提供给他的外模式中的数据。例如不同的用户创建了不同数据库，那么一个用户只能访问他有权限访问的数据库。 一个数据库可以有多个外模式，一个用户只能有一个外模式，但是一个外模式可以给多个用户使用。 2. 模式可以分为概念模式和逻辑模式，概念模式可以用概念-关系来描述；逻辑模式使用特定的数据模式（比如关系模型）来描述数据的逻辑结构，这种逻辑结构包括数据的组成、数据项的名称、类型、取值范围。不仅如此，逻辑模式还要描述数据之间的关系、数据的完整性与安全性要求。 3. 内模式又称为存储模式，描述记录的存储方式，例如索引的组织方式、数据是否压缩以及是否加密等等。 4. 外模式/模式映像把外模式的局部逻辑结构和模式的全局逻辑结构联系起来。该映像可以保证数据和应用程序的逻辑独立性。 5. 模式/内模式映像把模式的全局逻辑结构和内模式的物理结构联系起来，该映像可以保证数据和应用程序的物理独立性。 九、关系数据库建模ER 图Entity-Relationship，有三个组成部分：实体、属性、联系。 1. 实体的三种联系联系包含一对一，一对多，多对多三种。 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；如果是一对一，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是一对多的关系。 2. 表示出现多次的关系一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。 3. 联系的多向性虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。 一般只使用二元联系，可以把多元关系转换为二元关系。 4. 表示子类用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。 十、约束1. 键码用于唯一表示一个实体。 键码可以由多个属性构成，每个构成键码的属性称为码。 2. 单值约束某个属性的值是唯一的。 3. 引用完整性约束一个实体的属性引用的值在另一个实体的某个属性中存在。 4. 域约束某个属性的值在特定范围之内。 5. 一般约束比如大小约束，数量约束。 参考资料 史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006. 施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013. The InnoDB Storage Engine Transaction isolation levels Concurrency Control The Nightmare of Locking, Blocking and Isolation Levels! 三级模式与两级映像 Database Normalization and Normal Forms with an Example The basics of the InnoDB undo logging and history system MySQL locking for the busy web developer 浅入浅出 MySQL 和 InnoDB Innodb 中的事务隔离级别和锁的关系]]></content>
      <categories>
        <category>数据库</category>
        <category>编程基础知识</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2018%2F04%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[一、概述 网络的网络 ISP 互联网的组成 主机之间的通信方式 电路交换与分组交换 时延 计算机网络体系结构* 二、物理层 通信方式 带通调制 信道复用技术 三、数据链路层 信道分类 三个基本问题 局域网 PPP 协议 CSMA/CD 协议* 扩展局域网* MAC 层* 四、网络层* 网际协议 IP 概述 IP 数据报格式 IP 地址编址方式 IP 地址和 MAC 地址 地址解析协议 ARP 路由器的结构 路由器分组转发流程 路由选择协议 网际控制报文协议 ICMP 分组网间探测 PING 虚拟专用网 VPN 网络地址转换 NAT 五、运输层* UDP 和 TCP 的特点 UDP 首部格式 TCP 首部格式 TCP 的三次握手 TCP 的四次挥手 TCP 滑动窗口 TCP 可靠传输 TCP 流量控制 TCP 拥塞控制 六、应用层* 域名系统 DNS 文件传输协议 FTP 远程终端协议 TELNET 电子邮件协议 动态主机配置协议 DHCP 点对点传输 P2P Web 页面请求过程 常用端口 参考资料 一、概述网络的网络网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。 互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。 互联网的组成 边缘部分：所有连接在互联网上的主机，用户可以直接使用； 核心部分：由大量的网络和连接这些网络的路由器组成，为边缘部分的主机提供服务。 主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务器。 电路交换与分组交换 1. 电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 报文交换报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。 3. 分组交换分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。 存储转发允许在一条传输线路上传送多个主机的分组，也就是说两个用户之间的通信不需要占用端到端的线路资源。 相比于报文交换，由于分组比报文更小，因此分组交换的存储转发速度更加快速。 时延总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 1. 发送时延主机或路由器发送数据帧所需要的时间。 $$delay= \frac{l(bit)}{v(bit/s)}$$ 其中 l 表示数据帧的长度，v 表示发送速率。 2. 传播时延电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。 $$delay=\frac{l(m)}{v(m/s)}$$ 其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。 3. 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据部、进行差错检验或查找适当的路由等。 4. 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 计算机网络体系结构* 1. 七层协议如图 a 所示，其中表示层和会话层用途如下： 表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩； 会话层：不同机器上的用户之间建立及管理会话。 2. 五层协议 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 3. 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 4. TCP/IP 体系结构它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。 二、物理层通信方式 单向通信，又称为单工通信； 双向交替通信，又称为半双工通信； 双向同时通信，又称为全双工通信。 带通调制模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 信道复用技术1. 频分复用、时分复用频分复用的所有用户在相同的时间占用不同的频率带宽资源；时分复用的所有用户在不同的时间占用相同的频率带宽资源。 使用这两种方式进行通信，在通信的过程中用户会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。 2. 统计时分复用是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 3. 波分复用光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 4. 码分复用为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 和 有 为了讨论方便，取 m=8，设码片 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。 在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到 其中 为 的反码。 利用上面的式子我们知道，当接收端使用码片 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。 码分复用需要发送的数据量为原先的 m 倍。 三、数据链路层信道分类 点对点信道：一对一通信方式； 广播信道：一对多通信方式。 三个基本问题1. 封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2. 透明传输透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符，如果出现转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3. 差错检测目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 局域网局域网是典型的一种广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 可以按照网络拓扑对局域网进行分类： PPP 协议用于点对点信道中。互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 在 PPP 的帧中： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 CSMA/CD 协议*用于广播信道中。在广播信道上，同一时间只能允许一台计算机发送数据。 CSMA/CD 表示载波监听多点接入 / 碰撞检测。 多点接入 ：说明这是总线型网络，许多计算机以多点的方式连接到总线上。 载波监听 ：每个站都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定，从离散的整数集合 {0, 1, ./image, (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 扩展局域网*1. 在物理层进行扩展使用集线器进行扩展。 集线器的主要功能是对接收到的信号进行放大，以扩大网络的传输距离。 集线器不能根据 MAC 地址进行转发，而是以广播的方式发送数据帧。 集线器是一种共享式的传输设备，意味着同一时刻只能传输一组数据帧。 2. 在链路层进行扩展最开始使用的是网桥，它收到一个帧时，根据帧的 MAC 地址，查找网桥中的地址表，确定帧转发的接口。 网桥不是共享式设备，因此性能比集线器这种共享式设备更高。 交换机的问世很快就淘汰了网桥，它实质上是一个多接口网桥，而网桥是两接口。交换机的每个接口都能直接与一个主机或者另一个交换机相连，并且一般都工作在全双工方式。 交换机具有自学习能力，学习的是交换表的内容。交换表中存储着 MAC 地址到接口的映射。下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧。主机 B 收下之后，查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 3 的映射。 3. 虚拟局域网虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息，例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 MAC 层*MAC 地址是 6 字节（48 位）的地址，用于唯一标识网络适配器（网卡），一台主机拥有多少个适配器就有多少个 MAC 地址，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。 在 MAC 帧中： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 前同步码 ：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。 四、网络层*网际协议 IP 概述因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 IP 地址编址方式IP 地址的编址方式经历了三个历史阶段： 分类 子网划分 无分类 1. 分类由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 IP 地址和 MAC 地址网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 地址解析协议 ARP实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。 路由器的结构路由器从功能上可以划分为：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 路由选择协议互联网使用的路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类： 内部网关协议 IGP（Interior Gateway Protocol）：在 AS 内部使用，如 RIP 和 OSPF。 外部网关协议 EGP（External Gateway Protocol）：在 AS 之间使用，如 BGP。 1. 内部网关协议 RIPRIP 是一种分布式的基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP 协议实现简单，开销小，但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPAS 之间的路由选择很困难，主要是互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。它采用路径向量路由选择协议。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 分组网间探测 PINGPING 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报。 Ping 的过程： 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，但 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 五、运输层*网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。 UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文段，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2MSL 时间后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。 TCP 滑动窗口 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1. 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。 2. 快重传与快恢复在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M~1~ 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个==重复确认==，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。 在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 六、应用层*域名系统 DNS把主机名解析为 IP 地址。 被设计成分布式系统。 ==DNS解析过程的请求和回答都是使用的UDP数据报。== 1. 层次结构一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。 域名服务器可以分为以下四类： 根域名服务器：解析顶级域名； 顶级域名服务器：解析二级域名； 权限域名服务器：解析区内的域名； 本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。 区和域的概念不同，可以在一个域中划分多个区。图 b 在域 abc.com 中划分了两个区：abc.com 和 y.abc.com 因此就需要两个权限域名服务器： 2. 解析过程主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。 迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归的方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。 文件传输协议 FTPFTP 在运输层使用 TCP，并且需要建立两个并行的 TCP 连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开，而数据连接在数据传送完毕之后就关闭。控制连接使用端口号 21，数据连接使用端口号 20。 远程终端协议 TELNETTELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1. POP3POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 2. IMAPIMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。 3. SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则。 动态主机配置协议 DHCPDHCP 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。 工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。 点对点传输 P2P把某个文件分发的所有对等集合称为一个洪流。文件的数据单元称为文件块，它的大小是固定的。一个新的对等方加入某个洪流，一开始并没有文件块，但是能够从其它对等方中逐渐地下载到一些文件块，与此同时，它也为别的对等方上传一些文件块。 每个洪流都有一个基础设施，称为追踪器。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。可以在任何时间加入和退出某个洪流。 一个新的对等方加入洪流时，追踪器会随机从洪流中选择若干个对等方，并让新对等方与这些对等方建立连接，把这些对等方称为相邻对等方。接收和发送文件块都是在相邻对等方中进行。 当一个对等方需要很多文件块时，通过使用最稀有优先的策略来取得文件块，也就是一个文件块在相邻对等方中副本最少，那么就优先请求这个文件块。 当很多对等方向同一个对等方请求文件块时，该对等方优先选择以最高速率向其发送文件块的对等方。 P2P 是一个分布式系统，任何时候都有对等方加入或者退出。使用分布式散列表 DHT，可以查找洪流中的资源和 IP 地址映射。 Web 页面请求过程1. DHCP 配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2. ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3. DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4. HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYNACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 常用端口 应用层协议 端口号 运输层协议 DNS 53 UDP FTP 控制连接 21，数据连接 20 TCP TELNET 23 TCP DHCP 67 68 UDP HTTP 80 TCP SMTP 25 TCP POP3 110 TCP IMAP 143 TCP 参考资料 计算机网络, 谢希仁 JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014.]]></content>
      <categories>
        <category>编程基础知识</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识]]></title>
    <url>%2F2018%2F04%2F16%2F1_Java%20IO%2F</url>
    <content type="text"><![CDATA[一、概览 二、磁盘操作 三、字节操作 四、字符操作 五、对象操作 六、网络操作 InetAddress URL Sockets Datagram 七、NIO 流与块 通道与缓冲区 缓冲区状态变量 文件 NIO 实例 套接字 NIO 实例 内存映射文件 对比 八、参考资料 一、概览Java 的 I/O 大概可以分成以下几类： 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO 二、磁盘操作File 类可以用于表示文件和目录，但是它只用于表示文件的信息，而不表示文件的内容。 三、字节操作 Java I/O 使用了装饰者模式来实现。以 InputStream 为例，InputStream 是抽象组件，FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作。FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能，例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。 1BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。 批量读入文件内容到字节数组： 123456byte[] buf = new byte[20*1024];int bytes = 0;// 最多读取 buf.length 个字节，返回的是实际读取的个数，返回 -1 的时候表示读到 eof，即文件尾while((bytes = in.read(buf, 0 , buf.length)) != -1) &#123; // ...&#125; 四、字符操作不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。 InputStreamReader 实现从文本文件的字节流解码成字符流；OutputStreamWriter 实现字符流编码成为文本文件的字节流。它们继承自 Reader 和 Writer。 编码就是把字符转换为字节，而解码是把字节重新组合成字符。 12byte[] bytes = str.getBytes(encoding); // 编码String str = new String(bytes, encoding)； // 解码 GBK 编码中，中文占 2 个字节，英文占 1 个字节；UTF-8 编码中，中文占 3 个字节，英文占 1 个字节；Java 使用双字节编码 UTF-16be，中文和英文都占 2 个字节。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 五、对象操作序列化就是将一个对象转换成字节序列，方便存储和传输。 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() 序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现。 transient 关键字可以使一些属性不会被序列化。 ArrayList 序列化和反序列化的实现 ：ArrayList 中存储数据的数组是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。 1private transient Object[] elementData; 六、网络操作Java 中的网络支持： InetAddress：用于表示网络上的硬件资源，即 IP 地址； URL：统一资源定位符，通过 URL 可以直接读取或者写入网络上的数据； Sockets：使用 TCP 协议实现网络通信； Datagram：使用 UDP 协议实现网络通信。 InetAddress没有公有构造函数，只能通过静态方法来创建实例。 12InetAddress.getByName(String host);InetAddress.getByAddress(byte[] addr); URL可以直接从 URL 中读取字节流数据 123456789101112URL url = new URL("http://www.baidu.com");InputStream is = url.openStream(); // 字节流InputStreamReader isr = new InputStreamReader(is, "utf-8"); // 字符流BufferedReader br = new BufferedReader(isr);String line = br.readLine();while (line != null) &#123; System.out.println(line); line = br.readLine();&#125;br.close();isr.close();is.close(); Sockets ServerSocket：服务器端类 Socket：客户端类 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。 Datagram DatagramPacket：数据包类 DatagramSocket：通信类 七、NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。 流与块I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I/O 一次处理一个字节数据，一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。 一个面向块的 I/O 系统以块的形式处理数据，一次处理一个数据块。按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。 通道与缓冲区1. 通道通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。 通道与流的不同之处在于，流只能在一个方向上移动，(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。 通道包括以下类型： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 2. 缓冲区发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。 缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。 缓冲区包括以下类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区状态变量 capacity：最大容量； position：当前已经读写的字节数； limit：还可以读写的字节数。 状态变量的改变过程举例： ① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。 ② 从输入通道中读取 3 个字节数据写入缓冲区中，此时 position 移动设为 3，limit 保持不变。 ③ 以下图例为已经从输入通道读取了 5 个字节数据写入缓冲区中。在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。 ④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。 ⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。 文件 NIO 实例① 为要读取的文件创建 FileInputStream，之后通过 FileInputStream 获取输入 FileChannel； 12FileInputStream fin = new FileInputStream("readandshow.txt");FileChannel fic = fin.getChannel(); ② 创建一个容量为 1024 的 Buffer； 1ByteBuffer buffer = ByteBuffer.allocate(1024); ③ 将数据从输入 FileChannel 写入到 Buffer 中，如果没有数据的话，read() 方法会返回 -1； 1234int r = fcin.read(buffer);if (r == -1) &#123; break;&#125; ④ 为要写入的文件创建 FileOutputStream，之后通过 FileOutputStream 获取输出 FileChannel 12FileOutputStream fout = new FileOutputStream("writesomebytes.txt");FileChannel foc = fout.getChannel(); ⑤ 调用 flip() 切换读写 1buffer.flip(); ⑥ 把 Buffer 中的数据读取到输出 FileChannel 中 1foc.write(buffer); ⑦ 最后调用 clear() 重置缓冲区 1buffer.clear(); 套接字 NIO 实例1. ServerSocketChannel每一个监听端口都需要有一个 ServerSocketChannel 用来监听连接。 123456ServerSocketChannel ssc = ServerSocketChannel.open();ssc.configureBlocking(false); // 设置为非阻塞ServerSocket ss = ssc.socket();InetSocketAddress address = new InetSocketAddress(ports[i]);ss.bind(address); // 绑定端口号 2. Selectors异步 I/O 通过 Selector 注册对特定 I/O 事件的兴趣 ― 可读的数据的到达、新的套接字连接等等，在发生这样的事件时，系统将会发送通知。 创建 Selectors 之后，就可以对不同的通道对象调用 register() 方法。register() 的第一个参数总是这个 Selector。第二个参数是 OP_ACCEPT，这里它指定我们想要监听 ACCEPT 事件，也就是在新的连接建立时所发生的事件。 SelectionKey 代表这个通道在此 Selector 上的这个注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。 12Selector selector = Selector.open();SelectionKey key = ssc.register(selector, SelectionKey.OP_ACCEPT); 3. 主循环首先，我们调用 Selector 的 select() 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时，select() 方法将返回所发生的事件的数量。 接下来，我们调用 Selector 的 selectedKeys() 方法，它返回发生了事件的 SelectionKey 对象的一个集合。 我们通过迭代 SelectionKeys 并依次处理每个 SelectionKey 来处理事件。对于每一个 SelectionKey，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。 123456789int num = selector.select();Set selectedKeys = selector.selectedKeys();Iterator it = selectedKeys.iterator();while (it.hasNext()) &#123; SelectionKey key = (SelectionKey)it.next(); // ... deal with I/O event ...&#125; 4. 监听新连接程序执行到这里，我们仅注册了 ServerSocketChannel，并且仅注册它们“接收”事件。为确认这一点，我们对 SelectionKey 调用 readyOps() 方法，并检查发生了什么类型的事件： 12345if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123; // Accept the new connection // ...&#125; 可以肯定地说，readOps() 方法告诉我们该事件是新的连接。 5. 接受新的连接因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 accept() 操作会阻塞： 12ServerSocketChannel ssc = (ServerSocketChannel)key.channel();SocketChannel sc = ssc.accept(); 下一步是将新连接的 SocketChannel 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 SocketChannel 注册到 Selector 上，如下所示： 12sc.configureBlocking(false);SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ); 注意我们使用 register() 的 OP_READ 参数，将 SocketChannel 注册用于读取而不是接受新连接。 6. 删除处理过的 SelectionKey在处理 SelectionKey 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的 remove() 方法来删除处理过的 SelectionKey： 1it.remove(); 现在我们可以返回主循环并接受从一个套接字中传入的数据 (或者一个传入的 I/O 事件) 了。 7. 传入的 I/O当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 Selector.select()，并返回一个或者多个 I/O 事件。这一次， SelectionKey 将被标记为 OP_READ 事件，如下所示： 123456&#125; else if ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123; // Read the data SocketChannel sc = (SocketChannel)key.channel(); // ...&#125; 内存映射文件内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。 只有文件中实际读取或者写入的部分才会映射到内存中。 现代操作系统一般会根据需要将文件的部分映射为内存的部分，从而实现文件系统。Java 内存映射机制只不过是在底层操作系统中可以采用这种机制时，提供了对该机制的访问。 向内存映射文件写入可能是危险的，仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。 下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，您可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。 1MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024); 对比NIO 与普通 I/O 的区别主要有以下两点： NIO 是非阻塞的。应当注意，FileChannel 不能切换到非阻塞模式，套接字 Channel 可以。 NIO 面向块，I/O 面向流。 八、参考资料 Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002. IBM: NIO 入门 深入分析 Java I/O 的工作机制 NIO 与传统 IO 的区别 Decorator Design Pattern Socket Multicast]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机学习]]></title>
    <url>%2F2018%2F04%2F05%2F1_Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[一、运行时数据区域 程序计数器 虚拟机栈 本地方法栈 堆 方法区 运行时常量池 直接内存 二、垃圾收集 判断一个对象是否可回收 垃圾收集算法 垃圾收集器 内存分配与回收策略 Full GC 的触发条件 三、类加载机制 类的生命周期 类初始化时机 类加载过程 类加载器 四、JVM 参数 GC 优化配置 GC 类型设置 参考资料 一、运行时数据区域 程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 虚拟机栈每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小： 1java -Xss=512M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 本地方法栈本地方法不是用 Java 实现，对待这些方法需要特别处理。 与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 堆所有对象实例都在这里分配内存。 是垃圾收集的主要区域（”GC 堆”），现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把 Java 堆分成以下三块： 新生代（Young Generation） 老年代（Old Generation） 永久代（Permanent Generation） 当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间： Eden From Survivor To Survivor Java 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 1java -Xms=1M -Xmx=2M HackTheJava 方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。JDK1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收，JDK8 之后，取消了永久代，用 metaspace（元数据）区替代。 运行时常量池运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。 直接内存在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 二、垃圾收集程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。 判断一个对象是否可回收1. 引用计数给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 12objA.instance = objB;objB.instance = objA; 2. 可达性通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是可用的，不可达的对象可被回收。 GC Roots 一般包含以下内容： 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中引用的对象 3. 引用类型无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与引用有关。 Java 对引用的概念进行了扩充，引入四种强度不同的引用类型。 （一）强引用 只要强引用存在，垃圾回收器永远不会回收被引用的对象。 使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); （二）软引用 用来描述一些还有用但是并非必需的对象。 在系统将要发生内存溢出异常之前，会将这些对象列进回收范围之中进行第二次回收。 软引用主要用来实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源获取数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源获取这些数据。 使用 SoftReference 类来实现软引用。 12Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj); （三）弱引用 只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会被回收。 使用 WeakReference 类来实现弱引用。 12Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj); （四）虚引用 又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 使用 PhantomReference 来实现虚引用。 12Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj); 4. 方法区的回收因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGo 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 5. finalize()finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。 垃圾收集算法1. 标记 - 清除 将需要回收的对象进行标记，然后清除。 不足： 标记和清除过程效率都不高； 会产生大量碎片，内存碎片过多可能导致无法给大对象分配内存。 2. 标记 - 整理 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 3. 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和 使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间。 4. 分代收集现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将 Java 堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清理 或者 标记 - 整理 算法 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用.。 1. Serial 收集器 它是单线程的收集器，不仅意味着只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停所有其他工作线程，往往造成过长的等待时间。 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 在 Client 应用场景中，分配给虚拟机管理的内存一般来说不会很大，该收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 2. ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。 3. Parallel Scavenge 收集器是并行的多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。自适应调节策略也是它与 ParNew 收集器的一个重要区别。 4. Serial Old 收集器 Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5. Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS 收集器 CMS（Concurrent Mark Sweep），从 Mark Sweep 可以知道它是基于标记 - 清除算法实现的。 特点：并发收集、低停顿。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 对 CPU 资源敏感。CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4，当 CPU 不足 4 个时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。并且低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率变低。 无法处理浮动垃圾。由于并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留到下一次 GC 时再清理掉，这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此它不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。可以使用 -XX:CMSInitiatingOccupancyFraction 的值来改变触发收集器工作的内存占用百分比，JDK 1.5 默认设置下该值为 68，也就是当老年代使用了 68% 的空间之后会触发收集器工作。如果该值设置的太高，导致浮动垃圾无法保存，那么就会出现 Concurrent Mode Failure，此时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集。 标记 - 清除算法导致的空间碎片，给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 7. G1 收集器 G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。 具备如下特点： 并行与并发：能充分利用多 CPU 环境下的硬件优势，使用多个 CPU 来缩短停顿时间。 分代收集：分代概念依然得以保留，虽然它不需要其它收集器配合就能独立管理整个 GC 堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次 GC 的旧对象来获取更好的收集效果。 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：这是它相对 CMS 的一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。 在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老生代，而 G1 不再是这样，Java 堆的内存布局与其他收集器有很大区别，将整个 Java 堆划分为多个大小相等的独立区域（Region）。虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分 Region（不需要连续）的集合。 之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。它跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了它在有限的时间内可以获取尽可能高的收集效率。 Region 不可能是孤立的，一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个 Java 堆才能保证准确性，这显然是对 GC 效率的极大伤害。为了避免全堆扫描的发生，每个 Region 都维护了一个与之对应的 Remembered Set。虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中，如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 8. 七种垃圾收集器的比较 收集器 串行、并行 or 并发 新生代 / 老年代 算法 目标 适用场景 Serial 串行 新生代 复制算法 响应速度优先 单 CPU 环境下的 Client 模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单 CPU 环境下的 Client 模式、CMS 的后备预案 ParNew 并行 新生代 复制算法 响应速度优先 多 CPU 环境时在 Server 模式下与 CMS 配合 Parallel Scavenge 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 并行 老年代 标记-整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并发 老年代 标记-清除 响应速度优先 集中在互联网站或 B/S 系统服务端上的 Java 应用 G1 并发 both 标记-整理 + 复制算法 响应速度优先 面向服务端应用，将来替换 CMS 内存分配与回收策略对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。 1. 优先在 Eden 分配大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 关于 Minor GC 和 Full GC： Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。 2. 大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 提供 -XX:PretenureSizeThreshold 参数，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 3. 长期存活的对象进入老年代JVM 为对象定义年龄计数器，经过 Minor GC 依然存活，并且能被 Survivor 区容纳的，移被移到 Survivor 区，年龄就增加 1 岁，增加到一定年龄则移动到老年代中（默认 15 岁，通过 -XX:MaxTenuringThreshold 设置）。 4. 动态对象年龄判定JVM 并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等待 MaxTenuringThreshold 中要求的年龄。 5. 空间分配担保在发生 Minor GC 之前，JVM 先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话 JVM 会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 Full GC 的触发条件对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 1. 调用 System.gc()此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc()。 2. 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。 3. 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。 4. JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 5. Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 三、类加载机制类是在运行期间动态加载的。 类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 类初始化时机虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随着发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。 1. 加载加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。 从网络中获取，这种场景最典型的应用是 Applet。 运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。 从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。… 2. 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 主要有以下 4 个阶段： （一）文件格式验证 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。 （二）元数据验证 对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。 （三）字节码验证 通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。 （四）符号引用验证 发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。 3. 准备类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。 1public static final int value = 123; 4. 解析将常量池的符号引用替换为直接引用的过程。 5. 初始化初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 &lt;clinit&gt;() 方法具有以下特点： 是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 与类的构造函数（或者说实例构造器 &lt;init&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 &lt;clinit&gt;() 方法运行之前，父类的 &lt;clinit&gt;() 方法已经执行结束。因此虚拟机中第一个执行 &lt;clinit&gt;() 方法的类肯定为 java.lang.Object。 由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码： 1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); // 输出结果是父类中的静态变量 A 的值 ，也就是 2。&#125; &lt;clinit&gt;() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 &lt;clinit&gt;() 方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。 虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。 类加载器虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流 ( 即字节码 )”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 1. 类与类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗而言：比较两个类是否“相等”（这里所指的“相等”，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况），只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 2. 类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分； 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 3. 双亲委派模型应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 （一）工作过程 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是把这个请求委派给父类加载器，每一个层次的加载器都是如此，依次递归。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成此加载请求（它搜索范围中没有找到所需类）时，子加载器才会尝试自己加载。 （二）好处 使用双亲委派模型来组织类加载器之间的关系，使得 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型，由各个类加载器自行加载的话，如果用户编写了一个称为java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将变得一片混乱。如果开发者尝试编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但是永远无法被加载运行。 （三）实现 1234567891011121314151617181920212223protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // 先检查请求的类是否已经被加载过了 Class c = findLoadedClass(name); if(c == null) &#123; try&#123; if(parent != null) &#123; c = parent.loadClass(name, false); &#125; else&#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch(ClassNotFoundException e) &#123; // 如果父类加载器抛出 ClassNotFoundException，说明父类加载器无法完成加载请求 &#125; if(c == null) &#123; // 如果父类加载器无法完成加载请求，再调用自身的 findClass() 来进行加载 c = findClass(name); &#125; &#125; if(resolve) &#123; resolveClass(c); &#125; return c;&#125; 四、JVM 参数GC 优化配置 配置 描述 -Xms 初始化堆内存大小 -Xmx 堆内存最大值 -Xmn 新生代大小 -XX:PermSize 初始化永久代大小 -XX:MaxPermSize 永久代最大容量 GC 类型设置 配置 描述 -XX:+UseSerialGC 串行垃圾回收器 -XX:+UseParallelGC 并行垃圾回收器 -XX:+UseConcMarkSweepGC 并发标记扫描垃圾回收器 -XX:ParallelCMSThreads= 并发标记扫描垃圾回收器 = 为使用的线程数量 -XX:+UseG1GC G1 垃圾回收器 1java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar 参考资料 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011. Jvm memory Memory Architecture Of JVM(Runtime Data Areas) JVM Run-Time Data Areas Android on x86: Java Native Interface and the Android Native Development Kit 深入理解 JVM(2)——GC 算法与内存分配策略 深入理解 JVM(3)——7 种垃圾收集器 JVM Internals]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式补充-23种设计模式]]></title>
    <url>%2F2018%2F04%2F01%2F1_Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[设计模式补充-23种设计模式设计模式补充​ 这一个知识总结是对前面设计模式总结没有介绍的设计模式进行一个补充介绍。主要参考第四章模式系统里面的归纳，补充的设计模式主要来自于GOF的《设计模式》。 设计模式概括设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。 什么是设计模式？​ 那么,什么是设计模式呢? ​ 从广义角度讲设计模式是可解决一类软件问题并能重复使用的设计方案; ​ 从狭义角度讲设计模式是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述,是在类和对象的层次描述的可重复使用的软件设计问题的解决方案. ​ 模式体现的是程序整体的构思,也会出现在分析或者是概要设计阶段,包括创建型模式、结构型模式和行为型模式. ​ ==模式的核心思想是通过增加抽象层,把变化部分从那些不变部分里分离出来.== ​ 模式的四大基本要素包括： ​ 1.模式名称（Pattern Name） ​ 2.问题（Problem）：描述应该在何时使用模式,解释了设计问题和问题存在的前因后果,可能还描述模式必须满足的先决条件 ​ 3.解决方案（Solution）：描述了设计的组成成分、相互关系及各自的职责和协作方式.模式就像一个模板,可应用于多种场合,所以解决方案并不描述一个具体的设计或实现,而是提供设计问题的抽象描述和解决问题所采用的元素组合（类和对象）. ​ 4.效果（Consequences）：描述模式的应用效果及使用模式应权衡的问题. 设计模式的SOLID原则 **S.O.L.I.D **是面向对象设计(OOD)和面向对象编程(OOP)中的几个重要编码原则(Programming Priciple)的首字母缩写。 前辈们总结出来的，遵循五大原则可以使程序解决紧耦合，更加健壮。 ​ 面向对象设计的原则| 简称 | 全称 | 解释 || —- | ———————————– | ———— || SRP | The Single Responsibility Principle | 单一职责原则 || OCP | The Open Closed Principle | 开放封闭原则 || LSP | The Liskov Substitution Principle | 里氏替换原则 || ISP | The Interface Segregation Principle | 接口分离原则 || DIP | The Dependency Inversion Principle | 依赖倒置原则 | 一、单一职责原则（SRP） 定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。 遵循单一职责原的优点有： 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 ​ 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。 实际例子 ​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能抑制或者削弱这个类完成其他职责的能力。例如餐厅服务员负责把订单给厨师去做，而不是服务员又要订单又要炒菜。 二、开闭原则（OCP） 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。 解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 实际例子 ​ 对扩展开放，对修改关闭。意为一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。例如一开始做了普通计算器程序，突然添加新需求，要再做一个程序员计算器，这时不应该修改普通计算器内部，应该使用面向接口编程，组合实现扩展。 三、里氏替换原则（LSP） 定义：所有引用基类的地方必须能透明地使用其子类的对象。 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。 解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 实际例子 ​ 所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。例如机动车必须有轮胎和发动机，子类宝马和奔驰不应该改写没轮胎或者没发动机。 四、接口隔离原则（ISP） 定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 ​ 很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 ​ 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 实际例子 ​ 类不应该依赖不需要的接口，知道越少越好。例如电话接口只约束接电话和挂电话，不需要让依赖者知道还有通讯录。 五、依赖倒置原则（DIP） 定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。 ​ 传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。 ​ 在实际编程中，我们一般需要做到如下3点：​ 1. 低层模块尽量都要有抽象类或接口，或者两者都有。​ 2. 变量的声明类型尽量是抽象类或接口。​ 3. 使用继承时遵循里氏替换原则。 ​ 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。 实际例子 ​ 指的是高级模块不应该依赖低级模块，而是依赖抽象。抽象不能依赖细节，细节要依赖抽象。比如类A内有类B对象，称为类A依赖类B，但是不应该这样做，而是选择类A去依赖抽象。例如垃圾收集器不管垃圾是什么类型，要是垃圾就行。 附、迪米特法则（最少知道原则）（Demeter Principle） 定义：一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 解决方案：尽量降低类与类之间的耦合。 总结 ​ 单一职责原则告诉我们实现类要职责单一； ​ 里氏替换原则告诉我们不要破坏继承体系； ​ 依赖倒置原则告诉我们要面向接口编程； ​ 接口隔离原则告诉我们在设计接口的时候要精简单一； ​ 开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 ​ 迪米特法则告诉我们要降低耦合。 参考资料：设计模式之SOLID原则再回首 ​ 设计模式原则SOLID ​ 设计模式之SOLID原则 Interpreter(解释器)模式实际的例子 ​ 在执行加减乘除四则运算，或者执行正则表达式的时候，都是将表示的文本内容进行解释，然后再进行执行的。 定义 ​ Interpreter(解释器)模式是一种特殊的设计模式，它建立一个解释器（Interpreter），对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。解释器模式属于行为模式，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 组成结构 ​ Interpreter 模式UML结构图如图1所示： ​ 一个解释器模式中包含的四种角色 抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器和非终结符解释器完成。 终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 自己的理解：终结符就是不可以再拆分、单一的符号，也就是语言的基本元素。 非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。 自己的理解：非终结符，就是具有逻辑功能的、并不是表示数值的符号，实际上非终结符定义的是语言的规则。 环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。 ​ 例子 ​ 我们需要一个能够解释加法和减法的解释器，那么最好的方式就是用解释器模式来实现。 ​ 先来看看抽象表达式123456789101112131415161718public abstract class Expression &#123; /** * 以环境为准，本方法解释给定的任何一个表达式 */ public abstract int interpret(Context ctx); /** * 检验两个表达式在结构上是否相同 */ public abstract boolean equals(Object obj); /** * 返回表达式的hash code */ public abstract int hashCode(); /** * 将表达式转换成字符串 */ public abstract String toString();&#125; ​ 因为需要解释加法和减法，因此实现类也有Plus和Minus两个非终结符表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Plus extends Expression &#123; private Expression left,right; public Plus(Expression left , Expression right)&#123; this.left = left; this.right = right; &#125; @Override public boolean equals(Object obj) &#123; if(obj != null &amp;&amp; obj instanceof Plus) &#123; return left.equals(((Plus)obj).left) &amp;&amp; right.equals(((Plus)obj).right); &#125; return false; &#125; @Override public int hashCode() &#123; return this.toString().hashCode(); &#125; @Override public int interpret(Context ctx) &#123; return left.interpret(ctx) + right.interpret(ctx); &#125; @Override public String toString() &#123; return "(" + left.toString() + " + " + right.toString() + ")"; &#125;&#125;public class Minus extends Expression &#123; private Expression left, right; public Minus(Expression left, Expression right) &#123; this.left = left; this.right = right; &#125; @Override public boolean equals(Object obj) &#123; if (obj != null &amp;&amp; obj instanceof Minus) &#123; return left.equals(((Minus) obj).left) &amp;&amp; right.equals(((Minus) obj).right); &#125; return false; &#125; @Override public int hashCode() &#123; return this.toString().hashCode(); &#125; @Override public int interpret(Context ctx) &#123; return left.interpret(ctx) - right.interpret(ctx); &#125; @Override public String toString() &#123; return "(" + left.toString() + " - " + right.toString() + ")"; &#125;&#125; ​ 除此之外我们还需要变量与常量两个终结符表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Constant extends Expression&#123; private int value; public Constant(int value)&#123; this.value = value; &#125; @Override public boolean equals(Object obj) &#123; if(obj != null &amp;&amp; obj instanceof Constant)&#123; return this.value == ((Constant)obj).value; &#125; return false; &#125; @Override public int hashCode() &#123; return this.toString().hashCode(); &#125; @Override public int interpret(Context ctx) &#123; return value; &#125; @Override public String toString() &#123; return new Integer(value).toString(); &#125;&#125;public class Variable extends Expression &#123; private String name; public Variable(String name)&#123; this.name = name; &#125; @Override public boolean equals(Object obj) &#123; if(obj != null &amp;&amp; obj instanceof Variable) &#123; return this.name.equals( ((Variable)obj).name); &#125; return false; &#125; @Override public int hashCode() &#123; return this.toString().hashCode(); &#125; @Override public String toString() &#123; return name; &#125; @Override public int interpret(Context ctx) &#123; return ctx.lookup(this); &#125;&#125; ​ 环境角色基本可以存放文法中各个终结符所对应的具体值，下面的类就是用一个map来负责12345678910111213141516public class Context &#123; private Map&lt;Variable,Integer&gt; map = new HashMap&lt;Variable,Integer&gt;(); public void assign(Variable var , int value)&#123; map.put(var, new Integer(value)); &#125; public int lookup(Variable var) throws IllegalArgumentException&#123; Integer value = map.get(var); if(value == null)&#123; throw new IllegalArgumentException(); &#125; return value.intValue(); &#125;&#125; ​ Client客户端的代码123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Context ctx = new Context(); Variable x = new Variable("x"); Variable y = new Variable("y"); Constant c = new Constant(1); ctx.assign(x, 2); ctx.assign(y, 3); Expression exp = new Plus(new Plus(c,x) , new Minus(y,x)); System.out.println(exp.toString() + "=" + exp.interpret(ctx)); &#125;&#125; ​ 输出结果如下 ((1 + x) + (y - x))=4 优缺点 ​ 解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了。比如我们现在需要修改Plus的含义，那么只需要修改Plus类即可，如果要增加乘法操作，那么也只需要增加一个Multiple类就行。​ 但是，解释器模式会引起类的膨胀，每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来非常多的麻烦。同时，从例子我们也可以看到，整个表达式的运算过程采用了递归调用方法，每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。由于使用了大量的循环和递归，效率是一个不容忽视的问题。特别是用于解释一个解析复杂、冗长的语法时，效率是难以忍受的。 Interpreter 模式适用性： (1).可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 (2). 一些重复出现的问题可以用一种简单的语言来进行表达。 (3).一个语言的文法较为简单。 (4).执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。） Interpreter 模式使用总结： ​ 尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。 总结 ​ 解释器模式，将语言的表示与执行进行了分离。语言的表示会不停的变化，语言的执行也是会发生变化的。不变的是，语言的表示一定要的解释才能够执行。在解释器模式中要注意终结符和非终结符的区分。 参考资料：解释器模式 ​ Interpreter 模式详解–设计模式 简单工厂模式（Simple Factory）定义 ​ 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式（同属于创建型模式的还有工厂方法模式，抽象工厂模式，单例模式，建造者模式）。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式结构 ​ 从上图可以看出，简单工厂模式由三部分组成：具体工厂、具体产品和抽象产品。 工厂类（Creator）角色：担任这个角色的是简单工厂模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。 抽象产品（AbstractProduct）角色：担任这个角色的类是由简单工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现。 具体产品（ConcreteProduct）角色：简单工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。 产品类： 1234567891011121314151617abstract class BMW &#123; public BMW()&#123; &#125; &#125; public class BMW320 extends BMW &#123; public BMW320() &#123; System.out.println("制造--&gt;BMW320"); &#125; &#125; public class BMW523 extends BMW&#123; public BMW523()&#123; System.out.println("制造--&gt;BMW523"); &#125; &#125; ​ 工厂类：1234567891011121314151617public class Factory &#123; public static BMW createBMW(int type) &#123; switch (type) &#123; case 320: return new BMW320(); case 523: return new BMW523(); default: break; &#125; return null; &#125; &#125; ​ 客户类：123456public class Customer &#123; public static void main(String[] args) &#123; BMW bmw320 = Factory.createBMW(320); BMW bmw523 = Factory.createBMW(523); &#125; &#125; 解决的问题 ​ 将对象的使用与创建进行分离。例如，想要一辆奔驰车时，只需要向造车工厂传入奔驰车的型号，然后工厂就可以造出来一辆符合要求的奔驰车了，而不用去关注对象创建过程中的细节。 简单工厂的优点/缺点： ​ 优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。​ 缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则。 适用场景 在以下情况下可以使用简单工厂模式： 1、工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 总结： ​ 客户端要求的具体产品会不断的变化，可能这一次需要车型A，下一次就需要车型B了，而且在工厂中建造不同车型的方法也不一样。但是，一辆车如果需要使用，那么一定要被建造。简单工厂模式就是固定了产品会被工厂创建的这种关系，同时将产品的消费和生产进行了分离。 参考资料: 设计模式（一）简单工厂模式 ​ JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式) 工厂方法模式（Factory Method）定义 ​ 工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类来规定创建对象的公共接口，而子类则负责生成具体的对象。 解决的问题 ​ 上文介绍的简单工厂模式存在一系列问题： 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响； 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 为了解决上述的问题，我们又使用了一种新的设计模式：工厂方法模式。 模式原理 ​ UML类图 ​ 模式的组成 组成（角色） 关系 作用 抽象产品（Product） 具体产品的父类 描述具体产品的公共接口 具体产品（Concrete Product） 抽象产品的子类；工厂类创建的目标类 描述生产的具体产品 抽象工厂（Creator） 具体工厂的父类 描述具体工厂的公共接口 具体工厂（Concrete Creator） 抽象工厂的子类；被外界调用 描述具体工厂；实现FactoryMethod工厂方法创建产品的实例 使用步骤 步骤1： 创建抽象工厂类，定义具体工厂的公共接口；步骤2： 创建抽象产品类 ，定义具体产品的公共接口；步骤3： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 实际例子 实例概况 背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；解决方案：小成决定置办塑料分厂B来生产B类产品； 即工厂方法模式 使用步骤 步骤1： 创建抽象工厂类，定义具体工厂的公共接口123abstract class Factory&#123; public abstract Product Manufacture();&#125; 步骤2： 创建抽象产品类 ，定义具体产品的公共接口；123abstract class Product&#123; public abstract void Show();&#125; 步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；12345678910111213141516//具体产品A类class ProductA extends Product&#123; @Override public void Show() &#123; System.out.println("生产出了产品A"); &#125;&#125;//具体产品B类class ProductB extends Product&#123; @Override public void Show() &#123; System.out.println("生产出了产品B"); &#125;&#125; 步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；123456789101112131415//工厂A类 - 生产A类产品class FactoryA extends Factory&#123; @Override public Product Manufacture() &#123; return new ProductA(); &#125;&#125;//工厂B类 - 生产B类产品class FactoryB extends Factory&#123; @Override public Product Manufacture() &#123; return new ProductB(); &#125;&#125; 步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例123456789101112//生产工作流程public class FactoryPattern &#123; public static void main(String[] args)&#123; //客户要产品A FactoryA mFactoryA = new FactoryA(); mFactoryA.Manufacture().Show(); //客户要产品B FactoryB mFactoryB = new FactoryB(); mFactoryB.Manufacture().Show(); &#125;&#125; 结果：12生产出了产品A生产出了产品C 优点 更符合开-闭原则新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可 简单工厂模式需要修改工厂类的判断逻辑 符合单一职责原则每个具体工厂类只负责创建对应的产品 简单工厂中的工厂类存在复杂的switch逻辑判断 不使用静态工厂方法，可以形成基于继承的等级结构。 简单工厂模式的工厂类使用静态工厂方法 总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。 缺点 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销； 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类； 一个具体工厂只能创建一种具体产品 应用场景 在了解了优缺点后，我总结了工厂方法模式的应用场景： 当一个类不知道它所需要的对象的类时在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可； 当一个类希望通过其子类来指定创建对象时在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 答疑解惑 使用工厂方法模式，看上去会感觉到这不是更麻烦了吗，直接在外界创建具体的抽象子类不行吗？还用这么麻烦的创建工厂子类，然后再用工厂子类去创建抽象子类。 我将从两方面回答这个问题： 假设现在项目比较大，在外界很多地方都直接使用了抽象子类直接进行运算，这种方式在写代码的时候确实很快也很爽。但是，假设有一天，产品经理过来说要改需求，我现在不要加减乘除这四种运算了，我要换成更高级的其他运算。。。如果这样改起来改动就大了，需要把所有直接使用抽象子类实例化的地方都做修改。 这只是一种设计模式的思路，在程序的开发中没有一种设计模式是万能的，在适合的地方用适合的设计模式，或根据业务需求自己制定一套模式，这才是最好的。只有最适合业务的模式，才是最好的模式。 总结 ​ 工厂方法模式是对简单工厂模式的改进，使得模式对修改关闭，对扩展开放。在工厂方法模式中，变化的是：随着具体产品的不同，那么对应的具体工厂也就不同。不变的是：产品与工厂的关系没有发生改变，产品还是要从工厂生产。这个模式依然可以使得对象的使用与创建分离。不过，相对于简单工厂模式，工厂方法模式更加往上抽象了一层。 参考资料: JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式) ​ 工厂方法模式（Factory Method）-最易懂的设计模式解析 ​ 工厂模式三部曲－工厂方法模式 抽象工厂模式（Abstract Factory）例子背景 ​ 着客户的要求越来越高，宝马车需要不同配置的空调和发动机等配件。于是这个工厂开始生产空调和发动机，用来组装汽车。这时候工厂有两个系列的产品:空调和发动机。宝马320系列配置A型号空调和A型号发动机，宝马230系列配置B型号空调和B型号发动机。 问题 ​ 抽象工厂模式是工厂方法模式的升级版本，他用来创建==一组相关或者相互依赖的对象==。比如宝马320系列使用空调型号A和发动机型号A，而宝马230系列使用空调型号B和发动机型号B，那么使用抽象工厂模式，在为320系列生产相关配件时，就无需制定配件的型号，它会自动根据车型生产对应的配件型号A。 抽象工厂（Abstract Factory）模式结构 抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品具体类型的情况下，创建多个产品族中的产品对象。这就是抽象工厂模式的用意。 ​ 每个模式都是针对一定问题的解决方案。抽象工厂模式面对的问题是多产品等级结构的系统设计。​ 在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。​ 产品族：是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的CPU和ADM芯片的主板，组成一个家族。Intel的CPU和Intel芯片的主板，又组成一个家族。而这两个家族都来自于两个产品等级：CPU，主板。一个等级结构是由相同的结构的产品组成，示意图如下： 理解这个产品结构是理解抽象工厂模式的关键所在，所以我不惜花费时间来画此图。如果领悟不到此图的含义，就无法区分工厂方法模式和抽象工厂模式的区别。 ​ 从上图可以看出，抽象工厂模式的每个工厂创造出来的都是一族产品，而不是一个或者一组。组是可以随意组合的！其实两个就这点点差别，呵呵，估计现在你已经差不多明白了抽象工厂模式的含义。 ​ 抽象工厂模式中各个组件之间的结构如下图所示： ​ 抽象工厂模式代码 ​ 产品类：1234567891011121314151617181920212223242526272829//发动机以及型号 public interface Engine &#123; &#125; public class EngineA extends Engine&#123; public EngineA()&#123; System.out.println("制造--&gt;EngineA"); &#125; &#125; public class EngineBextends Engine&#123; public EngineB()&#123; System.out.println("制造--&gt;EngineB"); &#125; &#125; //空调以及型号 public interface Aircondition &#123; &#125; public class AirconditionA extends Aircondition&#123; public AirconditionA()&#123; System.out.println("制造--&gt;AirconditionA"); &#125; &#125; public class AirconditionB extends Aircondition&#123; public AirconditionB()&#123; System.out.println("制造--&gt;AirconditionB"); &#125; &#125; ​ 创建工厂类：123456789101112131415161718192021222324252627282930313233343536//创建工厂的接口 public interface AbstractFactory &#123; //制造发动机 public Engine createEngine(); //制造空调 public Aircondition createAircondition(); &#125; //为宝马320系列生产配件 public class FactoryBMW320 implements AbstractFactory&#123; @Override public Engine createEngine() &#123; return new EngineA(); &#125; @Override public Aircondition createAircondition() &#123; return new AirconditionA(); &#125; &#125; //宝马523系列public class FactoryBMW523 implements AbstractFactory &#123; @Override public Engine createEngine() &#123; return new EngineB(); &#125; @Override public Aircondition createAircondition() &#123; return new AirconditionB(); &#125; &#125; ​ 客户:1234567891011121314public class Customer &#123; public static void main(String[] args)&#123; //生产宝马320系列配件 FactoryBMW320 factoryBMW320 = new FactoryBMW320(); factoryBMW320.createEngine(); factoryBMW320.createAircondition(); //生产宝马523系列配件 FactoryBMW523 factoryBMW523 = new FactoryBMW523(); factoryBMW320.createEngine(); factoryBMW320.createAircondition(); &#125; &#125; 抽象工厂模式的起源 ​ 下面引用一段抽象工厂模式的起源： ​ 抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。 ​ 在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。 ​ 可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。 ​ 系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图： ​ 显然，一个系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行。所以，系统实际上只能消费属于同一个产品族的产品。 ​ 在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了。 总结 ​ 抽象工厂模式，使得一个工厂可以创建一组相关或联系的对象，功能更加的强大。如果采用工厂方法模式，创建一组相关或联系的对象，会产生很多的工厂对象。说白了，抽象工厂模式也是一个工厂模式。 ​ 无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 ​ 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。 参考资料： JAVA设计模式之抽象工厂模式 ​ Java设计模式圣经连载（03）－抽象工厂模式 ​ 《设计模式》 单例模式问题 ​ 许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在计算机中只有一个打印机，那么管理打印机的程序就应该只有一个，否则会出现多个文件被同时打印的情况。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 概念 ​ 单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。 ​ j单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下特点： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。 基本的实现思路 ​ 单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。 ​ 单例的实现主要是通过以下两个步骤： 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例； 在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。 注意事项 ​ 单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建 方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。 一、懒汉式单例123456789101112//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton single=null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; ​ Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。 ​ 事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。 ​ 但是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全。 1、在getInstance方法上加同步123456789101112//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton single=null; //静态工厂方法 public static synchronized Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 2、双重检查锁定1234567891011121314151617//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123;&#125; private static volatile Singleton single=null;//注意有volatile关键字 //静态工厂方法 public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; ​ 注意，使用双重检查锁定这种方式的时候，为了达到真正的线程安全，还需要在声明私有变量singleton 使用关键字volatile。然synchronized已经起到了多线程下原子性、有序性、可见性的作用，为什么还要加volatile呢，原因可参考http://www.iteye.com/topic/652440和http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html。 3、静态内部类(==zhg: 使用这种==) 12345678910public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125; &#125; ​ 这种比上面1、2都好一些，既实现了线程安全，又避免了同步带来的性能影响。 二、饿汉式单例12345678910//饿汉式单例类.在类初始化时，已经自行实例化 public class Singleton1 &#123; private Singleton1() &#123;&#125; private static final Singleton1 single = new Singleton1(); //静态工厂方法 public static Singleton1 getInstance() &#123; return single; &#125;&#125; ​ 饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。 ​ 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。 ​ 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 三、登记式单例(可忽略)1234567891011121314151617181920212223242526272829303132333435363738//类似Spring里面的方法，将类名注册，下次从里面直接获取。public class Singleton3 &#123; private static Map&lt;String,Singleton3&gt; map = new HashMap&lt;String,Singleton3&gt;(); static&#123; Singleton3 single = new Singleton3(); map.put(single.getClass().getName(), single); &#125; //保护的默认构造子 protected Singleton3()&#123;&#125; //静态工厂方法,返还此类惟一的实例 public static Singleton3 getInstance(String name) &#123; if(name == null) &#123; name = Singleton3.class.getName(); System.out.println("name == null"+"---&gt;name="+name); &#125; if(map.get(name) == null) &#123; try &#123; map.put(name, (Singleton3) Class.forName(name).newInstance()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; return map.get(name); &#125; //一个示意性的商业方法 public String about() &#123; return "Hello, I am RegSingleton."; &#125; public static void main(String[] args) &#123; Singleton3 single3 = Singleton3.getInstance(null); System.out.println(single3.about()); &#125;&#125; 登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。 ​ 这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。 四、枚举方式单例 123456public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; ​ 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。 饿汉式和懒汉式区别 ​ 从名字上来说，饿汉和懒汉， ​ 饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。 ​ 另外从以下两点再区分以下这两种方式： ​ 1、线程安全： ​ 饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题， ​ 懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。 ​ 2、资源加载和性能： ​ 饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成， ​ 而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。 ​ 至于1、2、3这三种实现又有些区别， ​ 第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的， ​ 第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗 ​ 第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。 什么是线程安全？ ​ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 ​ 或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。 总结 ​ 由结果可以得知单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。 对于单例模式的几种实现方式，知道饿汉式和懒汉式的区别，线程安全，资源加载的时机，还有懒汉式为了实现线程安全的3种方式的细微差别。 参考资料：JAVA设计模式之单例模式 ​ 单例模式的八种写法比较 建造者(builder)模式定义 ​ 在阎宏博士的《JAVA与模式》一书中开头是这样描述建造（Builder）模式的： 建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 ​ 产品的内部表象： ​ 一个产品常有不同的组成成分作为产品的零件，这些零件有可能是对象，也有可能不是对象，它们通常又叫做产品的内部表象（internal representation）。不同的产品可以有不同的内部表象，也就是不同的零件。使用建造模式可以使客户端不需要知道所生成的产品有哪些零件，每个产品的对应零件彼此有何不同，是怎么建造出来的，以及怎么组成产品。 实际的例子 ​ 有些情况下，一个对象会有一些重要的性质，在它们没有恰当的值之前，对象不能作为一个完整的产品使用。比如，一个电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，而在最起码的收件人地址得到赋值之前，这个电子邮件不能发送。 ​ 在进入肯德基点一个套餐时，每一个套餐的基本东西都是鸡翅、汉堡、可乐等，只不过不同的套餐中这些东西的组成不同，分量也不同。我们不用知道他们的具体组成方式，只用了解套餐就可以了。 建造模式的结构 ​ 在这个示意性的系统中，最终的产品Product只有两个部件，即part1和part2。相应的建造方法也有两个：buildPart1()和buildPart2()。同时可以看到该模式涉及到四个角色，它们分别是： Builder：抽象Builder类，规范产品的组建，一般是由子类实现。 ConcreteBulider: 抽象Builder类的实现类，实现抽象Builder类定义的所有方法，并且返回一个组建好的对象 Dirextor: 指挥者类，用于统一组装流程 Product: 产品类 ​ 建造模式利用一个导演者对象和具体建造者对象一个个地建造出所有的零件，从而建造出完整的产品对象。建造者模式将产品的结构和产品的零件的建造过程对客户端隐藏起来。 源代码 产品类Product12345678910111213141516171819202122public class Product &#123; /** * 定义一些关于产品的操作 */ private String part1; private String part2; public String getPart1()&#123; return part1; &#125; public void setPart1(String part1) &#123; this.part1 = part1; &#125; public String getPart2() &#123; return part2; &#125; public void setPart2(String part2) &#123; this.part2 = part2; &#125; &#125; 抽象建造者类Builder 12345public interface Builder &#123; public void buildPart1(); public void buildPart2(); public Product retrieveResult();&#125; 具体建造者类ConcreteBuilder12345678910111213141516171819202122232425262728public class ConcreteBuilder implements Builder &#123; private Product product = new Product(); /** * 产品零件建造方法1 */ @Override public void buildPart1() &#123; //构建产品的第一个零件 product.setPart1("编号：9527"); &#125; /** * 产品零件建造方法2 */ @Override public void buildPart2() &#123; //构建产品的第二个零件 product.setPart2("名称：XXX"); &#125; /** * 产品返还方法 */ @Override public Product retrieveResult() &#123; return product; &#125;&#125; 导演者类Director123456789101112131415161718192021public class Director &#123; /** * 持有当前需要使用的建造器对象 */ private Builder builder; /** * 构造方法，传入建造器对象 * @param builder 建造器对象 */ public Director(Builder builder)&#123; this.builder = builder; &#125; /** * 产品构造方法，负责调用各个零件建造方法 */ public void construct()&#123; builder.buildPart1(); builder.buildPart2(); &#125;&#125; 客户端类Client1234567891011public class Client &#123; public static void main(String[]args)&#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.retrieveResult(); System.out.println(product.getPart1()); System.out.println(product.getPart2()); &#125;&#125; 时序图 ​ 客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。 优缺点 ​ 优点： 使用建造者模式可以使客户端不必知道产品内部组成的细节。 具体的建造者类之间是相互独立的，容易扩展。 由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。 ​ 缺点： 产生多余的Build对象以及Dirextor类。 总结 ​ 在一个复杂对象的创建过程中，复杂对象的每一个部分可能会经常性的变化，但是将复杂对象各个部分组装到一起的算法比较稳定，这个时候就可以将具体每个部分的建造放在较低层次，组装流程放在较高层次。使得具体部分的建造改变不会影响整个复杂对象的创建。 ​ 建造模式在将复杂对象的装配过程封装在Dirctor中，并且客户端不用关注复杂对象建造的具体细节。 参考资料： 设计模式（三）建造者模式 ​ 《JAVA与模式》之建造模式 原型(Prototype)模式定义 ​ 原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。所谓原型模式，就是java中的克隆技术，以某个对象为原型。复制出新的对象。显然新的对象具备原型对象的特点。效率高（避免了重新执行构造过程步骤） ​ 克隆类似于new，但和new不同。new创建新的对象属性采用的是默认值。克隆出来的对象的属性值完全和原型对象相同。并且克隆出的新对象不会影响原型对象，克隆后。还可以再修改克隆对象的值。 ​ 要实现原型模式，必须实现Cloneable接口，而这个接口里面是空的。 ​ Cloneable接口是一个空接口，使用Cloneable接口都不用导入包。而clone方法是属于Object对象的。如果要克隆某个对象的话必须实现Cloneable接口。 结构 ​ 原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件： 实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。 重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。 ​ 原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，它的原型类Prototype也常用抽象类来替代。 原型模式的注意事项 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。 深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（8种基本数据类型byte,char,short,int,long,float,double，boolean），对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。 ​ 如果我们要克隆某个对象有浅克隆和深克隆 ​ 浅克隆：copy该对象，然后保留该对象原有的引用。也就是说不克隆该对象的属性。 ​ 深克隆：copy该对象，并且把该对象的所有属性也克隆出一份新的。 实现代码： ​ 用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 1、浅克隆代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 原型模式:浅克隆 * Cloneable是一个空接口（标记接口），是一个规范。但是如果要克隆这个类对象的话必须实现Cloneable接口 */ public class Sheep implements Cloneable&#123; private String sname; private Date birthday; /** * 重写Object对象的clone方法 */ @Override protected Object clone() throws CloneNotSupportedException &#123; //直接调用Object对象的clone方法 Object obj = super.clone();//这个super.clone()会将当前对象的属性进行拷贝，不过是浅拷贝。 return obj; &#125; //省略get，set方法和构造方法&#125;/** * 测试原型模式（浅克隆） */ public class Test &#123; public static void main(String[] args) throws Exception &#123; Date date = new Date(1274397294739L); Sheep s1 = new Sheep("原型羊",date); Sheep s2 = (Sheep) s1.clone();//克隆一个羊 System.out.println(s1); System.out.println(s1.getSname()); System.out.println("原日期："+s1.getBirthday()); date.setTime(34732834827389L);//改变原有date的值 System.out.println("改变后的日期："+date.toString()); //克隆羊的信息 System.out.println("---------------------------------"); System.out.println(s2); System.out.println(s2.getSname()); System.out.println(s2.getBirthday());//此时的birthday日期使用的是改变后的日期对象引用 &#125; &#125; 最后的结果为：克隆的对象仍然保留了原有对象的引用，值随着改变而改变123456789com.fz.prototype.Sheep@153f67e原型羊原日期：Fri May 21 07:14:54 CST 2010改变后的日期：Mon Aug 22 17:40:27 CST 3070---------------------------------com.fz.prototype.Sheep@18f51f原型羊Mon Aug 22 17:40:27 CST 3070 2、深克隆代码实现：克隆对象的同时，把该对象的属性也连带着克隆出新的。 深克隆只需要在clone方法中将该对象的属性也克隆即可123456789101112/*** 重写Object对象的clone方法*/@Overrideprotected Object clone() throws CloneNotSupportedException &#123; //直接调用Object对象的clone方法 Object obj = super.clone(); //深克隆：把对象下的所有属性也克隆出来 Sheep22 s = (Sheep22) obj; s.birthday = (Date) this.birthday.clone(); return s;&#125; 测试代码不变，结果则会变了。克隆了之后把原来的日期改变后，克隆的对象2的属性则不会被影响。123456789com.fz.prototype.Sheep2@15bdc50原型羊原日期：Fri May 21 07:14:54 CST 2010改变后的日期：Mon Aug 22 17:40:27 CST 3070---------------------------------com.fz.prototype.Sheep2@18f51f原型羊Fri May 21 07:14:54 CST 2010 3、通过序列化和反序列化来实现深克隆对象：序列化需要原型对象实现Serializable接口123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.Date;/** * 测试原型模式（利用序列化和反序列化实现深克隆） */public class Test3 &#123; public static void main(String[] args) throws Exception &#123; Date date = new Date(1274397294739L); Sheep s1 = new Sheep("原型羊",date); // Sheep s2 = (Sheep) s1.clone();//克隆一个羊 //使用序列化和反序列化实现深复制 //1、将s1对象序列化为一个数组 //通过ObjectOutputStream流将s1对象读出来给ByteArrayOutputStream流 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(s1); //ByteArrayOutputStream流将对象信息转成byte数组，这样byte数组里就包含了对象的数据 byte[] bytes = bos.toByteArray(); //2、将字节数组中的内容反序列化为一个Sheep对象 //通过ByteArrayInputStream流读入bytes字节数组中数据，然后传给ObjectInputStream对象输入流 ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); //通过ObjectInputStream返回一个Sheep对象 Sheep s2 = (Sheep) ois.readObject(); //原型羊的信息 System.out.println(s1); System.out.println("原日期："+s1.getBirthday()); date.setTime(34732834827389L);//改变原有date的值 System.out.println("改变后的日期："+date.toString()); //克隆羊的信息 System.out.println("---------------------------------"); System.out.println(s2); System.out.println(s2.getBirthday()); &#125;&#125; 通过序列化和反序列化的结果，最终结果还是和深克隆一样。1234567891011com.fz.prototype.Sheep@1a116c9原日期：Fri May 21 07:14:54 CST 2010改变后的日期：Mon Aug 22 17:40:27 CST 3070---------------------------------com.fz.prototype.Sheep@7eb6e2Fri May 21 07:14:54 CST 2010 测试克隆对象的效率12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.fz.prototype;/** * 测试clone对象的效率 */ public class TestClone &#123; //new 对象 public static void testNew(int size)&#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; size; i++) &#123; Laptop l = new Laptop(); &#125; long end = System.currentTimeMillis(); System.out.println("new 对象耗时："+(end-start)); &#125; //clone 对象 public static void testClone(int size)&#123; long start = System.currentTimeMillis(); Laptop l = new Laptop(); for (int i = 0; i &lt; size; i++) &#123; try &#123; Laptop temp = (Laptop) l.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println("clone 对象耗时："+(end-start)); &#125; public static void main(String[] args) &#123; testNew(1000); testClone(1000); &#125; &#125;class Laptop implements Cloneable&#123; public Laptop() &#123; //模拟创建Laptop对象的时候比较耗时 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 最后结果为： new 对象耗时：10063 clone 对象耗时：10 总结 ​ 原型模式解决的问题是，复杂的对象需要多次创建，如果使用new创建，则会很耗时。使用原型模式，则可以极大的提升效率，并且可以向客户端隐藏创建对象的细节。 ​ 在使用原型模式的时候，要注意实现Clonable接口，并且要注意浅克隆和深克隆的区别。并且，使用原型模式的时候，构造函数的private权限会失效，这个时候就需要注意单例模式的实现了。在实现单例模式的时候，尽量不要再使用原型模式。 ​ 原型模式适用场景：如果某个对象new的过程中很耗时，则可以考虑使用原型模式。 ​ Spring框架中bean对象的创建就两种模式：单例模式或者原型模式。 参考资料： JAVA设计模式之原型模式 ​ 原型模式（Prototype） 组合模式（Composite）实际例子 ​ 对于树形结构，在代码中有容器节点和叶子节点之分，容器节点可以有子节点，而叶子节点没有，所以两者是有区分的，而在实际使用中，我们更希望一致的对待他们，因为如若区别对待，在程序上会非常复杂。组合模式则是为了解决此类问题而生的，它可以让叶子对象和容器对象的使用具有一致性。他是组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。 ​ 比较常见的例子就是，电脑中的文件系统，一级目录里面有普通的文本文件、照片文件，还有二级目录。在做某些操作时，例如查看一个文件夹中所有文件大小（包括子目录中的文件），如果能将里面的文件统一对待，那么在迭代遍历的时候就会非常的方便。 模式定义 ​ 组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。​ 在组合模式中引入了抽象构件类Component，它是所有容器类和叶子类的公共父类，客户端针对Component进行编程。 模式结构 Component 抽象构件，叶子构件和容器构件的接口或抽象类 Leaf 叶子构件，叶子节点没有子节点 Composite 容器构件，容器节点可以有子节点，子节点也可以是容器构件。 适用场景 ​ 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。 ​ 在一个使用面向对象语言开发的系统中需要处理一个树形结构。 实现代码 ​ 抽象角色，抽象文件： 具体文件和具体文件夹都继承该抽象文件角色12345678910111213141516package com.pichen.dp.structuralpattern.combination;public abstract class File &#123; protected String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public abstract void showFileName();&#125; 树枝角色：具体文件夹1234567891011121314151617181920212223242526272829package com.pichen.dp.structuralpattern.combination;import java.util.ArrayList;import java.util.List;public class Folder extends File&#123; private List&lt;File&gt; fileList = new ArrayList&lt;File&gt;(); public Folder(String name) &#123; this.name = name; &#125; @Override public void showFileName() &#123; System.out.println(this.name); &#125; public void addFile(File file)&#123; fileList.add(file); &#125; //打印文件夹下的文件名 public void displayFiles()&#123; for(File file : this.fileList)&#123; file.showFileName(); &#125; &#125;&#125; 叶子角色：具体文件1234567891011121314package com.pichen.dp.structuralpattern.combination;public class TXTFile extends File&#123; public TXTFile(String name) &#123; this.name = name; &#125; @Override public void showFileName() &#123; System.out.println(this.name); &#125;&#125; 123456789101112package com.pichen.dp.structuralpattern.combination;public class AVIFile extends File&#123; public AVIFile(String name) &#123; this.name = name; &#125; @Override public void showFileName() &#123; System.out.println(this.name); &#125;&#125; 客户端，模拟文件/文件夹树形结构123456789101112131415161718192021222324252627282930313233343536package com.pichen.dp.structuralpattern.combination;public class Main &#123; public static void main(String[] args) &#123; Folder folder = new Folder("一级目录"); File txtFile = new TXTFile("二级文件txt"); File aviFile = new AVIFile("二级文件avi"); Folder txtFolder = new Folder("二级txt目录"); Folder aviFolder = new Folder("二级avi目录"); File txtFile1 = new TXTFile("三级文件txt1"); File txtFile2 = new TXTFile("三级文件txt2"); File txtFile3 = new TXTFile("三级文件txt3"); File aviFile1 = new AVIFile("三级文件avi1"); File aviFile2 = new AVIFile("三级文件avi2"); folder.addFile(txtFile); folder.addFile(aviFile); folder.addFile(txtFolder); folder.addFile(aviFolder); txtFolder.addFile(txtFile1); txtFolder.addFile(txtFile2); txtFolder.addFile(txtFile3); aviFolder.addFile(aviFile1); aviFolder.addFile(aviFile2); System.out.println("一级目录下的文件:"); folder.displayFiles(); System.out.println("\n二级txt目录下的文件:"); txtFolder.displayFiles(); System.out.println("\n二级avi目录目录下的文件:"); aviFolder.displayFiles(); &#125;&#125; 打印结果：1234567891011121314一级目录下的文件:二级文件txt二级文件avi二级txt目录二级avi目录二级txt目录下的文件:三级文件txt1三级文件txt2三级文件txt3二级avi目录目录下的文件:三级文件avi1三级文件avi2 总结 ​ 树形结构由容器节点和叶子节点组成，组合模式将容器节点和叶子节点都转化为一种节点来使用。这样一来便可以将精力更专注于树的结构，而不是节点的类型上了。 ​ 使用组合模式构建的树形结构，很容易就可以进行遍历操作，可以将叶子和容器节点同等的对待。 参考资料：【设计模式】组合模式 ​ 结构型模式之——组合模式 适配器模式（Adapter）概述 ​ 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。 解决的问题 ​ 即Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。 ​ 下面是两个非常形象的例子 模式的结构 ​ （1）类的适配器模式（采用继承实现） ​ （2）对象适配器（采用对象组合方式实现） ​ 适配器模式的类图 模式中的角色 ​ 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。 需要适配的类（Adaptee）：需要适配的类或适配者类。 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。 实现代码 ​ 一、类的适配器模式1234567891011121314151617181920212223242526272829303132333435363738// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类class Adaptee &#123; public void specificRequest() &#123; System.out.println("被适配类具有 特殊功能..."); &#125;&#125;// 目标接口，或称为标准接口interface Target &#123; public void request();&#125;// 具体目标类，只提供普通功能class ConcreteTarget implements Target &#123; public void request() &#123; System.out.println("普通类 具有 普通功能..."); &#125;&#125;// 适配器类，继承了被适配类，同时实现标准接口class Adapter extends Adaptee implements Target&#123; public void request() &#123; super.specificRequest(); &#125;&#125;// 测试类public class Client &#123; public static void main(String[] args) &#123; // 使用普通功能类 Target concreteTarget = new ConcreteTarget(); concreteTarget.request(); // 使用特殊功能类，即适配类 Target adapter = new Adapter(); adapter.request(); &#125;&#125; 测试结果：12普通类 具有 普通功能... 被适配类具有 特殊功能... ​ 上面这种实现的适配器称为类适配器，因为 Adapter 类既继承了 Adaptee （被适配类），也实现了 Target 接口（因为 Java 不支持多继承，所以这样来实现），在 Client 类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。另外一种适配器模式是对象适配器，它不是使用多继承或继承再实现的方式，而是使用直接关联，或者称为委托的方式，类图如下： 代码如下：123456789101112131415161718192021222324252627282930// 适配器类，直接关联被适配类，同时实现标准接口class Adapter implements Target&#123; // 直接关联被适配类 private Adaptee adaptee; // 可以通过构造函数传入具体需要适配的被适配类对象 public Adapter (Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void request() &#123; // 这里是使用委托的方式完成特殊功能 this.adaptee.specificRequest(); &#125;&#125;// 测试类public class Client &#123; public static void main(String[] args) &#123; // 使用普通功能类 Target concreteTarget = new ConcreteTarget(); concreteTarget.request(); // 使用特殊功能类，即适配类， // 需要先创建一个被适配类的对象作为参数 Target adapter = new Adapter(new Adaptee()); adapter.request(); &#125;&#125; ​ 测试结果与上面的一致。从类图中我们也知道需要修改的只不过就是 Adapter 类的内部结构，即 Adapter 自身必须先拥有一个被适配类的对象，再把具体的特殊功能委托给这个对象来实现。使用对象适配器模式，可以使得 Adapter 类（适配类）根据传入的 Adaptee 对象达到适配多个不同被适配类的功能，当然，此时我们可以为多个被适配类提取出一个接口或抽象类。这样看起来的话，似乎对象适配器模式更加灵活一点。 一个实际的例子 ​ 我们就拿日本电饭煲的例子进行说明，日本电饭煲电源接口标准是110V电压，而中国标准电压接口是220V，所以要想在中国用日本电饭煲，需要一个电源转换器。 ​ 定义日本和中国两种接口及其实现 ​ 我们先定义日本220V电源接口和实现。 ​ 110V接口：123456/** * 日本110V电源接口 * */ public interface JP110VInterface &#123; public void connect(); &#125; ​ 110Ｖ接口实现：123456public class JP110VInterfaceImpl implements JP110VInterface &#123; public void connect() &#123; System.out.println(&quot;接通电源，开始工作....&quot;); &#125;&#125; ​ 我们再定义中国220V电源接口和实现。 ​ 220V接口：123public interface CN220VInterface &#123; public void connect();&#125; ​ 220V接口实现：123456public class CN220VInterfaceImpl implements CN220VInterface &#123; public void connect() &#123; System.out.println("接通电源，开始工作......"); &#125;&#125; ​ 定义一个电压适配器 ​ 要想在中国使用日本电饭煲，需要把电饭煲110v的电源接口适配成我们220V的电源接口，这就需要一个电源适配器：123456789101112/** * 为了能够适配定电饭煲110v电源接口，我们需要继承110v接口 * */public class PowerAdaptor implements JP110VInterface &#123; private CN220VInterface cn220VInterface;//用220V接口进行适配 PowerAdaptor(CN220VInterface cn220VInterface)&#123; this.cn220VInterface=cn220VInterface; &#125; public void connect() &#123; cn220VInterface.connect(); &#125;&#125; ​ 适配器继承的是要适配的接口，并持有对客户的接口的引用。使用的是关联一个对象的方式。 ​ 电饭煲 ​ 下面正式开始啦，现在我们有一个日本电饭煲，用的是110v的电源接口：1234567891011public class ElectricCooker &#123; private JP110VInterface jp110VInterface;//日本电饭煲，用的是日本110V标准电源接口 ElectricCooker(JP110VInterface jp110VInterface)&#123; this.jp110VInterface=jp110VInterface; &#125; public void cook()&#123; jp110VInterface.connect();//接通电源 System.out.println("开始做饭......"); &#125;&#125; ​ 电饭煲用的是110V接口 ​ 电饭煲配合适配器工作 ​ 测试类：123456789public class AdaptorTest &#123; public static void main(String[] args) &#123; CN220VInterface cn220VInterface=new CN220VInterfaceImpl();//中国的220V电源 PowerAdaptor adaptor=new PowerAdaptor(cn220VInterface);//电源适配器 ElectricCooker cooker=new ElectricCooker(adaptor);//使用110V接口的电饭煲 cooker.cook();//使用了适配器，在220V的环境下可以工作啦 &#125;&#125; ​ 适配器继承了110V接口，就可以用于日本电饭煲；适配器又持有220V接口的引用，就可以用220V进行工作。 ​ 运行结果：12接通电源，开始工作......开始做饭...... 优缺点 ​ 优点： ​ 通过适配器，可以是两个不兼容的类在一起工作。可以复用现有的类来适应原来不能提供的接口。将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。 ​ 缺点： ​ 适配的过程比较复杂。过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 ​ 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类 总结 ​ 适配者模式，类似于在两个不能兼容的类之间做了一个中间者，来兼容这两个类。适配者模式分离了被适配者和目标接口变化的影响。例如，被适配者发生变化时，由于有适配器的存在，不会影响到目标接口。 参考资料： JAVA设计模式初探之适配器模式 ​ 设计模式之适配器模式(adaptor pattern) 装饰者模式(Decorator Pattern)简单介绍 ​ Decorator Pattern叫装饰模式，或装饰者模式，以前叫包装器模式（Wrapper，GoF在92-93年由Wrapper改为Decorator）。 ​ 装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。 ​ Decorator模式的工作原理是：可以创建始于Decorator对象（负责新的功能的对象）终于原对象的一个对象“链”。 ​ 装饰者模式隐含的是通过一条条装饰链去实现具体对象，每一条装饰链都始于一个Componet对象，每个装饰者对象后面紧跟着另一个装饰者对象，而对象链终于ConcreteComponet对象。 定义 ==装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供比继承更有弹性的替代方案。== 适用性 需要扩展一个类的功能，或给一个类添加附加职责。 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 结构 在装饰模式中的各个角色有： （1）抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。 （2）具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。 （3）装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。 （4）具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。 例子 ​ 咖啡的例子：当我们去咖啡厅的时候。不知道是不是会遇到这种问题呢？本来你点一杯普通的coffe，然后他的价格是10元，但是你尝了之后发现有点苦，想要加点红糖，然后加这个糖的价格是2元；然后过了一会你的朋友过来了，他叫了一杯普通coffee，然后加了点牛奶（假设可以加），这个牛奶的价格是3元，如果叫你设计一个程序负责这部分的内容，你会怎么做呢？ ​ 会不会有人这么想，java不是面向对象的语言吗？我们可以通过设计对象来啊，首先创建coffee一个抽象类，然后在列出可能添加调料的可能食品，然后付款的时候，调用方法不就行了吗？确实这样做是可以的，但是前面说了耦合度高，这个时候，就到了我们的装饰者出场了。 首先画出关系图： 我们要做的就是点咖啡1的时候加sugar，点咖啡2的时候加milk （1）创建coffee的接口12345678910package com.zqu.yqy.scdn.test.test006;public abstract class coffee &#123; String coffeeInformation = "普通咖啡"; public String getCoffeeInformation()&#123; return coffeeInformation; &#125; public abstract double cost();&#125; 实现类coffee1，coffee2：12345678910111213package com.zqu.yqy.scdn.test.test006;public class coffee1 extends coffee &#123; public coffee1()&#123; coffeeInformation = "coffee1"; &#125; @Override public double cost() &#123; return 10.0; &#125;&#125; 1234567891011121314package com.zqu.yqy.scdn.test.test006;public class coffee2 extends coffee &#123; public coffee2()&#123; coffeeInformation = "coffee2"; &#125; @Override public double cost() &#123; return 12.0; &#125;&#125; （2）调料类12345package com.zqu.yqy.scdn.test.test006;public abstract class AddThings extends coffee &#123; public abstract String getCoffeeInformation();&#125; 实现类：123456789101112131415161718192021package com.zqu.yqy.scdn.test.test006;public class milk extends AddThings&#123; coffee coff; public milk(coffee c) &#123; this.coff = c; &#125; @Override public String getCoffeeInformation() &#123; String addThings = coff.getCoffeeInformation()+"添加"+"milk"; return addThings; &#125; @Override public double cost() &#123; return 3.0+coff.cost(); &#125;&#125; 123456789101112131415161718192021package com.zqu.yqy.scdn.test.test006;public class sugar extends AddThings &#123; coffee coff; public sugar(coffee c) &#123; this.coff = c; &#125; @Override public String getCoffeeInformation() &#123; String addThings = coff.getCoffeeInformation()+"添加"+"sugar"; return addThings; &#125; @Override public double cost() &#123; return 2.0+coff.cost(); &#125;&#125; （3）实现类：12345678910111213141516package com.zqu.yqy.scdn.test.test006;public class cost &#123; public static void main(String[] args) &#123; coffee c1 = new coffee1(); coffee c2 = new coffee2(); coffee a1 = new sugar(c1); coffee a2 = new milk(c1); //coffee a3 = new milk(c2); System.out.println(a1.getCoffeeInformation()+" "+a1.cost()); System.out.println(a2.getCoffeeInformation()+" "+a2.cost()); //System.out.println(a3.getCoffeeInformation()+" "+a3.cost()); &#125;&#125; 结果截图： ​ 你会发现很神奇的实现了，我们要的功能，可能有的人会好奇，为什么我们的调料类也要继承coffee的呢？这个问题问得好，但是我相信你把我注释掉的那部分代码再执行一遍，你会很神奇的发现，我们的coffee1或者是coffee2还能添加牛奶呢。这你实践一下就会明白的，这样的目的怎么，是不是非常棒！！！ 优缺点 ​ 优点：可以动态的给对象添加一些功能，并且添加功能的顺序可以动态的进行调整。 ​ 缺点：继承层级比较深。暂时还没有发现其他的缺点。 总结 ​ 装饰者模式利用关联被装饰的对象，使得可以给被装饰的对象添加新的功能。并且被装饰后，还可以当作原来对象的类型来使用。 参考资料：设计模式总结之Decorator Pattern（装饰者模式） ​ 简单理解设计模式之装饰者模式 代理模式( Proxy pattern)定义 ​ ==给某一个对象提供一个代理，并由代理对象控制对原对象的访问==。对应到现实生活中，代理模式就类似于中介。 ​ 可以详细控制访问某个类（对象）的方法，在调用这个方法前作的前置处理（统一的流程代码放到代理中处理）。调用这个方法后做后置处理。 ​ 例如：明星的经纪人，租房的中介等等都是代理 结构 代理模式包含如下角色： ​ Subject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。 ​ RealSubject：真实主题角色，是实现抽象主题接口的类。 ​ ProxySubject：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 ​ 实现动态代理的关键技术是反射。 静态代理 ​ 代理模式有几种，虚拟代理，计数代理，远程代理，动态代理。主要分为两类，静态代理和动态代理。静态代理比较简单，是由程序员编写的代理类，并在程序运行前就编译好的，而不是由程序动态产生代理类，这就是所谓的静态。 ​ 考虑这样的场景，管理员在网站上执行操作，在生成操作结果的同时需要记录操作日志，这是很常见的。此时就可以使用代理模式，代理模式可以通过聚合和继承两种方式实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/**方式一：聚合式静态代理 * @author Goser (mailto:goskalrie@163.com) * @Since 2016年9月7日 */ //1.抽象主题接口 public interface Manager &#123; void doSomething(); &#125; //2.真实主题类 public class Admin implements Manager &#123; public void doSomething() &#123; System.out.println("Admin do something."); &#125; &#125; //3.以聚合方式实现的代理主题 public class AdminPoly implements Manager&#123; private Admin admin; public AdminPoly(Admin admin) &#123; super(); this.admin = admin; &#125; public void doSomething() &#123; System.out.println("Log:admin操作开始"); admin.doSomething(); System.out.println("Log:admin操作结束"); &#125; &#125; //4.测试代码 Admin admin = new Admin(); Manager m = new AdminPoly(admin); m.doSomething(); //方式二：继承式静态代理 //与上面的方式仅代理类和测试代码不同 //1.代理类 public class AdminProxy extends Admin &#123; @Override public void doSomething() &#123; System.out.println("Log:admin操作开始"); super.doSomething(); System.out.println("Log:admin操作开始"); &#125; &#125; //2.测试代码 AdminProxy proxy = new AdminProxy(); proxy.doSomething(); ​ 聚合实现方式中代理类聚合了被代理类，且代理类及被代理类都实现了同一个接口，可实现灵活多变。继承式的实现方式则不够灵活。 动态代理 ​ 一般来说，对代理模式而言，一个主题类与一个代理类一一对应，这也是静态代理模式的特点。 ​ 但是，也存在这样的情况，有n各主题类，但是代理类中的“前处理、后处理”都是一样的，仅调用主题不同。也就是说，多个主题类对应一个代理类，共享“前处理，后处理”功能，动态调用所需主题，大大减小了程序规模，这就是动态代理模式的特点。 JDK动态代理 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//1. 抽象主题public interface Moveable &#123; void move() throws Exception;&#125;//2. 真实主题public class Car implements Moveable &#123; public void move() throws Exception &#123; Thread.sleep(new Random().nextInt(1000)); System.out.println("汽车行驶中…"); &#125;&#125;//3.事务处理器public class TimeHandler implements InvocationHandler &#123; private Object target; public TimeHandler(Object target) &#123; super(); this.target = target; &#125; /** * 参数： *proxy 被代理的对象 *method 被代理对象的方法 *args 方法的参数 * 返回： *Object 方法返回值 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long startTime = System.currentTimeMillis(); System.out.println("汽车开始行驶…"); method.invoke(target, args); long stopTime = System.currentTimeMillis(); System.out.println("汽车结束行驶…汽车行驶时间：" + (stopTime - startTime) + "毫秒！"); return null; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) throws Exception&#123; Car car = new Car(); InvocationHandler h = new TimeHandler(car); Class&lt;?&gt; cls = car.getClass(); /** *loader 类加载器 *interfaces 实现接口 *h InvocationHandler */ Moveable m = (Moveable) Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(), h); m.move(); &#125;&#125; 代码讲解： 在测试代码中，Proxy.newProxyInstance()方法需要3个参数：类加载器（要进行代理的类）、被代理类实现的接口，事务处理器。所以先实例化Car，实例化InvocationHandler的子类TimeHandler，将各参数传入Proxy的静态方法newProxyInstance()即可获得Car的代理类，前面的静态代理，代理类是我们编写好的，而动态代理则不需要我们去编写代理类，是在程序中动态生成的。 JDK动态代理步骤 1. 创建一个实现InvocationHandler接口的类，它必须实现invoke()方法 2. 创建被代理的类及接口 3. 调用Proxy的静态方法，创建一个代理类 4. 通过代理调用方法 ​ 在JDK动态代理中，发现生成的代理类字节码中类的声明为： public final class $Proxy1 extends Proxy ​ 可以看到生成的代理类是继承了Proxy类的，这就是说明了为什么使用JDK动态代理不能实现继承式动态代理，原因是Java不允许多继承，而生成的代理类本身就已经继承了Proxy类。也就是说在Proxy.newProxyInstance（）转递的类型参数应该是被代理类实现的接口。 cglib动态代理 ​ 前面分析到，因为Java只允许单继承，而JDK生成的代理类本身就继承了Proxy类，因此，使用JDK实现的动态代理不能完成继承式的动态代理，但是我们可以使用cglib来实现继承式的动态代理。 ​ 大名鼎鼎的Spring中就含有cglib动态代理，在此也以Spring中自带的cglib完成动态代理的实现：12345678910111213141516171819202122232425262728293031323334353637383940//1.具体主题public class Train&#123; public void move()&#123; System.out.println("火车行驶中…"); &#125;&#125;//2.生成代理public class CGLibProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class&lt;?&gt; clazz)&#123; enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; /** * 拦截所有目标类方法的调用 * 参数： * obj目标实例对象 *method 目标方法的反射对象 * args方法的参数 * proxy代理类的实例 */ public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; //代理类调用父类的方法 System.out.println("日志开始"); proxy.invokeSuper(obj, args); System.out.println("日志结束"); return null; &#125;&#125;//3.测试public class Test &#123; public static void main(String[] args) &#123; CGLibProxy proxy = new CGLibProxy(); Train t = (Train) proxy.getProxy(Train.class); t.move(); &#125;&#125; 小结 ​ 动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样对每一个方法或方法组合进行处理。Proxy 很美很强大，但是仅支持 interface 代理。Java 的单继承机制注定了这些动态代理类们无法实现对 class 的动态代理。好在有cglib为Proxy提供了弥补。class与interface的区别本来就模糊，在java8中更是增加了一些新特性，使得interface越来越接近class，当有一日，java突破了单继承的限制，动态代理将会更加强大。 总结 ​ 代理模式就类似于中介，会控制被代理对象的访问，可以添加前置处理和后置处理。真正强大的是动态代理。 参考资料：说说 JAVA 代理模式 ​ Java设计模式——代理模式实现及原理 ​ 说说cglib动态代理 门面模式( Facade Pattern 外观模式)定义 ​ 门面模式(Facade Pattern)：==为子系统中的一组接口提供一个一致的界面==，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。门面模式又称为外观模式，它是一种对象结构型模式。 模式动机 ​ 现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其“分而治之”，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。 首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。 ​ 上图描述的是病人在医院里的体验，图中的方框代表医院。 解决这种不便的方法便是引进门面模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是门面模式的体现，病人只接触接待员，由接待员与各个部门打交道。 结构 ​ 门面模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明。 ​ 由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，那么此时示例的整体结构图如下： 在这个对象图中，出现了两个角色： 门面(Facade)角色 ：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。（门面对象不干活，而是将活让子系统干） 子系统(SubSystem)角色 ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 实例分析 ​ 这次我们来关注一下土豪的个人生活，话说土豪下班回到家里后首先要做的就是把灯打开，我们假设他一共需要打开三个灯，然后就是打开热水器烧水准备洗澡，在等待的过程还会打开电视机看新闻。如果我们用一般的方法来实现的话，代码就会是下面这个样子。 ​ 这是电灯的类，里边有打开的方法。1234567package com.designpattern.facade;public class Light &#123; public void open()&#123; System.out.println("Light has been opened!"); &#125;&#125; ​ 这是热水器的类，里边有打开的方法。1234567package com.designpattern.facade;public class Heater &#123; public void open()&#123; System.out.println("Heater has been opened!"); &#125;&#125; ​ 这是电视机的类，里边有打开的方法。12345678package com.designpattern.facade;public class TV &#123; public void open()&#123; System.out.println("TV has been opened!"); &#125;&#125; ​ 在主函数里就要创建各种对象，并且调用他们的额open方法。我们看到主函数为了实现土豪下班回家这一个功能需要和三个电灯，一个热水器和一台电视机打交道，非常的复杂，所以这时候我们就应该使用门面模式。相当于给土豪弄一个总开关，一键打开所有的东西。123456789101112131415161718192021package com.designpattern.facade;public class Main &#123; public static void main(String[] args)&#123; Light light1 = new Light(); Light light2 = new Light(); Light light3 = new Light(); Heater heater = new Heater(); TV tv = new TV(); /** * 需要一步一步的操作 */ light1.open(); light2.open(); light3.open(); heater.open(); tv.open(); &#125;&#125; ​ 在门面类中我们创建一个统一的open方法，来调度所有的开关。123456789101112131415161718192021222324package com.designpattern.facade;public class Facade &#123; private Light light1, light2, light3; private Heater heater; private TV tv; public Facade() &#123; light1 = new Light(); light2 = new Light(); light3 = new Light(); heater = new Heater(); tv = new TV(); &#125; public void open() &#123; light1.open(); light2.open(); light3.open(); heater.open(); tv.open(); &#125;&#125; ​ 这样在主函数类只需要使用门面类就可以了。12345678910111213package com.designpattern.facade;public class Main2 &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); /** * 一步操作就可以完成所有的准备工作 */ facade.open(); &#125;&#125; 注意 ​ 一个系统可以有几个门面类? ​ 在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。 ​ 为子系统增加新行为 ​ 初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。 优缺点 ​ 门面模式的优点： ● 松散耦合 门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。 ● 简单易用 门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。 ● 更好的划分访问层次 通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。 ​ 缺点： 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 总结 ​ 门面模式可以给子系统中的多个接口提供一个一致的对外界面，既方便客户端对于子系统的使用，也可以将客户端与子系统内部功能解耦，客户端不用知道子系统的细节，只需要跟门面对象沟通就可以了。 参考资料：JAVA设计模式之门面模式（外观模式） ​ 设计模式（七）门面模式（Facade Pattern 外观模式） 桥接模式（Bridge)定义 ​ ==桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化==。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 ​ 这个定义可能刚开始看不太懂，可以结合下面的结构图和实际例子来理解。其实一个模式的定义是从一个高度抽象的层面描述模式的本质。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 结构 ​ 桥接模式的UML图如下： ​ 桥接模式（Bridge)是一种结构型设计模式。Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。 ​ 桥接模式的角色和职责： ​ 1.Client 调用端 ​ 这是Bridge模式的调用者。 ​ 2.抽象类（Abstraction） ​ 抽象类接口（接口这货抽象类）维护队行为实现（implementation）的引用。它的角色就是桥接类。 ​ 3.Refined Abstraction ​ 这是Abstraction的子类。 ​ 4.Implementor ​ 行为实现类接口（Abstraction接口定义了基于Implementor接口的更高层次的操作） ​ 5.ConcreteImplementor ​ Implementor的子类 示例代码如下 ​ 首先定义Implementor接口，其中定义了其实现类必须要实现的接口operation() 1231 public interface Implementor &#123;2 public void operation();3 &#125; ​ 下面定义Implementor接口的两个实现类： 1234561 public class ConcreateImplementorA implements Implementor &#123;2 @Override3 public void operation() &#123;4 System.out.println("this is concreteImplementorA's operation...");5 &#125;6 &#125; 1234561 public class ConcreateImplementorB implements Implementor &#123;2 @Override3 public void operation() &#123;4 System.out.println("this is concreteImplementorB's operation...");5 &#125;6 &#125; 下面定义桥接类Abstraction，其中有对Implementor接口的引用：12345678910111213141516public abstract class Abstraction &#123; private Implementor implementor; public Implementor getImplementor() &#123; return implementor; &#125; public void setImplementor(Implementor implementor) &#123; this.implementor = implementor; &#125; protected void operation()&#123; implementor.operation(); &#125;&#125; ​ 下面是Abstraction类的子类RefinedAbstraction： 1234561 public class RefinedAbstraction extends Abstraction &#123;2 @Override3 protected void operation() &#123;4 super.getImplementor().operation();5 &#125;6 &#125; ​ 下面给出测试类：123456789101112131415public class BridgeTest &#123; public static void main(String[] args) &#123; Abstraction abstraction = new RefinedAbstraction(); //调用第一个实现类 abstraction.setImplementor(new ConcreateImplementorA()); abstraction.operation(); //调用第二个实现类 abstraction.setImplementor(new ConcreateImplementorB()); abstraction.operation(); &#125;&#125; ​ 其运行结果如下：12this is concreteImplementorA's operation...this is concreteImplementorB's operation... ​ 这样，通过对Abstraction桥接类的调用，实现了对接口Implementor的实现类ConcreteImplementorA和ConcreteImplementorB的调用。实现了抽象与行为实现的分离。 实际例子 ​ 个人理解：桥接是一个接口，它与一方应该是绑定的，也就是解耦的双方中的一方必然是继承这个接口的，这一方就是实现方，而另一方正是要与这一方解耦的抽象方，如果不采用桥接模式，一般我们的处理方式是直接使用继承来实现，这样双方之间处于强链接，类之间关联性极强，如要进行扩展，必然导致类结构急剧膨胀。采用桥接模式，正是为了避免这一情况的发生，将一方与桥绑定，即实现桥接口，另一方在抽象类中调用桥接口（指向的实现类），这样桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响。 下面的实例能真正体现着一点： 实例准备：我们假设有一座桥，桥左边为A，桥右边为B，A有A1，A2，A3等，表示桥左边的三个不同地方，B有B1，B2，B3等，表示桥右边的三个不同地方，假设我们要从桥左侧A出发到桥的右侧B，我们可以有多重方案，A1到B1，A1到B2，A1到B3，A2到B1…等等，以此为例，代码如下： 桥接口：Qiao 12341 public interface Qiao &#123;2 //目的地B3 void targetAreaB();4 &#125; 目的地B1,B2,B3：1234567891011121314151617181920212223242526272829303132333435/** * 目的地B1 */public class AreaB1 implements Qiao &#123; @Override public void targetAreaB() &#123; System.out.println("我要去B1"); &#125;&#125;/** * 目的地B2 */ public class AreaB2 implements Qiao &#123; @Override public void targetAreaB() &#123; System.out.println("我要去B2"); &#125;&#125;/** * 目的地B3 */ public class AreaB3 implements Qiao &#123; @Override public void targetAreaB() &#123; System.out.println("我要去B3"); &#125;&#125; 抽象来源地A：AreaA 1234561 public abstract class AreaA &#123;2 //引用桥接口3 Qiao qiao;4 //来源地5 abstract void fromAreaA();6 &#125; 来源地A1，A2，A3：1234567891011121314151617181920212223242526272829303132333435/** * 来源地A1 */ public class AreaA1 extends AreaA &#123; @Override void fromAreaA() &#123; System.out.println("我来自A1"); &#125;&#125;/** * 来源地A2 */public class AreaA2 extends AreaA &#123; @Override void fromAreaA() &#123; System.out.println("我来自A2"); &#125;&#125;/** * 来源地A3 */ public class AreaA3 extends AreaA &#123; @Override void fromAreaA() &#123; System.out.println("我来自A3"); &#125;&#125; 测试类：Clienter123456789public class Clienter &#123; public static void main(String[] args) &#123; AreaA a = new AreaA2(); a.qiao = new AreaB3(); a.fromAreaA(); a.qiao.targetAreaB(); &#125;&#125; 运行结果： 12我来自A2我要去B3 如何，只要你认真看完了实例，你就明白了这种模式的好处，现在我们要添加来源地和目的地，只要继续继承AreaA和实现Qiao即可，之前我所说的绑定，正式此处将桥与目的地绑定在一起，使用一个接口完成。 其实要完成桥接模式，注意点并不多，重在理解模式的使用场景。 注意点： 1、定义一个桥接口，使其与一方绑定，这一方的扩展全部使用实现桥接口的方式。 2、定义一个抽象类，来表示另一方，在这个抽象类内部要引入桥接口，而这一方的扩展全部使用继承该抽象类的方式。 其实我们可以发现桥接模式应对的场景有方向性的，桥绑定的一方都是被调用者，属于被动方，抽象方属于主动方。 其实我的JDK提供的JDBC数据库访问接口API正是经典的桥接模式的实现者，接口内部可以通过实现接口来扩展针对不同数据库的具体实现来进行扩展，而对外的仅仅只是一个统一的接口调用，调用方过于抽象，可以将其看做每一个JDBC调用程序（这是真实实物，当然不存在抽象） 优缺点 1.桥接模式的优点 ​ （1）实现了抽象和实现部分的分离 ​ 桥接模式分离了抽象部分和实现部分，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，分别定义接口，这有助于系统进行分层设计，从而产生更好的结构化系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。 ​ （2）更好的可扩展性 ​ 由于桥接模式把抽象部分和实现部分分离了，从而分别定义接口，这就使得抽象部分和实现部分可以分别独立扩展，而不会相互影响，大大的提供了系统的可扩展性。 ​ （3）可动态的切换实现 ​ 由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。 ​ （4）实现细节对客户端透明，可以对用户隐藏实现细节。 ​ 2.桥接模式的缺点 ​ （1）桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。 ​ （2）桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。 桥接模式的使用场景 ​ （1）如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 ​ （2）抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 ​ （3）一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 总结 ​ 桥接模式，就是将实现行为的一方，与需要这些行为的抽象一方进行解耦。具体行为在变化，需要执行行为的实体一方也在变化，但是实体方需要具体行为对象的这个关系不会发生变化。桥接模式就是将这种变化与关系的不变化进行分离。使得变化的行为方和实体方可以独立变化，而相互不影响。 参考资料：Java设计模式之《桥接模式》及应用场景 ​ 设计模式之桥接模式 享元模式(Flyweight Pattern)定义 ​ ==采用一个共享来避免大量拥有相同内容对象的开销==。这种开销中最常见、直观的就是内存的损耗。享元模式以共享的方式高效的支持大量的细粒度对象。 实际例子 ​ 比如在文档编辑器的设计过程中，我们如果为没有字母创建一个对象的话，系统可能会因为大量的对象而造成存储开销的浪费。例如一个字母“a”在文档中出现了100000次，而实际上我们可以让这一万个字母“a”共享一个对象，当然因为在不同的位置可能字母“a”有不同的显示效果（例如字体和大小等设置不同），在这种情况我们可以为将对象的状态分为“外部状态”和“内部状态”，将可以被共享（不会变化）的状态作为内部状态存储在对象中，而外部对象（例如上面提到的字体、大小等）我们可以在适当的时候将外部对象最为参数传递给对象（例如在显示的时候，将字体、大小等信息传递给对象）。 适用场景 ​ 当以下所有的条件都满足时，可以考虑使用享元模式： （1）.一个系统有大量的对象。 （2）.这些对象耗费大量的内存。 （3）.这些对象的状态中的大部分都可以外部化。 （4）.这些对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。 （5）.软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。 满足以上的这些条件的系统可以使用享元对象。 最后，使用享元模式需要维护一个记录了系统已有的所有享元的表，而这需要耗费资源。因此，应当在有足够多的享元实例可供共享时才值得使用享元模式。 结构 ​ ==单纯Flyweight享元模式==典型的UML结构图如图1所示： ​ 单纯Flyweight享元模式抽象基类及接口： 抽象享元(Flyweight)角色：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态(External State)的操作可以通过调用商业方法以参数形式传入。 ​ 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享的。 ​ 享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个复合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应 当创建一个合适的享元对象。 ​ 客户端(Client)角色：本角色需要维护一个对所有享元对象的引用。本角色需要自行存储所有享元对象的外蕴状态。 ​ 复合Flyweight享元模式典型的UML结构图如图2所示： ​ 复合Flyweight享元模式抽象基类及接口： ​ 抽象享元角色：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态(External State)的操作可以通过方法的参数传入。抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。 ​ 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。有时候具体享元角色又叫做单纯具体享元角色，因为复合享元角色是由单纯具体享元角色通过复合而成的。 ​ 复合享元(UnsharableFlyweight)角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称做不可共享的享元对象。 ​ 享元工厂(FlyweightFactoiy)角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象请求一个享元对象的时候，享元工厂角色需要检查系统中是否已经有一个符合要求的享元对象，如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个新的合适的享元对象。 ​ 客户端(Client)角色：本角色还需要自行存储所有享元对象的外蕴状态。 示例代码 ​ 单纯Flyweight享元模式典型的示例代码如下： ​ 先定义一个抽象的Flyweight类1234package Flyweight;public abstract class Flyweight&#123; public abstract void operation();&#125; ​ 实现一个具体类：12345678910package Flyweight;public class ConcreteFlyweight extends Flyweight&#123; private String string; public ConcreteFlyweight(String str)&#123; string = str; &#125; public void operation()&#123; System.out.println("Concrete---Flyweight : " + string); &#125;&#125; ​ 实现一个工厂方法类123456789101112131415161718package Flyweight;import java.util.Hashtable;public class FlyweightFactory&#123; private Hashtable flyweights = new Hashtable();//----------------------------1 public FlyweightFactory()&#123;&#125; public Flyweight getFlyWeight(Object obj)&#123; Flyweight flyweight = (Flyweight) flyweights.get(obj);//----------------2 if(flyweight == null)&#123;//---------------------------------------------------3 //产生新的ConcreteFlyweight flyweight = new ConcreteFlyweight((String)obj); flyweights.put(obj, flyweight);//--------------------------------------5 &#125; return flyweight;//---------------------------------------------------------6 &#125; public int getFlyweightSize()&#123; return flyweights.size(); &#125;&#125; ​ 这个工厂方法类非常关键，这里详细解释一下： 在1处定义了一个Hashtable用来存储各个对象；在2处选出要实例化的对象，在6处将该对象返回，如果在Hashtable中没有要选择的对象，此时变量flyweight为null，产生一个新的flyweight存储在Hashtable中，并将该对象返回。 最后看看Flyweight的调用：1234567891011121314151617181920212223242526272829303132333435package Flyweight;import java.util.Hashtable;public class FlyweightPattern&#123; FlyweightFactory factory = new FlyweightFactory(); Flyweight fly1; Flyweight fly2; Flyweight fly3; Flyweight fly4; Flyweight fly5; Flyweight fly6; /** *//** Creates a new instance of FlyweightPattern */ public FlyweightPattern()&#123; fly1 = factory.getFlyWeight("Google"); fly2 = factory.getFlyWeight("Qutr"); fly3 = factory.getFlyWeight("Google"); fly4 = factory.getFlyWeight("Google"); fly5 = factory.getFlyWeight("Google"); fly6 = factory.getFlyWeight("Google"); &#125; public void showFlyweight()&#123; fly1.operation(); fly2.operation(); fly3.operation(); fly4.operation(); fly5.operation(); fly6.operation(); int objSize = factory.getFlyweightSize(); System.out.println("objSize = " + objSize); &#125; public static void main(String[] args)&#123; System.out.println("The FlyWeight Pattern!"); FlyweightPattern fp = new FlyweightPattern(); fp.showFlyweight(); &#125;&#125; ​ 下面是运行结果：1234567Concrete---Flyweight : GoogleConcrete---Flyweight : QutrConcrete---Flyweight : GoogleConcrete---Flyweight : GoogleConcrete---Flyweight : GoogleConcrete---Flyweight : GoogleobjSize = 2 ​ 我们定义了6个对象，其中有5个是相同的，按照Flyweight模式的定义“Google”应该共享一个对象，在实际的对象数中我们可以看出实际的对象却是只有2个。 Flyweight(享元)模式是如此的重要，因为它能帮你在一个复杂的系统中大量的节省内存空间。在JAVA语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。 ​ 复合式享元相当于多个单纯享元的集合。也就是说复合享元相当于对单纯享元进行了一个再分组，在复合享元的每个分组里又是一个独立的单纯享元模式。相关关键代码如下：1234567891011121314151617public class ConcreteCompositeFlyweight implements Flyweight &#123; private Map&lt;Integer, Flyweight&gt; labels = new HashMap&lt;Integer, Flyweight&gt;(); public void add(int key, Flyweight flyweight) &#123; labels.put(key, flyweight); &#125; @Override public void operation(String extrinsicState) &#123; Flyweight flyweight = null; for (Object key : labels.keySet()) &#123; flyweight = labels.get(key); flyweight.operation(extrinsicState); &#125; &#125;&#125; ​ 对于其构建工厂也需要进行重新设计，如下：12345678910111213141516171819202122232425public class FlyweightFactory &#123; private Map&lt;Integer, Flyweight&gt; labels = new HashMap&lt;Integer, Flyweight&gt;(); /** * 单纯享元工厂 */ public Flyweight factory(String intrinsicState) &#123; ... ... return fly; &#125; /** * 复合享元工厂 */ public Flyweight compositeFactory(List&lt;String&gt; intrinsicStates) &#123; ConcreteCompositeFlyweight flyweight = new ConcreteCompositeFlyweight(); for (String intrinsicState : intrinsicStates) &#123; flyweight.add(intrinsicState.hashCode(), factory(intrinsicState)); &#125; return flyweight; &#125;&#125; 测试类123456789101112131415public void compositeFlyweight() &#123; List&lt;String&gt; intrinsicStates = new ArrayList&lt;String&gt;(); intrinsicStates.add("Hello"); intrinsicStates.add("Java"); intrinsicStates.add("DesignPattern"); intrinsicStates.add("Flyweight"); FlyweightFactory factory = new FlyweightFactory(); Flyweight flyweight1 = factory.compositeFactory(intrinsicStates); Flyweight flyweight2 = factory.compositeFactory(intrinsicStates); System.out.println("flyweight1 == flyweight2 ? " + (flyweight1 == flyweight2)); flyweight1.operation("复合享元-1"); flyweight2.operation("复合享元-2"); &#125; ​ 执行结果：1234567891011121314151617flyweight1 == flyweight2 ? false内蕴状态：Java外蕴状态：复合享元-1内蕴状态：Flyweight外蕴状态：复合享元-1内蕴状态：Hello外蕴状态：复合享元-1内蕴状态：DesignPattern外蕴状态：复合享元-1内蕴状态：Java外蕴状态：复合享元-2内蕴状态：Flyweight外蕴状态：复合享元-2内蕴状态：Hello外蕴状态：复合享元-2内蕴状态：DesignPattern外蕴状态：复合享元-2 示例1：一个咖啡的例子 ​ 在这个咖啡摊(CoffeeStall)所使用的系统里，有一系列的咖啡”风味(Flavor)”。客人到摊位上购买咖啡，所有的咖啡均放在台子上，客人自己拿到咖啡后就离开摊位。咖啡有内蕴状态，也就是咖啡的风味；咖啡没有环境因素，也就是说没有外蕴状态。如果系统为每一杯咖啡都创建一个独立的对象的话，那么就需要创建出很多的细小对象来。这样就不如把咖啡按照种类(即”风味”)划分，每一种风味的咖啡只创建一个对象，并实行共享。 ​ 使用咖啡摊主的语言来讲，所有的咖啡都可按”风味”划分成如Capucino、Espresso等，每一种风味的咖啡不论卖出多少杯，都是全同、不可分辨的。所谓共享，就是咖啡风味的共享，制造方法的共享等。因此，享元模式对咖啡摊来说，就意味着不需要为每一份单独调制。摊主可以在需要时，一次性地调制出足够一天出售的某一种风味的咖啡。 ​ 很显然，这里适合使用单纯享元模式。 示例2：咖啡店的例子 ​ 在前面的咖啡摊项目里，由于没有供客人坐的桌子，所有的咖啡均没有环境的影响。换言之，咖啡仅有内蕴状态，也就是咖啡的种类，而没有外蕴状态。下面考虑一个规模稍稍大一点的咖啡屋(Coffee Shop)项目。屋子里有很多的桌子供客人坐，系统除了需要提供咖啡的”风味”之外，还需要跟踪咖啡被送到哪一个桌位上，因此，咖啡就有了桌子作为外蕴状态。 ​ 由于外蕴状态的存在，没有外蕴状态的单纯享元模式不再符合要求。系统的设计可以利用有外蕴状态的单纯享元模式。 优缺点 ​ 优点： ​ Flyweight享元模式的优点在于它大幅度地降低内存中对象的数量。 ​ 缺点： ​ Flyweight享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。Flyweight享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。 总结 ​ Flyweight享元模式就是共享一些对象，来达到减少资源的消耗。其中共享的对象一旦创建就不会改变了。其实解决的问题就是，大量不同的对象却有很多共同的内容，将共同的内容抽取出来形成对象，并共享。主要注意的是FlyweightFactory对象，其中使用一个键值对集合来存储共享对象。 参考资料：Flyweight模式详解 ​ 深入浅出享元模式 ​ Java设计模式——享元模式 ​ JAVA设计模式之享元模式 策略模式( Strategy )定义 ​ 策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。 ​ 分析下定义，策略模式定义和封装了一系列的算法，它们是可以相互替换的，也就是说它们具有共性，而它们的共性就体现在策略接口的行为上，另外为了达到最后一句话的目的，也就是说让算法独立于使用它的客户而独立变化，我们需要让客户端依赖于策略接口。 问题 ​ 在软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。 ​ 这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。 ​ 如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？ 方案 ​ 把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。 ​ 比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。 结构 ​ 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。 ​ 这个模式涉及到三个角色： ● 环境(Context)角色：持有一个Strategy的引用。 ● 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 ● 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 源代码 ​ 抽象策略类1234567public interface Strategy &#123; /** * 策略方法 */ public void strategyInterface();&#125; ​ 具体策略类1234567public class ConcreteStrategyA implements Strategy &#123; @Override public void strategyInterface() &#123; //相关的业务 &#125;&#125; 12345678public class ConcreteStrategyB implements Strategy &#123; @Override public void strategyInterface() &#123; //相关的业务 &#125;&#125; 环境角色类1234567891011121314151617181920public class Context &#123; //持有一个具体策略的对象 private Strategy strategy; /** * 构造函数，传入一个具体策略对象 * @param strategy 具体策略对象 */ public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; /** * 策略方法 */ public void contextInterface()&#123; strategy.strategyInterface(); &#125; &#125; 实际例子 ​ 假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。 根据描述，折扣是根据以下的几个算法中的一个进行的： 算法一：对初级会员没有折扣。 算法二：对中级会员提供10%的促销折扣。 算法三：对高级会员提供20%的促销折扣。 使用策略模式来实现的结构图如下： ​ 实现代码 ​ 抽象折扣类123456789public interface MemberStrategy &#123; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice);&#125; ​ 初级会员折扣类123456789public class PrimaryMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于初级会员的没有折扣"); return booksPrice; &#125;&#125; ​ 中级会员折扣类123456789public class IntermediateMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于中级会员的折扣为10%"); return booksPrice * 0.9; &#125;&#125; ​ 高级会员折扣类123456789public class AdvancedMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于高级会员的折扣为20%"); return booksPrice * 0.8; &#125;&#125; ​ 价格类123456789101112131415161718192021public class Price &#123; //持有一个具体的策略对象 private MemberStrategy strategy; /** * 构造函数，传入一个具体的策略对象 * @param strategy 具体的策略对象 */ public Price(MemberStrategy strategy)&#123; this.strategy = strategy; &#125; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double quote(double booksPrice)&#123; return this.strategy.calcPrice(booksPrice); &#125;&#125; ​ 客户端123456789101112public class Client &#123; public static void main(String[] args) &#123; //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); //创建环境 Price price = new Price(strategy); //计算价格 double quote = price.quote(300); System.out.println("图书的最终价格为：" + quote); &#125;&#125; ​ 从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。 优缺点 ​ 优点： ​ 策略模式将相关的算法作为一个算法族进行管理。算法实现之间可以相互替换，使得程序结构灵活，并且客户端不会依赖算法的具体实现。 ​ 缺点： ​ 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。 适用场景 ​ 1.针对同一类型问题的多种处理方式，仅仅是具体行为有差别时；​ 2.需要安全地封装多种同一类型的操作时；​ 3.出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。 总结 ​ 某一个任务或功能，可以有多种算法来实现，并且不同算法之间还有很大的差异。这个时候可以使用策略模式来管理这组相关的算法实现，并且可以使得使用策略的客户端不依赖于具体的算法实现。 ​ 变化的是实现相同功能的不同算法，不变的是客户端对于这个功能的使用与需求。策略模式可以将这个问题的变化的内容和不变的内容分开。 参考资料：设计模式学习之策略模式 ​ 《JAVA与模式》之策略模式 ​ Java设计模式之策略模式 模板方法模式( Template Method )定义 ​ 定义一个算法中的操作框架，而将一些步骤延迟到子类中。使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。（Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure） 问题 ​ 某一些流程的骨架是确定的，但是每一步骤具体的细节会随着情况的改变发生大的变化。例如煮饭，都是第一步烧水，第二步做主食，第三步做菜。但是主食做什么，菜又做什么，这些要看具体的情况而定。 方案 ​ 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 结构 ​ 模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。 模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。 模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示： 这里涉及到两个角色： 抽象模板(Abstract Template)角色有如下责任： ■ 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 ■ 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任： ■ 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 ■ 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 实际例子 ​ 举个例子，以准备去学校所要做的工作（prepareGotoSchool）为例，假设需要分三步：穿衣服（dressUp），吃早饭（eatBreakfast），带上东西（takeThings）。学生和老师要做得具体事情肯定有所区别。 ​ 抽象类AbstractClass12345678910111213public abstract class AbstractPerson&#123; //抽象类定义整个流程骨架 public void prepareGotoSchool()&#123; dressUp(); eatBreakfast(); takeThings(); &#125; //以下是不同子类根据自身特性完成的具体步骤 protected abstract void dressUp(); protected abstract void eatBreakfast(); protected abstract void takeThings();&#125; ​ 具体类ConcreteClass12345678910111213141516public class Student extends AbstractPerson&#123; @Override protected void dressUp() &#123; System.out.println(“穿校服"); &#125; @Override protected void eatBreakfast() &#123; System.out.println(“吃妈妈做好的早饭"); &#125; @Override protected void takeThings() &#123; System.out.println(“背书包，带上家庭作业和红领巾"); &#125;&#125; 12345678910111213141516public class Teacher extends AbstractPerson&#123; @Override protected void dressUp() &#123; System.out.println(“穿工作服"); &#125; @Override protected void eatBreakfast() &#123; System.out.println(“做早饭，照顾孩子吃早饭"); &#125; @Override protected void takeThings() &#123; System.out.println(“带上昨晚准备的考卷"); &#125;&#125; ​ 测试类12345678910public class Client &#123; public static void main(String[] args) &#123; Student student = new Student() student.prepareGotoSchool(); Teacher teacher = new Teacher() teacher.prepareGotoSchool(); &#125;&#125; 优缺点 ​ 在全面解析完模板方法模式后，我来分析下其优缺点： ​ 优点： 提高代码复用性将相同部分的代码放在抽象的父类中 提高了拓展性将不同的代码放入不同的子类中，通过对子类的扩展增加新的行为 实现了反向控制通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，实现了反向控制 &amp; 符合“开闭原则” 缺点 ： 引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度。 应用场景 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现； 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复； 控制子类的扩展。 总结 ​ 模板方法模式将那些不变的，稳定的内容或步骤放在一个抽象类中。将那些需要随着具体情况发生变化的内容延迟到子类实现。主要是抽象类中的骨架部分非常重要。​ 有一些流程，虽然步骤的具体细节会不停的变化，但是向上抽象一层，则发现步骤是固定的。模板方法模式就是将这些固定的步骤抽象出来并且固定，让那些细节可以在子类中随着具体情况发生改变。 参考资料：模板方法模式 ​ 模板方法模式（Template Method） - 最易懂的设计模式解析 [Java设计模式之模板方法模式（Template Method）](http://blog.csdn.net/jason0539/article/details/45037535) 观察者模式（ Observer Pattern ）定义 ​ ==定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。== ​ 在这里先讲一下面向对象设计的一个重要原则——单一职责原则。因此系统的每个对象应该将重点放在问题域中的离散抽象上。因此理想的情况下，一个对象只做一件事情。这样在开发中也就带来了诸多的好处：提供了重用性和维护性，也是进行重构的良好的基础。 ​ 因此几乎所有的设计模式都是基于这个基本的设计原则来的。 ​ 观察者模式是关于多个对象想知道一个对象中数据变化情况的一种成熟的模式。观察者模式中有一个称作“主题”的对象和若干个称作“观察者”的对象，“主题”和“观察者”间是一种一对多的依赖关系，当“主题”的状态发生变化时，所有“观察者”都得到通知。前面所述的“求职中心”相当于观察者模式的一个具体“主题”；每个“求职者”相当于观察者模式中的一个具体“观察者”。 问题 ​ 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 解决方案 ​ 一个被观察者管理所有相依于它的观察者物件，并且在本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。 结构 观察者模式结构的类图如下所示： 图例说明 图片中的空心三角箭头，代表着继承（extends）或实现（Implement）关系， 由继承者/实现者 指向 被继承者/被继承者。 图片中的实心三角箭头且箭头末尾没有圆圈的， 代表着单一的引用关系， 但是被引用的对象也有可能被其他对象引用。 图片中的实心三角箭头且箭头末尾有圆圈的， 代表着一对多的引用关系。 图片中的末端有圆圈的虚线是一个对方法体内容用伪代码说明的关系 观察者模式的结构中包含四种角色： ​ （1）主题（Subject）：主题是一个接口，该接口规定了具体主题需要实现的方法，比如，添加、删除观察者以及通知观察者更新数据的方法。 ​ （2）观察者（Observer）：观察者是一个接口，该接口规定了具体观察者用来更新数据的方法。 ​ （3）具体主题（ConcreteSubject）：具体主题是实现主题接口类的一个实例，该实例包含有可以经常发生变化的数据。具体主题需使用一个集合，比如ArrayList，存放观察者的引用，以便数据变化时通知具体观察者。 ​ （4）具体观察者（ConcreteObserver）：具体观察者是实现观察者接口类的一个实例。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，使自己成为它的观察者，或让这个具体主题将自己从具体主题的集合中删除，使自己不再是它的观察者。 适用场景 ​ 1) 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 ​ 2) 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 ​ 3) 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。 实际例子 ​ 珠宝商运送一批钻石，有黄金强盗准备抢劫，珠宝商雇佣了私人保镖，警察局也派人护送，于是当运输车上路的时候，强盗保镖警察都要观察运输车一举一动， ​ 抽象的观察者12345public interface Watcher&#123; public void update();&#125; ​ 抽象的被观察者(主题，subject)，在其中声明方法（添加、移除观察者，通知观察者）：12345678public interface Subject&#123; public void addWatcher(Watcher watcher); public void removeWatcher(Watcher watcher); public void notifyWatchers();&#125; ​ 具体的观察者 ​ 保镖123456789public class Security implements Watcher&#123; @Override public void update() &#123; System.out.println(“运输车有行动，保安贴身保护"); &#125;&#125; ​ 强盗12345678public class Thief implements Watcher&#123; @Override public void update() &#123; System.out.println(“运输车有行动，强盗准备动手"); &#125;&#125; ​ 警察12345678public class Police implements Watcher&#123; @Override public void update() &#123; System.out.println(“运输车有行动，警察护航"); &#125;&#125; ​ 具体的被观察者1234567891011121314151617181920212223242526public class Transporter implements Subject&#123; private List&lt;Watcher&gt; list = new ArrayList&lt;Watcher&gt;(); @Override public void addWatcher(Watcher watcher) &#123; list.add(watcher); &#125; @Override public void removeWatcher(Watcher watcher) &#123; list.remove(watcher); &#125; @Override public void notifyWatchers(String str) &#123; for (Watcher watcher : list) &#123; watcher.update(); &#125; &#125;&#125; ​ 测试类1234567891011121314151617public class Client&#123; public static void main(String[] args) &#123; Transporter transporter = new Transporter(); Police police = new Police(); Security security = new Security(); Thief thief = new Thief(); transporter.addWatcher(police); transporter.addWatcher(security); transporter.addWatcher(thief); transporter.notifyWatchers(); &#125;&#125; 我推你拉模型 ​ 例子中没有关于数据和状态的变化通知，只是简单通知到各个观察者，告诉他们被观察者有行动。观察者模式在关于目标角色、观察者角色通信的具体实现中，有两个版本。 ​ 一种情况便是目标角色在发生变化后，仅仅告诉观察者角色“我变化了”，观察者角色如果想要知道具体的变化细节，则就要自己从目标角色的接口中得到。这种模式被很形象的称为：拉模式——就是说变化的信息是观察者角色主动从目标角色中“拉”出来的。 ​ 还有一种方法，那就是我目标角色“服务一条龙”，通知你发生变化的同时，通过一个参数将变化的细节传递到观察者角色中去。这就是“推模式”——管你要不要，先给你啦。 ​ 这两种模式的使用，取决于系统设计时的需要。如果目标角色比较复杂，并且观察者角色进行更新时必须得到一些具体变化的信息，则“推模式”比较合适。如果目标角色比较简单，则“拉模式”就很合适啦。 优缺点 ​ 优点： ​ （1）具体主题和具体观察者是松耦合关系。由于主题接口仅仅依赖于观察者接口，因此具体主题只是知道它的观察者是实现观察者接口的某个类的实例，但不需要知道具体是哪个类。同样，由于观察者仅仅依赖于主题接口，因此具体观察者只是知道它依赖的主题是实现主题接口的某个类的实例，但不需要知道具体是哪个类。 ​ （2）观察者模式满足“开-闭原则”。主题接口仅仅依赖于观察者接口，这样，就可以让创建具体主题的类也仅仅是依赖于观察者接口，因此，如果增加新的实现观察者接口的类，不必修改创建具体主题的类的代码。。同样，创建具体观察者的类仅仅依赖于主题接口，如果增加新的实现主题接口的类，也不必修改创建具体观察者类的代码。 ​ ( 3 ) 可以将一个对象的改变通知到依赖它的对象。这是观察者模式完成的基本任务，并且由于抽象观察者与抽象主题的存在，具体观察者和具体主题可以独立变化，而不影响另外一方。 ​ 缺点： ​ 增加了类结构层级，使得设计时比较复杂。 总结 ​ 在观察者模式对应的问题中，具体观察者会发生改变，并且具体主题也会发生改变。但是主题一定是要被观察者来关注的，这个关系是不会发生改变的。观察者模式向上抽象了一层，利用抽象观察者接口和抽象主题接口，使得主题与观察者的一对多关系被固定下来。同时也将观察者与主题的具体类别解耦，使得一方的改变不会影响到另外一方。 参考资料：设计模式拾荒之观察者模式( Observer Pattern )： MVC的进一步泛化 ​ 设计模式学习笔记（二：观察者模式） [深入浅出观察者模式](http://blog.csdn.net/ai92/article/details/375691) ​ Java设计模式之观察者模式 迭代子(Iterator)模式定义 ​ 在软件构建过程中，集合对象内部结构常常变化各异，但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作提供了可能。 ​ 使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。 ​ 迭代子(Iterator)模式又叫游标(Cursor)模式，是对象的行为模式。==迭代子模式可以提供一种方法顺序访问一个聚集对象中各个元素 , 而又不需暴露该对象的内部表示。== 聚集和JAVA聚集 ​ 多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。数组就是最基本的聚集，也是其他的JAVA聚集对象的设计基础。 JAVA聚集对象是实现了共同的java.util.Collection接口的对象，是JAVA语言对聚集概念的直接支持。从1.2版开始，JAVA语言提供了很多种聚集，包括Vector、ArrayList、HashSet、HashMap、Hashtable等，这些都是JAVA聚集的例子。 问题背景 ​ 顺序访问聚集中的对象，主要用于集合中。一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。 迭代子模式为遍历集合提供了统一的接口方法。从而使得客户端不需要知道聚集的内部结构就能就能对聚集进行遍历等操作。Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 ​ 例如，如果没有使用Iterator，遍历一个数组的方法是使用索引：​ for(int i=0; i&lt;array.size(); i++) {​ … get(i) … ​ }​ 而访问一个链表（LinkedList）又必须使用while循环： ​ while((e=e.next())!=null) { … e.data() … } ​ 以上两种方法客户端都必须事先知道集合的内部结构，访问代码和集合本身是紧耦合，无法将访问逻辑从集合类和客户端代码中分离出来，每一种集合对应一种遍历方法，客户端代码无法复用。 ​ 更恐怖的是，如果以后需要把ArrayList更换为LinkedList，则原来的客户端代码必须全部重写。 ​ 为解决以上问题，Iterator模式总是用同一种逻辑来遍历集合：​ for(Iterator it = c.iterater(); it.hasNext(); ) { … } ​ 奥秘在于客户端自身不维护遍历集合的”指针”，所有的内部状态（如当前元素位置，是否有下一个元素）都由Iterator来维护，而这个Iterator由集合类通过工厂方法生成，因此，它知道如何遍历整个集合。 ​ 客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。 迭代子模式的结构 ​ 迭代子模式有两种实现方式，分别是白箱聚集与外禀迭代子和黑箱聚集于内禀迭代子。 ​ 白箱聚集与外禀(bing, 三声)迭代子 ​ 如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做白箱聚集。聚集对象向外界提供同样的宽接口，如下图所示： ​ 由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代子叫做游标迭代子（Cursor Iterator）。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做外禀迭代子（Extrinsic Iterator）。 ​ 现在看一看白箱聚集与外禀迭代子的实现。一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代子可以通过聚集的遍历方法实现迭代功能。 因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代子角色往往仅仅保持迭代的游标位置。 一个典型的由白箱聚集与外禀迭代子组成的系统如下图所示，在这个实现中具体迭代子角色是一个外部类，而具体聚集角色向外界提供遍历聚集元素的接口。 ​ 注意，从上图可以看出，在具体迭代子中关联了一个具体的聚集对象！ ​ 迭代子模式涉及到以下几个角色： ● 抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。 ● 具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。 ● 聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。 ● 具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。 ● 客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。 ​ 源代码 ​ 抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。1234567public abstract class Aggregate &#123; /** * 工厂方法，创建相应迭代子对象的接口 */ public abstract Iterator createIterator();&#125; ​ 具体聚集角色类，实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。123456789101112131415161718192021222324252627282930313233public class ConcreteAggregate extends Aggregate &#123; private Object[] objArray = null; /** * 构造方法，传入聚合对象的具体内容 */ public ConcreteAggregate(Object[] objArray)&#123; this.objArray = objArray; &#125; @Override public Iterator createIterator() &#123; return new ConcreteIterator(this); &#125; /** * 取值方法：向外界提供聚集元素 */ public Object getElement(int index)&#123; if(index &lt; objArray.length)&#123; return objArray[index]; &#125;else&#123; return null; &#125; &#125; /** * 取值方法：向外界提供聚集的大小 */ public int size()&#123; return objArray.length; &#125;&#125; ​ 抽象迭代子角色类12345678910111213141516171819public interface Iterator &#123; /** * 迭代方法：移动到第一个元素 */ public void first(); /** * 迭代方法：移动到下一个元素 */ public void next(); /** * 迭代方法：是否为最后一个元素 */ public boolean isDone(); /** * 迭代方法：返还当前元素 */ public Object currentItem();&#125; ​ 具体迭代子角色类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ConcreteIterator implements Iterator &#123; //持有被迭代的具体的聚合对象 private ConcreteAggregate agg; //内部索引，记录当前迭代到的索引位置 private int index = 0; //记录当前聚集对象的大小 private int size = 0; public ConcreteIterator(ConcreteAggregate agg)&#123; this.agg = agg; this.size = agg.size(); index = 0; &#125; /** * 迭代方法：返还当前元素 */ @Override public Object currentItem() &#123; return agg.getElement(index); &#125; /** * 迭代方法：移动到第一个元素 */ @Override public void first() &#123; index = 0; &#125; /** * 迭代方法：是否为最后一个元素 */ @Override public boolean isDone() &#123; return (index &gt;= size); &#125; /** * 迭代方法：移动到下一个元素 */ @Override public void next() &#123; if(index &lt; size) &#123; index ++; &#125; &#125;&#125; 客户端类1234567891011121314151617181920public class Client &#123; public void operation()&#123; Object[] objArray = &#123;"One","Two","Three","Four","Five","Six"&#125;; //创建聚合对象 Aggregate agg = new ConcreteAggregate(objArray); //循环输出聚合对象中的值 Iterator it = agg.createIterator(); while(!it.isDone())&#123; System.out.println(it.currentItem()); it.next(); &#125; &#125; public static void main(String[] args) &#123; Client client = new Client(); client.operation(); &#125;&#125; ​ 上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代子对象。在得到迭代子的实例后，客户端开始迭代过程，打印出所有的聚集元素。 ​ 外禀迭代子的意义 ​ 一个常常会问的问题是：既然白箱聚集已经向外界提供了遍历方法，客户端已经可以自行进行迭代了，为什么还要应用迭代子模式，并创建一个迭代子对象进行迭代呢？ 客户端当然可以自行进行迭代，不一定非得需要一个迭代子对象。但是，迭代子对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代子责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代子作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。 此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代子模式和一个外界的迭代子对象是有意义的。具有同一迭代接口的不同迭代子对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。 黑箱聚集与内禀迭代子 ​ 如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的窄接口。 聚集对象为迭代子对象提供一个宽接口，而为其他对象提供一个窄接口。换言之，聚集对象的内部结构应当对迭代子对象适当公开，以便迭代子对象能够对聚集对象有足够的了解，从而可以进行迭代操作。但是，聚集对象应当避免向其他的对象提供这些方法，因为其他对象应当经过迭代子对象进行这些工作，而不是直接操控聚集对象。 在JAVA语言中，实现双重接口的办法就是将迭代子类设计成聚集类的内部成员类。这样迭代子对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构。下面给出一个示意性的实现，说明这种双重接口的结构时怎么样产生的，以及使用了双重接口结构之后迭代子模式的实现方案。这种同时保证聚集对象的封装和迭代子功能的实现的方案叫做黑箱实现方案。 由于迭代子是聚集的内部类，迭代子可以自由访问聚集的元素，所以迭代子可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代子是在聚集的结构之内定义的，因此这样的迭代子又叫做内禀迭代子（Intrinsic Iterator）。 ​ 为了说明黑箱方案的细节，这里给出一个示意性的黑箱实现。在这个实现里，聚集类ConcreteAggregate含有一个内部成员类ConcreteIterator，也就是实现了抽象迭代子接口的具体迭代子类，同时聚集并不向外界提供访问自己内部元素的方法。 ​ 从上图可以看出，相对于外禀迭代子，内禀迭代子由于是聚集对象的内部类，所以它(ConcreteIterator)不用持有具体聚集对象的引用。 ​ 源代码 ​ 抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。1234567public abstract class Aggregate &#123; /** * 工厂方法，创建相应迭代子对象的接口 */ public abstract Iterator createIterator();&#125; ​ 抽象迭代子角色类12345678910111213141516171819public interface Iterator &#123; /** * 迭代方法：移动到第一个元素 */ public void first(); /** * 迭代方法：移动到下一个元素 */ public void next(); /** * 迭代方法：是否为最后一个元素 */ public boolean isDone(); /** * 迭代方法：返还当前元素 */ public Object currentItem();&#125; ​ 具体聚集角色类，实现了抽象聚集角色所要求的接口，也就是createIterator()方法。此外，聚集类有一个内部成员类ConcreteIterator，这个内部类实现了抽象迭代子角色所规定的接口；而工厂方法createIterator()所返还的就是这个内部成员类的实例。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ConcreteAggregate extends Aggregate &#123;​ private Object[] objArray = null; /** * 构造方法，传入聚合对象的具体内容 */ public ConcreteAggregate(Object[] objArray)&#123; this.objArray = objArray; &#125; @Override public Iterator createIterator() &#123; return new ConcreteIterator(); &#125; /** * 内部成员类，具体迭代子类 */ private class ConcreteIterator implements Iterator &#123; //内部索引，记录当前迭代到的索引位置 private int index = 0; //记录当前聚集对象的大小 private int size = 0; /** * 构造函数 */ public ConcreteIterator()&#123; this.size = objArray.length; index = 0; &#125; /** * 迭代方法：返还当前元素 */ @Override public Object currentItem() &#123; return objArray[index]; &#125; /** * 迭代方法：移动到第一个元素 */ @Override public void first() &#123; index = 0; &#125; /** * 迭代方法：是否为最后一个元素 */ @Override public boolean isDone() &#123; return (index &gt;= size); &#125; /** * 迭代方法：移动到下一个元素 */ @Override public void next() &#123; if(index &lt; size) &#123; index ++; &#125; &#125; &#125;&#125; ​ 客户端类1234567891011121314151617181920public class Client &#123; public void operation()&#123; Object[] objArray = &#123;"One","Two","Three","Four","Five","Six"&#125;; //创建聚合对象 Aggregate agg = new ConcreteAggregate(objArray); //循环输出聚合对象中的值 Iterator it = agg.createIterator(); while(!it.isDone())&#123; System.out.println(it.currentItem()); it.next(); &#125; &#125; public static void main(String[] args) &#123; Client client = new Client(); client.operation(); &#125;&#125; ​ 上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代子对象。在得到迭代子的实例后，客户端开始迭代过程，打印出所有的聚集元素。 主动迭代子和被动迭代子 ​ 主动迭代子和被动迭代子又称作外部迭代子和内部迭代子。 所谓主动（外部）迭代子，指的是由客户端来控制迭代下一个元素的步骤，客户端会明显调用迭代子的next()等迭代方法，在遍历过程中向前进行。 所谓被动（内部）迭代子，指的是由迭代子自己来控制迭代下一个元素的步骤。因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传递给迭代子，迭代子在迭代的时候会在每个元素上执行这个操作，类似于JAVA的回调机制。 总体来说外部迭代器比内部迭代器要灵活一些，因此我们常见的实现多属于主动迭代子。 静态迭代子和动态迭代子 ​ ● 静态迭代子由聚集对象创建，并持有聚集对象的一份快照(snapshot)，在产生后这个快照的内容就不再变化。客户端可以继续修改原聚集的内容，但是迭代子对象不会反映出聚集的新变化。 静态迭代子的好处是它的安全性和简易性，换言之，静态迭代子易于实现，不容易出现错误。但是由于静态迭代子将原聚集复制了一份，因此它的短处是对时间和内存资源的消耗。 ● 动态迭代子则与静态迭代子完全相反，在迭代子被产生之后，迭代子保持着对聚集元素的引用，因此，任何对原聚集内容的修改都会在迭代子对象上反映出来。 完整的动态迭代子不容易实现，但是简化的动态迭代子并不难实现。大多数JAVA设计师遇到的迭代子都是这种简化的动态迭代子。为了说明什么是简化的动态迭代子，首先需要介绍一个新的概念：Fail Fast。 Fail Fast ​ JAVA语言以接口java.util.Iterator的方式支持迭代子模式，Collection接口要求提供iterator()方法，此方法在调用时返还一个Iterator类型的对象。而作为Collection接口的子类型，AbstractList类的内部成员类Itr便是实现Iterator接口的类。 Itr类的源代码如下所示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private class Itr implements Iterator&lt;E&gt; &#123; /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 从Itr类的源代码中可以看到，方法checkForComodification()会检查聚集的内容是否刚刚被外界直接修改过(不是通过迭代子提供的方法修改的)。如果在迭代开始后，聚集的内容被外界绕过迭代子对象而直接修改的话，这个方法会立即抛出ConcurrentModificationException()异常。 ​ 这就是说，AbstractList.Itr迭代子是一个Fail Fast的迭代子。 优缺点 ​ 优点： ​ （1）迭代子模式简化了聚集的接口。迭代子具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。 （2）每一个聚集对象都可以有一个或多个迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。 （3）由于遍历算法被封装在迭代子角色里面，因此迭代的算法可以独立于聚集角色变化。 ​ 缺点： ​ 暂时想到的缺点就是，会增加结构层次，并且在聚集类中增加方法，并且会关联到迭代子对象。 总结 ​ 迭代子模式可以为不同的聚集对象提供一个遍历集合中所有元素的统一接口，使得客户端在遍历集合元素时，不需要考虑集合的内部实现和访问方式。 ​ 聚集对象的内部结构在变化，访问方式也在变化，但是客户端始终是需要对集合元素进行遍历的需求不会变化。迭代子模式很好的屏蔽了集合内部变化对客户端遍历元素的影响。 ​ 要注意下外禀迭代子和内禀迭代子的实现。 参考资料：《JAVA与模式》之迭代子模式 ​ java设计模式—-迭代子模式 ​ Java设计模式之迭代子模式 责任链模式（Chain fo Responsibility）定义 ​ 使多个对象都有机会处理请求，从而避免了请求的发送和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 模式解析 ​ 责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 责任链模式的要点主要是： 1、有多个对象共同对一个任务进行处理。 2、这些对象使用链式存储结构，形成一个链，每个对象知道自己的下一个对象。 3、一个对象对任务进行处理，可以添加一些操作后将对象传递个下一个任务。也可以在此对象上结束任务的处理，并结束任务。 3、客户端负责组装链式结构，但是客户端不需要关心最终是谁来处理了任务。 结构 ​ 责任链模式结构的类图，如下图所示： ​ 责任链模式涉及到的角色： ​ 抽象处理者角色(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。 ​ 具体处理者角色(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。 源代码12345678910111213141516171819202122232425public abstract class Handler &#123; /** * 持有后继的责任对象 */ protected Handler successor; /** * 示意处理请求的方法，虽然这个示意方法是没有传入参数的 * 但实际是可以传入参数的，根据具体需要来选择是否传递参数 */ public abstract void handleRequest(); /** * 取值方法 */ public Handler getSuccessor() &#123; return successor; &#125; /** * 赋值方法，设置后继的责任对象 */ public void setSuccessor(Handler successor) &#123; this.successor = successor; &#125;&#125; ​ 具体处理者角色1234567891011121314151617181920212223public class ConcreteHandler extends Handler &#123; /** * 处理方法，调用此方法处理请求 */ @Override public void handleRequest() &#123; /** * 判断是否有后继的责任对象 * 如果有，就转发请求给后继的责任对象 * 如果没有，则处理请求 */ if(getSuccessor() != null) &#123; System.out.println("放过请求"); getSuccessor().handleRequest(); &#125;else &#123; System.out.println("处理请求"); &#125; &#125;&#125; ​ 客户端类123456789101112public class Client &#123; public static void main(String[] args) &#123; //组装责任链 Handler handler1 = new ConcreteHandler(); Handler handler2 = new ConcreteHandler(); handler1.setSuccessor(handler2); //提交请求 handler1.handleRequest(); &#125;&#125; ​ 可以看出，客户端创建了两个处理者对象，并指定第一个处理者对象的下家是第二个处理者对象，而第二个处理者对象没有下家。然后客户端将请求传递给第一个处理者对象。 ​ 由于本示例的传递逻辑非常简单：只要有下家，就传给下家处理；如果没有下家，就自行处理。 ​ 因此，第一个处理者对象接到请求后，会将请求传递给第二个处理者对象。由于第二个处理者对象没有下家，于是自行处理请求。活动时序图如下所示。 实际例子 ​ 申请聚餐费用的管理，申请聚餐费用的大致流程一般是，由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。​ 不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。 ​ 当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。申请人只要直接与项目经理交互就可以，其余的工作在黑盒中，究竟流程是怎样的，最后是由谁审批通过的，申请人无需关心。 ​ 抽象处理者角色类1234567891011121314151617181920212223242526public abstract class Handler &#123; /** * 持有下一个处理请求的对象 */ protected Handler successor = null; /** * 取值方法 */ public Handler getSuccessor() &#123; return successor; &#125; /** * 设置下一个处理请求的对象 */ public void setSuccessor(Handler successor) &#123; this.successor = successor; &#125; /** * 处理聚餐费用的申请 * @param user 申请人 * @param fee 申请的钱数 * @return 成功或失败的具体通知 */ public abstract String handleFeeRequest(String user , double fee);&#125; ​ 具体处理者角色123456789101112131415161718192021222324252627282930public class ProjectManager extends Handler &#123; @Override public String handleFeeRequest(String user, double fee) &#123; String str = ""; //项目经理权限比较小，只能在500以内 if(fee &lt; 500) &#123; //为了测试，简单点，只同意张三的请求 if("张三".equals(user)) &#123; str = "成功：项目经理同意【" + user + "】的聚餐费用，金额为" + fee + "元"; &#125;else &#123; //其他人一律不同意 str = "失败：项目经理不同意【" + user + "】的聚餐费用，金额为" + fee + "元"; &#125; &#125;else &#123; //超过500，继续传递给级别更高的人处理 if(getSuccessor() != null) &#123; return getSuccessor().handleFeeRequest(user, fee); &#125; &#125; return str; &#125;&#125; 123456789101112131415161718192021222324252627282930public class DeptManager extends Handler &#123; @Override public String handleFeeRequest(String user, double fee) &#123; String str = ""; //部门经理的权限只能在1000以内 if(fee &lt; 1000) &#123; //为了测试，简单点，只同意张三的请求 if("张三".equals(user)) &#123; str = "成功：部门经理同意【" + user + "】的聚餐费用，金额为" + fee + "元"; &#125;else &#123; //其他人一律不同意 str = "失败：部门经理不同意【" + user + "】的聚餐费用，金额为" + fee + "元"; &#125; &#125;else &#123; //超过1000，继续传递给级别更高的人处理 if(getSuccessor() != null) &#123; return getSuccessor().handleFeeRequest(user, fee); &#125; &#125; return str; &#125;&#125; 123456789101112131415161718192021222324252627282930public class GeneralManager extends Handler &#123; @Override public String handleFeeRequest(String user, double fee) &#123; String str = ""; //总经理的权限很大，只要请求到了这里，他都可以处理 if(fee &gt;= 1000) &#123; //为了测试，简单点，只同意张三的请求 if("张三".equals(user)) &#123; str = "成功：总经理同意【" + user + "】的聚餐费用，金额为" + fee + "元"; &#125;else &#123; //其他人一律不同意 str = "失败：总经理不同意【" + user + "】的聚餐费用，金额为" + fee + "元"; &#125; &#125;else &#123; //如果还有后继的处理对象，继续传递 if(getSuccessor() != null) &#123; return getSuccessor().handleFeeRequest(user, fee); &#125; &#125; return str; &#125;&#125; ​ 客户端类123456789101112131415161718192021222324252627282930public class Client &#123; public static void main(String[] args) &#123; //先要组装责任链 Handler h1 = new GeneralManager(); Handler h2 = new DeptManager(); Handler h3 = new ProjectManager(); h3.setSuccessor(h2); h2.setSuccessor(h1); //开始测试 String test1 = h3.handleFeeRequest("张三", 300); System.out.println("test1 = " + test1); String test2 = h3.handleFeeRequest("李四", 300); System.out.println("test2 = " + test2); System.out.println("---------------------------------------"); String test3 = h3.handleFeeRequest("张三", 700); System.out.println("test3 = " + test3); String test4 = h3.handleFeeRequest("李四", 700); System.out.println("test4 = " + test4); System.out.println("---------------------------------------"); String test5 = h3.handleFeeRequest("张三", 1500); System.out.println("test5 = " + test5); String test6 = h3.handleFeeRequest("李四", 1500); System.out.println("test6 = " + test6); &#125;&#125; 优缺点 ​ 优点： ​ 1、降低耦合度。它将请求的发送者和接收者解耦。 ​ 2、简化了对象。使得对象不需要知道链的结构。 ​ 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 ​ 4、增加新的请求处理类很方便。 ​ 缺点： ​ 1、不能保证请求一定被接收。 ​ 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 ​ 3、可能不容易观察运行时的特征，有碍于除错。 适用场景 ​ 当有多个对象需要对某一个任务进行检查或者处理的时候，可以使用责任链模式来简化对象的关系。并且也可以使得任务发送者与任务接送者之间的解耦。 总结 ​ 责任链模式可以处理任务多个处理对象之间的组织关系，并且可以简化客户端的考虑。处理任务的对象可能会增加、减少，或者发生其他的结构变化，但是由于责任链的存在，客户端不需要考虑这些变化带来的影响，客户端只知道任务最终是会被处理的，这件事情是确定的。 参考资料： 大话设计模式—责任链模式 ​ [工作中的设计模式]责任链模式chain ​ 设计模式之责任链模式 ​ Java设计模式之责任链模式、职责链模式 命令模式( Command )定义 ​ 命令模式是一个高内聚的模式，其定义为：Encapsulate a request as an object,there by letting you parameterize clients with different requests,queue or log requests,and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请 求排队或者记录请求日志，可以提供命令的撤销和恢复功能。） 问题 ​ 在软件设计中，我们经常会遇到某些对象发送请求，然后某些对象接受请求后执行，但发送请求的对象可能并不知道接受请求的对象是谁，执行的是什么动作。此时可通过 命令模式 来实现，让发送者和接受者完全的松耦合，这样可大大增强程序的灵活性。 结构 ​ 命令模式的示意性类图如下所示： ​ 在命令模式结构图中包含如下几个角色： Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。 ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。 Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。 Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。 ​ 命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。 适用情况 ​ 1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 ​ 2.系统需要在不同的时间指定请求、将请求排队和执行请求。 ​ 3.系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 ​ 4.系统需要将一组操作组合在一起，即支持宏命令。 实际例子1234//执行命令的接口public interface Command &#123; void execute();&#125; 1234567891011121314151617//命令接收者Receiverpublic class Tv &#123; public int currentChannel = 0; public void turnOn() &#123; System.out.println("The televisino is on."); &#125; public void turnOff() &#123; System.out.println("The television is off."); &#125; public void changeChannel(int channel) &#123; this.currentChannel = channel; System.out.println("Now TV channel is " + channel); &#125;&#125; 123456789101112//开机命令ConcreteCommandpublic class CommandOn implements Command &#123; private Tv myTv; public CommandOn(Tv tv) &#123; myTv = tv; &#125; public void execute() &#123; myTv.turnOn(); &#125;&#125; 123456789101112//关机命令ConcreteCommandpublic class CommandOff implements Command &#123; private Tv myTv; public CommandOff(Tv tv) &#123; myTv = tv; &#125; public void execute() &#123; myTv.turnOff(); &#125;&#125; 123456789101112131415//频道切换命令ConcreteCommandpublic class CommandChange implements Command &#123; private Tv myTv; private int channel; public CommandChange(Tv tv, int channel) &#123; myTv = tv; this.channel = channel; &#125; public void execute() &#123; myTv.changeChannel(channel); &#125;&#125; 12345678910111213141516171819202122//可以看作是遥控器Invokerpublic class Control &#123; private Command onCommand, offCommand, changeChannel; public Control(Command on, Command off, Command channel) &#123; onCommand = on; offCommand = off; changeChannel = channel; &#125; public void turnOn() &#123; onCommand.execute(); &#125; public void turnOff() &#123; offCommand.execute(); &#125; public void changeChannel() &#123; changeChannel.execute(); &#125;&#125; 12345678910111213141516171819202122//测试类Clientpublic class Client &#123; public static void main(String[] args) &#123; // 命令接收者Receiver Tv myTv = new Tv(); // 开机命令ConcreteCommond CommandOn on = new CommandOn(myTv); // 关机命令ConcreteCommond CommandOff off = new CommandOff(myTv); // 频道切换命令ConcreteCommond CommandChange channel = new CommandChange(myTv, 2); // 命令控制对象Invoker Control control = new Control(on, off, channel); // 开机 control.turnOn(); // 切换频道 control.changeChannel(); // 关机 control.turnOff(); &#125;&#125; 执行结果123The televisino is on.Now TV channel is 2The television is off. 优缺点 ​ 优点： ​ 1.降低对象之间的耦合度。 ​ 2.新的命令可以很容易地加入到系统中。 ​ 3.可以比较容易地设计一个组合命令。 ​ 4.调用同一方法实现不同的功能 ​ 缺点： ​ 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。 总结 ​ 命令模式的本质就是将命令封装起来了，这样在命令发送者和接受者之间就构建了一个桥梁，使得他们解耦。所以每一个命令都不同，但是将命令封装并抽象一个层次，那么就可以对命令做一些共性的操作，比如撤销、记录和排队等。主要的作用还是在解耦命令的发送者和接受者。 参考资料：设计模式-命令模式 ​ 设计模式 —— 命令模式（Command Pattern） ​ java设计模式之命令模式 ​ Java设计模式之命令模式 备忘录模式( Memento )定义 ​ 备忘录（Memento）模式又称标记（Token）模式。GOF给备忘录模式的定义为：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 问题 ​ 一个对象中一般都封装了很多属性，这些属性的值会随着程序的运行而变化。当我们需要保存某一时刻对象的某些值的时候，我们就再创建一个对象，将当前对象中的一些属性保存到新的对象中，当我们需要恢复的时候再从新的对象中取出属性值即可。这种想法就是备忘录模式。 结构 ​ 备忘录模式的类图： 角色分类 ​ 1) 备忘录（Memento）角色：备忘录角色存储“备忘发起角色”的内部状态。“备忘发起角色”根据需要决定备忘录角色存储“备忘发起角色”的哪些内部状态。为了防止“备忘发起角色”以外的其他对象访问备忘录。备忘录实际上有两个接口，“备忘录管理者角色”只能看到备忘录提供的窄接口——对于备忘录角色中存放的属性是不可见的。“备忘发起角色”则能够看到一个宽接口——能够得到自己放入备忘录角色中属性。 2) 备忘发起（Originator）角色：“备忘发起角色”创建一个备忘录，用以记录当前时刻它的内部状态。在需要时使用备忘录恢复内部状态。 3) 备忘录管理者（Caretaker）角色：负责保存好备忘录。不能对备忘录的内容进行操作或检查。 备忘录模式的分类 ​ 1.”白箱”备忘录模式的实现 ​ 2.“黑箱”备忘录模式的实现 ​ 3.“多重”检查点 ​ 4.”自述历史”模式 举例 ​ “白箱”备忘录模式的实现 ​ 备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。因此这个实现又叫做“白箱实现”。 ​ “白箱”实现将发起人角色的状态存储在一个大家都看得到的地方，因此是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。因此白箱实现仍然是有意义的。 ​ 下面给出一个示意性的“白箱实现”。 ​ demo 入口123456789101112131415161718192021222324252627282930313233343536package com.wc.momoto;/** * 类似白箱备忘录模式 * @author weichyang * */ public class Client &#123; /** * 客户端 * * @param args */ public static void main(String[] args) &#123; int state = 3; Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); originator.setState(state); /** * 创建备忘录对象的 缓存起来 */ caretaker.saveMemento(originator.creatMementoObject()); /* * 进行设置重新还原 */ originator.setState(5); System.out.println("发起人更改状态：" + originator.getState()); originator.restoreMemento(caretaker.retrieveMemento()); &#125;&#125; ​ 管理者，负责发起者的管理123456789101112131415161718192021222324252627package com.wc.momoto;/** * 管理者 负责管理Caretaker * ​ * @author weichyang * */public class Caretaker &#123; private Memento memento; /** * 备忘录的取值方法 */ public Memento retrieveMemento() &#123; return this.memento; &#125; /** * 备忘录的赋值方法 */ public void saveMemento(Memento memento) &#123; this.memento = memento; &#125;&#125; ​ 备忘录，对发起者进行缓存的类123456789101112131415161718192021222324252627282930package com.wc.momoto;/** * 备忘录 * ​ * @author weichyang * */public class Memento &#123; private int state; public Memento() &#123; ​ super(); &#125; public Memento(int state) &#123; ​ this.state = state; ​ System.out.println("备忘录 当前保存 状态：" + state); &#125; public int getState() &#123; ​ return state; &#125; public void setState(int state) &#123; ​ this.state = state; &#125;&#125; ​ 发起者，负责备忘录的创建，修改，恢复1234567891011121314151617181920212223242526272829303132333435package com.wc.momoto;/** * 发起者 * ​ * @author weichyang * */public class Originator &#123; private int state = 0; Caretaker caretaker = new Caretaker(); public Memento creatMementoObject() &#123; ​ return new Memento(state); &#125; /** * 将发起人恢复到备忘录对象所记载的状态 */ public void restoreMemento(Memento memento) &#123; this.state = memento.getState(); System.out.println("恢复 备忘录 状态：" + state); &#125; public int getState() &#123; ​ return state; &#125; public void setState(int state) &#123; ​ this.state = state; &#125;&#125; ​ “黑箱”备忘录模式的实现 ​ 备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。这样的实现叫做“黑箱实现”。 ​ 在JAVA语言中，实现双重接口的办法就是将备忘录角色类设计成发起人角色类的内部成员类。 ​ 将Memento设成Originator类的内部类，从而将Memento对象封装在Originator里面；在外部提供一个标识接口 MementoIF给Caretaker以及其他对象。这样，Originator类看到的是Menmento的所有接口，而Caretaker以及其他 对象看到的仅仅是标识接口MementoIF所暴露出来的接口。12345678910111213141516171819202122232425262728293031323334353637package com.wc.momoto.black;/** * 类似黑箱备忘录模式 * ​ * @author weichyang * */public class Client &#123; /** * 客户端 * ​ * @param args */ public static void main(String[] args) &#123; int state = 3; Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); originator.setState(state); /** * 创建备忘录对象的 缓存起来 */ caretaker.saveMemento(originator.creatMementoObject()); /* * 进行设置重新还原 */ originator.setState(5); System.out.println(" 黑箱发起人更改状态：" + originator.getState()); originator.restoreMemento(caretaker.retrieveMemento()); &#125;&#125; 12345package com.wc.momoto.black;public interface MemotoIF &#123;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.wc.momoto.black;/** * 发起者 * 内部类如何拿到外部类的引用 https://zhidao.baidu.com/question/513464853.html * 已经外部类如何访问内部类中的成员 * @author weichyang * */public class Originator &#123; private int state = 0; Caretaker caretaker = new Caretaker(); public Memento creatMementoObject() &#123; ​ return new Memento(state); &#125; /** * 将发起人恢复到备忘录对象所记载的状态 */ public void restoreMemento(MemotoIF momIf) &#123; this.setState(((Memento) momIf).getState()); System.out.println("黑箱恢复 备忘录 状态：" + state); &#125; public int getState() &#123; ​ return state; &#125; public void setState(int state) &#123; ​ this.state = state; &#125; private class Memento implements MemotoIF &#123; ​ private int state; ​ public Memento(int state) &#123; ​ this.state = state; ​ System.out.println("黑箱备忘录 当前保存 状态：" + state); ​ &#125; ​ public int getState() &#123; ​ return state; ​ &#125; ​ public void setState(int state) &#123; ​ this.state = state; ​ &#125; &#125;&#125; 123456789101112131415161718192021222324252627package com.wc.momoto.black;/** * 管理者 负责管理Caretaker * ​ * @author weichyang * */public class Caretaker &#123; private MemotoIF memento; /** * 备忘录的取值方法 */ public MemotoIF retrieveMemento() &#123; return this.memento; &#125; /** * 备忘录的赋值方法 */ public void saveMemento(MemotoIF memento) &#123; this.memento = memento; &#125;&#125; 多重检查点 ​ 前面所给出的白箱和黑箱的示意性实现都是只存储一个状态的简单实现，也可以叫做只有一个检查点。常见的系统往往需要存储不止一个状态，而是需要存储多个状态，或者叫做有多个检查点。 备忘录模式可以将发起人对象的状态存储到备忘录对象里面，备忘录模式可以将发起人对象恢复到备忘录对象所存储的某一个检查点上。 ”自述历史”模式 ​ 所谓“自述历史”模式(History-On-Self Pattern)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(Originator)角色、负责人(Caretaker)角色和备忘录 (Memento)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历 史”模式里面，发起人角色自己兼任负责人角色。 优缺点 ​ 优点： ​ 1、备忘录模式可以把发起人内部信息对象屏蔽起来，从而可以保持封装的边界。​ 2、简化了发起人类。当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。 ​ 优点： ​ 1、如果状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象比较昂贵。 总结 ​ 备忘录模式就是将一个对象的状态保存在它的外部，这样方便以后恢复这个对象的状态。由于备忘录角色和管理角色的存在，所以当发起者角色的状态变化方式不一样的时候，客户端仍然可以按照之前的方式来操作对象，而不需要进行改变。 ​ 可以说，备忘录模式使得客户端恢复对象状态的方式固定不变，而对象状态发生改变的方式可以改变并不会影响到客户端。 参考资料：23种设计模式之—备忘录模式 [JAVA设计模式之：备忘录模式](http://blog.csdn.net/true100/article/details/50561081) ​ “备忘录模式”就这么简单 状态模式( state pattern )定义 ​ 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式是一种对象行为型模式。 ​ 也就是说状态模式封装的非常好，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。 问题 ​ 一个对象的内部状态会影响到它的行为，并且行为还会改变这个对象的状态。状态之间存在着复杂的切换关系。 方案 ​ 将对象的状态抽象出来，对象状态的改变也封装到状态对象中去。这样客户端和对象就不在关注状态改变的细节，以及状态和行为之间的改变也不需要关注。 使用场景 ​ （1）对象的行为依赖于它的状态，并且可以在运行时根据状态改变行为。 ​ （2）代码中包含大量与对象状态有关的if/else语句，这些条件对应于对象的各种状态，这些冗余条件语句的出现导致代码的可维护性和灵活性变差，这种情况适合使用状态模式进行优化。 结构 ​ 下图是状态模式结构的简单示意图 状态模式涉及的角色： ​ （1）Context类，定义客户端所感兴趣的接口，并且内部维护一个具体状态类的实例，从而维护了对象的现有状态。 ​ （2）State：抽象状态类或状态接口，用以抽象封装行为。 ​ （3）ConcreteState类：具体状态类，实现了State中的抽象方法。 实际例子 ​ 实例1 ​ 我们使用一个常见的场景，比如我们用手机打开了CSDN，找到了一篇文章，觉得写的不错，当我们点击“收藏”时，会突然跳出一个登录界面，这时我们才发觉原来我们还没有登录，如果我们已经登录成功，在点击“收藏”，就会有相应的业务逻辑处理。 ​ 实例2 ​ 我们每天都在乘电梯，电梯就涉及到状态（停止、运行等）和动作（敞开、关闭等）。那我们来看看电梯有哪些动作（映射到Java 中就是有多少方法）:开门、关门、运行、停止，就这四个动作，好，我们就用程序来实现一下电梯的动作，先看类图设计： ​ 非常简单的类图，定义一个接口，然后是一个实现类，然后业务类Client 就可以调用，并运行起来，简单也来看看我们的程序,先看接口：1234567891011121314151617package com.gumx.common;/*** @author gumx* I'm glad to share my knowledge with you all.* 定义一个电梯的接口 */public interface ILift &#123; //首先电梯门开启动作 public void open(); //电梯门有开启，那当然也就有关闭了 public void close(); //电梯要能上能下，跑起来 public void run(); //电梯还要能停下来，停不下来那就扯淡了 public void stop();&#125; ​ 然后看实现类：12345678910111213141516171819202122232425package com.gumx.common;/*** @author gumx* I'm glad to share my knowledge with you all.* 电梯的实现类 */ public class Lift implements ILift &#123; //电梯门关闭 public void close() &#123; System.out.println("电梯门关闭..."); &#125; //电梯门开启 public void open() &#123; System.out.println("电梯门开启..."); &#125; //电梯开始跑起来 public void run() &#123; System.out.println("电梯上下跑起来..."); &#125; //电梯停止 public void stop() &#123; System.out.println("电梯停止了..."); &#125; &#125; ​ 电梯的开、关、跑、停都实现了，开看业务是怎么调用的：12345678910111213141516171819202122package com.gumx.common;/*** @author gumx* I'm glad to share my knowledge with you all.* 模拟电梯的动作 */ public class Client &#123; public static void main(String[] args) &#123; ILift lift = new Lift(); //首先是电梯门开启，人进去 lift.open(); //然后电梯门关闭 lift.close(); //再然后，电梯跑起来，向上或者向下 lift.run(); //最后到达目的地，电梯挺下来 lift.stop(); &#125; &#125; ​ 运行的结果如下：1234电梯门开启...电梯门关闭...电梯上下跑起来...电梯停止了... ​ 太简单的程序了，是个程序员都会写这个程序，这么简单的程序还拿出来show，是不是太小看我们的智商了？！非也，非也，我们继续往下分析，这个程序有什么问题，你想呀电梯门可以打开，但不是随时都可以开，是有前提条件的的，你不可能电梯在运行的时候突然开门吧？！电梯也不会出现停止了但是不开门的情况吧？！那要是有也是事故嘛，再仔细想想，电梯的这四个动作的执行都是有前置条件，具体点说说在特定状态下才能做特定事，那我们来分析一下电梯有什么那些特定状态： ​ 门敞状态—按了电梯上下按钮，电梯门开，这中间有5 秒的时间（当然你也可以用身体挡住电梯门，那就不是5 秒了），那就是门敞状态；在这个状态下电梯只能做的动作是关门动作，做别的动作？那就危险喽 ​ 门闭状态—电梯门关闭了，在这个状态下，可以进行的动作是：开门（我不想坐电梯了）、停止（忘记按路层号了）、运行 ​ 运行状态—电梯正在跑，上下窜，在这个状态下，电梯只能做的是停止； ​ 停止状态—电梯停止不动，在这个状态下，电梯有两个可选动作：继续运行和开门动作； ​ 我们用一张表来表示电梯状态和动作之间的关系： 开门(open) 关门(close) 运行(run) 停止(stop) 门敞状态 ○ ☆ ○ ○ 门闭状态 ☆ ○ ☆ ☆ 运行状态 ○ ○ ○ ☆ 停止状态 ☆ ○ ☆ ○ ​ 电梯状态和动作对应表（○表示不允许，☆表示允许动作） ​ 看到这张表后，我们才发觉，哦~~，我们的程序做的很不严谨，好，我们来修改一下，先看类图： 增加了状态的类图 ​ 在接口中定义了四个常量，分别表示电梯的四个状态：门敞状态、关闭状态、运行状态、停止状态，然后在实现类中电梯的每一次动作发生都要对状态进行判断，判断是否运行执行，也就是动作的执行是否符合业务逻辑，实现类中的四个私有方法是仅仅实现电梯的动作，没有任何的前置条件，因此这四个方法是不能为外部类调用的，设置为私有方法。我们先看接口的改变：1234567891011121314151617181920212223package com.gumx.common2;/*** @author gumx* I'm glad to share my knowledge with you all.* 定义一个电梯的接口*/public interface ILift &#123; //电梯的四个状态 public final static int OPENING_STATE = 1; //门敞状态 public final static int CLOSING_STATE = 2; //门闭状态 public final static int RUNNING_STATE = 3; //运行状态 public final static int STOPPING_STATE = 4; //停止状态； //设置电梯的状态 public void setState(int state); //首先电梯门开启动作 public void open(); //电梯门有开启，那当然也就有关闭了 public void close(); //电梯要能上能下，跑起来 public void run(); //电梯还要能停下来，停不下来那就扯淡了 public void stop();&#125; 增加了四个静态常量，增加了一个方法setState，设置电梯的状态。我们再来看实现类是如何实现的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.gumx.common2;/*** @author gumx* I'm glad to share my knowledge with you all.* 电梯的实现类*/public class Lift implements ILift &#123; private int state; public void setState(int state) &#123; this.state = state; &#125; //电梯门关闭 public void close() &#123; //电梯在什么状态下才能关闭 switch(this.state)&#123; case OPENING_STATE: //如果是则可以关门，同时修改电梯状态 this.closeWithoutLogic(); this.setState(CLOSING_STATE); break; case CLOSING_STATE: //如果电梯就是关门状态，则什么都不做 //do nothing; break; case RUNNING_STATE: //如果是正在运行，门本来就是关闭的，也说明都不做 //do nothing; break; case STOPPING_STATE: //如果是停止状态，本也是关闭的，什么也不做 //do nothing; break; &#125; &#125; //电梯门开启 public void open() &#123; //电梯在什么状态才能开启 switch(this.state)&#123; case OPENING_STATE: //如果已经在门敞状态，则什么都不做 //do nothing; break; case CLOSING_STATE: //如是电梯时关闭状态，则可以开启 this.openWithoutLogic(); this.setState(OPENING_STATE); break; case RUNNING_STATE: //正在运行状态，则不能开门，什么都不做 //do nothing; break; case STOPPING_STATE: //停止状态，淡然要开门了 this.openWithoutLogic(); this.setState(OPENING_STATE); break; &#125; &#125; //电梯开始跑起来 public void run() &#123; switch(this.state)&#123; case OPENING_STATE: //如果已经在门敞状态，则不你能运行，什么都不做 //do nothing; break; case CLOSING_STATE: //如是电梯时关闭状态，则可以运行 this.runWithoutLogic(); this.setState(RUNNING_STATE); break; case RUNNING_STATE: //正在运行状态，则什么都不做 //do nothing; break; case STOPPING_STATE: //停止状态，可以运行 this.runWithoutLogic(); this.setState(RUNNING_STATE); &#125; &#125; //电梯停止 public void stop() &#123; switch(this.state)&#123; case OPENING_STATE: //如果已经在门敞状态，那肯定要先停下来的，什么都不做 //do nothing; break; case CLOSING_STATE: //如是电梯时关闭状态，则当然可以停止了 this.stopWithoutLogic(); this.setState(CLOSING_STATE); break; case RUNNING_STATE: //正在运行状态，有运行当然那也就有停止了 this.stopWithoutLogic(); this.setState(CLOSING_STATE); break; case STOPPING_STATE: //停止状态，什么都不做 //do nothing; break; &#125; &#125; //纯粹的电梯关门，不考虑实际的逻辑 private void closeWithoutLogic()&#123; System.out.println("电梯门关闭..."); &#125; //纯粹的店门开，不考虑任何条件 private void openWithoutLogic()&#123; System.out.println("电梯门开启..."); &#125; //纯粹的运行，不考虑其他条件 private void runWithoutLogic()&#123; System.out.println("电梯上下跑起来..."); &#125; //单纯的停止，不考虑其他条件 private void stopWithoutLogic()&#123; System.out.println("电梯停止了..."); &#125;&#125; ​ 程序有点长，但是还是很简单的，就是在每一个接口定义的方法中使用witch…case 来进行判断，是否运行运行指定的动作。我们来看Client 程序的变更： 123456789101112131415161718192021package com.gumx.common2;/*** @author gumx* I'm glad to share my knowledge with you all.* 模拟电梯的动作*/public class Client &#123; public static void main(String[] args) &#123; ILift lift = new Lift(); //电梯的初始条件应该是停止状态 lift.setState(ILift.STOPPING_STATE); //首先是电梯门开启，人进去 lift.open(); //然后电梯门关闭 lift.close(); //再然后，电梯跑起来，向上或者向下 lift.run(); //最后到达目的地，电梯挺下来 lift.stop(); &#125;&#125; ​ 业务调用的方法中增加了电梯状态判断，电梯要开门不是随时都可以开的，必须满足了一定条件你才能开门，人才能走进去，我们设置电梯的起始是停止状态，看运行结果：1234电梯门开启...电梯门关闭...电梯上下跑起来...电梯停止了... 我们来想一下，这段程序有什么问题，首先Lift.java 这个文件有点长，长的原因是我们在程序中使用了大量的switch…case 这样的判断（if…else 也是一样），程序中只要你有这样的判断就避免不了加长程序，同步的在业务比较复杂的情况下，程序体会更长，这个就不是一个很好的习惯了，较长的方法或者类的维护性比较差，毕竟程序是给人来阅读的；其次，扩展性非常的不好，大家来想想，电梯还有两个状态没有加，是什么？通电状态和断电状态，你要是在程序再增加这两个方法，你看看Open()、Close()、Run()、Stop()这四个方法都要增加判断条件，也就是说switch 判断体中还要增加case 项，也就说与开闭原则相违背了；再其次，我们来思考我们的业务，电梯在门敞开状态下就不能上下跑了吗？电梯有没有发生过只有运行没有停止状态呢（从40 层直接坠到1 层嘛）？电梯故障嘛，还有电梯在检修的时候，可以在stop状态下不开门，这也是正常的业务需求呀，你想想看，如果加上这些判断条件，上面的程序有多少需要修改？虽然这些都是电梯的业务逻辑，但是一个类有且仅有一个原因引起类的变化，单一职责原则，看看我们的类，业务上的任务一个小小增加或改动都对我们的这个电梯类产生了修改，这是在项目开发上是有很大风险的。既然我们已经发现程序上有以上问题，我们怎么来修改呢？ ​ 刚刚我们是从电梯的有哪些方法以及这些方法执行的条件去分析，现在我们换个角度来看问题，我们来想电梯在具有这些状态的时候，能够做什么事情，也就是说在电梯处于一个具体状态时，我们来思考这个状态是由什么动作触发而产生以及在这个状态下电梯还能做什么事情，举个例子来说，电梯在停止状态时，我们来思考两个问题： 第一、这个停止状态时怎么来的，那当然是由于电梯执行了stop 方法而来的； ​ 第二、在停止状态下，电梯还能做什么动作?继续运行？开门？那当然都可以了。 ​ 我们再来分析其他三个状态，也都是一样的结果，我们只要实现电梯在一个状态下的两个任务模型就可以了：这个状态是如何产生的以及在这个状态下还能做什么其他动作（也就是这个状态怎么过渡到其他状态），既然我们以状态为参考模型，那我们就先定义电梯的状态接口，思考过后我们来看类图： ​ 以状态作为导向的类图 ​ 在类图中，定义了一个LiftState 抽象类，声明了一个受保护的类型Context 变量，这个是串联我们各个状态的封装类，封装的目的很明显，就是电梯对象内部状态的变化不被调用类知晓，也就是迪米特法则了，我的类内部情节你知道越少越好，并且还定义了四个具体的实现类，承担的是状态的产生以及状态间的转换过渡，我们先来看LiftState 程序:123456789101112131415161718192021222324package com.gumx.advance;/*** @author gumx* I'm glad to share my knowledge with you all.* 定义一个电梯的接口 */ public abstract class LiftState&#123; //定义一个环境角色，也就是封装状态的变换引起的功能变化 protected Context context; public void setContext(Context _context)&#123; this.context = _context; &#125; //首先电梯门开启动作 public abstract void open(); //电梯门有开启，那当然也就有关闭了 public abstract void close(); //电梯要能上能下，跑起来 public abstract void run(); //电梯还要能停下来，停不下来那就扯淡了 public abstract void stop(); &#125; 抽象类比较简单，我们来先看一个具体的实现，门敞状态的实现类：12345678910111213141516171819202122232425262728293031package com.cbf4life.advance;/*** @author cbf4Life cbf4life@126.com* I'm glad to share my knowledge with you all.* 在电梯门开启的状态下能做什么事情 */ public class OpenningState extends LiftState &#123; //开启当然可以关闭了，我就想测试一下电梯门开关功能 @Override public void close() &#123; //状态修改 super.context.setLiftState(Context.closeingState); //动作委托为CloseState来执行 super.context.getLiftState().close(); &#125; //打开电梯门 @Override public void open() &#123; System.out.println("电梯门开启..."); &#125; //门开着电梯就想跑，这电梯，吓死你！ @Override public void run() &#123; //do nothing; &#125; //开门还不停止？ public void stop() &#123; //do nothing; &#125; &#125; ​ 我来解释一下这个类的几个方法，Openning 状态是由open()方法产生的，因此这个方法中有一个具体的业务逻辑，我们是用print 来代替了；在Openning 状态下，电梯能过渡到其他什么状态呢？按照现在的定义的是只能过渡到Closing 状态，因此我们在Close()中定义了状态变更，同时把Close 这个动作也委托了给CloseState 类下的Close 方法执行，这个可能不好理解，我们再看看Context 类就可能好理解一点：123456789101112131415161718192021222324252627282930313233343536package com.gumx.advance;/*** @author gumx* I'm glad to share my knowledge with you all. */ public class Context &#123; //定义出所有的电梯状态 public final static OpenningState openningState = new OpenningState(); public final static ClosingState closeingState = new ClosingState(); public final static RunningState runningState = new RunningState(); public final static StoppingState stoppingState = new StoppingState(); //定一个当前电梯状态 private LiftState liftState; public LiftState getLiftState() &#123; return liftState; &#125; public void setLiftState(LiftState liftState) &#123; this.liftState = liftState; //把当前的环境通知到各个实现类中 this.liftState.setContext(this); &#125; public void open()&#123; this.liftState.open(); &#125; public void close()&#123; this.liftState.close(); &#125; public void run()&#123; this.liftState.run(); &#125; public void stop()&#123; this.liftState.stop(); &#125; &#125; ​ 结合以上三个类，我们可以这样理解，Context 是一个环境角色，它的作用是串联各个状态的过渡，在LiftSate 抽象类中我们定义了并把这个环境角色聚合进来，并传递到了子类，也就是四个具体的实现类中自己根据环境来决定如何进行状态的过渡。我们把其他的三个具体实现类阅读完毕，下面是关闭状态：12345678910111213141516171819202122232425262728293031323334package com.gumx.advance;/*** @author gumx* I'm glad to share my knowledge with you all.* 电梯门关闭以后，电梯可以做哪些事情 */ public class ClosingState extends LiftState &#123; //电梯门关闭，这是关闭状态要实现的动作 @Override public void close() &#123; System.out.println("电梯门关闭..."); &#125; //电梯门关了再打开，逗你玩呢，那这个允许呀 @Override public void open() &#123; super.context.setLiftState(Context.openningState); //置为门敞状态 super.context.getLiftState().open(); &#125; //电梯门关了就跑，这是再正常不过了 @Override public void run() &#123; super.context.setLiftState(Context.runningState); //设置为运行状态； super.context.getLiftState().run(); &#125; //电梯门关着，我就不按楼层 @Override public void stop() &#123; super.context.setLiftState(Context.stoppingState); //设置为停止状态； super.context.getLiftState().stop(); &#125; &#125; 下面是电梯的运行状态： 123456789101112131415161718192021222324252627282930package com.gumx.advance;/*** @author gumx* I'm glad to share my knowledge with you all.* 电梯在运行状态下能做哪些动作 */ public class RunningState extends LiftState &#123; //电梯门关闭？这是肯定了 @Override public void close() &#123; //do nothing &#125; //运行的时候开电梯门？你疯了！电梯不会给你开的 @Override public void open() &#123; //do nothing &#125; //这是在运行状态下要实现的方法 @Override public void run() &#123; System.out.println("电梯上下跑..."); &#125; //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了 @Override public void stop() &#123; super.context.setLiftState(Context.stoppingState); //环境设置为停止状态； super.context.getLiftState().stop(); &#125; &#125; ​ 下面是停止状态：123456789101112131415161718192021222324252627282930313233package com.gumx.advance;/*** @author gumx* I'm glad to share my knowledge with you all.* 在停止状态下能做什么事情 */ public class StoppingState extends LiftState &#123; //停止状态关门？电梯门本来就是关着的！ @Override public void close() &#123; //do nothing; &#125; //停止状态，开门，那是要的！ @Override public void open() &#123; super.context.setLiftState(Context.openningState); super.context.getLiftState().open(); &#125; //停止状态再跑起来，正常的很 @Override public void run() &#123; super.context.setLiftState(Context.runningState); super.context.getLiftState().run(); &#125; //停止状态是怎么发生的呢？当然是停止方法执行了 @Override public void stop() &#123; System.out.println("电梯停止了..."); &#125; &#125; 业务逻辑都已经实现了，我们来看看Client 怎么实现：12345678910111213141516171819package com.gumx.advance;/*** @author gumx* I'm glad to share my knowledge with you all.* 模拟电梯的动作 */ public class Client &#123; public static void main(String[] args) &#123; Context context = new Context(); context.setLiftState(new ClosingState()); context.open(); context.close(); context.run(); context.stop(); &#125; &#125; ​ Client 调用类太简单了，只要定义个电梯的初始状态，然后调用相关的方法，就完成了，完全不用考虑状态的变更，看运行结果：1234电梯门开启...电梯门关闭...电梯上下跑起来...电梯停止了... ​ 我们再来回顾一下我们刚刚批判上一段的代码，首先我们说人家代码太长，这个问题我们解决了，通过各个子类来实现，每个子类的代码都很短，而且也取消了的switch…case 条件的判断；其次，说人家不符合开闭原则，那如果在我们这个例子中要增加两个状态怎么加？增加两个子类，一个是通电状态，一个是断电状态，同时修改其他实现类的相应方法，因为状态要过渡呀，那当然要修改原有的类，只是在原有类中的方法上增加，而不去做修改；再其次，我们说人家不符合迪米特法则，我们现在呢是各个状态是单独的一个类，只有与这个状态的有关的因素修改了这个类才修改，符合迪米特法则，非常完美! 优缺点 ​ 状态模式既然有优点，那当然有缺点了，只有一个缺点，子类会太多，也就是类膨胀，你想一个事物有七八、十来个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目自己衡量。其实有很大方式解决这个状态问题，比如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。状态模式使用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说行为是受状态约束的情况下可以使用状态模式，而且状态模式使用时对象的状态最好不要超过五个，防止你写子类写疯掉。 拓展 ​ 上面的例子可能比较复杂，请各位看官耐心的看，看完我想肯定有所收获。我翻遍了所有能找的到的资料（至少也有十几本，其中有几本原文的书还是很的很不错的，我举这个电梯的例子也是从《Design Pattern for Dummies》这本书来激发出来的），基本（基本哦，还是有几本讲的不错）上没有一本把这个状态模式讲透彻的，我不敢说我就讲的透彻，大家都只讲了一个状态到另一个状态过渡，状态间的过渡是固定的，举个简单的例子： 这个状态图是很多书上都有的，状态A 只能变更到状态B，状态B 再变更到状态C，例子举的最多的就是TCP 监听的例子，TCP 有三个状态：等待，连接，断开，然后这三个状态中按照顺序循环变更，按照这个状态变更来讲解状态模式，我认为是不太合适的，为什么呢？你在项目中太少看到一个状态只能过渡到另一个状态情形，项目中遇到的大多数情况都是一个状态可以转换为几种状态，如下图： 状态B 可以转换为状态C 也可以转换为状态D，而状态D 呢也可以转换为状态A 或状态B，这在项目分析过程中有一个叫状态图可以完整的展示这种蜘蛛网结构，举个实际例子来说，一些收费网站的用户就有很多状态，比如普通用户，普通会员，VIP 会员，白金级用户等等，这个状态的变更你不允许跳跃？！这不可能，所以我在例子中就举了一个比较复杂的应用，基本上可以实现状态间自由切换，这才是最经常用到的状态模式。然后我再提问个问题，状态间的自由切换，那会有很多种呀，你要一个一个的牢记一遍吗？比如上面那个电梯的例子，我要一个正常的电梯运行逻辑，规则是开门-&gt;关门-&gt;运行-&gt;停止；还要一个紧急状态（比如火灾）下的运行逻辑，关门-&gt;停止，紧急状态电梯当然不能用了；再要一个维修状态下的运行逻辑，这个状态任何情况都可以，开着门电梯运行？可以！门来回开关？可以！永久停止不动？可以！ 那这怎么实现呢？需要我们把已经有的几种状态按照一定的顺序再重新组装一下，那这个是什么模式？什么模式？大声点！建造者模式！对，建造模式+状态模式会起到非常好的封装作用。 ​ 再往深里面扯几句，应该有部分读者做过工作流开发，如果不是土制框架的话，就应该有个状态机管理（即使是土制框架也应该有），比如一个Activity（节点）有初始化状态（Initialized State）、挂起状态（Suspended State）、完成状态（Completed State）等等，流程实例也是有这么多状态，那这些状态怎么管理呢？通过状态机(State Machine)来管理，那状态机是个什么东西呢？就是我们上面提到的Context类的升级变态BOSS！ 总结 ​ 状态模式主要是对对象涉及的内部状态进行封装，使得状态对象来负责与状态相关的动作和状态变化。这样，客户端就不需要再来关心状态与行为的影响，以及状态变化的细节。 ​ 在状态模式中，状态在不停的变换，行为也在不停的变化，并且状态还会影响到行为。但是，状态和行为之间的影响关系不会变化，状态对象的封装，使得状态与行为之间的影响关系固定，并且向客户端隐藏状态过渡细节。 参考资料： 设计模式——状态模式详解 ​ Java设计模式——状态模式（STATE PATTERN） 访问者模式(Vistor)定义 ​ 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 ​ 可以对定义这么理解：有这么一个操作，它是作用于一些元素之上的，而这些元素属于某一个对象结构。同时这个操作是在不改变各元素类的前提下，在这个前提下定义新操作是访问者模式精髓中的精髓。 问题 ​ 在一些数据结构上，会频繁的执行一些操作，并且这个操作是变化的，可能会增加新的操作。 方案 ​ 将操作与数据结构进行分离，将操作封装成独立的对象。这样，及时操作改变了，或者增加新的操作时，都不会影响到数据结构。 使用场景 ​ （1）数据结构稳定，作用于数据结构的操作经常变化的时候。 ​ （2）需要对一个对象结构中的对象进行很多不同的且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。 ​ （3）有时在对数据结构上的元素进行操作的时候，需要区分具体的类型，这时使用访问者模式可以针对不同的类型，在访问者类中定义不同的操作，从而去除掉类型判断。 结构 ​ 访问者模式的结构示意图为： ​ 结构图补充：在ElementA和ElementB中的accept(Vistor) 方法中会调用vistor的方法对元素进行访问。 ​ 访问者模式涉及的角色： ​ （1）Visitor：接口或者抽象类，它定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法数理论上来讲与元素个数是一样的，因此，访问者模式要求元素的类族要稳定，如果经常添加、移除元素类，必然会导致频繁地修改Visitor接口，如果这样则不适合使用访问者模式。 ​ （2）ConcreteVisitor1、ConcreteVisitor2：具体的访问类，它需要给出对每一个元素类访问时所产生的具体行为。 ​ （3）Element：元素接口或者抽象类，它定义了一个接受访问者的方法（Accept），其意义是指每一个元素都要可以被访问者访问。 ​ （4）ConcreteElementA、ConcreteElementB：具体的元素类，它提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 ​ （5）ObjectStructure：定义当中所说的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素供访问者访问。 实际例子 ​ 我们都知道财务都是有账本的，这个账本就可以作为一个对象结构，而它其中的元素有两种，收入和支出，这满足我们访问者模式的要求，即元素的个数是稳定的，因为账本中的元素只能是收入和支出。 ​ 而查看账本的人可能有这样几种，比如老板，会计事务所的注会，财务主管，等等。而这些人在看账本的时候显然目的和行为是不同的。 ​ 首先我们给出单子的接口，它只有一个方法accept。123456//单个单子的接口（相当于Element）public interface Bill &#123; void accept(AccountBookViewer viewer);//相当于接受一个访问者&#125; ​ 其中的方法参数AccountBookViewer是一个账本访问者接口，接下来也就是实现类，收入单子和消费单子，或者说收入和支出类。1234567891011121314151617181920212223242526//消费的单子public class ConsumeBill implements Bill&#123; private double amount; private String item; public ConsumeBill(double amount, String item) &#123; super(); this.amount = amount; this.item = item; &#125; public void accept(AccountBookViewer viewer) &#123; viewer.view(this); &#125; public double getAmount() &#123; return amount; &#125; public String getItem() &#123; return item; &#125;&#125; 1234567891011121314151617181920212223242526//收入单子public class IncomeBill implements Bill&#123; private double amount; private String item; public IncomeBill(double amount, String item) &#123; super(); this.amount = amount; this.item = item; &#125; public void accept(AccountBookViewer viewer) &#123; viewer.view(this); &#125; public double getAmount() &#123; return amount; &#125; public String getItem() &#123; return item; &#125; &#125; ​ 上面最关键的还是里面的accept方法，它直接让访问者访问自己，这相当于一次静态分派（文章最后进行解释），当然我们也可以不使用重载而直接给方法不同的名称。 ​ 接下来是账本访问者接口12345678910//账单查看者接口（相当于Visitor）public interface AccountBookViewer &#123; //查看消费的单子 void view(ConsumeBill bill); //查看收入的单子 void view(IncomeBill bill);&#125; 这两个方法是重载方法，就是在上面的元素类当中用到的，当然你也可以按照访问者模式类图当中的方式去做，将两个方法分别命名为viewConsumeBill和viewIncomeBill，而一般建议按照类图上来做的 访问者的实现1234567891011121314151617181920212223242526//老板类，查看账本的类之一public class Boss implements AccountBookViewer&#123; private double totalIncome; private double totalConsume; //老板只关注一共花了多少钱以及一共收入多少钱，其余并不关心 public void view(ConsumeBill bill) &#123; totalConsume += bill.getAmount(); &#125; public void view(IncomeBill bill) &#123; totalIncome += bill.getAmount(); &#125; public double getTotalIncome() &#123; System.out.println("老板查看一共收入多少，数目是：" + totalIncome); return totalIncome; &#125; public double getTotalConsume() &#123; System.out.println("老板查看一共花费多少，数目是：" + totalConsume); return totalConsume; &#125;&#125; 1234567891011121314//注册会计师类，查看账本的类之一public class CPA implements AccountBookViewer&#123; //注会在看账本时，如果是支出，则如果支出是工资，则需要看应该交的税交了没 public void view(ConsumeBill bill) &#123; if (bill.getItem().equals("工资")) &#123; System.out.println("注会查看工资是否交个人所得税。"); &#125; &#125; //如果是收入，则所有的收入都要交税 public void view(IncomeBill bill) &#123; System.out.println("注会查看收入交税了没。"); &#125;&#125; ​ 老板只关心收入和支出的总额，而注会只关注该交税的是否交税 ​ 接下来是账本类，它是当前访问者模式例子中的对象结构123456789101112131415//账本类（相当于ObjectStruture）public class AccountBook &#123; //单子列表 private List&lt;Bill&gt; billList = new ArrayList&lt;Bill&gt;(); //添加单子 public void addBill(Bill bill)&#123; billList.add(bill); &#125; //供账本的查看者查看账本 public void show(AccountBookViewer viewer)&#123; for (Bill bill : billList) &#123; bill.accept(viewer); &#125; &#125;&#125; ​ 账本类当中有一个列表，这个列表是元素（Bill）的集合，这便是对象结构的通常表示，它一般会是一堆元素的集合，不过这个集合不一定是列表，也可能是树，链表等等任何数据结构，甚至是若干个数据结构。其中show方法，就是账本类的精髓，它会枚举每一个元素，让访问者访问。 ​ 测试客户端12345678910111213141516171819202122public class Client &#123; public static void main(String[] args) &#123; AccountBook accountBook = new AccountBook(); //添加两条收入 accountBook.addBill(new IncomeBill(10000, "卖商品")); accountBook.addBill(new IncomeBill(12000, "卖广告位")); //添加两条支出 accountBook.addBill(new ConsumeBill(1000, "工资")); accountBook.addBill(new ConsumeBill(2000, "材料费")); AccountBookViewer boss = new Boss(); AccountBookViewer cpa = new CPA(); //两个访问者分别访问账本 accountBook.show(cpa); accountBook.show(boss); ((Boss) boss).getTotalConsume(); ((Boss) boss).getTotalIncome(); &#125;&#125; ​ 上面的代码中，可以这么理解，账本以及账本中的元素是非常稳定的，这些几乎不可能改变，而最容易改变的就是访问者这部分。 ​ 访问者模式最大的优点就是增加访问者非常容易，我们从代码上来看，如果要增加一个访问者，你只需要做一件事即可，那就是写一个类，实现AccountBookViewer接口，然后就可以直接调用AccountBook的show方法去访问账本了。 ​ 如果没使用访问者模式，一定会增加许多if else，而且每增加一个访问者，你都需要改你的if else，代码会显得非常臃肿，而且非常难以扩展和维护。 静态分派以及动态分派 ​ 变量被声明时的类型叫做变量的静态类型(Static Type)，有些人又把静态类型叫做明显类型(Apparent Type)；而变量所引用的对象的真实类型又叫做变量的实际类型(Actual Type)。比如：12List list = null;list = new ArrayList(); ​ 声明了一个变量list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。静态分派(Static Dispatch)发生在编译时期，分派根据静态类型信息发生。 静态分派 ​ 静态分派就是按照变量的静态类型进行分派，从而确定方法的执行版本，静态分派在编译时期就可以确定方法的版本。而静态分派最典型的应用就是方法重载.123456789101112131415161718public class Main &#123; public void test(String string)&#123; System.out.println("string"); &#125; public void test(Integer integer)&#123; System.out.println("integer"); &#125; public static void main(String[] args) &#123; String string = "1"; Integer integer = 1; Main main = new Main(); main.test(integer); main.test(string); &#125;&#125; ​ 在静态分派判断的时候，我们根据多个判断依据（即参数类型和个数）判断出了方法的版本，那么这个就是多分派的概念，因为我们有一个以上的考量标准，也可以称为宗量。所以JAVA是静态多分派的语言。 动态分派​ 对于动态分派，与静态相反，它不是在编译期确定的方法版本，而是在运行时才能确定。而动态分派最典型的应用就是多态的特性12345678910111213141516171819202122interface Person&#123; void test();&#125;class Man implements Person&#123; public void test()&#123; System.out.println("男人"); &#125;&#125;class Woman implements Person&#123; public void test()&#123; System.out.println("女人"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Person man = new Man(); Person woman = new Woman(); man.test(); woman.test(); &#125;&#125; ​ 这段程序输出结果为依次打印男人和女人，然而这里的test方法版本，就无法根据man和woman的静态类型去判断了，他们的静态类型都是Person接口，根本无从判断。 ​ 显然，产生的输出结果，就是因为test方法的版本是在运行时判断的，这就是动态分派。 ​ 动态分派判断的方法是在运行时获取到man和woman的实际引用类型，再确定方法的版本，而由于此时判断的依据只是实际引用类型，只有一个判断依据，所以这就是单分派的概念，这时我们的考量标准只有一个宗量，即变量的实际引用类型。相应的，这说明JAVA是动态单分派的语言。 访问者模式中的伪动态双分派 ​ 访问者模式中使用的是伪动态双分派，所谓的动态双分派就是在运行时依据两个实际类型去判断一个方法的运行行为，而访问者模式实现的手段是进行了两次动态单分派来达到这个效果。 ​ 回到上面例子当中账本类中的accept方法 ​ for (Bill bill : billList) {​ bill.accept(viewer);​ } ​ 这里就是依据biil和viewer两个实际类型决定了view方法的版本，从而决定了accept方法的动作。 ​ 分析accept方法的调用过程​ 1.当调用accept方法时，根据bill的实际类型决定是调用ConsumeBill还是IncomeBill的accept方法。 ​ 2.这时accept方法的版本已经确定，假如是ConsumeBill，它的accept方法是调用下面这行代码。 public void accept(AccountBookViewer viewer) {​ viewer.view(this); } ​ 此时的this是ConsumeBill类型，所以对应于AccountBookViewer接口的view(ConsumeBill bill)方法，此时需要再根据viewer的实际类型确定view方法的版本，如此一来，就完成了动态双分派的过程。 ​ 以上的过程就是通过两次动态双分派，第一次对accept方法进行动态分派，第二次对view（类图中的visit方法）方法进行动态分派，从而达到了根据两个实际类型确定一个方法的行为的效果。 ​ 而原本我们的做法，通常是传入一个接口，直接使用该接口的方法，此为动态单分派，就像策略模式一样。在这里，show方法传入的viewer接口并不是直接调用自己的view方法，而是通过bill的实际类型先动态分派一次，然后在分派后确定的方法版本里再进行自己的动态分派。 ​ 注意：这里确定view(ConsumeBill bill)方法是静态分派决定的，所以这个并不在此次动态双分派的范畴内，而且静态分派是在编译期就完成的，所以view(ConsumeBill bill)方法的静态分派与访问者模式的动态双分派并没有任何关系。动态双分派说到底还是动态分派，是在运行时发生的，它与静态分派有着本质上的区别，不可以说一次动态分派加一次静态分派就是动态双分派，而且访问者模式的双分派本身也是另有所指。 ​ 这里的this的类型不是动态确定的，你写在哪个类当中，它的静态类型就是哪个类，这是在编译期就确定的，不确定的是它的实际类型，请各位区分开这一点。 优缺点 ​ 优点： ​ 1、使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。 ​ 2、添加新的操作或者说访问者会非常容易。 ​ 3、将对各个元素的一组操作集中在一个访问者类当中。 ​ 缺点： ​ 1、增加新的元素会非常困难。 ​ 2、实现起来比较复杂，会增加系统的复杂性。 ​ 3、破坏封装，如果将访问行为放在各个元素中，则可以不暴露元素的内部结构和状态，但使用访问者模式的时候，为了让访问者能获取到所关心的信息，元素类不得不暴露出一些内部的状态和结构，就像收入和支出类必须提供访问金额和单子的项目的方法一样。点： 总结 ​ 访问者模式，主要是在数据结构不变的情况下，方便访问数据的操作改变或者增加。其实就是将稳定不变的数据结构与变化的数据访问操作分离开来，并将数据访问操作进行抽象和封装，使得可以很容易的增加数据访问操作。 参考资料：设计模式学习之访问者模式 ​ java设计模式-访问者模式visit ​ Java设计模式之访问者模式 中介者模式(Mediator)定义 ​ 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 ​ ①中介者模式主要用来将同事类之间网状结构变为星状结构，使同事类之间的关系变的清晰一些。 ②所有对象只跟中介者对象进行通信，相互之间不再有联系，这样也能够集中控制这些对象的交互关系。 问题背景 一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。 ​ 如果引入中介者模式，那么同事类之间的关系将变为星型结构，从图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。 结构 ​ 中介者模式的结构如下所示： ​ ①Mediator： 中介者接口。在里面定义各个同事之间交互需要的方法，可以是公共的通信方法，比如changed方法，大家都可以用（一般会传入同事类的this指针），也可以是小范围的交互方法。 ②ConcreteMediator：具体中介者实现对象。这需要了解并维扩各个同事对象，并负具体的协调各同事对象的交互关系。 ③Colleague：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。同事类的定义，通常实现为抽象类，主要负责约束同事对象的类型，并能实现一些具体同事类之间的公共功能。同时，一般会持有中介者的引用。在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。在中介者模式中，同事类之间必须通过中介者才能进行消息传递 ④ConcreteColleague：具体的同事类，实现自己的业务，在需要与其他同事通信的时候，就与持有的中介者通信，中介者会负责与其他的同事交互。 实际例子 我们使用一个例子来说明一下什么是同事类：有两个类A和B，类中各有一个数字，并且要保证类B中的数字永远是类A中数字的100倍。也就是说，当修改类A的数时，将这个数字乘以100赋给类B，而修改类B时，要将数除以100赋给类A。类A类B互相影响，就称为同事类。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647abstract class AbstractColleague &#123; protected int number; public int getNumber() &#123; return number; &#125; public void setNumber(int number)&#123; this.number = number; &#125; //抽象方法，修改数字时同时修改关联对象 public abstract void setNumber(int number, AbstractColleague coll);&#125;class ColleagueA extends AbstractColleague&#123; public void setNumber(int number, AbstractColleague coll) &#123; this.number = number; coll.setNumber(number*100); &#125;&#125;class ColleagueB extends AbstractColleague&#123;​ public void setNumber(int number, AbstractColleague coll) &#123; this.number = number; coll.setNumber(number/100); &#125;&#125;public class Client &#123; public static void main(String[] args)&#123; AbstractColleague collA = new ColleagueA(); AbstractColleague collB = new ColleagueB(); System.out.println("==========设置A影响B=========="); collA.setNumber(1288, collB); System.out.println("collA的number值："+collA.getNumber()); System.out.println("collB的number值："+collB.getNumber()); System.out.println("==========设置B影响A=========="); collB.setNumber(87635, collA); System.out.println("collB的number值："+collB.getNumber()); System.out.println("collA的number值："+collA.getNumber()); &#125;&#125; ​ 上面的代码中，类A类B通过直接的关联发生关系，假如我们要使用中介者模式，类A类B之间则不可以直接关联，他们之间必须要通过一个中介者来达到关联的目的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384abstract class AbstractColleague &#123; protected int number; public int getNumber() &#123; return number; &#125; public void setNumber(int number)&#123; this.number = number; &#125; //注意这里的参数不再是同事类，而是一个中介者 public abstract void setNumber(int number, AbstractMediator am);&#125;class ColleagueA extends AbstractColleague&#123; public void setNumber(int number, AbstractMediator am) &#123; this.number = number; am.AaffectB(); &#125;&#125;class ColleagueB extends AbstractColleague&#123; @Override public void setNumber(int number, AbstractMediator am) &#123; this.number = number; am.BaffectA(); &#125;&#125;abstract class AbstractMediator &#123; protected AbstractColleague A; protected AbstractColleague B; public AbstractMediator(AbstractColleague a, AbstractColleague b) &#123; A = a; B = b; &#125; public abstract void AaffectB(); public abstract void BaffectA();&#125;class Mediator extends AbstractMediator &#123; public Mediator(AbstractColleague a, AbstractColleague b) &#123; super(a, b); &#125; //处理A对B的影响 public void AaffectB() &#123; int number = A.getNumber(); B.setNumber(number*100); &#125; //处理B对A的影响 public void BaffectA() &#123; int number = B.getNumber(); A.setNumber(number/100); &#125;&#125;public class Client &#123; public static void main(String[] args)&#123; AbstractColleague collA = new ColleagueA(); AbstractColleague collB = new ColleagueB(); AbstractMediator am = new Mediator(collA, collB); System.out.println("==========通过设置A影响B=========="); collA.setNumber(1000, am); System.out.println("collA的number值为："+collA.getNumber()); System.out.println("collB的number值为A的10倍："+collB.getNumber()); System.out.println("==========通过设置B影响A=========="); collB.setNumber(1000, am); System.out.println("collB的number值为："+collB.getNumber()); System.out.println("collA的number值为B的0.1倍："+collA.getNumber()); &#125;&#125; ​ 虽然代码比较长，但是还是比较容易理解的，其实就是把原来处理对象关系的代码重新封装到一个中介类中，通过这个中介类来处理对象间的关系。 优缺点 ​ 中介者模式优点： 适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。 使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。 使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。 ​ 缺点： 潜在的过度集中化。如果同事对象的交互非常多，而且比较复杂。当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，难于管理和维护。 由于“中介“承担了较多的责任，所以一旦这个中介对象出现了问题，那么整个系统就会受到重大的影响。 适用场景 ​ 在面向对象编程中，一个类必然会与其他的类发生依赖关系，完全独立的类是没有意义的。一个类同时依赖多个类的情况也相当普遍，既然存在这样的情况，说明，一对多的依赖关系有它的合理性，适当的使用中介者模式可以使原本凌乱的对象关系清晰，但是如果滥用，则可能会带来反的效果。一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。 总结 ​ 中介者模式可以将同事类之间的复杂交互关系抽离出来形成单独类。同事类之间如果交互过多，则一个同事类发生改变，那么将牵扯到很多的同事类。引入中介者类后，一个同事类的改变只会影响到自身和中介者。 参考资料：第19章 行为型模式—中介者模式 ​ 23种设计模式（7）：中介者模式 [Java 设计模式之中介者模式](http://blog.csdn.net/jason0539/article/details/45216585)]]></content>
      <categories>
        <category>Java高级知识</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象思想]]></title>
    <url>%2F2018%2F03%2F29%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[一、设计原则 S.O.L.I.D 其他常见原则 二、三大特性 封装 继承 多态 三、类图 泛化关系 (Generalization) 实现关系 (Realization) 聚合关系 (Aggregation) 组合关系 (Composition) 关联关系 (Association) 依赖关系 (Dependency) 参考资料 一、设计原则S.O.L.I.D 简写 全拼 中文翻译 SRP The Single Responsibility Principle 单一责任原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 ISP The Interface Segregation Principle 接口分离原则 DIP The Dependency Inversion Principle 依赖倒置原则 1. 单一责任原则 修改一个类的原因应该只有一个。 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。 2. 开放封闭原则 类应该对扩展开放，对修改关闭。 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。 符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。 3. 里氏替换原则 子类对象必须能够替换掉所有父类对象。 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。 如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。 4. 接口分离原则 不应该强迫客户依赖于它们不用的方法。 因此使用多个专门的接口比使用单一的总接口要好。 5. 依赖倒置原则 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。 高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。 依赖于抽象意味着： 任何变量都不应该持有一个指向具体类的指针或者引用； 任何类都不应该从具体类派生； 任何方法都不应该覆写它的任何基类中的已经实现的方法。 其他常见原则除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。 简写 全拼 中文翻译 LOD The Law of Demeter 迪米特法则 CRP The Composite Reuse Principle 合成复用原则 CCP The Common Closure Principle 共同封闭原则 SAP The Stable Abstractions Principle 稳定抽象原则 SDP The Stable Dependencies Principle 稳定依赖原则 1. 迪米特法则迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。 2. 合成复用原则尽量使用对象组合，而不是继承来达到复用的目的。 3. 共同封闭原则一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。 4. 稳定抽象原则最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。 5. 稳定依赖原则包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。 二、三大特性封装利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 优点： 减少耦合：可以独立地开发、测试、优化、使用、理解和修改 减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块 有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能 提高软件的可重用性 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。 注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。 123456789101112131415161718192021public class Person &#123; private String name; private int gender; private int age; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender == 0 ? "man" : "woman"; &#125; public void work() &#123; if(18 &lt;= age &amp;&amp; age &lt;= 50) &#123; System.out.println(name + " is working very hard!"); &#125; else &#123; System.out.println(name + " can't work any more!"); &#125; &#125;&#125; 继承继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。 Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。 1Animal animal = new Cat(); 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。 多态多态分为编译时多态和运行时多态。编译时多态主要指方法的重载，运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定。 运行时多态有三个条件： 继承 覆盖 向上转型 下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。 12345678910111213141516171819202122232425262728public class Instrument &#123; public void play() &#123; System.out.println("Instument is playing..."); &#125;&#125;public class Wind extends Instrument &#123; public void play() &#123; System.out.println("Wind is playing..."); &#125;&#125;public class Percussion extends Instrument &#123; public void play() &#123; System.out.println("Percussion is playing..."); &#125;&#125;public class Music &#123; public static void main(String[] args) &#123; List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;(); instruments.add(new Wind()); instruments.add(new Percussion()); for(Instrument instrument : instruments) &#123; instrument.play(); &#125; &#125;&#125; 三、类图泛化关系 (Generalization)用来描述继承关系，在 Java 中使用 extends 关键字。 实现关系 (Realization)用来实现一个接口，在 Java 中使用 implement 关键字。 聚合关系 (Aggregation)表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。 组合关系 (Composition)和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。 关联关系 (Association)表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 依赖关系 (Dependency)和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式： A 类是 B 类中的（某中方法的）局部变量； A 类是 B 类方法当中的一个参数； A 类向 B 类发送消息，从而影响 B 类发生变化； 参考资料 Java 编程思想 敏捷软件开发：原则、模式与实践 面向对象设计的 SOLID 原则 看懂 UML 类图和时序图 UML 系列——时序图（顺序图）sequence diagram 面向对象编程三大特性 —— 封装、继承、多态]]></content>
      <categories>
        <category>编程基础知识</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2018%2F03%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL%2F</url>
    <content type="text"><![CDATA[一、基础 二、创建表 三、修改表 四、插入 五、更新 六、删除 七、查询 八、排序 九、过滤 十、通配符 十一、计算字段 十二、函数 十三、分组 十四、子查询 十五、连接 十六、组合查询 十七、视图 十八、存储过程 十九、游标 二十、触发器 二十一、事务处理 二十二、字符集 二十三、权限管理 参考资料 一、基础模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。 主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。 SQL 支持以下三种注释： 12345# 注释SELECT *FROM mytable; -- 注释/* 注释1 注释2 */ 数据库创建与使用： 12CREATE DATABASE test;USE test; 二、创建表123456CREATE TABLE mytable ( id INT NOT NULL AUTO_INCREMENT, col1 INT NOT NULL DEFAULT 1, col2 VARCHAR(45) NULL, col3 DATE NULL, PRIMARY KEY (`id`)); 三、修改表添加列 12ALTER TABLE mytableADD col CHAR(20); 删除列 12ALTER TABLE mytableDROP COLUMN col; 删除表 1DROP TABLE mytable; 四、插入普通插入 12INSERT INTO mytable(col1, col2)VALUES(val1, val2); 插入检索出来的数据 123INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2; 将一个表的内容插入到一个新表 12CREATE TABLE newtable ASSELECT * FROM mytable; 五、更新123UPDATE mytableSET col = valWHERE id = 1; 六、删除12DELETE FROM mytableWHERE id = 1; TRUNCATE TABLE 可以清空表，也就是删除所有行。 1TRUNCATE TABLE mytable; 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。 七、查询DISTINCT相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 12SELECT DISTINCT col1, col2FROM mytable; LIMIT限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 返回前 5 行： 123SELECT *FROM mytableLIMIT 5; 123SELECT *FROM mytableLIMIT 0, 5; 返回第 3 ~ 5 行： 123SELECT *FROM mytableLIMIT 2, 3; 八、排序 ASC ：升序（默认） DESC ：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式： 123SELECT *FROM mytableORDER BY col1 DESC, col2 ASC; 九、过滤不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。 123SELECT *FROM mytableWHERE col IS NULL; 下表显示了 WHERE 子句可用的操作符 操作符 说明 = &lt; &gt; 等于 小于 大于 &lt;&gt; != 不等于 &lt;= !&gt; 小于等于 &gt;= !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为 NULL 值 应该注意到，NULL 与 0、空字符串都不同。 AND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 十、通配符通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配 &gt;=0 个任意字符； _ 匹配 ==1 个任意字符； [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 使用 Like 来进行通配符匹配。 123SELECT *FROM mytableWHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本 不要滥用通配符，通配符位于开头处匹配会非常慢。 十一、计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12SELECT col1 * col2 AS aliasFROM mytable; CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 12SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_colFROM mytable; 十二、函数各个 DBMS 的函数都是不相同的，因此不可移植。 文本处理 函数 说明 LEFT() RIGHT() 左边或者右边的字符 LOWER() UPPER() 转换为小写或者大写 LTRIM() RTIM() 去除左边或者右边的空格 LENGTH() 长度 SOUNDEX() 转换为语音值 其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。 123SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple') 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 1mysql&gt; SELECT NOW(); 12018-4-14 20:25:11 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以让汇总函数值汇总不同的值。 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable 十三、分组分组就是把具有相同的数据值的行放在同一组中。 可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。 指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。 123SELECT col, COUNT(*) AS numFROM mytableGROUP BY col; GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。 1234SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num; WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。 12345SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING num &gt;= 2; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 十四、子查询子查询中只能返回一个字段的数据。 可以将子查询的结果作为 WHRER 语句的过滤条件： 1234SELECT *FROM mytable1WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次： 123456SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM CustomersORDER BY cust_name; 十五、连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123SELECT a, b, cFROM A INNER JOIN BON A.key = B.key; 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123SELECT a, b, cFROM A, BWHERE A.key = B.key; 在没有条件语句的情况下返回笛卡尔积。 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 123456SELECT nameFROM employeeWHERE department = ( SELECT department FROM employee WHERE name = "Jim"); 自连接版本 1234SELECT e1.nameFROM employee AS e1, employee AS e2WHERE e1.department = e2.department AND e2.name = "Jim"; 连接一般比子查询的效率高。 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 12SELECT *FROM employee NATURAL JOIN department; 外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; 如果需要统计顾客的订单数，使用聚集函数。 12345SELECT Customers.cust_id, COUNT(Orders.order_num) AS num_ordFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id; 十六、组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。 每个查询必须包含相同的列、表达式和聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 十七、视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。 对视图的操作和对普通表的操作一样。 视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的连接； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 1234CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_colFROM mytableWHERE col5 = val; 十八、存储过程存储过程可以看成是对一系列 SQL 操作的批处理； 使用存储过程的好处 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 1234567891011delimiter //create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end //delimiter ; 12call myprocedure(@ret);select @ret; 十九、游标在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； 1234567891011121314151617181920delimiter //create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate '02000' set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 二十、触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化。 INSERT 触发器包含一个名为 NEW 的虚拟表。 1234CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col into @result;SELECT @result; -- 获取结果 DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。 MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。 二十一、事务处理基本术语： 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过设置 autocommit 为 0 可以取消自动提交，直到 autocommit 被设置为 1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。 1234567START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT 二十二、字符集基本术语： 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定： 123CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对： 123SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci; 二十三、权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 12USE mysql;SELECT user FROM user; 创建账户 1CREATE USER myuser IDENTIFIED BY 'mypassword'; 新创建的账户没有任何权限。 修改账户名 1RENAME myuser TO newuser; 删除账户 1DROP USER myuser; 查看权限 1SHOW GRANTS FOR myuser; 授予权限 1GRANT SELECT, INSERT ON mydatabase.* TO myuser; 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 删除权限 1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 更改密码 必须使用 Password() 函数 1SET PASSWROD FOR myuser = Password('new_password'); 参考资料 BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.]]></content>
      <categories>
        <category>数据库</category>
        <category>编程基础知识</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA学习]]></title>
    <url>%2F2018%2F03%2F05%2F1_Java%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JAVA学习Java常用知识一、数组的三种创建方式及区别​ 创建数组的三种方式：其实分为2类,一种是静态的创建，如方式一。一种是动态的创建，只不过根据写法的不同分为方式二和方式三：12345678910public static void main(String[] args) &#123; // 1.方式一 声明 分配空间并赋值 int[] arr1 = &#123;1,2,3&#125;; // 2.方式二 显示初始化 int[] arr2; arr2 = new int[]&#123;1,2,3&#125;; // 3.方式三 显示初始化() int[] arr3; arr3 = new int[3];&#125; ​ 他们的区别，方式一：在声明的时候直接就已经分配空间，并赋值，方式一是不能写成如下这种形式的。12int[] arr1;arr1 = &#123;1,2,3&#125;;//错误写法 编译不同过 ​ 方式二和方式三,声明和内存分配是分开的，如上面的例子，1int[] arr2; 和 int[] arr3; ​ 这一步是在栈空间分配一个引用，存放的是一个引用，null12arr2 = new int[]&#123;1,2,3&#125;;arr3 = new int[3];&lt;/span&gt; ​ 到这一步的时候jvm才开始在内存堆区域分配空间，并赋值，方式二直接赋值 1,2,3 方式三 默认初始化，基本类型是 0 布尔类型是 false 引用类型为null， 注意：内存一旦分配不能改变，所有说数组长度固定 二、Integer执行++操作解析​ 当我们对基本类型int的包装类进行自增操作，返回的值不是原来的对象：12345678910package com.qianqiang; public class Demo &#123; public static void main(String[] args) &#123; Integer inttest=new Integer(15); Integer inttest2=inttest++; System.out.println(inttest==inttest2); &#125; &#125; ​ 答案输出的是false，这是因为Integer执行自加操作的时候，是要进行拆箱操作即调用Integer的intValue返回基本类型数据，执行完自增以后，再调用Integer的装箱操作即调用valueOf重新创建对象。当然如果值的范围是在（-128-127）之间调用Integer已经缓存的对象，上面的代码中返回inttest2返回15的Integer缓存的对象。而此时的inttest因为值自增了1，变为16，所以要调用装箱操作，返回Integer中的已经缓存的16对应的Integer对象。 三、Java 与 C++ 的区别Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java C++ Java does not support pointers, templates, unions, operator overloading, structures etc. The Java language promoters initially said “No pointers!”, but when many programmers questioned how you can work without pointers, the promoters began saying “Restricted pointers.” Java supports what it calls “references”. References act a lot like pointers in C++ languages but you cannot perform arithmetic on pointers in Java. References have types, and they’re type-safe. These references cannot be interpreted as raw address and unsafe conversion is not allowed. C++ supports structures, unions, templates, operator overloading, pointers and pointer arithmetic. Java support automatic garbage collection. It does not support destructors as C++ does. C++ support destructors, which is automatically invoked when the object is destroyed. Java does not support conditional compilation and inclusion. Conditional inclusion (#ifdef #ifndef type) is one of the main features of C++. Java has built in support for threads. In Java, there is a Thread class that you inherit to create a new thread and override the run() method. C++ has no built in support for threads. C++ relies on non-standard third-party libraries for thread support. Java does not support default arguments. There is no scope resolution operator (::) in Java. The method definitions must always occur within a class, so there is no need for scope resolution there either. C++ supports default arguments. C++ has scope resolution operator (::) which is used to to define a method outside a class and to access a global variable within from the scope where a local variable also exists with the same name. There is no goto statement in Java. The keywords const and goto are reserved, even though they are not used. C++ has goto statement. However, it is not considered good practice to use of goto statement. Java doesn’t provide multiple inheritance, at least not in the same sense that C++ does. C++ does support multiple inheritance. The keyword virtual is used to resolve ambiguities during multiple inheritance if there is any. Exception handling in Java is different because there are no destructors. Also, in Java, try/catch must be defined if the function declares that it may throw an exception. While in C++, you may not include the try/catch even if the function throws an exception. Java has method overloading, but no operator overloading. The String class does use the + and += operators to concatenate strings and Stringexpressions use automatic type conversion, but that’s a special built-in case. C++ supports both method overloading and operator overloading. Java has built-in support for documentation comments (/** ... */); therefore, Java source files can contain their own documentation, which is read by a separate tool usually javadoc and reformatted into HTML. This helps keeping documentation maintained in easy way. C++ does not support documentation comments. Java is interpreted for the most part and hence platform independent. C++ generates object code and the same code may not run on different platforms. What are the main differences between Java and C++? 四、方法中的局部变量不会初始化​ 类变量、实例变量，如果不对他们进行显示的初始化，编译器会给他们赋值默认的初始值。但是对于方法体重局部变量，如果不进行显示的初始化操作，那么编译器也不会给它默认值，并且会编译报错。 ​ 可以看到，在idea开发环境中，直接就报错了。 Java语言三大特性Java语言的三大特性即是：封装、继承、多态 Java基础知识总结转载地址:http://www.cnblogs.com/BYRans/p/Java.html 一：java概述1，JDK：Java Development Kitjava的开发和运行环境，java的开发工具和jre。 2，JRE：Java Runtime Environmentjava程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。 3，配置环境变量:让java jdk\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。 环境变量的配置： 1）：永久配置方式： JAVA_HOME=%安装路径%\Java\jdk path=%JAVA_HOME%\bin 2）：临时配置方式： set path=%path%;C:\Program Files\Java\jdk\bin 特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。 classpath的配置:1）：永久配置方式：classpath=.;c:\;e:\ 2）：临时配置方式：set classpath=.;c:\;e:\ 注意：在定义classpath环境变量时，需要注意的情况，如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件； 如果指定了classpath，那么会在指定的目录下查找要运行的类文件。还会在当前目录找吗？两种情况： 注意classpath环境变量前面的那个小点”.”，这个点就代表当前目录，如果有这个点的话，就会先在当前目录下查找要运行的类，如果没有的话，那么就不会在当前目录下找。 CLASSPATH是什么？它的作用是什么？它是javac编译器的一个环境变量。它的作用与import、package关键字有关。当你写下improt java.util.*时，编译器面对import关键字时，就知道你要引入java.util这个package中的类；但是编译器如何知道你把这个package放在哪里了呢？所以你首先得告诉编译器这个package的所在位置；如何告诉它呢？就是设置CLASSPATH啦 :) 如果java.util这个package在c:/jdk/ 目录下，你得把c:/jdk/这个路径设置到CLASSPATH中去！当编译器面对import java.util.*这个语句时，它先会查找CLASSPATH所指定的目录，并检视子目录java/util是否存在，然后找出名称吻合的已编译文件（.class文件）。如果没有找到就会报错！ CLASSPATH有点像c/c++编译器中的INCLUDE路径的设置哦，是不是？当c/c++编译器遇到include 这样的语句，它是如何运作的？哦，其实道理都差不多！搜索INCLUDE路径，检视文件！当你自己开发一个package时，然后想要用这个package中的类；自然，你也得把这个package所在的目录设置到CLASSPATH中去！ CLASSPATH的设定，对JAVA的初学者而言是一件棘手的事。所以Sun让JAVA2的JDK更聪明一些。你会发现，在你安装之后，即使完全没有设定CLASSPATH，你仍然能够编译基本的JAVA程序，并且加以执行。 PATH环境变量PATH环境变量。作用是指定命令搜索路径，在命令行下面执行命令如javac编译java程序时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序。我们需要把jdk安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件如javac/java/javadoc等待，设置好PATH变量后，就可以在任何目录下执行javac/java等工具了。 4，javac命令和java命令做什么事情呢？要知道java是分两部分的：一个是编译，一个是运行。 javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。 java：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行. 一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数. 二：java语法基础1. 标示符：1），数字不可以开头。 2），不可以使用关键字。 2. 变量的作用域和生存期:变量的作用域：作用域从变量定义的位置开始，到该变量所在的那对大括号结束； 生命周期：变量从定义的位置开始就在内存中活了；变量到达它所在的作用域的时候就在内存中消失了； 3. 数据类型：1）基本数据类型：byte、short、int、long、float、double、char、boolean 简单类型 boolean byte char short int long float double void 二进制位数 1 8 16 16 32 64 32 64 – 封装器类 Boolean Byte Character Short Integer Long Float Double Void 4. 运算符号：1). 逻辑运算符。&amp; | ^ ! &amp;&amp; || 逻辑运算符除了 ! 外都是用于连接两个boolean类型表达式。 &amp;: 只有两边都为true结果是true。否则就是false。 |:只要两边都为false结果是false，否则就是true ^:异或：和或有点不一样。两边结果一样，就为false。两边结果不一样，就为true. &amp; 和 &amp;&amp;区别： &amp; ：无论左边结果是什么，右边都参与运算。 &amp;&amp;:短路与，如果左边为false，那么右边不参与运算。 | 和|| 区别：|：两边都运算。||：短路或，如果左边为true，那么右边不参 2). 位运算符:用于操作二进制位的运算符。 &amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移) 练习：对两个变量的数据进行互换。不需要第三方变量。 int a = 3,b = 5;–&gt;b = 3,a = 5; 1234567891011121314151617方法一： a = a + b; a = 8; b = a - b; b = 3; a = a - b; a = 5;方法二： a = a ^ b;// b = a ^ b;//b = a ^ b ^ b = a a = a ^ b;//a = a ^ b ^ a = b;练习：高效的算出 2*8 = 2&lt;&lt;3; 5. 重载与重写重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。重写：父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。#### 6. Java内存管理Java内存管理：深入Java内存区域Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。##### 1） 概述：对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的”所有权”，又担负着每一个对象生命开始到终结的维护责任。对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。##### 2) 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：##### 3) 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为”线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 4) Java虚拟机栈与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的”堆”在后面会专门讲述，而所指的”栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。##### 5) 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。##### 6) Java堆对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么”绝对”了。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做”GC堆”（Garbage Collected Heap，幸好国内没翻译成”垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配和回收等细节将会是下一章的主题。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。##### 7) 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为”永久代”Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并”搬家”至Native Memory来实现方法区的规划了。Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样”永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收”成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中， 曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。##### 8) 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。#### 7. 对象访问介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码： Object obj = new Object();假设这句代码出现在方法体中，那”Object obj”这部分的语义将会反映到Java栈的本地变量表中，作为一个reference类型数据出现。而”new Object()”这部分的语义将会反映到Java堆中，形成一块存储了Object类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示：如果使用的是直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如下图所示：这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。### 三：面向对象：★★★★★#### 类匿名对象使用场景：1：当对方法只进行一次调用的时候，可以使用匿名对象。2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。类中怎么没有定义主函数呢？注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。成员变量和局部变量的区别：1：成员变量直接定义在类中。局部变量定义在方法中，参数上，语句中。2：成员变量在这个类中有效。局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。构造函数：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。特点：1. 该函数的名称和所在类的名称相同。2. 不需要定义返回值类型。3. 该函数没有具体的返回值。记住：所有对象创建时，都需要初始化才可以使用。注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。构造代码块和构造函数有什么区别？构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。构造函数：是给与之对应的对象进行初始化。它具有针对性。1. 执行顺序：（优先级从高到低。）静态代码块&gt;mian方法&gt;构造代码块&gt;构造方法。其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。2. 静态代码块的作用：比如我们在调用C语言的动态库时会可把.so文件放在此处。3. 构造代码块的功能：（可以把不同构造方法中相同的共性的东西写在它里面）。例如：比如不论任何机型的电脑都有开机这个功能，此时我们就可以把这个功能定义在构造代码块内。 Person p = new Person();创建一个对象都在内存中做了什么事情？ 1：先将硬盘上指定位置的Person.class文件加载进内存。 2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。 3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new 4：在该实体空间中进行属性的空间分配，并进行了默认初始化。 5：对空间中的属性进行显示初始化。 6：进行实体的构造代码块初始化。 7：调用该实体对应的构造函数，进行构造函数初始化。（） 8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象) 封 装（面向对象特征之一）：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。好处：将变化隔离；便于使用；提高重用性；安全性。 封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。 this:代表对象。就是所在函数所属对象的引用。this到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。开发时，什么时候使用this呢？在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。this 还可以用于构造函数间的调用。调用格式：this(实际参数)；this对象后面跟上 . 调用的是成员属性和成员方法(一般方法)；this对象后面跟上 () 调用的是本类中的对应参数的构造函数。注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。 否则编译失败。 static：★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。特点：1、static变量按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。2、静态方法静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。3、static代码块static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。4、static和final一块用表示什么static final用来修饰成员变量和成员方法，可简单理解为”全局常量”！对于变量，表示一旦给值就不可修改，并且通过类名可以访问。对于方法，表示不可覆盖，并且可以通过类名直接访问。备注： 1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。 2，静态方法只能访问静态成员，不可以访问非静态成员。 (这句话是针对同一个类环境下的，比如说，一个类有多个成员（属性，方法，字段），静态方法A，那么可以访问同类名下其他静态成员，你如果访问非静态成员就不行) 因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。 3，静态方法中不能使用this，super关键字。 因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。 4，主函数是静态的。 成员变量和静态变量的区别： 1，成员变量所属于对象。所以也称为实例变量。 静态变量所属于类。所以也称为类变量。 2，成员变量存在于堆内存中。 静态变量存在于方法区中。 3，成员变量随着对象创建而存在。随着对象被回收而消失。 静态变量随着类的加载而存在。随着类的消失而消失。 4，成员变量只能被对象所调用 。 静态变量可以被对象调用，也可以被类名调用。 所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。 静态代码块：就是一个有静态关键字标示的一个代码块区域。定义在类中。作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。final 根据程序上下文环境，Java关键字final有”这是无法改变的”或者”终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变、设计或效率。 final类不能被继承，没有子类，final类中的方法默认是final的。 final方法不能被子类的方法覆盖，但可以被继承。 final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 final不能用于修饰构造方法。 注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。 1、final类 final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。 2、final方法 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。 使用final方法的原因有二： 第一、把方法锁定，防止任何继承类修改它的意义和实现。 第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。 3、final变量（常量） 用final修饰的成员变量表示常量，值一旦给定就无法改变！ final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。 从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。 另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。 4、final参数 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。 生成Java帮助文档：命令格式：javadoc –d 文件夹名 –auther –version *.java12345678910111213141516171819/** //格式*类描述*@author 作者名*@version 版本号*//***方法描述*@param 参数描述*@return 返回值描述*/#### 继 承（面向对象特征之一）java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是可实现多接口。##### 1：成员变量。当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。如果想要调用父类中的属性值，需要使用一个关键字：super This：代表是本类类型的对象引用。Super：代表是子类所属的父类中的内存空间引用。注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。##### 2：成员函数。当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：重写 3：构造函数。发现子类构造函数运行时，先运行了父类的构造函数。为什么呢? 原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super(); super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。 为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?) 因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。 注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。 问题： super()和this()是否可以同时出现的构造函数中？ 两个语句只能有一个定义在第一行，所以只能出现其中一个。 super()或者this():为什么一定要定义在第一行？ 因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。 在方法覆盖时，注意两点： 1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。（举个例子，在父类中是public的方法，如果子类中将其降低访问权限为private，那么子类中重写以后的方法对于外部对象就不可访问了，这个就破坏了继承的含义） 2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖) 继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。 这时如何解决问题呢？介绍一个关键字，final。 final特点：（详细解释见前面） 1：这个关键字是一个修饰符，可以修饰类，方法，变量。 2：被final修饰的类是一个最终类，不可以被继承。 3：被final修饰的方法是一个最终方法，不可以被覆盖。 4：被final修饰的变量是一个常量，只能赋值一次。 抽象类: abstract 抽象类的特点： 1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。2：抽象方法只定义方法声明，并不定义方法实现。3：抽象类不可以被创建对象(实例化)。4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。 抽象类的细节： 1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。 2：抽象类中是否可以定义非抽象方法？ 可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。 3：抽象关键字abstract和哪些不可以共存？final , private , static 4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。 接 口：★★★★★1：是用关键字interface定义的。 2：接口中包含的成员，最常见的有全局常量、抽象方法。 注意：接口中的成员都有固定的修饰符。 &emsp;&emsp;成员变量：public static final &emsp;&emsp;成员方法：public abstract1234567interface Inter&#123; public static final int x = 3; public abstract void show();&#125; 3：接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。 4：类与类之间存在着继承关系，类与接口中间存在的是实现关系。 &emsp;&emsp;继承用extends ；实现用implements ； 5：接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。 6：一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。 7：其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。 java类是单继承的。classB Extends classA java接口可以多继承。Interface3 Extends Interface0, Interface1, interface…… 不允许类多重继承的主要原因是，如果A同时继承B和C，而b和c同时有一个D方法，A如何决定该继承那一个呢？ 但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。 抽象类与接口： 抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。 接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。 抽象类和接口的共性：都是不断向上抽取的结果。 抽象类和接口的区别： 1：抽象类只能被继承，而且只能单继承。接口需要被实现，而且可以多实现。2：抽象类中可以定义非抽象方法，子类可以直接继承使用。接口中都是抽象方法，需要子类去实现。3：抽象类使用的是 is a 关系。接口使用的 like a 关系。4：抽象类的成员修饰符可以自定义。 接口中的成员修饰符是固定的。全都是public的。 多 态★★★★★多 态★★★★★（面向对象特征之一）：函数本身就具备多态性，某一种事物有不同的具体的体现。体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();父类可以调用子类中覆写过的（父类中有的方法）多态的好处：提高了程序的扩展性。继承的父类或接口一般是类库中的东西，（如果要修改某个方法的具体实现方式）只有通过子类去覆写要改变的某一个方法，这样在通过将父类的应用指向子类的实例去调用覆写过的方法就行了！多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)多态的前提： 必须要有关系，比如继承、或者实现。 通常会有覆盖操作。 如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？ 可以可以通过一个关键字 instanceof ;//判断对象是否实现了指定的接口或继承了指定的类 格式：&lt;对象 instanceof 类型&gt; ，判断一个对象是否所属于指定的类型。 Student instanceof Person = true;//student继承了person类 -—————————————————————————-———java.lang.Object Object：所有类的直接或者间接父类，Java认为所有的对象都具备一些基本的共性内容，这些内容可以不断的向上抽取，最终就抽取到了一个最顶层的类中的，该类中定义的就是所有对象都具备的功能。具体方法：1. boolean equals(Object obj)：用于比较两个对象是否相等，其实内部比较的就是两个对象地址。2. String toString()：将对象变成字符串；默认返回的格式：类名@哈希值 = getClass().getName() + ‘@’ + Integer.toHexString(hashCode()) 为了对象对应的字符串内容有意义，可以通过复写，建立该类对象自己特有的字符串表现形式。12345public String toString()&#123; return &quot;person : &quot;+age;&#125;3. Class getClass()：获取任意对象运行时的所属字节码文件对象。4. int hashCode()：返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。将该对象的内部地址转换成一个整数来实现的。通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。 -————————————————————————— 内部类：如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。-————————————————————————–1234567891011121314151617181920212223class Outer&#123; int num = 4; class Inner &#123; void show()&#123; System.out.println(&quot;inner show run &quot;+num); &#125; &#125; public void method()&#123; Inner in = new Inner();//创建内部类的对象。 in.show();//调用内部类的方法。 //内部类直接访问外部类成员，用自己的实例对象； &#125; //外部类访问内部类要定义内部类的对象；&#125;-—————————————————————————–当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。1：默认修饰符。直接访问内部类格式：外部类名.内部类名 变量名 = 外部类对象.内部类对象; Outer.Inner in = new Outer.new Inner();//这种形式很少用。 但是这种应用不多见，因为内部类之所以定义在内部就是为了封装。想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。 2：私有修饰符。 通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。 3：静态修饰符。 如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。 注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。 内部类编译后的文件名为：”外部类名$内部类名.java”； 为什么内部类可以直接访问外部类中的成员呢？ 那是因为内部中都持有一个外部类的引用。这个是引用是 外部类名.this 内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。 当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。 匿名内部类（对象）：没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。 匿名内部类的格式：new 父类名&amp;接口名(){ 定义子类成员或者覆盖父类方法 }.方法。 匿名内部类的使用场景： 当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。 其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。 -—————————————————————————-123456789101112131415161718192021222324252627//面试 //1 new Object()&#123; void show()&#123; System.out.println(&quot;show run&quot;); &#125; &#125;.show(); //写法和编译都没问题 //2 Object obj = new Object()&#123; void show()&#123; System.out.println(&quot;show run&quot;); &#125; &#125;; obj.show(); //写法正确，编译会报错 1和2的写法正确吗？有区别吗？说出原因。 写法是正确，1和2都是在通过匿名内部类建立一个Object类的子类对象。 区别： 第一个可是编译通过，并运行。 第二个编译失败，因为匿名内部类是一个子类对象，当用Object的obj引用指向时，就被提升为了Object类型，而编译时会检查Object类中是否有show方法，此时编译失败。 异 常：★★★★–java.lang.Throwable： Throwable：可抛出的。&emsp;&emsp;|–Error：错误，一般情况下，不编写针对性的代码进行处理，通常是jvm发生的，需要对程序进行修正。&emsp;&emsp;|–Exception：异常，可以有针对性的处理方式这个体系中的所有类和对象都具备一个独有的特点；就是可抛性。可抛性的体现：就是这个体系中的类和对象都可以被throws和throw两个关键字所操作。throw与throws区别：throws是用来声明一个方法可能抛出的所有异常信息，而throw则是指抛出的一个具体的异常类型。此外throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。throw用于抛出异常对象，后面跟的是异常对象；throw用在函数内。throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。throws格式：方法名（参数）throws 异常类1，异常类2，…..throw：就是自己进行异常处理，处理的时候有两种方式，要么自己捕获异常（也就是try catch进行捕捉），要么声明抛出一个异常（就是throws 异常~~）。处理方式有两种：1、捕捉；2、抛出。对于捕捉：java有针对性的语句块进行处理。 try { 需要被检测的代码； } catch(异常类 变量名){ 异常处理代码； } fianlly{ 一定会执行的代码； }定义异常处理时，什么时候定义try，什么时候定义throws呢？定义异常处理时，什么时候定义try，什么时候定义throws呢？ 功能内部如果出现异常，如果内部可以处理，就用try； 如果功能内部处理不了，就必须声明出来，让调用者处理。使用throws抛出，交给调用者处理。谁调用了这个功能谁就是调用者； 自定义异常的步骤： 1：定义一个子类继承Exception或RuntimeException，让该类具备可抛性(既可以使用throw和throws去调用此类)。 2：通过throw 或者throws进行操作。 异常的转换思想：当出现的异常是调用者处理不了的，就需要将此异常转换为一个调用者可以处理的异常抛出。try catch finally的几种结合方式： trycatchfinally trycatch tryfinally 这种情况，如果出现异常，并不处理，但是资源一定关闭，所以try finally集合只为关闭资源。 记住：finally很有用，主要用户关闭资源。无论是否发生异常，资源都必须进行关闭。System.exit(0); //退出jvm，只有这种情况finally不执行。注意：如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，如果子类的覆盖的方法中出现了异常，只能try不能throws。如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，这样，子类的方法上是不需要throws声明的。##### 多线程：★★★★返回当前线程的名称：Thread.currentThread().getName() 线程的名称是由：Thread-编号定义的。编号从0开始。 线程要运行的代码都统一存放在了run方法中。 线程要运行必须要通过类中指定的方法开启。start方法。（启动后，就多了一条执行路径） start方法：1）、启动了线程；2）、让jvm调用了run方法。Thread类中run()和start()方法的区别：start()：用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。run()：run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。总结：start()方法最本质的功能是从CPU中申请另一个线程空间来执行 run()方法中的代码,它和当前的线程是两条线,在相对独立的线程空间运行,也就是说,如果你直接调用线程对象的run()方法,当然也会执行,但那是 在当前线程中执行,run()方法执行完成后继续执行下面的代码.而调用start()方法后,run()方法的代码会和当前线程并发(单CPU)或并行 (多CPU)执行。所以请记住一句话：调用线程对象的run方法不会产生一个新的线程，虽然可以达到相同的执行结果,但执行过程和执行效率不同创建线程的第一种方式：继承Thread ，由子类复写run方法。 步骤： &emsp;&emsp;1，定义类继承Thread类； &emsp;&emsp;2，目的是复写run方法，将要让线程运行的代码都存储到run方法中； &emsp;&emsp;3，通过创建Thread类的子类对象，创建线程对象； &emsp;&emsp;4，调用线程的start方法，开启线程，并执行run方法。 线程状态： 被创建：start() 运行：具备执行资格，同时具备执行权； 冻结：sleep(time),wait()—notify()唤醒；线程释放了执行权，同时释放执行资格； 临时阻塞状态：线程具备cpu的执行资格，没有cpu的执行权； 消亡：stop() 创建线程的第二种方式：实现一个接口Runnable。 步骤： &emsp;&emsp;1，定义类实现Runnable接口。 &emsp;&emsp;2，覆盖接口中的run方法（用于封装线程要运行的代码）。 &emsp;&emsp;3，通过Thread类创建线程对象； &emsp;&emsp;4，将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。 &emsp;&emsp;为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。 &emsp;&emsp;5，调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。 Ticket t = new Ticket(); /* 直接创建Ticket对象，并不是创建线程对象。 因为创建对象只能通过new Thread类，或者new Thread类的子类才可以。 所以最终想要创建线程。既然没有了Thread类的子类，就只能用Thread类。 */ Thread t1 = new Thread(t); //创建线程。 /* 只要将t作为Thread类的构造函数的实际参数传入即可完成线程对象和t之间的关联 为什么要将t传给Thread类的构造函数呢？其实就是为了明确线程要运行的代码run方法。 */ t1.start(); 为什么要有Runnable接口的出现？ 1：通过继承Thread类的方式，可以完成多线程的建立。但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承Thread类，因为java单继承的局限性。 可是该类中的还有部分代码需要被多个线程同时执行。这时怎么办呢？ 只有对该类进行额外的功能扩展，java就提供了一个接口Runnable。这个接口中定义了run方法，其实run方法的定义就是为了存储多线程要运行的代码。 所以，通常创建线程都用第二种方式。 因为实现Runnable接口可以避免单继承的局限性。 2：其实是将不同类中需要被多线程执行的代码进行抽取。将多线程要运行的代码的位置单独定义到接口中。为其他类进行功能扩展提供了前提。 所以Thread类在描述线程时，内部定义的run方法，也来自于Runnable接口。 实现Runnable接口可以避免单继承的局限性。而且，继承Thread，是可以对Thread类中的方法，进行子类复写的。但是不需要做这个复写动作的话，只为定义线程代码存放位置，实现Runnable接口更方便一些。所以Runnable接口将线程要执行的任务封装成了对象。 -—————————————————— //面试 new Thread(new Runnable(){ //匿名 public void run(){ System.out.println(&quot;runnable run&quot;); } }) ​ { public void run(){ System.out.println(&quot;subthread run&quot;); } }.start(); //结果：subthread run -——————————————————– synchronized关键字（一） 一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。 四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。 五、以上规则对其它对象锁同样适用. package ths; public class Thread1 implements Runnable { public void run() { synchronized(this) { for (int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName()+&quot;synchronized loop &quot; + i); } } } } synchronized关键字（二） synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。 1. synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如： public synchronized void accessVal(int newVal); synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。 在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。 synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized 块。 2. synchronized 块：通过 synchronized关键字来声明synchronized 块。语法如下： synchronized(syncObject) { //允许访问控制的代码 } synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。 对synchronized(this)的一些理解 一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。 四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。 五、以上规则对其它对象锁同样适用 解决安全问题的原理： 只要将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。 如何保障共享数据的线程安全呢？ java中提供了一个解决方式：就是同步代码块。 格式： synchronized(对象) { //任意对象都可以。这个对象就是共享数据。 需要被同步的代码； } -————————————————————–-————————————————————– 同步：★★★★★ 好处：解决了线程安全问题。Synchronized 弊端：相对降低性能，因为判断锁需要消耗资源，产生了死锁。 同步的第二种表现形式： //对共享资源的方法定义同步 同步函数：其实就是将同步关键字定义在函数上，让函数具备了同步性。同步函数是用的哪个锁呢？ //synchronized(this)用以定义需要进行同步的某一部分代码块通过验证，函数都有自己所属的对象this，所以同步函数所使用的锁就是this锁。This.方法名 当同步函数被static修饰时，这时的同步用的是哪个锁呢？ 静态函数在加载时所属于类，这时有可能还没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了对象，这个对象就是该类的字节码文件对象。 所以静态加载时，只有一个对象存在，那么静态同步函数就使用的这个对象。 这个对象就是 类名.class 同步代码块和同步函数的区别？ 同步代码块使用的锁可以是任意对象。 同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。 在一个类中只有一个同步的话，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。 -—————————————————— ★考点问题：请写一个延迟加载的单例模式？写懒汉式；当出现多线程访问时怎么解决？加同步，解决安全问题；效率高吗？不高；怎样解决？通过双重判断的形式解决。 //懒汉式：延迟加载方式。 当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。 为了效率问题，通过双重判断的形式解决。 class Single{ private static Single s = null; private Single(){} public static Single getInstance(){ //锁是谁？字节码文件对象； if(s == null){ synchronized(Single.class){ if(s == null) s = new Single(); } } return s; } } -——————————————————– 等待唤醒机制：涉及的方法：wait:将同步中的线程处于冻结状态。释放了执行权，释放了资格。同时将线程对象存储到线程池中。notify：唤醒线程池中某一个等待线程。notifyAll:唤醒的是线程池中的所有线程。注意：1：这些方法都需要定义在同步中。2：因为这些方法必须要标示所属的锁。你要知道 A锁上的线程被wait了,那这个线程就相当于处于A锁的线程池中，只能A锁的notify唤醒。3：这三个方法都定义在Object类中。为什么操作线程的方法定义在Object类中？因为这三个方法都需要定义同步内，并标示所属的同步锁，既然被锁调用，而锁又可以是任意对象，那么能被任意对象调用的方法一定定义在Object类中。wait和sleep区别： 分析这两个方法：从执行权和锁上来分析：wait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyAll来唤醒。sleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。wait：线程会释放执行权，而且线程会释放锁。sleep：线程会释放执行权，但是不释放锁。线程的停止：通过stop方法就可以停止线程。但是这个方式过时了。停止线程：原理就是：让线程运行的代码结束，也就是结束run方法。怎么结束run方法？一般run方法里肯定定义循环。所以只要结束循环即可。第一种方式：定义循环的结束标记。第二种方式：如果线程处于了冻结状态，是不可能读到标记的，这时就需要通过Thread类中的interrupt方法，将其冻结状态强制清除。让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。———&lt; java.lang.Thread &gt;———- interrupt()：中断线程。setPriority(int newPriority)：更改线程的优先级。getPriority()：返回线程的优先级。toString()：返回该线程的字符串表示形式，包括线程名称、优先级和线程组。Thread.yield()：暂停当前正在执行的线程对象，并执行其他线程。setDaemon(true)：将该线程标记为守护线程或用户线程。将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。该方法必须在启动线程前调用。join：临时加入一个线程的时候可以使用join方法。当A线程执行到了B线程的join方式。A线程处于冻结状态，释放了执行权，B开始执行。A什么时候执行呢？只有当B线程运行结束后，A才从冻结状态恢复运行状态执行。LOCK的出现替代了同步：lock.lock();………lock.unlock();Lock接口：多线程在JDK1.5版本升级时，推出一个接口Lock接口。解决线程安全问题使用同步的形式，(同步代码块，要么同步函数)其实最终使用的都是锁机制。到了后期版本，直接将锁封装成了对象。线程进入同步就是具备了锁，执行完，离开同步，就是释放了锁。在后期对锁的分析过程中，发现，获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。所以同步是隐示的锁操作，而Lock对象是显示的锁操作，它的出现就替代了同步。在之前的版本中使用Object类中wait、notify、notifyAll的方式来完成的。那是因为同步中的锁是任意对象，所以操作锁的等待唤醒的方法都定义在Object类中。而现在锁是指定对象Lock。所以查找等待唤醒机制方式需要通过Lock接口来完成。而Lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。这个对象就是Condition，将Object中的三个方法进行单独的封装。并提供了功能一致的方法 await()、signal()、signalAll()体现新版本对象的好处。&lt; java.util.concurrent.locks &gt; Condition接口：await()、signal()、signalAll()；-——————————————————- class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); }finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); try { while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; –count; notFull.signal(); return x; }finally { lock.unlock(); } } }### 四、集合框架集合框架：★★★★★，用于存储数据的容器。对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。集合容器在不断向上抽取过程中。出现了集合体系。在使用一个体系时，原则：参阅顶层内容。建立底层对象。 -———————————————————– List接口--&lt; java.util &gt;– List接口： List本身是Collection接口的子接口，具备了Collection的所有方法。现在学习List体系特有的共性方法，查阅方法发现List的特有方法都有索引，这是该集合最大的特点。 List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。&emsp;&emsp;|–ArrayList：底层的数据结构是数组,线程不同步，ArrayList替代了Vector，查询元素的速度非常快。&emsp;&emsp;|–LinkedList：底层的数据结构是链表，线程不同步，增删元素的速度非常快。 &emsp;&emsp;|–Vector：底层的数据结构就是数组，线程同步的，Vector无论查询和增删都巨慢。 变长度数组的原理： 当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。 ArrayList：是按照原数组的50%延长。构造一个初始容量为 10 的空列表。 Vector：是按照原数组的100%延长。 -———————————————————– Set接口–&lt; java.util &gt;– Set接口： 数据结构：数据的存储方式； Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一种，迭代器。 &emsp;&emsp;|–HashSet：底层数据结构是哈希表，线程是不同步的。无序，高效； &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;HashSet集合保证元素唯一性：通过元素的hashCode方法，和equals方法完成的。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;当元素的hashCode值相同时，才继续判断元素的equals是否为true。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;如果为true，那么视为相同元素，不存。如果为false，那么存储。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;如果hashCode值不同，那么不判断equals，从而提高对象比较的速度。 &emsp;&emsp;|–LinkedHashSet：有序，hashset的子类。 &emsp;&emsp;&emsp;&emsp;|–TreeSet：对Set集合中的元素的进行指定顺序的排序。不同步。TreeSet底层的数据结构就是二叉树。 对于ArrayList集合，判断元素是否存在，或者删元素底层依据都是equals方法。 对于HashSet集合，判断元素是否存在，或者删除元素，底层依据的是hashCode方法和equals方法。 -———————————————————– Map集合Map集合： |–Hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。|–HashMap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了Hashtable.|–TreeMap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。Map集合存储和Collection有着很大不同：Collection一次存一个元素；Map一次存一对元素。Collection是单列集合；Map是双列集合。Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。特点：要保证map集合中键的唯一性。 5，想要获取map中的所有元素： 原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成Set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。把map集合转成set的方法：​ Set keySet(); Set entrySet();//取的是键和值的映射关系。Entry就是Map接口中的内部接口；Entry就是Map接口中的内部接口；为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。-————————————————————————-取出map集合中所有元素的方式一：keySet()方法。 可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。 Set keySet = map.keySet(); Iterator it = keySet.iterator(); while(it.hasNext()) { Object key = it.next(); Object value = map.get(key); System.out.println(key+&quot;:&quot;+value); } -————————————————————————— 取出map集合中所有元素的方式二：entrySet()方法。 Set entrySet = map.entrySet(); Iterator it = entrySet.iterator(); while(it.hasNext()) { Map.Entry me = (Map.Entry)it.next(); System.out.println(me.getKey()+&quot;::::&quot;+me.getValue()); } -———————————————————————— 将非同步集合转成同步集合的方法将非同步集合转成同步集合的方法：Collections中的 XXX synchronizedXXX(XXX); List synchronizedList(list); Map synchronizedMap(map); public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) { return new SynchronizedMap&lt;K,V&gt;(m); }原理：定义一个类，将集合所有的方法加同一把锁后返回。 List list = Collections.synchronizedList(new ArrayList()); Map&lt;String,String&gt; synmap = Collections.synchronizedMap(map);#### Collection 和 Collections的区别Collection 和 Collections的区别： Collections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。 Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。 -——————————————————————— 五、自动拆装箱自动拆装箱：java中数据类型分为两种 ： 基本数据类型 引用数据类型(对象)在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下： int –&gt; Integer byte –&gt; Byte short –&gt; Short long –&gt; Long char –&gt; Character double –&gt; Double float –&gt; Float boolean –&gt; Booleanjdk5以前基本数据类型和包装类之间需要互转：基本—引用 Integer x = new Integer(x);引用—基本 int num = x.intValue();1)、Integer x = 1; x = x + 1; 经历了什么过程？装箱 -&gt; 拆箱 -&gt; 装箱；2)、为了优化，虚拟机为包装类提供了缓冲池，Integer池的大小 -128~127 一个字节的大小； 3)、String池：Java为了优化字符串操作 提供了一个缓冲池； -——————————————————————————- 六、泛型泛型：jdk1.5版本以后出现的一个安全机制。表现格式：&lt; &gt; 好处：1：将运行时期的问题ClassCastException问题转换成了编译失败，体现在编译时期，程序员就可以解决问题。2：避免了强制转换的麻烦。 泛型中的通配符：可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。-——————————————————————————### 七、反射技术反射技术：其实就是动态加载一个指定的类，并获取该类中的所有的内容。并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。反射的好处：大大的增强了程序的扩展性。#### 反射的基本步骤：1、获得Class对象，就是获取到指定的名称的字节码文件对象。2、实例化对象，获得类的属性、方法或构造函数。3、访问属性、调用方法、调用构造函数创建对象。 获取这个Class对象，有三种方式：1：通过每个对象都具备的方法getClass来获取。弊端：必须要创建该类对象，才可以调用getClass方法。 2：每一个数据类型(基本数据类型和引用数据类型)都有一个静态的属性class。弊端：必须要先明确该类。 前两种方式不利于程序的扩展，因为都需要在程序使用具体的类来完成。 3：使用的Class类中的方法，静态的forName方法。 指定什么类名，就获取什么类字节码文件对象，这种方式的扩展性最强，只要将类名的字符串传入即可。 // 1. 根据给定的类名来获得 用于类加载 String classname = &quot;cn.itcast.reflect.Person&quot;;// 来自配置文件 Class clazz = Class.forName(classname);// 此对象代表Person.class // 2. 如果拿到了对象，不知道是什么类型 用于获得对象的类型 Object obj = new Person(); Class clazz1 = obj.getClass();// 获得对象具体的类型 // 3. 如果是明确地获得某个类的Class对象 主要用于传参 Class clazz2 = Person.class; 反射的用法：1）、需要获得java类的各个组成部分，首先需要获得类的Class对象，获得Class对象的三种方式： Class.forName(classname) 用于做类加载 obj.getClass() 用于获得对象的类型 类名.class 用于获得指定的类型，传参用 2)、反射类的成员方法：2)、反射类的成员方法：2)、反射类的成员方法： Class clazz = Person.class; Method method = clazz.getMethod(methodName, new Class[]{paramClazz1, paramClazz2}); method.invoke(); ​ 3)、反射类的构造函数： Constructor con = clazz.getConstructor(new Class[]{paramClazz1, paramClazz2,...}) con.newInstance(params...) 4)、反射类的属性： Field field = clazz.getField(fieldName); field.setAccessible(true); field.setObject(value); 获取了字节码文件对象后，最终都需要创建指定类的对象：获取了字节码文件对象后，最终都需要创建指定类的对象： 创建对象的两种方式(其实就是对象在进行实例化时的初始化方式)： 1，调用空参数的构造函数：使用了Class类中的newInstance()方法。 2，调用带参数的构造函数：先要获取指定参数列表的构造函数对象，然后通过该构造函数的对象的newInstance(实际参数) 进行对象的初始化。 综上所述，第二种方式，必须要先明确具体的构造函数的参数类型，不便于扩展。所以一般情况下，被反射的类，内部通常都会提供一个公有的空参数的构造函数。 -—————————————————– // 如何生成获取到字节码文件对象的实例对象。 Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;);//类加载 // 直接获得指定的类型 clazz = Person.class; // 根据对象获得类型 Object obj = new Person(&quot;zhangsan&quot;, 19); clazz = obj.getClass(); ​​ Object obj = clazz.newInstance(); //该实例化对象的方法调用就是指定类中的空参数构造函数，给创建对象进行初始化。 //当指定类中没有空参数构造函数时，该如何创建该类对象呢？请看method_2(); public static void method_2() throws Exception { Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;); //既然类中没有空参数的构造函数,那么只有获取指定参数的构造函数,用该函数来进行实例化。 //获取一个带参数的构造器。 Constructor constructor = clazz.getConstructor(String.class,int.class); //想要对对象进行初始化，使用构造器的方法newInstance(); Object obj = constructor.newInstance(&quot;zhagnsan&quot;,30); //获取所有构造器。 Constructor[] constructors = clazz.getConstructors();//只包含公共的 constructors = clazz.getDeclaredConstructors();//包含私有的 for(Constructor con : constructors) { System.out.println(con); } } -—————————————————– 反射指定类中的方法：//获取类中所有的方法。 public static void method_1() throws Exception { Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;); Method[] methods = clazz.getMethods();//获取的是该类中的公有方法和父类中的公有方法。 methods = clazz.getDeclaredMethods();//获取本类中的方法，包含私有方法。 for(Method method : methods) { System.out.println(method); } } //获取指定方法； //获取指定方法； public static void method_2() throws Exception { Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;); //获取指定名称的方法。 Method method = clazz.getMethod(&quot;show&quot;, int.class,String.class); //想要运行指定方法，当然是方法对象最清楚，为了让方法运行，调用方法对象的invoke方法即可， //但是方法运行必须要明确所属的对象和具体的实际参数。 Object obj = clazz.newInstance(); method.invoke(obj, 39,&quot;hehehe&quot;);//执行一个方法 } //想要运行私有方法。 public static void method_3() throws Exception { Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;); //想要获取私有方法。必须用getDeclearMethod(); Method method = clazz.getDeclaredMethod(&quot;method&quot;, null); // 私有方法不能直接访问，因为权限不够。非要访问，可以通过暴力的方式。 method.setAccessible(true);//一般很少用，因为私有就是隐藏起来，所以尽量不要访问。 } //反射静态方法。 public static void method_4() throws Exception { Class clazz = Class.forName(&quot;cn.itcast.bean.Person&quot;); Method method = clazz.getMethod(&quot;function&quot;,null); method.invoke(null,null); } 参考网址:参考网址:Java基础知识总结 java 线程同步和等待唤醒机制java 等待唤醒机制涉及的方法： wait();让线程处于冻结状态，被wait的线程会被存储到线程池中。 notify();唤醒线程池中一个线程（任意）。 notifyAll()：唤醒线程池中的所有线程。 这些方法都必须定义在同步中。因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。 为什么操作线程的方法wait notify notifyAll 定义在了Object类中。因为这些方法时监视器的方法。监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。 wait()和notify()的使用注意点 wait方法与notify方法必须要在同步代码块或者是同步函数中才能使用。理由：如果不存在同步代码块和同步函数则没有锁对象这个概念，而这两个方法必须由锁对象调用。 wait方法与notify方法必需要由锁对象调用。理由：因为需要以锁对象为标识符建立一个线程池，生产者与消费者必须用同一个锁，不同的锁会建立不同的线程池。且不用锁对象调用是报错的，要求就是以锁对象调用，否则就会报错 参考资料： 下面这篇知识点写的很好！ Java并发编程（二）线程同步和等待唤醒机制 Java 快速失败( fail-fast ) 安全失败( fail-safe )一. 快速失败( fail-fast ) ​ 先了解一下并发修改 1. 什么是并发修改？ ​ 当一个或多个线程正在遍历一个集合Collection，此时另一个线程修改了这个集合的内容（添加，删除或者修改）。 这就是并发修改 2.什么是 fail-fast 机制? 1.7的jdk这么写到 ​ if the map is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove ​ method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. ​ Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException ​ on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. ​ 大概意思是:如果map在迭代的时候被修改了结构,除了使用迭代器本身的remove方法之外,否则就会扔出一个异常.因此面对并发的场景下map的迭代很快就会抛出异常.fail-fast的表现不是能够保证一定发生,只是尽最大努力抛出异常.因此编写依赖于此异常的程序的做法是错误的。 ​ fail-fast机制在遍历一个集合时，当集合结构被修改，会抛出Concurrent Modification Exception。 ​ fail-fast会在以下两种情况下抛出ConcurrentModificationException ​ （1）单线程环境 ​ 集合被创建后，在遍历它的过程中修改了结构。 ​ 注意 ：迭代器的remove()方法会让expectModcount和modcount 相等，所以是不会抛出这个异常。 ​ （2）多线程环境 ​ 当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。 ​ 注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。 3. fail-fast机制是如何检测的？ ​ 迭代器在遍历过程中是直接访问内部数据的，因此内部的数据在遍历的过程中无法被修改。为了保证不被修改，迭代器内部维护了一个标记 “mode” ，当集合结构改变（添加删除或者修改），标记”mode”会被修改，而迭代器每次的hasNext()和next()方法都会检查该”mode”是否被改变，当检测到被修改时，抛出Concurrent Modification Exception。下面看看ArrayList迭代器部分的源码。123456789101112131415161718192021222324252627private class Itr implements Iterator&lt;E&gt; &#123; int cursor; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return (this.cursor != ArrayList.this.size); &#125; public E next() &#123; checkForComodification(); /** 省略此处代码 */ &#125; public void remove() &#123; if (this.lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); /** 省略此处代码 */ &#125; final void checkForComodification() &#123; if (ArrayList.this.modCount == this.expectedModCount) return; throw new ConcurrentModificationException(); &#125; &#125; ​ 可以看到它的标记“mode”为 expectedModeCount 二. fail-safe机制 ​ fail-safe任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException ​ fail-safe机制有两个问题 ​ （1）需要复制集合，产生大量的无效对象，开销大 ​ （2）无法保证读取的数据是目前原始数据结构中的数据。 ​ 三、fail-fast 和 fail-safe的例子 123456789101112131415161718import java.util.Iterator; import java.util.Map; public class FailFastExample&#123; public static void main(String[] args)&#123; Map&lt;String,String&gt; premiumPhone = new HashMap&lt;String,String&gt;(); premiumPhone.put("Apple", "iPhone"); premiumPhone.put("HTC", "HTC one"); premiumPhone.put("Samsung","S5"); Iterator iterator = premiumPhone.keySet().iterator(); while (iterator.hasNext())&#123; System.out.println(premiumPhone.get(iterator.next())); premiumPhone.put("Sony", "Xperia Z"); &#125; &#125; &#125; 输出 12345iPhone Exception in thread "main" java.util.ConcurrentModificationException at java.util.HashMap$HashIterator.nextEntry(Unknown Source) at java.util.HashMap$KeyIterator.next(Unknown Source) at FailFastExample.main(FailFastExample.java:20) 1234567891011121314151617import java.util.concurrent.ConcurrentHashMap; import java.util.Iterator; public class FailSafeExample &#123; public static void main(String[] args)&#123; ConcurrentHashMap&lt;String,String&gt; premiumPhone = new ConcurrentHashMap&lt;String,String&gt;(); premiumPhone.put("Apple", "iPhone"); premiumPhone.put("HTC", "HTC one"); premiumPhone.put("Samsung","S5"); Iterator iterator = premiumPhone.keySet().iterator(); while (iterator.hasNext())&#123; System.out.println(premiumPhone.get(iterator.next())); premiumPhone.put("Sony", "Xperia Z"); &#125; &#125; &#125; 输出 123S5HTC oneiPhone ​ Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常. 四、fail-fast和 fail-safe 的区别 Fail Fast Iterator Fail Safe Iterator Throw ConcurrentModification Exception Yes No Clone object No Yes Memory Overhead No Yes Examples HashMap,Vector,ArrayList,HashSet CopyOnWriteArrayList,ConcurrentHashMap 参考资料：Java集合中 fail-fast机制 ​ 夜谈 Java中 Fail-fast 和 Fail-safe 的原理与使用]]></content>
      <categories>
        <category>编程语言</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2018%2F03%2F02%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法常见算法(1) 基本思想 ： 枚举，递归，分治，模拟，贪心，动态规划，剪枝，回溯 (2) *图算法： 深度优先遍历与广度优先遍历，最短路径，最小生成树，拓扑排序 (3) 字符串算法：字符串查找，hash查找，KMP算法 (4) 排序算法： 冒泡，插入，选择，快排，归并排序，堆排序，桶排序 (5) 查找算法： 顺序查找、折半查找、插入查找以及Fibonacci查找 (6) 动态规划：背包问题，最长公共子序列，最优二分检索树 (7) *数论问题：素数问题，整数问题，进制转换，同余模运算 (8) 排列组合：排列和组合算法 (9) 其他：LCA与RMQ问题 参考资料：数据结构与算法汇总 一、排序算法0. 约定​ 待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法。 ​ 研究排序算法的成本模型时，计算的是比较和交换的次数。 ​ 使用辅助函数 less() 和 exch() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。123456789private boolean less(Comparable v, Comparable w)&#123; return v.compareTo(w) &lt; 0;&#125;private void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t;&#125; 1. 冒泡排序​ 冒泡排序（Bubble Sort）是最经典也是最简单的排序算法之一。 原理： ​ 比较两个相邻元素，将值大的元素交换到右边（降序则相反）。其实可以想象瓶子底部的泡泡，它比较轻，就会慢慢的向上浮，冒泡排序也是一个类似的过程。 步骤: ​ 比较相邻的元素。如果前一个比后一个大，就交换他们。第一趟冒泡排序 可以将最大的数放置到最后，第二趟可以将次大的元素放置到倒数第二的位置。以此类推，经过n-1趟，就可以排序完成。 分析 ​ 时间复杂度为O(n^2)，其实就是需要比较的次数为n(n-1)/2。空间复杂度为O(1)，因为只需要一个临时的空间作为交换时用。 2. 插入排序​ 插入排序从左到右进行，每次都将当前元素插入到左部已经排序的数组中，使得插入之后左部数组依然有序。 代码实现12345678910public class Insertion &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 1; i &lt; N; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) &#123; exch(a, j, j - 1); &#125; &#125; &#125;&#125; 总结： ​ 插入排序的复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么插入排序会很快。平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换，最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是逆序的；而最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。 ​ 插入排序对于部分有序数组和小规模数组特别高效。 选择排序和插入排序的比较： ​ 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比是一个较小的常数。 3. 希尔排序​ 对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，如果要把元素从一端移到另一端，就需要很多次操作。 ​ 希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，使得元素更快的移到正确的位置上。 ​ 希尔排序使用插入排序对间隔 h 的序列进行排序，如果 h 很大，那么元素就能很快的移到很远的地方。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。 实现代码1234567891011121314151617public class Shell &#123; public static void sort(Comparable[] a) &#123; int N = a.length; int h = 1; while (h &lt; N / 3) &#123; h = 3 * h + 1; // 1, 4, 13, 40, ... &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123; exch(a, j, j - h); &#125; &#125; h = h / 3; &#125; &#125;&#125; ​ 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, … 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。 4. 选择排序​ 找到数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。 实现代码123456789101112public class Selection &#123; public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 0; i &lt; N; i++) &#123; int min = i; for (int j = i + 1; j &lt; N; j++) &#123; if (less(a[j], a[min])) min = j; &#125; exch(a, i, min); &#125; &#125;&#125; ​ 选择排序需要 $O(\frac{N^2}{2})$ 次比较和 $O(N)$ 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。 5. 快速排序(1). 基本算法 ​ 归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。（快速排序就是用一个元素进行切分） 实现代码12345678910111213public class QuickSort &#123; public static void sort(Comparable[] a) &#123; shuffle(a); sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); &#125;&#125; (2). 切分 ​ 取 a[lo] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于等于它的元素，交换这两个元素，并不断继续这个过程，就可以保证左指针的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[lo] 和左子数组最右侧的元素 a[j] 交换然后返回 j 即可。 实现代码 123456789101112private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo, j = hi + 1; Comparable v = a[lo]; while (true) &#123; while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; if (i &gt;= j) break; exch(a, i, j); &#125; exch(a, lo, j); return j;&#125; (3). 性能分析 ​ 快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。 ​ 快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 C~N~=2C~N/2~+N，也就是复杂度为 O(NlogN)。 ​ 最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N^2^/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。 (4). 算法改进 (4.1) 切换到插入排序 ​ 因为快速排序在小数组中也会调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。 (4.2) 三取样 ​ 最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。人们发现取 3 个元素并将大小居中的元素作为切分元素的效果最好。 (4.3) 三向切分 对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。三向切分快速排序对于只有若干不同主键的随机数组可以在线性时间内完成排序。 三向切分快速排序实现代码123456789101112131415public class Quick3Way &#123; public static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int lt = lo, i = lo + 1, gt = hi; Comparable v = a[lo]; while (i &lt;= gt) &#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; &#125; sort(a, lo, lt - 1); sort(a, gt + 1, hi); &#125;&#125; 6. 归并排序​ 归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。 (1) 归并方法 ​ 归并方法将数据中两个已经排序好的部分归并成一个。123456789101112131415161718public class MergeSort &#123; private static Comparable[] aux; private static void merge(Comparable[] a, int lo, int mid, int hi) &#123; int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; // 将数据复制到辅助数组 &#125; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (aux[i].compareTo(a[j]) &lt; 0) a[k] = aux[i++]; // 先进行这一步，保证稳定性 else a[k] = aux[j++]; &#125; &#125;&#125; (2) 自顶向下归并排序123456789101112public static void sort(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a, 0, a.length - 1);&#125;private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); sort(a, mid + 1, hi); merge(a, lo, mid, hi);&#125; ​ 因为每次都将问题对半分成两个子问题，而这种对半分的算法复杂度一般为 O(NlogN)，因此该归并排序方法的时间复杂度也为 O(NlogN)。 ​ 因为小数组的递归操作会过于频繁，因此使用插入排序来处理小数组将会获得更高的性能。 (3) 自底向上归并排序 ​ 先归并那些微型数组，然后成对归并得到的子数组。 123456789public static void busort(Comparable[] a) &#123; int N = a.length; aux = new Comparable[N]; for (int sz = 1; sz &lt; N; sz += sz) &#123; for (int lo = 0; lo &lt; N - sz; lo += sz + sz) &#123; merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1)); &#125; &#125;&#125; ​ 其实，自底向上归并排序就是从小数组往大数组归并。自顶向下归并排序就是有一个划分的过程，其实也是要从小数组往大数组进行归并的。 7. 堆排序堆排序 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。 堆 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图： ​ 同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子 ​ 该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是： ​ 大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] ​ 小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] ​ ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤： 堆排序基本思想及步骤 ​ 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 (1) 构建初始堆 ​ 初始化堆的时候是对所有的非叶子结点进行筛选。 假设有n个元素的堆，那么最后一个非叶子元素的下标是[n/2]-1（向下取整），所以筛选只需要从第[n/2]-1个元素开始，从后往前进行调整。 比如，给定一个数组，首先根据该数组元素构造一个完全二叉树。 然后从最后一个非叶子结点开始，每次都是从父结点、左孩子、右孩子中进行比较交换，交换可能会引起孩子结点不满足堆的性质，所以每次交换之后需要重新对被交换的孩子结点进行调整。 （2）进行堆排序 堆排序是一种选择排序。建立的初始堆为初始的无序区。 排序开始，首先输出堆顶元素（因为它是最值），将堆顶元素和最后一个元素交换，这样，第n-1个位置（即最后一个位置）作为有序区，前n-2个位置仍是无序区，对无序区进行调整，得到堆之后，再交换堆顶和最后一个元素，这样有序区长度变为2。。。 不断进行此操作，将剩下的元素重新调整为堆，然后输出堆顶元素到有序区。每次交换都导致无序区-1，有序区+1。不断重复此过程直到有序区长度增长为n-1，排序完成。 实现代码(zhg):12345678910111213141516171819202122232425262728293031323334353637383940public class HeapSort &#123; public static void sort(int[] nums, int start, int end)&#123; //1.建立初始堆(大顶堆) for(int i = (end - start + 1)/2 -1; i&gt;=0; i--)&#123; updateHeap(nums, i, nums.length -1); &#125; //2.进行堆排序（升序） for(int i = nums.length-1; i&gt;0; i--)&#123; exch(nums, 0, i); updateHeap(nums, 0, i-1); &#125; &#125; // 对堆中的某一个元素进行一个从上到下的调整 public static void updateHeap(int[] nums, int index, int end_index)&#123; if(2*index + 1 &gt; end_index)&#123; return; &#125;else&#123; if(nums[index] &lt; nums[2*index+1])&#123; exch(nums, index, 2*index+1); updateHeap(nums, 2*index+1, end_index); &#125; &#125; if(2*index+2 &gt; end_index)&#123; return; &#125;else&#123; if(nums[index] &lt; nums[2*index+2])&#123; exch(nums, index, 2*index+2); updateHeap(nums, 2*index+2, end_index); &#125; &#125; &#125; // 交换数组中两个元素的位置 public static void exch(int[] nums, int x, int y)&#123; int tmp = nums[x]; nums[x] = nums[y]; nums[y] = tmp; &#125;&#125; 分析 ​ 一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。 ​ 对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。 ​ 堆排序时一种原地排序，没有利用额外的空间。 ​ 现代操作系统很少使用堆排序，因为它无法利用缓存，也就是数组元素很少和相邻的元素进行比较。 参考资料：图解排序算法(三)之堆排序 ​ 堆排序算法 8. 基数排序基本思想 ​ 不进行关键字的比较,而是利用”分配”和”收集”。 ​ PS：以十进制为例，基数指的是数的位，如个位，十位百位等。而以十六进制为例，0xB2，就有两个radices（radix的复数）。 Least significant digit（LSD） 短的关键字被认为是小的，排在前面，然后相同长度的关键字再按照词典顺序或者数字大小等进行排序。比如1，2，3，4，5，6，7，8，9，10，11或者”b, c, d, e, f, g, h, i, j, ba” 。 Most significance digit（MSD） 直接按照字典的顺序进行排序，对于字符串、单词或者是长度固定的整数排序比较合适。比如：1, 10, 2, 3, 4, 5, 6, 7, 8, 9和 “b, ba, c, d, e, f, g, h, i, j”。 基数排序图示 ​ 从图示中可以看出基数排序（LSD）的基本流程为如下节。 基数排序流程 ​ 将根据整数的最右边数字将其扔进相应的0~9号的篮子里，对于相同的数字要保持其原来的相对顺序（确保排序算法的稳定性），然后将篮子里的数如图所示的串起来，然后再进行第二趟的收集（按照第二位的数字进行收集），就这样不断的反复，当没有更多的位时，串起来的数字就是排好序的数字。 时间复杂度分析 上图示中每个数计有2 位，因此执行2 次分配和收集就可以了。在一般情况下，每个结点有d 位关键字，必须执行d 次分配和收集操作。 每次分配的代价：O(n)O(n) 每次收集的代价：O(radix)O(radix) 总的代价为：O(d×(n+radix)) 算法实现12345678910111213141516171819202122232425262728public static void radixSort(int[] nums)&#123; List&lt;Integer&gt;[] buckets = new List[10]; Arrays.setAll(buckets, index -&gt; new ArrayList&lt;&gt;()); int i=-1; while(buckets[0].size() != nums.length)&#123; Arrays.stream(buckets).forEach(List::clear); i += 1; //进行分配 for (int num : nums) &#123; int index = (num/(int)Math.pow(10, i))%10; if(buckets[index]==null)&#123; buckets[index] = new ArrayList&lt;Integer&gt;(); &#125; buckets[index].add(num); &#125; //进行收集 int t = 0; for (List&lt;Integer&gt; list : buckets) &#123; if(list != null)&#123; for(Integer num : list)&#123; nums[t++] = num; &#125; &#125; &#125; &#125;&#125; 9. 桶排序(BucketSort)​ 假设你有五百万份试卷，每份试卷的满分都是100分，如果要你对这些试卷按照分数进行排序，天噜啦，五百万份试卷啊，快速排序？堆排序？归并排序？面对这么多的数据，平均下来上面的每一种一种算法至少都要花费nlogn=5000000log5000000=111267433nlogn=5000000log5000000=111267433单位时间啊，将近一亿多，太慢了。 ​ 要是我们这样来做呢，首先买101只桶回来，分别为每一只桶编上0-100标号,我们就只管遍历一边所有的试卷，将分数为n的试卷丢入到编号为n的桶里面，当所有的试卷都放入到相应的桶里面时，我们就已经将所有的试卷按照分数进行排序了。遍历一遍所有数据的时间也就是五百万次，相比与一亿多次，那可是省了不少时间。这里所用到的就是桶排序的思想。 桶排序的思想 ​ 桶排序，顾名思义就是运用桶的思想来将数据放到相应的桶内，再将每一个桶内的数据进行排序，最后把所有桶内数据按照顺序取出来，得到的就是我们需要的有序数据 ​ 比如我们有下面的一些数据 ​ 49 43 11 61 31 71 53 51 71 84 ​ 下面我们按照这些数的十位将他们放入桶内 将数据放入桶内 bucket#.0 +++bucket#.1 +++ 11bucket#.2 +++bucket#.3 +++ 31bucket#.4 +++ 49 43bucket#.5 +++ 53 51bucket#.6 +++ 61bucket#.7 +++ 71 71bucket#.8 +++ 84bucket#.9 +++ ​ 注意一点，上面的各个桶内的数据是无序的，现在运用一个快速的排序算法对每一个桶内的数据进行排序，可以是快速排序，插入排序，归并排序里面的任何一种 对桶内数据进行排序 bucket#.0 +++bucket#.1 +++ 11bucket#.2 +++bucket#.3 +++ 31==bucket#.4 +++== 43 49==bucket#.5 +++== 51 53bucket#.6 +++ 61bucket#.7 +++ 71 71bucket#.8 +++ 84bucket#.9 +++ ​ 注意观察上面的红色标示的桶里面的数据顺序已经发生改变，在将各个桶里面的元素进行排序以后，我们需要按照顺序遍历每一个桶，将桶里面的数据按照顺序取出来，得到已经排序的有序序列 组合各个桶内的元素 11 31 43 49 51 53 61 71 71 84 总之，桶排序的的步骤为： 申请一定数量的桶 按照一个设定好的映射函数，将序列里面的元素映射到对应的桶里（上面例子的映射函数为BUCKET(i)=i/10） 遍历一遍所有的桶，将各个桶内的元素进行排序，排序算法可以采用冒泡排序，插入排序，快速排序，归并排序等等适合的算法 将所有桶内的元素按照顺序组合起来就是我们需要的有序序列 时间复杂度 ​ 如果桶的数量和序列元素的数量相等的话，那么算法将达到最优的效率$O(N)$，但是这个时候也是空间占用最大的时候。 ​ 如果桶内元素分布不平衡的，将会导致桶排序的算法效率大大降低，我们考虑最坏的情况，映射函数将所有的元素映射到同一个桶里面，再对桶里面元素进行插入排序，运行时间将升$O(N^2)$,所以设计一个性能优良的映射函数尤为重要。 10. 应用(1) 排序算法的比较 ​ 快速排序时最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其他线性对数级别的排序算法都要小。使用三向切分之后，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。 (2). Java 的排序算法实现 Java 系统库中的主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。 (3). 基于切分的快速选择算法 ​ 快速排序的 partition() 方法，会返回一个整数 j 使得 a[lo..j-1] 小于等于 a[j]，且 a[j+1..hi] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。 ​ 可以利用这个特性找出数组的第 k 个元素。12345678910public static Comparable select(Comparable[] a, int k) &#123; int lo = 0, hi = a.length - 1; while (hi &gt; lo) &#123; int j = partion(a, lo, hi); if (j == k) return a[k]; else if (j &gt; k) hi = j - 1; else lo = j + 1; &#125; return a[k];&#125; ​ 该算法是线性级别的，因为每次正好将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。 二、基本思想八大算法：枚举、递推、递归、分治、贪心、试探法、动态迭代和模拟算法思想。 1、枚举算法思想（暴力算法） 将问题的所有可能答案一一列举，根据判断条件判断此答案是否合适，一般用循环实现。 经典运用：百钱买百鸡、填写运算符 2、递推算法思想 1.顺推法：从已知条件出发，逐步推算出要解决问题的方法。 2.逆推法：从已知结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。 经典运用：斐波那契数列（顺推法）、银行存款（逆推法） 3、递归算法思想 1.递归过程一般通过函数或子过程实现； 2.递归算法在函数或子过程的内部，直接或间接调用自己的算法 3.递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解 注意：必须有一个明确的递归结束条件；如果递归次数过多，容易造成栈溢出。 经典运用：汉诺塔问题、阶乘问题 4、分治算法思想 将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。只要求出子问题的解，就可得到原问题的解。 一般步骤： 1.分解，将要解决的问题划分成若干个规模较小的同类问题 2.求解，当子问题划分得足够小时，用较简单的方法解决 3.合并，按原问题的要求，将子问题的解逐层合并构成原问题的解 经典运用：大数相乘问题、比赛日程安排 5、贪心算法思想 从问题的某一个初始解出发，逐步逼近给定的目标，以便尽快求出更好的解。 局限： 不能保证最后的解是最优的； 不能求最大最小解问题； 只能求满足某些约束条件的可行解范围。 基本过程： 1.从问题的某一初始解出发 2.while能向给定总目标前进一步 3.求出可行解的一个解元素 4.由所有解元素组合成问题的一个可行解 经典运用：装箱问题、找零方案 6、试探算法（回溯法） 在试探算法中，放弃当前候选解，并继续寻找下一个候选解的过程称为回溯。扩大当前候选解的规模，以继续试探的过程称为向前试探。 （为求得问题的正确解，会先委婉地试探某一种可能情况。在进行试探过程中，一旦发现原来选择的假设情况是不正确的，马上会自觉地退回一步重新选择，然后继续向前试探。反复进行，直到得到解或证明无解时才死心） 基本步骤： 1.针对所给问题，定义问题的解空间 2.确定易于搜索的解空间结构 3.以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索 经典运用：八皇后问题、29选7彩票组合 7、迭代算法（辗转法） 是一种不断用变量的旧值递推新值的过程，解决问题时总是重复利用一种方法。 1.确定迭代变量：直接或间接地不断由旧值递推出新值的变量 2.建立迭代关系式：新值与旧值的公式或关系。（解决迭代问题的关系） 3.对迭代过程进行控制：确定迭代过程什么时候结束 所需的迭代次数是个确定值，可以计算出来：可以构建一个固定次数的循环来实现对迭代过程的控制； 所需的迭代次数无法确定：需要进一步分析出用来结束迭代过程的条件。 经典运用：求平方根问题 8、模拟算法思想 对真实事物或者过程的虚拟。 经典运用：猜数字游戏、掷骰子问题 9、剪枝算法一：剪枝策略的寻找的方法 1）微观方法：从问题本身出发，发现剪枝条件 2）宏观方法：从整体出发，发现剪枝条件。 3）注意提高效率，这是关键，最重要的。 总之，剪枝策略，属于算法优化范畴；通常应用在DFS 和 BFS 搜索算法中；剪枝策略就是寻找过滤条件，提前减少不必要的搜索路径。 二：剪枝算法(算法优化) 1、简介 ​ 在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。 2、剪枝优化三原则: 正确、准确、高效.原则 ​ 搜索算法,绝大部分需要用到剪枝.然而,不是所有的枝条都可以剪掉,这就需要通过设计出合理的判断方法,以决定某一分支的取舍. 在设计判断方法的时候,需要遵循一定的原则. 剪枝的原则 1） 正确性 正如上文所述,枝条不是爱剪就能剪的. 如果随便剪枝,把带有最优解的那一分支也剪掉了的话,剪枝也就失去了意义. 所以,剪枝的前提是一定要保证不丢失正确的结果. 2）准确性 在保证了正确性的基础上,我们应该根据具体问题具体分析,采用合适的判断手段,使不包含最优解的枝条尽可能多的被剪去,以达到程序“最优化”的目的. 可以说,剪枝的准确性,是衡量一个优化算法好坏的标准. 3）高效性 ​ 设计优化程序的根本目的,是要减少搜索的次数,使程序运行的时间减少. 但为了使搜索次数尽可能的减少,我们又必须花工夫设计出一个准确性较高的优化算法,而当算法的准确性升高,其判断的次数必定增多,从而又导致耗时的增多,这便引出了矛盾. 因此,如何在优化与效率之间寻找一个平衡点,使得程序的时间复杂度尽可能降低,同样是非常重要的. 倘若一个剪枝的判断效果非常好,但是它却需要耗费大量的时间来判断、比较,结果整个程序运行起来也跟没有优化过的没什么区别,这样就太得不偿失了. 3、分类 剪枝算法按照其判断思路可大致分成两类:可行性剪枝及最优性剪枝. 3.1 可行性剪枝 —— 该方法判断继续搜索能否得出答案，如果不能直接回溯。 3.2 最优性剪枝 ​ 最优性剪枝，又称为上下界剪枝，是一种重要的搜索剪枝策略。它记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯。 三、查找算法1、顺序查找​ 顺序查找就是从第一个元素比较到最后一个元素，如果找到目标元素，则查找成功，否则失败。 顺序查找平均关键字匹配次数为表长的一半，其时间复杂度为O(n)。 ​ 顺序查找的优点是对表无要求，插入数据可在O(1)内完成。缺点是时间复杂度较大，数据规模较大时，效率较低。 算法伪代码1234567int Search_Seq(SSTable ST, KeyType key)&#123; //在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为 //该元素在表中的位置，否则为0 ST.elem[0].key = key; //哨兵 for(i=ST.length; !EQ(ST.elem[i].key, key); --i); //从后往前找 return i; //找不到时，i为0&#125; 2、折半查找​ 折半查找的查找过程是：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到该记录为止。 ​ 折半查找又称为二分查找，它的前提是线性表中的记录必须是有序的（通常从小到大有序），线性表必须采用顺序存储． 折半查找的基本思想是 ： 在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找.不断重复上述过程，直到查找成功 或所有查找区域无记录，查找失败。 算法伪代码123456789101112int Search_Bin ( SSTable ST, KeyType key ) &#123; //在有序表ST中折半査找其关键字等于key的数据元素。若找到，则函数值为 //该元素在表中的位置，否则为0。注意：在整个表中，o号元素时空着的。 low = 1； high = ST.length； // 置区间初值 while (low &lt;= high) &#123; raid = (low + high) / 2； if (EQ (key, ST. elem[mid].key)) return mid // 找到待査元素 else if (LT(key, ST.elem[mid].key)) high = mid - 1; //继续在前半区间进行査找 else low = mid + 1； //继续在后半区间进行査找 &#125; return 0; //顺序表中不存在待查元素&#125;// Search_Bin 3、插入查找​ 插值查找是根据给定值key来确定进行比较的关键字ST. elem[i]. key的查找方法。 ​ 令 $ i=\frac{key - ST.elem[1].key}{ST.elem[h].key - ST.elem[l]}(h - l + 1) $ ，其中ST.elem[l]和ST.elem[h] 别为有序表中具有最小关键字和最大关键字的记录。显然，这种插值查找只适于关键字均匀分布的表，在这种情况下，对表长较大的顺序表，其平均性能比折半査找好。 ​ 我的理解是，查值查找是在利用目标关键字在表中最小最大关键字之间的范围比例，来缺点要比较的元素的位置。 4、Fibonacci查找​ 斐波那契査找是根据斐波那契序列的特点对表进行分割的。假设开始时表中记录个数比某个裴波那契数小1，即$n = F_u - 1$ 然后将给定值key和ST. elem[$F_{u-1}$]. key进行比较，若相等，则査找成功；若key&lt;ST. elem[$F_{u-1}$]. key，则继续在自ST. elem[1]至 ST.elem[$F_{u-1} - 1$]的子表中进行査找，否则继续在自ST. elem[$F_{u-1} + 1$]至ST. elem[$F_u - 1$]的子表中进行査找，后一子表的长度为$F_{u-2} - 1$。斐波那契査找的平均性能比折 半査找好，但最坏情况下的性能（虽然仍是$O(\log n)$却比折半査找差。它还有一个优点 就是分割时只需进行加、减运算。 ​ 菲波那切序列可以定义为： $F_0 = 0, F_1 = 1, F_i = F_{i-1}+F_{i-2}, i\ge 2$ 四、动态规划0. 动态规划思想​ 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。 动态规划中递推式的求解方法不是动态规划的本质。 动态规划的本质，是对问题状态的定义和状态转移方程的定义。引自维基百科 dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems. ​ 动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。 本题下的其他答案(这个资料搜集于知乎上的一个问题)，大多都是在说递推的求解方法，但如何拆分问题，才是动态规划的核心。 而拆分问题，靠的就是状态的定义和状态转移方程的定义。 1. 什么是状态的定义？ ​ 首先想说大家千万不要被下面的数学式吓到，这里只涉及到了函数相关的知识。我们先来看一个动态规划的教学必备题： 给定一个数列，长度为N，求这个数列的最长上升（递增）子数列（LIS）的长度.以1 7 2 8 3 4为例。这个数列的最长递增子数列是 1 2 3 4，长度为4；次长的长度为3， 包括 1 7 8; 1 2 3 等. ​ 要解决这个问题，我们首先要定义这个问题和这个问题的子问题。 有人可能会问了，题目都已经在这了，我们还需定义这个问题吗？需要，原因就是这个问题在字面上看，找不出子问题，而没有子问题，这个题目就没办法解决。 ​ 所以我们来重新定义这个问题： 给定一个数列，长度为N，设$F_{k}$为：以数列中第k项结尾的最长递增子序列的长度.求$F_{1}..F_{N}$ 中的最大值. ​ 显然，这个新问题与原问题等价。 而对于$F_{k}$来讲，$[F_{1} .. F_{k-1}$都是$F_{k}$的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第$1..k-1$中某项结尾的LIS。 ​ 上述的新问题$F_{k}$也可以叫做状态，定义中的$F_{k}$为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。 之所以把$F_{k}$做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。 ​ 对状态的定义只有一种吗？当然不是。 我们甚至可以二维的，以完全不同的视角定义这个问题： 给定一个数列，长度为N，设$F_{i, k}$为：在前i项中的，长度为k的最长递增子序列中，最后一位的最小值. $1\leq k\leq N$.若在前i项中，不存在长度为k的最长递增子序列，则$F_{i, k}$为正无穷.求最大的x，使得$F_{N,x}$不为正无穷。 ​ 这个新定义与原问题的等价性也不难证明，请读者体会一下。 上述的$F_{i, k}$就是状态，定义中的”$F_{i, k}$为：在前i项中，长度为k的最长递增子序列中，最后一位的最小值”就是对状态的定义。 2. 什么是状态转移方程？ 上述状态定义好之后，状态和状态之间的关系式，就叫做状态转移方程。比如，对于LIS问题，我们的第一种定义： 设为：以数列中第k项结尾的最长递增子序列的长度. 设A为题中数列，状态转移方程为： $F_{1} = 1$ （根据状态定义导出边界情况）$F_{k}=max(F_{i}+1 | A_{k}&gt;A_{i}, i\in (1..k-1)) (k&gt;1)$ ​ 用文字解释一下是： 以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。 ​ 第二种定义： 设$F_{i, k}$为：在数列前i项中，长度为k的递增子序列中，最后一位的最小值 ​ 设A为题中数列，状态转移方程为： 若$A_{i}&gt;F_{i-1,k-1}$则$F_{i,k}=min(A_{i},F_{i-1,k})$否则：$F_{i,k}=F_{i-1,k} $ ​ 边界情况需要分类讨论较多，在此不列出，需要根据状态定义导出边界情况。）大家套着定义读一下公式就可以了，应该不难理解，就是有点绕。 ​ 这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。可以看出，状态转移方程就是带有条件的递推式。 3. 动态规划迷思 本题下其他用户的回答跟动态规划都有或多或少的联系，我也讲一下与本答案的联系。 ​ a. “缓存”，“重叠子问题”，“记忆化”： 这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。 上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。都不是动态规划的本质，**不是动态规划的核心。** ​ b. “递归”： 递归是递推式求解的方法，连技巧都算不上。 ​ c. “无后效性”，“最优子结构”： 上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是”无后效性”的通俗上的数学定义，符合这种定义的状态定义，我们可以说它具有“最优子结构”的性质，在动态规划中我们要做的，就是找到这种“最优子结构”。 ​ 在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。对状态和“最优子结构”的关系的进一步解释，什么是动态规划？动态规划的意义是什么？ - 王勐的回答 写的很好，可以去读一下。 ​ 需要注意的是，一个问题可能有多种不同的状态定义和状态转移方程定义，存在一个有后效性的定义，不代表该问题不适用动态规划。这也是其他几个答案中出现的逻辑误区： 动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义，在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。 ​ 文艺的说，动态规划是寻找一种对问题的观察角度，让问题能够以递推（或者说分治）的方式去解决。寻找看问题的角度，才是动态规划中最耀眼的宝石！（大雾） ​ 一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！ ​ 每个阶段只有一个状态-&gt;递推； 每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心； 每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索； 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到 这个性质叫做最优子结构； 而不管之前这个状态是如何得到的 这个性质叫做无后效性。 ​ 另：其实动态规划中的最优状态的说法容易产生误导，以为只需要计算最优状态就好，LIS问题确实如此，转移时只用到了每个阶段“选”的状态。但实际上有的问题往往需要对每个阶段的所有状态都算出一个最优值，然后根据这些最优值再来找最优状态。比如背包问题就需要对前i个包（阶段）容量为j时（状态）计算出最大价值。然后在最后一个阶段中的所有状态种找到最优值。 优化动态规划的方法： 递归求解 备忘录算法（记忆法） 逆向递推 总结：动态规划主要在于拆分问题，也就是说怎样定义子问题（定义状态），还有就是定义状态转移方程。 参考资料： 什么是动态规划？动态规划的意义是什么？ ​ 漫画：什么是动态规划？ 1. 背包问题题目 ​ 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 实际题目 ​ 01背包问题描述：有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，每件物品数量只有一个，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？ 基本思路 ​ 这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 ​ 用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：$$f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}$$ ​ 这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前$i$件物品放入容量为$v$的背包中”这个子问题，若只考虑第$i$件物品的策略（放或不放），那么就可以转化为一个只牵扯前$i-1$件物品的问题。如果不放第$i$件物品，那么问题就转化为“前$i-1$件物品放入容量为v的背包中”，价值为$f[i-1][v]$；如果放第i件物品，那么问题就转化为“前$i-1$件物品放入剩下的容量为$v-c[i]$的背包中”，此时能获得的最大价值就是$f[i-1][v-c[i]]$再加上通过放入第i件物品获得的价值$w[i]$。 优化空间复杂度 以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。 先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下： for i=1..N ​ for v=V..0 ​ f[v]=max{f[v],f[v-c[i]]+w[i]}; ​ 其中的f[v]=max{f[v],f[v-c[i]]+w[i]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 ​ 事实上，使用一维数组解01背包的程序在后面会被多次用到，所以这里抽象出一个处理一件01背包中的物品过程，以后的代码中直接调用不加说明。 ​ 过程ZeroOnePack，表示处理一件01背包中的物品，两个参数cost、weight分别表明这件物品的费用和价值。 procedure ZeroOnePack(cost,weight) ​ for v=V..cost ​ f[v]=max{f[v],f[v-cost]+weight} ​ 注意这个过程里的处理与前面给出的伪代码有所不同。前面的示例程序写成v=V..0是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。费用为cost的物品不会影响状态f[0..cost-1]，这是显然的。 ​ 有了这个过程以后，01背包问题的伪代码就可以这样写： for i=1..N ​ ZeroOnePack(c[i],w[i]); 初始化的细节问题 ​ 我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。 ​ 如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。 ​ 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。 ​ 为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。 ​ 这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。 小结 ​ 01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 参考资料以及其他类型的背包问题参见：dd_engi 的背包九讲 2. 最长公共子序列（不连续）(LCS, Longest Common Subsequence)，找两个字符串的最长公共子串，这个子串要求在原字符串中是连续的。而最长公共子序列则并不要求连续。 cnblogs与belong，最长公共子序列为blog（cnblogs, belong），最长公共子串为lo（cnblogs, belong） 这两个问题都是用空间换空间，创建一个二维数组来记录之前的每个状态 参考：【动态规划】最长公共子序列与最长公共子串 ​ C++实现最长公共子序列和最长公共子串 状态转移方程： ​ 用i，j遍历两个子串x,y，如果两个元素相等就+1 ，不等就用上一个状态最大的元素$$c[i, j] = \begin{cases} 0, &amp; i=0 \mbox{ or } j=0 \ c[i-1, j-1]+1 &amp; i,j \gt 0 \mbox{ and } x_i = y_i \ \max (c[i, j-1], c[i-1, j]) &amp; i,j \gt 0 \mbox{ and } x_i \ne y_i \end{cases}$$实现代码1234567891011121314151617public static int lcs(String str1, String str2) &#123; int len1 = str1.length(); int len2 = str2.length(); int c[][] = new int[len1+1][len2+1]; for (int i = 0; i &lt;= len1; i++) &#123; for( int j = 0; j &lt;= len2; j++) &#123; if(i == 0 || j == 0) &#123; c[i][j] = 0; &#125; else if (str1.charAt(i-1) == str2.charAt(j-1)) &#123; c[i][j] = c[i-1][j-1] + 1; &#125; else &#123; c[i][j] = max(c[i - 1][j], c[i][j - 1]); &#125; &#125; &#125; return c[len1][len2];&#125; 3. 最长公共子串（连续）​ 区别就是因为是连续的，如果两个元素不等，那么就要=0了而不能用之前一个状态的最大元素 ​ 状态转移方程如下：$$c[i, j] = \begin{cases} 0 &amp; i = 0 \mbox{ or } j =0 \ c[i-1, j-1] + 1 &amp; x_i = u_j \ 0 &amp; x_i \ne y_i \end{cases}$$ 实现代码12345678910111213141516171819202122232425262728293031323334public static int lcs2(String str1, String str2)&#123; int len1 = str1.length(); int len2 = str2.length(); int max_long = 0; int max_long_i = -1; //记录找到最长公共子串时的坐标 int max_long_j = -1; int[][] c = new int[len1+1][len2+2]; for (int i = 0; i &lt; len1+1; i++) &#123; for (int j = 0; j &lt; len2+1; j++) &#123; if(i == 0 || j == 0)&#123; c[i][j] = 0; &#125;else&#123; if(str1.charAt(i-1) == str2.charAt(j-1))&#123; c[i][j] = c[i-1][j-1] + 1; if(c[i][j] &gt; max_long)&#123; //更新最长记录 max_long = c[i][j]; max_long_i = i; max_long_j = j; &#125; &#125;else&#123; c[i][j] = 0; &#125; &#125; &#125; &#125; StringBuilder sb = new StringBuilder(); while((max_long_i&gt;0 &amp;&amp; max_long_j&gt;0)&amp;&amp;c[max_long_i][max_long_j] != 0)&#123; sb.append(str1.charAt(max_long_i-1)); max_long_i --; max_long_j --; &#125; System.out.println("找到的最长公共子串为 ： "+sb.reverse().toString()); return max_long;&#125; 4. 最优二分检索树问题描述 ​ 首先看个例子，如果有S = {5,7,10,12,14,15,18}，我们可以构建一个二分搜索树，所谓二分搜索树（Binary Search Tree），就或者是一棵空树，或者是具有下列性质的二分树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二分搜索树。现在，我们可以构建一下两种树： ​ 现在问题来了，如果在我们的搜索中15~18范围搜索的次数为80%，节点5的搜索次数为10%，其余的节点和节点以外的范围搜索次数频率相等，共计10%。显而易见，两种不同结构的二分搜索树的效率大不一样。在此，结合每个搜索到的节点和范围的频率（记为p[1：n]，q[0：n]）我们给出搜索树的总耗费公式为：$$\sum_{l=i+1}^{j} \mathbf{p_l}(depth(\mathbf{a_l}) + 1) \mathbf{+} \sum_{l=i}^{j}\mathbf{q_l}(depth(\mathbf{b_l}))$$ 这里depth(a~l~)为a~l~在该树中的深度，depth(b~l~)为b~l~在该树中的深度。 ​ 如今的问题就是，对于一个给定的序列，{b~0~，a~1~，b~1~……a~n~，b~n~}，其中a~1~，a~2~……a~n~是实节点，b~0~，b~1~，b~2~……b~n~是虚节点（就是二分搜索树最终找不到实节点的范围），如何找出并构建一个总耗费最小的二分搜索树？ 问题求解 ​ 分析： ​ 假定T~0~是棵最优二分搜索树，它的根是a~k~（第k小的数）。则a~k~的左子树中必然包含了{a~1~…a~k-1~， a~k~的右子树中必然包含了{a~k+1~…a~n~}。而且，左子树一定是关于{a~1~…a~k-1~的最优二分搜索树，右子树一定是关于{a~k+1~…a~n~}的最优二分搜索树。（否则，用更优的子树代替当前的子树，其总耗费比T~0~的更小，矛盾。） ​ 现在考虑二分搜索树问题的性质， ​ ① 根据二分搜索树的性质，任何一棵子树中结点的编号都是连续的。而且，最优树中的任何一棵子树，也必然是关于子树中结点的最优树。因此，最优二分搜索树具有最优子结构性质。 ​ ② 这样，若规模为m≤n-1的最优子树均已知，就可以通过逐一计算以a~1~，a~2~，…，a~n~为根的树的耗费，来确定（使耗费达到最小的）根a~k~并找出最优二分搜索树。 ​ 在上述计算中，规模较小的最优子树在计算中要多次被用到，故该问题具有高度重复性。 ​ 综合 ①和②的特性，我们就考虑动态规划来求解这个问题。 ​ 在所有由结点b~i~，a~i+1~，b~i+1~，…，a~j~，b~j~构成的树中，把耗费最小的树记为T~ij~。（注意该树中不含a~i~但含b~i~）。 ​ 若由结点b~i~，a~i+1~，b~i+1~，…，a~j~，b~j~构成的树以a~k~作为根 (i+1≤k≤j)， ​ 则b~i~，a~i+1~，b~i+1~，…，a~k-1~，b~k-1~必然在其左子树中， ​ 则b~k~，a~k+1~，b~k+1~，…，a~j~，b~j~必然在其右子树中， ​ 以a~k~为根的树有很多，但其中耗费最小的树必然是以T~i,k-1~为其左子树，以T~k,j~为其右子树。 ​ 记c~ij~是最优子树T~ij~的耗费， 则c~i,k-1~是最优子树T~i,k-1~的耗费，c~k,j~是最优子树T~k,j~的耗费。 ​ 考察以a~k~ (i+1≤k≤j)为根、由结点b~i~，a~i+1~，b~i+1~，…，a~j~，b~j~构成的、耗费最小的树的总耗费：根据上述讨论， 该树的左子树必然是T~i,k-1~，右子树必然是T~k,j~ 。该树的总耗费可分为三部分：左子树、右子树和根所产生的耗费。 ​ 紧接着就将T~i,k-1~和T~k,j~接到a~k~上，此处与每个左右子树中节点来说，搜索的耗费都增加了，因为每个节点的深度都增加了1，因此，引入一个公式，来表示子树在接入根节点的时候增加的耗费，$$\bf \sum_{l=i+1}^{j}p_l + \sum_{l=i}^{j} q_l = q_i + p_{i+1}+q_{i+1}+…+(p_j + q_j)$$​ 由于T~i,k-1~作为左子树接到结点a~k~之下时，其耗费增加w~i,k-1~，故左子树的耗费为：c~i,k-1~+ w~i,k-1~， ​ 同理，右子树的耗费为：c~k,j~+w~k,j~， ​ 由于根a~k~的深度为0，按定义，根的耗费为p~k~。 ​ 因此，以a~k~ 为根、耗费最小的树的总耗费为：c~i,k-1~+ w~i,k-1~+c~kj~+w~k,j~+p~k~。 ​ 注意到， ​ w~i,k-1~=q~i~+p~i+1~+q~i+1~+…+p~k-1~+q~k-1~， ​ w~k,j~=q~k~+p~k+1~+q~k+1~+…+p~j~+q~j~， ​ 从而有w~i,k-1~+w~kj~+p~k~ = q~i~+p~i+1~+q~i+1~+…+p~k-1~+q~k-1~+ p~k~ +q~k~+p~k+1~+q~k+1~+…+p~j~+q~j~ = w~ij~。 ​ 由此得到, 以a~k~ 为根、耗费最小的树的总耗费为：c~i,k-1~+c~kj~+w~i,j~由于p~i~（i=1,2,…,n）和 q~j~（j=0,1,2,…,n）在初始时已经知道，因此若w~i,j-1~已知，则根据w~i,j~= w~i,j-1~+p~j~ + q~j~可以计算出w~ij~。故当c~i,k-1~与c~kj~已知时，以a~k~ 为根的树的最小总耗费在O(1)时间就可以计算出来。 ​ 这样，分别计算以a~i+1~，a~i+2~，…，a~j~为根、含有结点b~i~，a~i+1~，b~i+1~，…，a~j~，b~j~的树的最小总耗费，再从中选出耗费最小的树，即可得最优子树T~ij~。 ​ 因此，最优子树Tij的耗费c~ij~= {c~i,k-1~+c~kj~+w~ij~}, 其中k使得c~ij~最小。 算法描述 递推求c~ij~及记录T~ij~的根的算法 ​ 初始时 w~ii~←q~i~(i=1,2,…,n)；c~ii~←0；/*∵空树T~ii~耗费为0（i=1,2,…,n）。*/ ​ for l←1 to n do /*计算规模为l（树中真实结点个数）的最优二分搜索树，从含1个结点直算到含n个结点*/ ​ { for i←0 to n-l do /*真实结点个数为l个的树共有(n-l+1)个，i为树中结点起始下标，从0直到n-l。*/ ​ { j←i+l; /* j为树中最后一个结点的下标*/ ​ w~i,j~←w~i,j-1~+p~j~ + q~j~ ; /*计算出规模为l (l=j-i)、当前所需的w~i,j~*/ ​ c~ij~← {c~i,k-1~+c~kj~+w~ij~}; /*在前一轮或前几轮，规模小的c~i,k-1~和c~kj~已计算出来了*/ ​ r~ij~←k’; /*k’为使得{c~i,k-1~+c~kj~+w~ij~}为最小的k值*/ ​ } /*即ak’是最优子树T~ij~的根，记录在案*/ ​ } 构建最优二分搜索树， ​ 设T~ij~的根为a~k~ (r~ij~记录到的值是k)，则从根开始建结点。 ​ Build-tree(i,j,r,A) /*建立最优子树T~ij~*/ ​ { ​ If i≥j return null; ​ pointer←newnode(nodetype); ​ k←r~ij~; /*必有i &lt; k ≤j*/ ​ pointer_key-value←A[k]; /*A[k]即ak*/ ​ pointer_leftson←Buildtree(i,k-1,r,A); /*建立最优左子树Ti,k-1*/ ​ pointer_rightson←Buildertree(k,j,r,A); /*建立最优右子树Tk,j*/ ​ return pointer; ​ } ​ 调用Build-tree(0,n,r,A)则可以建成最优二分搜索树。 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class OptimalBinarySearchTree &#123; public static void main(String[] args) &#123; int n = 4; int[] A = &#123;5, 7, 10, 15&#125;; int[] P = &#123;0,2, 10, 2, 2&#125;; int[] Q = &#123;1, 1, 1, 1, 1&#125;; buildBinarySearchTree(A, P, Q); &#125; public static void buildBinarySearchTree(int[] A, int[] p, int[] q)&#123; int n = A.length; int[][] W = new int[n+1][n+1]; int[][] C = new int[n+1][n+1]; int[][] T = new int[n+1][n+1]; //initial tabs for(int i=0;i&lt; n+1;i++)&#123; W[i][i]=q[i]; C[i][i]= 0; &#125; /** * 注意：W[i][j]代表是b[i],a[i+1],b[i+1],...,a[j],b[j]构成的最优二分搜索树，两头一定是虚节点 */ for(int l=1; l&lt;=n; l++)&#123;//L代表子最优二分搜索树的元素个数 for (int i = 0; i &lt;= n-l; i++) &#123; //最优二分搜索树的起始位置 int j = i+l; //找到最小的代价的那个根节点 W[i][j] = W[i][j-1] + p[j] + q[j]; int index = i+1; int tmp_cost = C[i][i] + C[i+1][j]; for(int k=i+2; k&lt;= j; k++)&#123; int tmp = C[i][k-1] + C[k][j]; if( tmp &lt; tmp_cost)&#123; tmp_cost = tmp; index = k; &#125; &#125; T[i][j] = index; C[i][j] =tmp_cost + W[i][j]; &#125; &#125; System.out.printf("cost=%d,root=%d\n",C[0][n],T[0][n]); &#125;&#125; 5. 最优子结构​ 最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。 ​ 比如求广州到北京的最短距离，假设这个路径必经过中间的南京，那么先把路径分割为（广州，南京）和（南京，北京）。分别求出子路径的最短距离然后再连接，就可以得到广州到北京的最短路径。 ​ 因此，寻求最短路径的问题可以利用子路径的最优解获得整个问题的最优解。这样就可以证明，最短路径具有最优子结构。 当然最长递增（LIS） ​ 反之，如果不能利用子问题的最优解获得整个问题的最优解，那么这种问题就不具有最优子结构。 ​ 很多问题的最优子结构都表现出非常直观的形式，以至于都不需要另外的证明过程。不过，遇到结构不是很直观的问题时，则需要用反证法证明（假设子问题的最优解不是整个问题的最优解 ⇒ ?）。 五、数论问题1. 素数问题(1) 朴素判断素数算法 ​ 就判断素数而言，事实上是非常简单的了。根据定义，判断一个整数n是否是素数，只需要去判断在整数区间[2, n-1]之内，是否具有某个数m，使得n % m == 0。代码可以这么写：12345678int isPrime(int n)&#123; for(int i=2; i&lt;n; i++)&#123; if(n % i == 0)&#123;//如果在1和n之间还找到了另外一个约数，那么n就不是素数 retrun 0; &#125; &#125; return 1;&#125; ​ 事实上，假如n除了1和它本身外还有约数a*b=n，那么a或者b一定是小于等于$\sqrt{n}$的，不可能两个约数都大于$\sqrt{n}$，所以只需要检查到$i=\sqrt{n}$就行了。时间复杂度可以从O(n)降低到$O(\sqrt{n})$。代码可以写成下面这样：1234567int isPrime(long long n) &#123; long long i; for (i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) return 0; &#125; return 1; &#125; ​ 原理很巧妙，也仅仅是把代码的i &lt; n变成了i * i &lt;= n而已，但是优化却是极其高的。可能你会注意到，在上一份代码里面，我定义的n为int类型，而后面一份代码，我却定义成了long long，这是因为在1s内，上一份代码能判断出来的数量级为1e8，而后面一份代码判断出来的数量级却几乎可以达到1e16 ​ 这个方法也可以称作试除法。 (2) 筛选法 ​ 上面介绍的一些素数判断的算法，在某些问题是基本可以适用的了。但是对于另外一类问题却十分尴尬。比如问你整数区间[1, n]内的素数个数是多少。这个时候如果一个个枚举，一个个判断，对于朴素方法来说，最优也是O(nsqrt(n))，即使是Miller_Rabin算法也无法在O(n)的时间内得到结果。于是就有了埃氏筛选法（埃拉托斯特尼筛法）。 ​ 对于筛选整数n以内的素数，算法是这么描述的：先把素数2的倍数全部删除，剩下的数第一个为3，再把素数3的倍数全部删除，剩下的第一个数为5，再把素数5的倍数全部删除······直到把n以内最后一个素数的倍数删除完毕，得到n以内的所有素数。代码可以这么写：12345678910111213141516public int getPrime(int n) &#123; int[] prime = new int[n + 1]; int index_prime = 0; //用于在prime中记录找到的素数 prime[1] = -1;//-1表示不是素数，0表示是素数 for (int i = 2; i &lt;= n; i++) &#123; if (prime[i] == -1) &#123;//不是素数 continue; &#125; else &#123;//是素数 prime[index_prime++] = i; for (int j = 2; i * j &lt;= n; j++) &#123; prime[i * j] = -1; &#125; &#125; &#125; return index_prime;&#125; ​ 而事实上，观察可以发现，上面的这种写法有很多次重复计算，这样显然无法做到线性筛选，而另外一种写法却可以得到线性筛选，达到时间复杂度为O(n)，代码可以这么写：1234567891011121314151617int[] prime = new int[n+1];//-1表示是合数，0表示素数int index_prime = 0;for (int i = 2; i &lt;= n; i++) &#123; if(prime[i] != -1)&#123;//i不是合数，即i是素数 prime[index_prime++] = i; &#125; for (int j = 0; j &lt; index_prime &amp;&amp; i * prime[j] &lt;= n; j++) &#123; prime[i*prime[j]] = -1; if(i % prime[j] == 0)&#123; //这if判断是为了确保对于一个合数，只会有一种乘积方式来求得。主要是为了避免重复计算 break; &#125; &#125;&#125;return index_prime;&#125; ​ 上面这段代码主要优化的地方在于去除重复计算，可以坐到对于每一个数字都只会扫描并判断一次，所以才能达到线性时间复杂度O(n)。 2. 整数问题3. 进制转换​ 各种进制之间相互转换，一个基本的方法就是，就是先把原来的进制数据转换成为十进制数，然后再从十进制数据转换成为目标进制数。12345678910111213141516171819202122232425262728293031323334353637383940414243public String convert(final int old_scale, final String old_value, final int new_scale)&#123; char[] num_2_char = &#123;'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;; StringBuilder new_value = new StringBuilder(); //1. 先把旧的进制数据转换成十进制表示 int old_num = 0; for (int i = 0; i &lt; old_value.length(); i++) &#123; old_num = old_num*old_scale + digit(old_value.charAt(i)); &#125; //System.out.println("解析到的旧数值（十进制）为："+old_num); //2. 将十进制表示的数据再转换成目进制数据 while(old_num!=0)&#123; new_value.append(num_2_char[old_num%new_scale]); old_num = old_num/new_scale; &#125; return new_value.reverse().toString();&#125;private int digit(char c)&#123; int c_value = 0; switch (c)&#123; case '0' : c_value = 0;break; case '1' : c_value = 1;break; case '2' : c_value = 2;break; case '3' : c_value = 3;break; case '4' : c_value = 4;break; case '5' : c_value = 5;break; case '6' : c_value = 6;break; case '7' : c_value = 7;break; case '8' : c_value = 8;break; case '9' : c_value = 9;break; case 'A' : case 'a' : c_value = 10;break; case 'B' : case 'b' : c_value = 11;break; case 'C' : case 'c' : c_value = 12;break; case 'D' : case 'd' : c_value = 13;break; case 'E' : case 'e' : c_value = 14;break; case 'F' : case 'f' : c_value = 15;break; default: System.out.println("字符非法"); System.exit(0); &#125; return c_value;&#125; 同余模运算]]></content>
      <categories>
        <category>编程高级知识</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统]]></title>
    <url>%2F2018%2F02%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[一、 概述 操作系统基本特征 操作系统基本功能 系统调用 大内核和微内核 中断分类 二、进程管理 进程与线程 进程状态的切换 调度算法 进程同步 经典同步问题 进程通信 三、死锁 死锁的必要条件 死锁的处理方法 四、内存管理 虚拟内存 分页与分段 分页系统地址映射 页面置换算法 五、设备管理 磁盘调度算法 六、链接 编译系统 目标文件 静态链接 动态链接 参考资料 一、 概述操作系统基本特征1. 并发并发性是指宏观上在一段时间内能同时运行多个程序，而并行性则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线或者多处理器。 操作系统通过引入进程和线程，使得程序能够并发运行。 2. 共享共享是指系统中的资源可以供多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。 3. 虚拟虚拟技术把一个物理实体转换为多个逻辑实体。 主要有两种虚拟技术：时分复用技术和空分复用技术。例如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。 4. 异步异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。 操作系统基本功能1. 进程管理进程控制、进程同步、进程通信、死锁处理、处理机调度等。 2. 内存管理内存分配、地址映射、内存保护与共享和内存扩充等功能。 3. 文件管理文件存储空间的管理、目录管理及文件读写管理和保护等。 4. 设备管理完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虛拟设备等功能。 系统调用如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。 Linux 的系统调用主要有以下这些： Task Commands 进程控制 fork(); exit(); wait(); 进程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 设备操作 ioctl(); read(); write(); 信息维护 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 大内核和微内核1. 大内核大内核是将操作系统功能作为一个紧密结合的整体放到内核。 由于各模块共享信息，因此有很高的性能。 2. 微内核由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。 在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。 因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。 中断分类1. 外中断由 CPU 执行指令以外的事件引起，如 I/O 结束中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 2. 异常由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 3. 陷入在用户程序中使用系统调用。 二、进程管理进程与线程1. 进程进程是资源分配的基本单位。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。 2. 线程线程是独立调度的基本单位。 一个进程中可以有多个线程，它们共享进程资源。 3. 区别 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。 举例：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 进程状态的切换 就绪状态（ready）：等待被调度 运行状态（running） 阻塞状态（waiting）：等待资源 应该注意以下内容： 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 调度算法需要针对不同环境来讨论调度算法。 1. 批处理系统中的调度1.1 先来先服务 first-come first-serverd（FCFS） 调度最先进入就绪队列的作业。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先 shortest job first（SJF） 调度估计运行时间最短的作业。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先 shortest remaining time next（SRTN） 2. 交互式系统中的调度2.1 优先级调度除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。 响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间 这种调度算法主要是为了解决短作业优先调度算法长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。 2.2 时间片轮转将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系。因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 2.3 多级反馈队列 如果一个进程需要执行 100 个时间片，如果采用轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 3. 实时系统中的调度实时系统要求一个服务请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步1. 临界区对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 123// entry section// critical section;// exit section 2. 同步与互斥 同步：多个进程按一定顺序执行； 互斥：多个进程在同一时刻只有一个进程能进入临界区。 3. 信号量信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() &#123; down(&amp;mutex); // 临界区 up(&amp;mutex);&#125;void P2() &#123; down(&amp;mutex); // 临界区 up(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题 问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 up(empty) 操作，empty 永远都为 0，那么生产者和消费者就会一直等待下去，造成死锁。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123; while(TRUE)&#123; int item = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); &#125;&#125;void consumer() &#123; while(TRUE)&#123; down(&amp;full); down(&amp;mutex); int item = remove_item(); up(&amp;mutex); up(&amp;empty); consume_item(item); &#125;&#125; 4. 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。 1234567891011121314monitor ProducerConsumer integer i; condition c; procedure insert(); begin // ... end; procedure remove(); begin // ... end;end monitor; 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 使用管程实现生成者-消费者问题 123456789101112131415161718192021222324252627282930313233343536373839404142// 管程monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;// 生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;// 消费者客户端procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 经典同步问题生产者和消费者问题前面已经讨论过了。 1. 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。 1234567891011121314151617181920212223242526typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void reader() &#123; while(TRUE) &#123; down(&amp;count_mutex); count++; if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if(count == 0) up(&amp;data_mutex); up(&amp;count_mutex); &#125;&#125;void writer() &#123; while(TRUE) &#123; down(&amp;data_mutex); write(); up(&amp;data_mutex); &#125;&#125; 2. 哲学家进餐问题 五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。 下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 123456789101112#define N 5void philosopher(int i) &#123; while(TRUE) &#123; think(); take(i); // 拿起左边的筷子 take((i+1)%N); // 拿起右边的筷子 eat(); put(i); put((i+1)%N); &#125;&#125; 为了防止死锁的发生，可以设置两个条件： 必须同时拿起左右两根筷子； 只有在两个邻居都没有进餐的情况下才允许进餐。 123456789101112131415161718192021222324252627282930313233343536373839404142#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N // 右邻居#define THINKING 0#define HUNGRY 1#define EATING 2typedef int semaphore;int state[N]; // 跟踪每个哲学家的状态semaphore mutex = 1; // 临界区的互斥semaphore s[N]; // 每个哲学家一个信号量void philosopher(int i) &#123; while(TRUE) &#123; think(); take_two(i); eat(); put_tow(i); &#125;&#125;void take_two(int i) &#123; down(&amp;mutex); state[i] = HUNGRY; test(i); up(&amp;mutex); down(&amp;s[i]);&#125;void put_tow(i) &#123; down(&amp;mutex); state[i] = THINKING; test(LEFT); test(RIGHT); up(&amp;mutex);&#125;void test(i) &#123; // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123; state[i] = EATING; up(&amp;s[i]); &#125;&#125; 进程通信1. 进程同步与进程通信的区别 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 在进程同步中介绍的信号量也属于进程通信的一种方式，但是属于低级别的进程通信，因为它传输的信息非常小。 2. 进程通信方式2.1 消息传递操作系统提供了用于通信的通道（Channel），进程可以通过读写这个通道进行通信。 （一）管道 写进程在管道的尾端写入数据，读进程在管道的首端读出数据。管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。 Linux 中管道通过空文件实现。 管道有三种： 普通管道：有两个限制，一是只能单向传输；二是只能在父子进程之间使用； 流管道：去除第一个限制，支持双向传输； 命名管道：去除第二个限制，可以在不相关进程之间进行通信。 （二）消息队列 消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 （三）套接字 套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。 2.2 共享内存操作系统建立一块共享内存，并将其映射到每个进程的地址空间上，进程就可以直接对这块共享内存进行读写。 共享内存是最快的进程通信方式。 三、死锁死锁的必要条件 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 死锁的处理方法1. 鸵鸟策略把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 2. 死锁检测与死锁恢复不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 （一）每种类型一个资源的死锁检测 上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。 图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 （二）每种类型多个资源的死锁检测 上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。 算法总结如下： 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果没有这样一个进程，算法终止。 （三）死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 3. 死锁预防在程序运行之前预防发生死锁。 （一）破坏互斥条件 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 （二）破坏占有和等待条件 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 （三）破坏不可抢占条件 （四）破坏环路等待 给资源统一编号，进程只能按编号顺序来请求资源。 4. 死锁避免在程序运行时避免发生死锁。 （一）安全状态 图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。 （二）单个资源的银行家算法 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。 （三）多个资源的银行家算法 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 如果一个状态不是安全的，也需要拒绝进入这个状态。 四、内存管理虚拟内存每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到一部分不在物理内存中的地址空间时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。 分页与分段1. 分页大部分虚拟内存系统都使用分页技术。把由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。例如有一台计算机可以产生 16 位地址，它的虚拟地址空间为 0~64K，然而计算机只有 32KB 的物理内存，因此虽然可以编写 64KB 的程序，但它们不能被完全调入内存运行。 虚拟地址空间划分成固定大小的页，在物理内存中对应的单元称为页框，页和页框大小通常相同，它们之间通过页表进行映射。 程序最开始只将一部分页调入页框中，当程序引用到没有在页框的页时，产生缺页中断，进行页面置换，按一定的原则将一部分页框换出，并将页调入。 2. 分段 上图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。 分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。 每个段都需要程序员来划分。 3. 段页式用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。 用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。 程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护。 4. 分页与分段区别 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 分页系统地址映射 内存管理单元（MMU）：管理着虚拟地址空间和物理内存的转换。 页表（Page table）：页（虚拟地址空间）和页框（物理内存空间）的映射表。例如下图中，页表的第 0 个表项为 010，表示第 0 个页映射到第 2 个页框。页表项的最后一位用来标记页是否在内存中。 下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。因此对于虚拟地址（0010 000000000100），前 4 位是用来存储页面号，而后 12 位存储在页中的偏移量。 （0010 000000000100）根据前 4 位得到页号为 2，读取表项内容为（110 1），它的前 3 为为页框号，最后 1 位表示该页在内存中。最后映射得到物理内存地址为（110 000000000100）。 页面置换算法在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。 页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 1. 最佳 Optimal 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列： 开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。 2. 先进先出 FIFO, First In First Out 所选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 3. 最近最久未使用 LRU, Least Recently Used 虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。 可以用栈来实现该算法，栈中存储页面的页面号。当进程访问一个页面时，将该页面的页面号从栈移除，并将它压入栈顶。这样，最近被访问的页面总是在栈顶，而最近最久未使用的页面总是在栈底。 4. 时钟 Clock 需要用到一个访问位，当一个页面被访问时，将访问位置为 1。 首先，将内存中的所有页面链接成一个循环队列，当缺页中断发生时，检查当前指针所指向页面的访问位，如果访问位为 0，就将该页面换出；否则将该页的访问位设置为 0，给该页面第二次的机会，移动指针继续检查。 五、设备管理磁盘调度算法当多个进程同时请求访问磁盘时，需要进行磁盘调度来控制对磁盘的访问。 磁盘调度的主要目标是使磁盘的平均寻道时间最少。 1. 先来先服务 FCFS, First Come First Served 根据进程请求访问磁盘的先后次序来进行调度。优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 2. 最短寻道时间优先 SSTF, Shortest Seek Time First 要求访问的磁道与当前磁头所在磁道距离最近的优先进行调度。这种算法并不能保证平均寻道时间最短，但是比 FCFS 好很多。 3. 扫描算法 SCAN SSTF 会出现饥饿现象。考虑以下情况，新进程请求访问的磁道与磁头所在磁道的距离总是比一个在等待的进程来的近，那么等待的进程会一直等待下去。 SCAN 算法在 SSTF 算法之上考虑了磁头的移动方向，要求所请求访问的磁道在磁头当前移动方向上才能够得到调度。因为考虑了移动方向，那么一个进程请求访问的磁道一定会得到调度。 当一个磁头自里向外移动时，移到最外侧会改变移动方向为自外向里，这种移动的规律类似于电梯的运行，因此又常称 SCAN 算法为电梯调度算法。 4. 循环扫描算法 CSCAN CSCAN 对 SCAN 进行了改动，要求磁头始终沿着一个方向移动。 六、链接编译系统以下是一个 hello.c 程序： 1234567#include &lt;stdio.h&gt;int main()&#123; printf("hello, world\n"); return 0;&#125; 在 Unix 系统上，由编译器把源文件转换为目标文件。 1gcc -o hello hello.c 这个过程大致如下： 预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编程序； 汇编阶段：将汇编程序翻译可重定向目标程序，它是二进制的； 链接阶段：将可重定向目标程序和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标程序。 目标文件 可执行目标文件：可以直接在内存中执行； 可重定向目标文件：可与其他可重定向目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：可以在运行时被动态加载进内存并链接； 静态链接静态连接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务： 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：编译器和汇编器生成从地址 0 开始的代码和数据节，链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 动态链接静态库有以下两个问题： 当静态库更新时那么整个程序都要重新进行链接； 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点： 在给定的文件系统中一个库只有一个 .so 文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中； 在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001. Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统. Operating System Notes 进程间的几种通信方式 Operating-System Structures Processes Inter Process Communication Presentation[1]]]></content>
      <categories>
        <category>操作系统</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔]]></title>
    <url>%2F2018%2F02%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记需要补充的知识：Java操作MySQL数据库 一、安装与启动MySQL1. 使用zip文件安装Windows 上安装 MySQL 相对来说会较为简单，你需要在 MySQL 下载中下载 Windows 版本的 MySQL 安装包 下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在 C:\web\mysql-8.0.11 下。 接下来我们需要配置下 MySQL 的配置文件 打开刚刚解压的文件夹 C:\web\mysql-8.0.11 ，里面有一个系统自带的配置文件 my-default.ini，复制该文件，并粘贴在同一目录下，设置新的文件为 my.ini，编辑 my.ini 配置以下基本信息： 1234567891011121314151617[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\wamp-all\mysql-5.7.13# 设置mysql数据库的数据的存放目录datadir=C:\wamp-all\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 接下来我们来启动下 MySQL 数据库： 以管理员身份打开 cmd 命令行工具，切换目录： 1cd C:\web\mysql-8.0.11\bin 输入以下安装命令： 1mysqld install 启动输入以下命令即可： 1net start mysql 注意: 在 5.7 需要初始化 data 目录： 12cd C:\web\mysql-8.0.11\bin mysqld --initialize-insecure 参考资料：MySQL安装|菜鸟教程 2. 使用msi安装程序安装MySQL这个主要参考教程：mysql5.7.21 安装与使用 注意：在windows上的服务名称为：MySQL57 使用mysql -u mucao -p 连接上MySQL后会有一行很重要的提示： Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement. 二、常见问题解决1. 在mysql中无法插入中文字符 参考网址：https://www.cnblogs.com/liushao/p/6370326.html 2. MySQL5.7.9，怎样永久设置client、connection、results这三项为utf8？ [client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect=’SET NAMES utf8′ character-set-server = utf8 3. MySQL为什么要set names 大家都知道SET NAMES x相当于SET character_set_client = x;SET character_set_results = x;SET character_set_connection = x; 参考资料：https://blog.csdn.net/y_h_t/article/details/17994335 4. mysql导出或导出数据时出现： MySQL server is running with the –secure-file-priv ​ 出现这个异常的原因主要是MySQL有自己的默认文件路径(配置在my.ini文件中，“secure-file-priv ”)，如果导出文件路径不对，则就会报错。只要把导出文件配置在指定路径中就行，或者修改my.ini文件中的“secure-file-priv ”值改为””就行了。可以参考：https://blog.csdn.net/qq_31518899/article/details/75662090 5. 创建数据库时设置字符集合更改数据库字符集 ​ 建立数据库时可以使用以下命令： ​ create database app_relation character set utf8; ​ use app_relation; ​ source app_relation.sql; ​ 修改数据库编码的命令为： ​ alter database app_relation character set utf8; 三、基本操作下面的内容来自参考资料：http://www.runoob.com/mysql/mysql-tutorial.html 1. 连接​ 可以使用下面的命令连接MySQL数据库 12[root@host]# mysql -u root -pEnter password:****** ​ 退出 12mysql&gt; exitBye 2. 创建数据库​ 可以在登陆 MySQL 服务后，使用 creat 命令创建数据库，语法如下: 1CREATE DATABASE 数据库名; 3. 删除数据库​ 使用drop命令删除数据库1drop database &lt;数据库名&gt;; 4. 选择数据库​ 在 mysql&gt; 提示窗口中可以很简单的选择特定的数据库。你可以使用SQL命令来选择指定的数据库。 ​ 以下实例选取了数据库 RUNOOB:12345[root@host]# mysql -u root -pEnter password:******mysql&gt; use RUNOOB;Database changedmysql&gt; ​ 执行以上命令后，你就已经成功选择了 RUNOOB 数据库，在后续的操作中都会在 RUNOOB 数据库中执行。 ​ 注意:所有的数据库名，表名，表字段都是区分大小写的。所以你在使用SQL命令时需要输入正确的名称。 5. MySQL数据类型​ MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数据类型 ​ MySQL支持所有标准SQL数值数据类型。 ​ 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 ​ 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 ​ BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 ​ 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9 233 372 036 854 775 808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型 ​ 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 ​ 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 ​ TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型 ​ 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 ​ CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 ​ BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 ​ BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 ​ 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 6. MySQL 创建数据表创建MySQL数据表需要以下信息： 表名 表字段名 定义每个表字段 语法 ​ 以下为创建MySQL数据表的SQL通用语法： 1CREATE TABLE table_name (column_name column_type); ​ 以下例子中我们将在 RUNOOB 数据库中创建数据表runoob_tbl： 12345678910111213root@host# mysql -u root -pEnter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; CREATE TABLE runoob_tbl( -&gt; runoob_id INT NOT NULL AUTO_INCREMENT, -&gt; runoob_title VARCHAR(100) NOT NULL, -&gt; runoob_author VARCHAR(40) NOT NULL, -&gt; submission_date DATE, -&gt; PRIMARY KEY ( runoob_id ) -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.16 sec)mysql&gt; ​ 注意: MySQL命令终止符为分号(;)。 实例解析： 如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 7. MySQL删除数据表​ MySQL中删除数据表是非常容易操作的， 但是你再进行删除表操作时要非常小心，因为执行删除命令后所有数据都会消失。 语法 ​ 以下为删除MySQL数据表的通用语法：1DROP TABLE table_name ; ​ 例子： 1mysql&gt; DROP TABLE runoob_tbl 8. 插入数据​ MySQL 表中使用 INSERT INTO SQL语句来插入数据。 语法 ​ 以下为向MySQL数据表插入数据通用的 INSERT INTO SQL语法： 123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); ​ 如果数据是字符型，必须使用单引号或者双引号，如：”value”。 实例 ​ 以下实例中我们将向 runoob_tbl 表插入三条数据: 1234567891011121314151617181920root@host# mysql -u root -p password;Enter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW());Query OK, 1 rows affected, 1 warnings (0.01 sec)mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 MySQL&quot;, &quot;菜鸟教程&quot;, NOW());Query OK, 1 rows affected, 1 warnings (0.01 sec)mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;JAVA 教程&quot;, &quot;RUNOOB.COM&quot;, &apos;2016-05-06&apos;);Query OK, 1 rows affected (0.00 sec)mysql&gt; ​ 注意： 使用箭头标记 -&gt; 不是 SQL 语句的一部分，它仅仅表示一个新行，如果一条SQL语句太长，我们可以通过回车键来创建一个新行来编写 SQL 语句，SQL 语句的命令结束符为分号 ;。 ​ 在以上实例中，我们并没有提供 runoob_id 的数据，因为该字段我们在创建表的时候已经设置它为 AUTO_INCREMENT(自动增加) 属性。 所以，该字段会自动递增而不需要我们去设置。实例中 NOW() 是一个 MySQL 函数，该函数返回日期和时间。 ​ 接下来我们可以通过以下语句查看数据表数据： ​ 读取数据表： ​ select * from runoob_tbl; ​ 输出结果： 9. 查询数据​ MySQL 数据库使用SQL SELECT语句来查询数据。 语法 ​ 以下为在MySQL数据库中查询数据通用的 SELECT 语法： 1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 实例 ​ 读取数据表： ​ select * from runoob_tbl; ​ 输出结果： 10. Where子句​ 如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句中。 语法 ​ 以下是 SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法： 12SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2..... 查询语句中你可以使用一个或者多个表，表之间使用逗号, 分割，并使用WHERE语句来设定查询条件。 你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。 以下为操作符列表，可用于 WHERE 子句中。 下表中实例假定 A 为 10, B 为 20 操作符 描述 实例 = 等号，检测两个值是否相等，如果相等返回true (A = B) 返回false。 &lt;&gt;, != 不等于，检测两个值是否相等，如果不相等返回true (A != B) 返回 true。 &gt; 大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true (A &gt; B) 返回false。 &lt; 小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true (A &lt; B) 返回 true。 &gt;= 大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true (A &gt;= B) 返回false。 &lt;= 小于等于号，检测左边的值是否小于于或等于右边的值, 如果左边的值小于或等于右边的值返回true (A &lt;= B) 返回 true。 ​ 如果我们想再 MySQL 数据表中读取指定的数据，WHERE 子句是非常有用的。 ​ 使用主键来作为 WHERE 子句的条件查询是非常快速的。 ​ 如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。 实例 ​ SELECT * from runoob_tbl WHERE runoob_author=’菜鸟教程’; ​ 输出结果： ​ MySQL 的 WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。 ​ 实例中使用了 BINARY 关键字，是区分大小写的，所以 runoob_author=’runoob.com’ 的查询条件是没有数据的。 11. Update 查询​ 如果需要修改或更新 MySQL 中的数据，可以使用 SQL UPDATE 命令来操作。. 语法 ​ 以下是 UPDATE 命令修改 MySQL 数据表数据的通用 SQL 语法： 12UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。 你可以在一个单独表中同时更新数据。 当你需要更新数据表中指定行的数据时 WHERE 子句是非常有用的。 实例 SQL UPDATE 语句：12345678910mysql&gt; UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3;Query OK, 1 rows affected (0.01 sec)mysql&gt; SELECT * from runoob_tbl WHERE runoob_id=3;+-----------+--------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+--------------+---------------+-----------------+| 3 | 学习 C++ | RUNOOB.COM | 2016-05-06 |+-----------+--------------+---------------+-----------------+1 rows in set (0.01 sec) ​ 从结果上看，runoob_id 为 3 的 runoob_title 已被修改。 12. Delete 语句​ 可以使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录。 语法 ​ 以下是 SQL DELETE 语句从 MySQL 数据表中删除数据的通用语法： 1DELETE FROM table_name [WHERE Clause] 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件 您可以在单个表中一次性删除记录。 当你想删除数据表中指定的记录时 WHERE 子句是非常有用的。 实例 ​ 以下实例将删除 runoob_tbl 表中 runoob_id 为3 的记录：1234mysql&gt; use RUNOOB;Database changedmysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3;Query OK, 1 row affected (0.23 sec) 13. Like字句​ 我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。 ​ WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。 ​ 但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。 ​ SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。准确的讲，百分号%表示的任意多个任意字符。 ​ 如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 语法 以下是 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法： 123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; 你可以在 WHERE 子句中指定任何条件。 你可以在 WHERE 子句中使用LIKE子句。 你可以使用LIKE子句代替等号 =。 LIKE 通常与 % 一同使用，类似于一个元字符的搜索。 你可以使用 AND 或者 OR 指定一个或多个条件。 你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。 实例 ​ 以下是我们将 runoob_tbl 表中获取 runoob_author 字段中以 COM 为结尾的的所有记录： ​ SQL UPDATE 语句：12345678910mysql&gt; use RUNOOB;Database changedmysql&gt; SELECT * from runoob_tbl WHERE runoob_author LIKE &apos;%COM&apos;;+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 3 | 学习 Java | RUNOOB.COM | 2015-05-01 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 |+-----------+---------------+---------------+-----------------+2 rows in set (0.01 sec) like 匹配/模糊匹配，会与 % 和 _ 结合使用。123456&apos;%a&apos; //以a结尾的数据&apos;a%&apos; //以a开头的数据&apos;%a%&apos; //含有a的数据&apos;_a_&apos; //三位且中间字母是a的&apos;_a&apos; //两位且结尾字母是a的&apos;a_&apos; //两位且开头字母是a的 14. union操作符描述 ​ MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 语法 ​ MySQL UNION 操作符语法格式：1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; 参数 expression1, expression2, … expression_n: 要检索的列。 tables: 要检索的数据表。 WHERE conditions: 可选， 检索条件。 DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。 ALL: 可选，返回所有结果集，包含重复数据。 演示数据库 ​ 下面使用RUNOOB样本数据库中”Websites”表的数据1234567891011mysql&gt; SELECT * FROM Websites;+----+--------------+---------------------------+-------+---------+| id | name | url | alexa | country |+----+--------------+---------------------------+-------+---------+| 1 | Google | https://www.google.cm/ | 1 | USA || 2 | 淘宝 | https://www.taobao.com/ | 13 | CN || 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN || 4 | 微博 | http://weibo.com/ | 20 | CN || 5 | Facebook | https://www.facebook.com/ | 3 | USA || 7 | stackoverflow | http://stackoverflow.com/ | 0 | IND |+----+---------------+---------------------------+-------+---------+ ​ 下面是 “apps” APP 的数据：123456789mysql&gt; SELECT * FROM apps;+----+------------+-------------------------+---------+| id | app_name | url | country |+----+------------+-------------------------+---------+| 1 | QQ APP | http://im.qq.com/ | CN || 2 | 微博 APP | http://weibo.com/ | CN || 3 | 淘宝 APP | https://www.taobao.com/ | CN |+----+------------+-------------------------+---------+3 rows in set (0.00 sec) SQL UNION 实例 ​ 下面的 SQL 语句从 “Websites” 和 “apps” 表中选取所有不同的country（只有不同的值）： 实例1234SELECT country FROM WebsitesUNIONSELECT country FROM appsORDER BY country; 执行结果：12345678+---------+| country |+---------+| USA || CN || IND || USA |+---------+ ​ 注释：UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！ ​ 下面的 SQL 语句使用 UNION ALL 从 “Websites” 和 “apps” 表中选取所有的country（也有重复的值）：1234SELECT country FROM WebsitesUNION ALLSELECT country FROM appsORDER BY country; 执行结果：12345678910111213+---------+| country |+---------+| USA || CN || CN || CN || CN || CN || CN || IND || USA |+---------+ 带有 WHERE 的 SQL UNION ALL123456SELECT country, name FROM WebsitesWHERE country=&apos;CN&apos;UNION ALLSELECT country, app_name FROM appsWHERE country=&apos;CN&apos;ORDER BY country; 执行结果：12345678910+---------+----------+| country | name |+---------+----------+| CN | 微博 APP || CN | 微博 || CN | 淘宝 APP || CN | 淘宝 || CN | QQ APP || CN | 菜鸟教程 |+---------+----------+ 15. 排序​ 如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。 语法 ​ 以下是 SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据： 12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]] 你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。 你可以设定多个字段来排序。 你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。 你可以添加 WHERE…LIKE 子句来设置条件。 实例 ​ 尝试以下实例，结果将按升序及降序排列1234567891011121314151617181920212223mysql&gt; use RUNOOB;Database changedmysql&gt; SELECT * from runoob_tbl ORDER BY submission_date ASC;+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 3 | 学习 Java | RUNOOB.COM | 2015-05-01 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 || 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 || 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 |+-----------+---------------+---------------+-----------------+4 rows in set (0.01 sec)mysql&gt; SELECT * from runoob_tbl ORDER BY submission_date DESC;+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 || 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 || 3 | 学习 Java | RUNOOB.COM | 2015-05-01 |+-----------+---------------+---------------+-----------------+4 rows in set (0.01 sec) 16. GROUP BY (分组) 语句​ GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 GROUP BY 语法 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 实例 ​ 本章节实例使用到了以下表结构及数据，使用前我们可以先将以下数据导入数据库中。1234567891011121314151617181920212223SET NAMES utf8;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for `employee_tbl`-- ----------------------------DROP TABLE IF EXISTS `employee_tbl`;CREATE TABLE `employee_tbl` ( `id` int(11) NOT NULL, `name` char(10) NOT NULL DEFAULT &apos;&apos;, `date` datetime NOT NULL, `singin` tinyint(4) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;登录次数&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of `employee_tbl`-- ----------------------------BEGIN;INSERT INTO `employee_tbl` VALUES (&apos;1&apos;, &apos;小明&apos;, &apos;2016-04-22 15:25:33&apos;, &apos;1&apos;), (&apos;2&apos;, &apos;小王&apos;, &apos;2016-04-20 15:25:47&apos;, &apos;3&apos;), (&apos;3&apos;, &apos;小丽&apos;, &apos;2016-04-19 15:26:02&apos;, &apos;2&apos;), (&apos;4&apos;, &apos;小王&apos;, &apos;2016-04-07 15:26:14&apos;, &apos;4&apos;), (&apos;5&apos;, &apos;小明&apos;, &apos;2016-04-11 15:26:40&apos;, &apos;4&apos;), (&apos;6&apos;, &apos;小明&apos;, &apos;2016-04-04 15:26:54&apos;, &apos;2&apos;);COMMIT;SET FOREIGN_KEY_CHECKS = 1; ​ 导入成功后，执行以下 SQL 语句： 123456789101112mysql&gt; set names utf8;mysql&gt; SELECT * FROM employee_tbl;+----+--------+---------------------+--------+| id | name | date | singin |+----+--------+---------------------+--------+| 1 | 小明 | 2016-04-22 15:25:33 | 1 || 2 | 小王 | 2016-04-20 15:25:47 | 3 || 3 | 小丽 | 2016-04-19 15:26:02 | 2 || 4 | 小王 | 2016-04-07 15:26:14 | 4 || 5 | 小明 | 2016-04-11 15:26:40 | 4 || 6 | 小明 | 2016-04-04 15:26:54 | 2 |+----+--------+---------------------+--------+ ​ 接下来我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录： 12345678mysql&gt; SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;+--------+----------+| name | COUNT(*) |+--------+----------+| 小丽 | 1 || 小明 | 3 || 小王 | 2 |+--------+----------+ 使用 WITH ROLLUP ​ WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。 ​ 例如我们将以上的数据表按名字进行分组，再统计每个人登录的次数： 123456789mysql&gt; SELECT name, SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------+--------------+| name | singin_count |+--------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+--------+--------------+ ​ 其中记录 NULL 表示所有人的登录次数。 ​ 我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：1select coalesce(a,b,c); ​ 参数说明：如果a\==null,则选择b；如果b\==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。 ​ 以下实例中如果名字为空我们使用总数代替：123456789mysql&gt; SELECT coalesce(name, &apos;总数&apos;), SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------------------------+--------------+| coalesce(name, &apos;总数&apos;) | singin_count |+--------------------------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || 总数 | 16 |+--------------------------+--------------+ 17. MySql 连接的使用​ 在真正的应用中经常需要从多个数据表中读取数据。本章节我们将向大家介绍如何使用 MySQL 的 JOIN 在两个或多个表中查询数据。 ​ 你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。 JOIN 按照功能大致分为如下三类： INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 本章节使用的数据库结构及数据下载：runoob-mysql-join-test.sql。 使用 INNER JOIN​ 我们在RUNOOB数据库中有两张表 tcount_tbl 和 runoob_tbl。两张数据表数据如下： 实例 ​ 测试实例数据12345678910111213141516171819202122mysql&gt; use RUNOOB;Database changedmysql&gt; SELECT * FROM tcount_tbl;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| 菜鸟教程 | 10 || RUNOOB.COM | 20 || Google | 22 |+---------------+--------------+3 rows in set (0.01 sec)mysql&gt; SELECT * from runoob_tbl;+-----------+---------------+---------------+-----------------+| runoob_id | runoob_title | runoob_author | submission_date |+-----------+---------------+---------------+-----------------+| 1 | 学习 PHP | 菜鸟教程 | 2017-04-12 || 2 | 学习 MySQL | 菜鸟教程 | 2017-04-12 || 3 | 学习 Java | RUNOOB.COM | 2015-05-01 || 4 | 学习 Python | RUNOOB.COM | 2016-03-06 || 5 | 学习 C | FK | 2017-04-05 |+-----------+---------------+---------------+-----------------+ ​ 接下来我们就使用MySQL的INNER JOIN(也可以省略 INNER 使用 JOIN，效果一样)来连接以上两张表来读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值： INNER JOIN123456789mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+-------------+-----------------+----------------+| a.runoob_id | a.runoob_author | b.runoob_count |+-------------+-----------------+----------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 |+-------------+-----------------+----------------+ ​ 以上 SQL 语句等价于： where 字句123456789mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;+-------------+-----------------+----------------+| a.runoob_id | a.runoob_author | b.runoob_count |+-------------+-----------------+----------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 |+-------------+-----------------+----------------+ MySQL LEFT JOIN​ MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。 实例 ​ 尝试以下实例，以 runoob_tbl 为左表，tcount_tbl 为右表，理解 MySQL LEFT JOIN 的应用： LEFT JOIN:12345678910mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+-------------+-----------------+----------------+| a.runoob_id | a.runoob_author | b.runoob_count |+-------------+-----------------+----------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 || 5 | FK | NULL |+-------------+-----------------+----------------+ ​ 以上实例中使用了 LEFT JOIN，该语句会读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值。 MySQL RIGHT JOIN​ MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据 实例 ​ 尝试以下实例，以 runoob_tbl 为左表，tcount_tbl 为右表，理解MySQL RIGHT JOIN的应用： RIGHT JOIN12345678910mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;+-------------+-----------------+----------------+| a.runoob_id | a.runoob_author | b.runoob_count |+-------------+-----------------+----------------+| 1 | 菜鸟教程 | 10 || 2 | 菜鸟教程 | 10 || 3 | RUNOOB.COM | 20 || 4 | RUNOOB.COM | 20 || NULL | NULL | 22 |+-------------+-----------------+----------------+ ​ 以上实例中使用了 RIGHT JOIN，该语句会读取右边的数据表 tcount_tbl 的所有选取的字段数据，即便在左侧表 runoob_tbl 中没有对应的runoob_author 字段值。 参考资料：http://www.runoob.com/mysql/mysql-join.html 18. NULL值处理​ MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。 ​ 为了处理这种情况，MySQL提供了三大运算符: IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 ​ 关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。 ​ 在 MySQL 中，NULL 值与任何其它值比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。 ​ MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。 实例 ​ 以下实例中假设数据库 RUNOOB 中的表 runoob_test_tbl 含有两列 runoob_author 和 runoob_count, runoob_count 中设置插入NULL值。 创建数据表 runoob_test_tbl123456789101112131415161718192021222324root@host# mysql -u root -p password;Enter password:*******mysql&gt; use RUNOOB;Database changedmysql&gt; create table runoob_test_tbl -&gt; ( -&gt; runoob_author varchar(40) NOT NULL, -&gt; runoob_count INT -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values (&apos;RUNOOB&apos;, 20);mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values (&apos;菜鸟教程&apos;, NULL);mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values (&apos;Google&apos;, NULL);mysql&gt; INSERT INTO runoob_test_tbl (runoob_author, runoob_count) values (&apos;FK&apos;, 20);mysql&gt; SELECT * from runoob_test_tbl;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| RUNOOB | 20 || 菜鸟教程 | NULL || Google | NULL || FK | 20 |+---------------+--------------+ ​ 以下实例中你可以看到 = 和 != 运算符是不起作用的：1234mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count = NULL;Empty set (0.00 sec)mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count != NULL;Empty set (0.01 sec) ​ 查找数据表中 runoob_test_tbl 列是否为 NULL，必须使用 IS NULL 和 IS NOT NULL，如下实例：123456789101112131415mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| 菜鸟教程 | NULL || Google | NULL |+---------------+--------------+mysql&gt; SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| RUNOOB | 20 || FK | 20 |+---------------+--------------+ 19. MySQL 正则表达式​ 在前面的章节我们已经了解到MySQL可以通过 LIKE …% 来进行模糊匹配。 ​ MySQL 同样也支持其他正则表达式的匹配， MySQL中使用 REGEXP 操作符来进行正则表达式匹配。 ​ 如果您了解PHP或Perl，那么操作起来就非常简单，因为MySQL的正则表达式匹配与这些脚本的类似。 ​ 下表中的正则模式可应用于 REGEXP 操作符中。 模式 描述 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 . 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 […] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^…] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。 p1\ p2\ p3 匹配 p1 或 p2 或 p3。例如，’z\ food’ 能匹配 “z” 或 “food”。’(z\ f)ood’ 则匹配 “zood” 或 “food”。 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 实例 ​ 了解以上的正则需求后，我们就可以根据自己的需求来编写带有正则表达式的SQL语句。以下我们将列出几个小实例(表名：person_tbl )来加深我们的理解： ​ 查找name字段中以’st’为开头的所有数据： 1mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;^st&apos;; ​ 查找name字段中以’ok’为结尾的所有数据： 1mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;ok$&apos;; ​ 查找name字段中包含’mar’字符串的所有数据： 1mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;mar&apos;; ​ 查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据： 1mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;^[aeiou]|ok$&apos;; 20. 事务​ MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！ 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句 一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。(参见这篇文章的第四章第1小节) 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务控制语句： BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 MYSQL 事务处理主要有两种方法： 1、用 BEGIN, ROLLBACK, COMMIT来实现 BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 事务测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546mysql&gt; use RUNOOB;Database changedmysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb; # 创建数据表Query OK, 0 rows affected (0.04 sec)mysql&gt; select * from runoob_transaction_test;Empty set (0.01 sec)mysql&gt; begin; # 开始事务Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into runoob_transaction_test value(5);Query OK, 1 rows affected (0.01 sec)mysql&gt; insert into runoob_transaction_test value(6);Query OK, 1 rows affected (0.00 sec)mysql&gt; commit; # 提交事务Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from runoob_transaction_test;+------+| id |+------+| 5 || 6 |+------+2 rows in set (0.01 sec)mysql&gt; begin; # 开始事务Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into runoob_transaction_test values(7);Query OK, 1 rows affected (0.00 sec)mysql&gt; rollback; # 回滚Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from runoob_transaction_test; # 因为回滚所以数据没有插入+------+| id |+------+| 5 || 6 |+------+2 rows in set (0.01 sec) 21. alter命令​ 当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。 ​ 开始本章教程前让我们先创建一张表，表名为：testalter_tbl。12345678910111213mysql&gt; create table testalter_tbl -&gt; ( -&gt; i INT, -&gt; c CHAR(1) -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; SHOW COLUMNS FROM testalter_tbl;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| i | int(11) | YES | | NULL | || c | char(1) | YES | | NULL | |+-------+---------+------+-----+---------+-------+ 删除，添加或修改表字段 如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：1ALTER TABLE testalter_tbl DROP i; ​ 如果数据表中只剩余一个字段则无法使用DROP来删除字段。 ​ MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:1ALTER TABLE testalter_tbl ADD i INT; ​ 执行以上命令后，i 字段会自动添加到数据表字段的末尾。12345678mysql&gt; SHOW COLUMNS FROM testalter_tbl;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c | char(1) | YES | | NULL | || i | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec) ​ 如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。 ​ 尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：1234ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT FIRST;ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT AFTER c; ​ FIRST 和 AFTER 关键字只占用于 ADD 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。 修改字段类型及名称 ​ 如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。 ​ 例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令: 1mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10); ​ 使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例： 1mysql&gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT; 1mysql&gt; ALTER TABLE testalter_tbl CHANGE j j INT; ALTER TABLE 对 Null 值和默认值的影响 ​ 当你修改字段时，你可以指定是否包含值或者是否设置默认值。 ​ 以下实例，指定字段 j 为 NOT NULL 且默认值为100 。 12mysql&gt; ALTER TABLE testalter_tbl -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100; ​ 如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。 修改字段默认值 ​ 你可以使用 ALTER 来修改字段的默认值，尝试以下实例： 123456789mysql&gt; ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;mysql&gt; SHOW COLUMNS FROM testalter_tbl;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c | char(1) | YES | | NULL | || i | int(11) | YES | | 1000 | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec) ​ 你也可以使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例： 12345678910mysql&gt; ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;mysql&gt; SHOW COLUMNS FROM testalter_tbl;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| c | char(1) | YES | | NULL | || i | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)Changing a Table Type: ​ 修改数据表类型，可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 testalter_tbl 的类型修改为 MYISAM ： ​ 注意：查看数据表类型可以使用 SHOW TABLE STATUS 语句。 12345678910111213141516171819mysql&gt; ALTER TABLE testalter_tbl ENGINE = MYISAM;mysql&gt; SHOW TABLE STATUS LIKE &apos;testalter_tbl&apos;\G*************************** 1. row **************** Name: testalter_tbl Type: MyISAM Row_format: Fixed Rows: 0 Avg_row_length: 0 Data_length: 0Max_data_length: 25769803775 Index_length: 1024 Data_free: 0 Auto_increment: NULL Create_time: 2007-06-03 08:04:36 Update_time: 2007-06-03 08:04:36 Check_time: NULL Create_options: Comment:1 row in set (0.00 sec) 修改表名 ​ 如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。 ​ 尝试以下实例将数据表 testalter_tbl 重命名为 alter_tbl： 1mysql&gt; ALTER TABLE testalter_tbl RENAME TO alter_tbl; ​ ALTER 命令还可以用来创建及删除MySQL数据表的索引，该功能我们会在接下来的章节中介绍。 22. MySQL索引​ MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 ​ 打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。 ​ 索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。 ​ 创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。 ​ 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。 ​ 上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 ​ 建立索引会占用磁盘空间的索引文件。 普通索引创建索引 ​ 这是最基本的索引，它没有任何限制。它有以下几种创建方式： 1CREATE INDEX indexName ON mytable(username(length)); ​ 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引) 1ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定 123456789CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法 1DROP INDEX [indexName] ON mytable; 唯一索引​ 它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： 创建索引 1CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构 1ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定 12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 使用ALTER 命令添加和删除索引 ​ 有四种方式来添加数据表的索引： ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。 以下实例为在表中添加索引。 1mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c); ​ 你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引: 1mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c; 使用 ALTER 命令添加和删除主键 ​ 主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下： 12mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); ​ 你也可以使用 ALTER 命令删除主键： 1mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY; ​ 删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。 显示索引信息 ​ 你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。 ​ 尝试以下实例: 1mysql&gt; SHOW INDEX FROM table_name; \G 23. 临时表​ MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。 ​ 临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。 ​ MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。 ​ 如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。 实例 ​ 以下展示了使用MySQL 临时表的简单实例，以下的SQL代码可以适用于PHP脚本的mysql_query()函数 1234567891011121314151617181920mysql&gt; CREATE TEMPORARY TABLE SalesSummary ( -&gt; product_name VARCHAR(50) NOT NULL -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00 -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00 -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0);Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO SalesSummary -&gt; (product_name, total_sales, avg_unit_price, total_units_sold) -&gt; VALUES -&gt; (&apos;cucumber&apos;, 100.25, 90, 2);mysql&gt; SELECT * FROM SalesSummary;+--------------+-------------+----------------+------------------+| product_name | total_sales | avg_unit_price | total_units_sold |+--------------+-------------+----------------+------------------+| cucumber | 100.25 | 90.00 | 2 |+--------------+-------------+----------------+------------------+1 row in set (0.00 sec) ​ 当你使用 SHOW TABLES命令显示数据表列表时，你将无法看到 SalesSummary表。 ​ 如果你退出当前MySQL会话，再使用 SELECT命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。 删除MySQL 临时表 ​ 默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 DROP TABLE 命令来手动删除临时表。 ​ 以下是手动删除临时表的实例： 123mysql&gt; DROP TABLE SalesSummary;mysql&gt; SELECT * FROM SalesSummary;ERROR 1146: Table &apos;RUNOOB.SalesSummary&apos; doesn&apos;t exist 24. 复制表​ 如果我们需要完全的复制MySQL的数据表，包括表的结构，索引，默认值等。 如果仅仅使用CREATE TABLE … SELECT 命令，是无法实现的。 ​ 本章节将为大家介绍如何完整的复制MySQL数据表，步骤如下： 使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。 复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。 如果你想复制表的内容，你就可以使用 INSERT INTO … SELECT 语句来实现。 实例 ​ 尝试以下实例来复制表 runoob_tbl 。 步骤一： ​ 获取数据表的完整结构。 123456789101112mysql&gt; SHOW CREATE TABLE runoob_tbl \G;*************************** 1. row *************************** Table: runoob_tblCreate Table: CREATE TABLE `runoob_tbl` ( `runoob_id` int(11) NOT NULL auto_increment, `runoob_title` varchar(100) NOT NULL default &apos;&apos;, `runoob_author` varchar(40) NOT NULL default &apos;&apos;, `submission_date` date default NULL, PRIMARY KEY (`runoob_id`), UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)) ENGINE=InnoDB 1 row in set (0.00 sec) 步骤二： ​ 修改SQL语句的数据表名，并执行SQL语句。 123456789mysql&gt; CREATE TABLE `clone_tbl` ( -&gt; `runoob_id` int(11) NOT NULL auto_increment, -&gt; `runoob_title` varchar(100) NOT NULL default &apos;&apos;, -&gt; `runoob_author` varchar(40) NOT NULL default &apos;&apos;, -&gt; `submission_date` date default NULL, -&gt; PRIMARY KEY (`runoob_id`), -&gt; UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)-&gt; ) ENGINE=InnoDB;Query OK, 0 rows affected (1.80 sec) 步骤三： ​ 执行完第二步骤后，你将在数据库中创建新的克隆表 clone_tbl。 如果你想拷贝数据表的数据你可以使用 INSERT INTO… SELECT 语句来实现。 1234567mysql&gt; INSERT INTO clone_tbl (runoob_id, -&gt; runoob_title, -&gt; runoob_author, -&gt; submission_date) -&gt; SELECT runoob_id,runoob_title, -&gt; runoob_author,submission_date -&gt; FROM runoob_tbl; ​ 执行以上步骤后，你将完整的复制表，包括表结构及表数据。 25. 元数据你可能想知道MySQL以下三种信息： 查询结果信息： SELECT, UPDATE 或 DELETE语句影响的记录数。 数据库和数据表的信息： 包含了数据库及数据表的结构信息。 MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等。 在MySQL的命令提示符中，我们可以很容易的获取以上服务器信息。 但如果使用Perl或PHP等脚本语言，你就需要调用特定的接口函数来获取。 接下来我们会详细介绍。 ​ 元数据主要是为了其他语言了解mysql数据库和数据表信息而设置的。 获取服务器元数据 ​ 以下命令语句可以在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本。 命令 描述 SELECT VERSION( ) 服务器版本信息 SELECT DATABASE( ) 当前数据库名 (或者返回空) SELECT USER( ) 当前用户名 SHOW STATUS 服务器状态 SHOW VARIABLES 服务器配置变量 26. 序列使用​ MySQL序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。 ​ 本小节将介绍如何使用MySQL的序列。 使用AUTO_INCREMENT ​ MySQL中最简单使用序列的方法就是使用 MySQL AUTO_INCREMENT 来定义列。 实例 ​ 以下实例中创建了数据表insect， insect中id无需指定值可实现自动增长。 123456789101112131415161718192021222324mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, # type of insect -&gt; date DATE NOT NULL, # date collected -&gt; origin VARCHAR(30) NOT NULL # where collected);Query OK, 0 rows affected (0.02 sec)mysql&gt; INSERT INTO insect (id,name,date,origin) VALUES -&gt; (NULL,&apos;housefly&apos;,&apos;2001-09-10&apos;,&apos;kitchen&apos;), -&gt; (NULL,&apos;millipede&apos;,&apos;2001-09-10&apos;,&apos;driveway&apos;), -&gt; (NULL,&apos;grasshopper&apos;,&apos;2001-09-10&apos;,&apos;front yard&apos;);Query OK, 3 rows affected (0.02 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM insect ORDER BY id;+----+-------------+------------+------------+| id | name | date | origin |+----+-------------+------------+------------+| 1 | housefly | 2001-09-10 | kitchen || 2 | millipede | 2001-09-10 | driveway || 3 | grasshopper | 2001-09-10 | front yard |+----+-------------+------------+------------+3 rows in set (0.00 sec) 获取AUTO_INCREMENT值 ​ 在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。 重置序列 ​ 如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 不过该操作要非常小心，如果在删除的同时又有新记录添加，有可能会出现数据混乱。操作如下所示： 1234mysql&gt; ALTER TABLE insect DROP id;mysql&gt; ALTER TABLE insect -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST, -&gt; ADD PRIMARY KEY (id); 设置序列的开始值 ​ 一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现： 12345678mysql&gt; CREATE TABLE insect -&gt; ( -&gt; id INT UNSIGNED NOT NULL AUTO_INCREMENT, -&gt; PRIMARY KEY (id), -&gt; name VARCHAR(30) NOT NULL, -&gt; date DATE NOT NULL, -&gt; origin VARCHAR(30) NOT NULL)engine=innodb auto_increment=100 charset=utf8; ​ 或者你也可以在表创建成功后，通过以下语句来实现： 1mysql&gt; ALTER TABLE t AUTO_INCREMENT = 100; 27. 处理重复数据​ 有些 MySQL 数据表中可能存在重复的记录，有些情况我们允许重复数据的存在，但有时候我们也需要删除这些重复的数据。 ​ 本章节我们将为大家介绍如何防止数据表出现重复数据及如何删除数据表中的重复数据。 防止表中出现重复数据 ​ 你可以在MySQL数据表中设置指定的字段为PRIMARY KEY（主键）或者 UNIQUE（唯一)索引来保证数据的唯一性。让我们尝试一个实例：下表中无索引及主键，所以该表允许出现多条重复记录。 12345CREATE TABLE person_tbl( first_name CHAR(20), last_name CHAR(20), sex CHAR(10)); ​ 如果你想设置表中字段first_name，last_name数据不能重复，你可以设置双主键模式来设置数据的唯一性， 如果你设置了双主键，那么那个键的默认值不能为NULL，可设置为NOT NULL。如下所示： 123456CREATE TABLE person_tbl( first_name CHAR(20) NOT NULL, last_name CHAR(20) NOT NULL, sex CHAR(10), PRIMARY KEY (last_name, first_name)); ​ 如果我们设置了唯一索引，那么在插入重复数据时，SQL语句将无法执行成功,并抛出错。 ​ INSERT IGNORE INTO与INSERT INTO的区别就是INSERT IGNORE会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。 ​ 以下实例使用了INSERT IGNORE INTO，执行后不会出错，也不会向数据表中插入重复数据： 123456mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name) -&gt; VALUES( &apos;Jay&apos;, &apos;Thomas&apos;);Query OK, 1 row affected (0.00 sec)mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name) -&gt; VALUES( &apos;Jay&apos;, &apos;Thomas&apos;);Query OK, 0 rows affected (0.00 sec) ​ INSERT IGNORE INTO当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而REPLACE INTO into如果存在primary 或 unique相同的记录，则先删除掉。再插入新记录。 ​ 另一种设置数据的唯一性方法是添加一个UNIQUE索引，如下所示： 1234567CREATE TABLE person_tbl( first_name CHAR(20) NOT NULL, last_name CHAR(20) NOT NULL, sex CHAR(10) UNIQUE (last_name, first_name)); 统计重复数据 ​ 以下我们将统计表中 first_name 和 last_name的重复记录数： 1234mysql&gt; SELECT COUNT(*) as repetitions, last_name, first_name -&gt; FROM person_tbl -&gt; GROUP BY last_name, first_name -&gt; HAVING repetitions &gt; 1; ​ 以上查询语句将返回 person_tbl 表中重复的记录数。 一般情况下，查询重复的值，请执行以下操作： 确定哪一列包含的值可能会重复。 在列选择列表使用COUNT(*)列出的那些列。 在GROUP BY子句中列出的列。 HAVING子句设置重复数大于1。 过滤重复数据 ​ 如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。 12mysql&gt; SELECT DISTINCT last_name, first_name -&gt; FROM person_tbl; ​ 你也可以使用 GROUP BY 来读取数据表中不重复的数据： 123mysql&gt; SELECT last_name, first_name -&gt; FROM person_tbl -&gt; GROUP BY (last_name, first_name); 删除重复数据 ​ 如果你想删除数据表中的重复数据，你可以使用以下的SQL语句： 123mysql&gt; CREATE TABLE tmp SELECT last_name, first_name, sex FROM person_tbl GROUP BY (last_name, first_name, sex);mysql&gt; DROP TABLE person_tbl;mysql&gt; ALTER TABLE tmp RENAME TO person_tbl; ​ 当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下： 12mysql&gt; ALTER IGNORE TABLE person_tbl -&gt; ADD PRIMARY KEY (last_name, first_name); 28. SQL注入​ 如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题。 ​ 本章节将为大家介绍如何防止SQL注入，并通过脚本来过滤SQL中注入的字符。 ​ 所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 ​ 我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。 ​ 以下实例中，输入的用户名必须为字母、数字及下划线的组合，且用户名长度为 8 到 20 个字符之间： 123456789if (preg_match(&quot;/^\w&#123;8,20&#125;$/&quot;, $_GET[&apos;username&apos;], $matches))&#123; $result = mysqli_query($conn, &quot;SELECT * FROM users WHERE username=$matches[0]&quot;);&#125; else &#123; echo &quot;username 输入异常&quot;;&#125; ​ 让我们看下在没有过滤特殊字符时，出现的SQL情况： 123// 设定$name 中插入了我们不需要的SQL语句$name = &quot;Qadir&apos;; DELETE FROM users;&quot;; mysqli_query($conn, &quot;SELECT * FROM users WHERE name=&apos;&#123;$name&#125;&apos;&quot;); ​ 以上的注入语句中，我们没有对 $name 的变量进行过滤，$name 中插入了我们不需要的SQL语句，将删除 users 表中的所有数据。 ​ 在PHP中的 mysqli_query() 是不允许执行多个 SQL 语句的，但是在 SQLite 和 PostgreSQL 是可以同时执行多条SQL语句的，所以我们对这些用户的数据需要进行严格的验证。 ​ 防止SQL注入，我们需要注意以下几个要点： 1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。 29. 导出数据MySQL中你可以使用SELECT…INTO OUTFILE语句来简单的导出数据到文本文件上。 使用 SELECT … INTO OUTFILE 语句导出数据 以下实例中我们将数据表 runoob_tbl 数据导出到 /tmp/tutorials.txt 文件中: 12mysql&gt; SELECT * FROM runoob_tbl -&gt; INTO OUTFILE &apos;/tmp/tutorials.txt&apos;; 你可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式： 123mysql&gt; SELECT * FROM passwd INTO OUTFILE &apos;/tmp/tutorials.txt&apos; -&gt; FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; -&gt; LINES TERMINATED BY &apos;\r\n&apos;; 在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。 1234SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos;FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;LINES TERMINATED BY &apos;\n&apos;FROM test_table; SELECT … INTO OUTFILE 语句有以下属性: LOAD DATA INFILE是SELECT … INTO OUTFILE的逆操作，SELECT句法。为了将一个数据库的数据写入一个文件，使用SELECT … INTO OUTFILE，为了将文件读回数据库，使用LOAD DATA INFILE。 SELECT…INTO OUTFILE ‘file_name’形式的SELECT可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。 输出不能是一个已存在的文件。防止文件数据被篡改。 你需要有一个登陆服务器的账号来检索文件。否则 SELECT … INTO OUTFILE 不会起任何作用。 在UNIX中，该文件被创建后是可读的，权限由MySQL服务器所拥有。这意味着，虽然你就可以读取该文件，但可能无法将其删除。 上面这些方法只是基本的导出数据到文件的方式，还有其他导出数据方式，可以参考资料：MySQL导出数据 30. 导入数据​ MySQL中可以使用两种简单的方式来导入MySQL导出的数据。 使用 LOAD DATA 导入数据 ​ MySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。 1mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl; ​ 如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。 ​ 你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。 ​ 两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。 ​ 如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。 123mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl -&gt; FIELDS TERMINATED BY &apos;:&apos; -&gt; LINES TERMINATED BY &apos;\r\n&apos;; ​ LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。 ​ 如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下： 12mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; -&gt; INTO TABLE mytbl (b, c, a); 使用 mysqlimport 导入数据 ​ mysqlimport客户端提供了LOAD DATA INFILEQL语句的一个命令行接口。mysqlimport的大多数选项直接对应LOAD DATA INFILE子句。 ​ 从文件 dump.txt 中将数据导入到 mytbl 数据表中, 可以使用以下命令： 12$ mysqlimport -u root -p --local database_name dump.txtpassword ***** ​ mysqlimport命令可以指定选项来设置指定格式,命令语句格式如下： 123$ mysqlimport -u root -p --local --fields-terminated-by=&quot;:&quot; \ --lines-terminated-by=&quot;\r\n&quot; database_name dump.txtpassword ***** ​ mysqlimport 语句中使用 –columns 选项来设置列的顺序： 123$ mysqlimport -u root -p --local --columns=b,c,a \ database_name dump.txtpassword ***** mysqlimport的常用选项介绍 选项 功能 -d or –delete 新数据导入数据表中之前删除数据数据表中的所有信息 -f or –force 不管是否遇到错误，mysqlimport将强制继续插入数据 -i or –ignore mysqlimport跳过或者忽略那些有相同唯一 关键字的行， 导入文件中的数据将被忽略。 -l or -lock-tables 数据被插入之前锁住表，这样就防止了， 你在更新数据库时，用户的查询和更新受到影响。 -r or -replace 这个选项与－i选项的作用相反；此选项将替代 表中有相同唯一关键字的记录。 –fields-enclosed- by= char 指定文本文件中数据的记录时以什么括起的， 很多情况下 数据以双引号括起。 默认的情况下数据是没有被字符括起的。 –fields-terminated- by=char 指定各个数据的值之间的分隔符，在句号分隔的文件中， 分隔符是句号。您可以用此选项指定数据之间的分隔符。 默认的分隔符是跳格符（Tab） –lines-terminated- by=str 此选项指定文本文件中行与行之间数据的分隔字符串 或者字符。 默认的情况下mysqlimport以newline为行分隔符。 您可以选择用一个字符串来替代一个单个的字符： 一个新行或者一个回车。 ​ mysqlimport命令常用的选项还有-v 显示版本（version）， -p 提示输入密码（password）等。 四、概念理解1. 事务的一致性理解 一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。 举个粒子，张三给李四转账100元。事务要做的是从张三账户上减掉100元，李四账户上加上100元。一致性的含义是其他事务要么看到张三还没有给李四转账的状态，要么张三已经成功转账给李四的状态，而对于张三少了100元，李四还没加上100元这个中间状态是不可见的。 那么反驳的声音来了： 要么转账操作全部成功，要么全部失败，这是原子性。从例子上看全部成功，那么一致性就是原子性的一部分咯，为什么还要单独说一致性和原子性？ 你说的不对。在未提交读的隔离级别下是事务内部操作是可见的，明显违背了一致性，怎么解释？ 好吧，需要注意的是： 原子性和一致性的的侧重点不同：原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见。但是因为某某性能的关系，对于一致性做了妥协 参考资料：MySQL事务一致性理解 2. 事务的隔离性理解​ 事务的ACID属性： Atomicity: Either all the changes from the transaction occur (writes, and messages sent), or none occur. Consistency: The transaction preserves the integrity of stored information. Isolation: Concurrently executing transactions see the stored information as if they were running serially (one after another). Durability: Once a transaction commits, the changes it made (writes and messages sent) survive any system failures. ​ 在上述隔离性（Isolation）的定义中，我们可以发现其目标是使并发事务的执行效果与串行一致，但在具体技术实现上往往需要在并发能力和串行化效果之间进行平衡，很难两者兼顾。平衡的结果就是会出现违反串行效果的现象即异常现象（Phenomenon）。通常来说，隔离级别的提升伴随着并发能力的下降，两者负相关。各种数据库在谈到隔离级别时都会引用ANSI SQL-92标准隔离级别，我们来看看它的具体内容。 ​ ANSI SQL-92 Isolation Levels ​ ANSI SQL-92可能是最早提出了基于异常现象来定义隔离级别的方法，同时没有将隔离级别与具体实现机制绑定，隔离的实现可以基于锁（lock-based）或者无锁（lock-free），兼容了后续的技术发展。该标准根据三种异常现象将隔离性定义为四个级别，具体如下。 脏读，事务（T1）中修改的数据项在尚未提交的情况下被其他事务（T2）读取到，而T1进行Rollback操作，则T2刚刚读取到的数据并没有实际存在。 不可重复读，T1读取数据项，T2对其中的数据进行了修改或删除且Commit成功。如果T1尝试再次读取这些数据，会得到T2修改后的数据或者发现数据已删除。这样T1在一个事务中两次同样条件的读取，且结果集内容变更或结果集数量减少。 幻读，T1使用特定的查询条件获得一个结果集，T2插入新的数据且这些数据符合T1刚刚操作的查询条件。T2 commit 成功后，T1再次执行同样的查询，此时得到的结果集增大。 ​ 上面这些介绍只是最简单的事务隔离级别，还有其他更严谨事务隔离级别分类，可以参考：https://www.cnblogs.com/ivan-uno/p/8274355.html 参考资料：再谈数据库事务隔离性 3. 主键、外键和索引的区别 主键 外键 索引 定义： 唯一标识一条记录，不能有重复的，不允许为空 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 该字段没有重复值，但可以有一个空值 作用： 用来保证数据完整性 用来和其他表建立联系用的 是提高查询排序的速度 个数： 主键只能有一个 一个表可以有多个外键 一个表可以有多个惟一索引]]></content>
      <categories>
        <category>数据库</category>
        <category>编程基础知识</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用代码块]]></title>
    <url>%2F2018%2F01%2F17%2F1_Java%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Java常用代码块1. 读取控制台的输入第一种方式：BufferedReader123BufferedReader br = new BufferedReader(new InputStreamReader(System.in));System.out.println(br.readLine());br.close(); ​ 这种方式，利用字符流来读取控制台的输入，读到的数据全部都是字符串。 第二种方式: Scanner 1234Scanner scanner = new Scanner(System.in);String line = scanner.next();System.out.println(line);scanner.close(); ​ 第二种方法利用了Scanner类，可以使用next读取字符串，nextInt等方法读取整型等基本类型数据，也就是说Scanner类具有一定的解析能力，如果是读取基本类型数据，推荐使用Scanner。 2. 使用迭代方式实现二叉树的中序遍历​ 实现二叉树的中序遍历，最简单的方式是采用递归。但是在有的题目中，或者一些场景下，不能使用递归，需要使用迭代的方式。这个时候就可以采用栈(Stack或LinkedList)来实现了，其实是对递归过程的一个模拟。下面是具体Java代码块：123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty())&#123; while (cur != null)&#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); list2.add(cur.val); cur = cur.right; &#125; return list2; &#125;&#125; 3. 二叉树的3种遍历的6种实现方法​ 二叉树有先序遍历、中序遍历和后序遍历，对应的都有递归实现和循环实现。递归实现很简洁，但是如果遍历的深度太深的话，那么可能会发生递归栈溢出。循环实现麻烦一点，但是更健壮一些。循环实现的话，主要是使用栈来进行实现。==在六种实现当中一定要多注意一下，二叉树的后序遍历循环实现代码==。 首先定义一个二叉树节点类：123456789public class TreeNode&lt;T&gt; &#123; //下面的权限是包内可以访问 T val;//当前节点值 TreeNode&lt;T&gt; left;//左孩子 TreeNode&lt;T&gt; right;//右孩子 public TreeNode(T val) &#123; this.val = val; &#125;&#125; 3.1 先序遍历​ (1)递归实现123456public static void firstRootTraverse(TreeNode&lt;Integer&gt; root)&#123; if(root == null) return; System.out.println(root.val); firstRootTraverse(root.left); firstRootTraverse(root.right);&#125; ​ (2) 循环实现12345678910111213public static void firstRootTraverse2(TreeNode&lt;Integer&gt; root)&#123; if(root == null) return ; LinkedList&lt;TreeNode&lt;Integer&gt;&gt; stack = new LinkedList&lt;&gt;(); while (root != null || !stack.isEmpty())&#123; if(root != null)&#123; System.out.println(root.val); stack.push(root); root = root.left; &#125;else &#123; root = stack.pop().right; &#125; &#125;&#125; 3.2 中序遍历​ (1)递归实现 123456public static void middleRootTraverse(TreeNode&lt;Integer&gt; root)&#123; if(root == null) return ; middleRootTraverse(root.left); System.out.println(root.val);//注意访问root.val相对位置 middleRootTraverse(root.right);&#125; ​ (2) 循环实现1234567891011121314public static void middleRootTraverse2(TreeNode&lt;Integer&gt; root)&#123; if(root == null) return ; LinkedList&lt;TreeNode&lt;Integer&gt;&gt; stack = new LinkedList&lt;&gt;(); while(root != null || !stack.isEmpty())&#123; if(root != null) &#123; stack.push(root); root = root.left; &#125;else &#123; root = stack.pop(); System.out.println(root.val); //注意访问 root.val的位置哦 root = root.right; &#125; &#125;&#125; 3.3 后序遍历​ (1)递归实现 123456public static void lastRootTraverse(TreeNode&lt;Integer&gt; root)&#123; if(root == null) return ; lastRootTraverse(root.left); lastRootTraverse(root.right); System.out.println(root.val);//注意访问root.val的位置&#125; ​ (2) 循环实现 ​ 二叉树的后序遍历非递归实现，一定要多注意一点，和前面几种实现相比还是有一定难度的。 1234567891011121314151617181920public static void lastRootTraverse2(TreeNode&lt;Integer&gt; root)&#123; if(root == null) return; LinkedList&lt;TreeNode&lt;Integer&gt;&gt; stack = new LinkedList&lt;&gt;(); TreeNode&lt;Integer&gt; read_node = null;//记录当前访问的节点 while(root != null || !stack.isEmpty())&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else &#123; root = stack.peek(); if(root.right == null || root.right == read_node)&#123;//右子节点不存在或者已经访问过了 System.out.println(root.val); read_node = stack.pop(); root = null; &#125;else &#123; root = root.right; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程常用知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2017%2F12%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FRedis%2F</url>
    <content type="text"><![CDATA[一、Redis 是什么 二、五种基本类型 1. STRING 2. LIST 3. SET 4. HASH 5. ZSET 三、键的过期时间 四、发布与订阅 五、事务 六、持久化 1. 快照持久化 2. AOF 持久化 七、复制 从服务器连接主服务器的过程 主从链 八、处理故障 九、分片 1. 客户端分片 2. 代理分片 3. 服务器分片 十、事件 事件类型 事件的调度与执行 十一、Redis 与 Memcached 的区别 数据类型 数据持久化 分布式 内存管理机制 十二、Redis 适用场景 缓存 消息队列 计数器 好友关系 十三、数据淘汰策略 十四、一个简单的论坛系统分析 文章信息 点赞功能 对文章进行排序 参考资料 一、Redis 是什么Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 五种类型数据类型为：字符串、列表、集合、有序集合、散列表。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 二、五种基本类型 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 LIST 链表 从两端压入或者弹出元素 读取单个或者多个元素 进行修剪，只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 What Redis data structures look like 1. STRING 12345678&gt; set hello worldOK&gt; get hello"world"&gt; del hello(integer) 1&gt; get hello(nil) 2. LIST 123456789101112131415161718192021&gt; rpush list-key item(integer) 1&gt; rpush list-key item2(integer) 2&gt; rpush list-key item(integer) 3&gt; lrange list-key 0 -11) "item"2) "item2"3) "item"&gt; lindex list-key 1"item2"&gt; lpop list-key"item"&gt; lrange list-key 0 -11) "item2"2) "item" 3. SET 123456789101112131415161718192021222324252627&gt; sadd set-key item(integer) 1&gt; sadd set-key item2(integer) 1&gt; sadd set-key item3(integer) 1&gt; sadd set-key item(integer) 0&gt; smembers set-key1) "item"2) "item2"3) "item3"&gt; sismember set-key item4(integer) 0&gt; sismember set-key item(integer) 1&gt; srem set-key item2(integer) 1&gt; srem set-key item2(integer) 0&gt; smembers set-key1) "item"2) "item3" 4. HASH 123456789101112131415161718192021222324&gt; hset hash-key sub-key1 value1(integer) 1&gt; hset hash-key sub-key2 value2(integer) 1&gt; hset hash-key sub-key1 value1(integer) 0&gt; hgetall hash-key1) "sub-key1"2) "value1"3) "sub-key2"4) "value2"&gt; hdel hash-key sub-key2(integer) 1&gt; hdel hash-key sub-key2(integer) 0&gt; hget hash-key sub-key1"value1"&gt; hgetall hash-key1) "sub-key1"2) "value1" 5. ZSET 12345678910111213141516171819202122232425&gt; zadd zset-key 728 member1(integer) 1&gt; zadd zset-key 982 member0(integer) 1&gt; zadd zset-key 982 member0(integer) 0&gt; zrange zset-key 0 -1 withscores1) "member1"2) "728"3) "member0"4) "982"&gt; zrangebyscore zset-key 0 800 withscores1) "member1"2) "728"&gt; zrem zset-key member1(integer) 1&gt; zrem zset-key member1(integer) 0&gt; zrange zset-key 0 -1 withscores1) "member0"2) "982" 三、键的过期时间Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。 过期时间对于清理缓存数据非常有用。 四、发布与订阅订阅者订阅了频道之后，发布者向频道发送字符串消息会被所有订阅者接收到。 发布与订阅模式和观察者模式有以下不同： 观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，发布者与订阅者不知道对方的存在，它们之间通过频道进行通信。 观察者模式是同步的，当事件触发时，主题会去调度观察者的方法；而发布与订阅模式是异步的； 发布与订阅有一些问题，很少使用它，而是使用替代的解决方案。问题如下： 如果订阅者读取消息的速度很慢，会使得消息不断积压在发布者的输出缓存区中，造成内存占用过多； 如果订阅者在执行订阅的过程中网络出现问题，那么就会丢失断线期间发送的所有消息。 五、事务Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 MULTI 和 EXEC 中的操作将会一次性发送给服务器，而不是一条一条发送，这种方式称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 六、持久化Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 1. 快照持久化将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量很大，保存快照的时间会很长。 2. AOF 持久化将写命令添加到 AOF 文件（Append Only File）的末尾。 对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，然后由操作系统决定什么时候将该内容同步到硬盘，用户可以调用 file.flush() 方法请求操作系统尽快将缓冲区存储的数据同步到硬盘。 将写命令添加到 AOF 文件时，要根据需求来保证何时将添加的数据同步到硬盘上，有以下同步选项： 选项 同步频率 always 每个写命令都同步 everysec 每秒同步一次 no 让操作系统来决定何时同步 always 选项会严重减低服务器的性能；everysec 选项比较合适，可以保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；no 选项并不能给服务器性能带来多大的提升，而且也会增加系统奔溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大；Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 七、复制通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。 一个从服务器只能有一个主服务器，并且不支持主主复制。 从服务器连接主服务器的过程 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令； 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令； 主服务器每执行一次写命令，就向从服务器发送相同的写命令。 主从链随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。 八、处理故障要用到持久化文件来恢复服务器的数据。 持久化文件可能因为服务器出错也有错误，因此要先对持久化文件进行验证和修复。对 AOF 文件就行验证和修复很容易，修复操作将第一个出错命令和其后的所有命令都删除；但是只能验证快照文件，无法对快照文件进行修复，因为快照文件进行了压缩，出现在快照文件中间的错误可能会导致整个快照文件的剩余部分无法读取。 当主服务器出现故障时，Redis 常用的做法是新开一台服务器作为主服务器，具体步骤如下：假设 A 为主服务器，B 为从服务器，当 A 出现故障时，让 B 生成一个快照文件，将快照文件发送给 C，并让 C 恢复快照文件的数据。最后，让 B 成为 C 的从服务器。 九、分片Redis 中的分片类似于 MySQL 的分表操作，分片是将数据划分为多个部分的方法，对数据的划分可以基于键包含的 ID、基于键的哈希值，或者基于以上两者的某种组合。通过对数据进行分片，用户可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Reids 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… 等等，有不同的方式来选择一个指定的键存储在哪个实例中。最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。 1. 客户端分片客户端使用一致性哈希等算法决定键应当分布到哪个节点。 2. 代理分片将客户端请求发送到代理上，由代理转发请求到正确的节点上。 3. 服务器分片Redis Cluster。 十、事件事件类型1. 文件事件服务器有许多套接字，事件产生时会对这些套接字进行操作，服务器通过监听套接字来处理事件。常见的文件事件有：客户端的连接事件；客户端的命令请求事件；服务器向客户端返回命令结果的事件； 2. 时间事件又分为两类：定时事件是让一段程序在指定的时间之内执行一次；周期性事件是让一段程序每隔指定时间就执行一次。 事件的调度与执行服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能监听太久，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。 事件调度与执行由 aeProcessEvents 函数负责，伪代码如下： 1234567891011121314151617181920212223def aeProcessEvents(): # 获取到达时间离当前时间最接近的时间事件 time_event = aeSearchNearestTimer() # 计算最接近的时间事件距离到达还有多少毫秒 remaind_ms = time_event.when - unix_ts_now() # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0 if remaind_ms &lt; 0: remaind_ms = 0 # 根据 remaind_ms 的值，创建 timeval timeval = create_timeval_with_ms(remaind_ms) # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定 aeApiPoll(timeval) # 处理所有已产生的文件事件 procesFileEvents() # 处理所有已到达的时间事件 processTimeEvents() 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下： 1234567891011def main(): # 初始化服务器 init_server() # 一直处理事件，直到服务器关闭为止 while server_is_not_shutdown(): aeProcessEvents() # 服务器关闭，执行清理操作 clean_server() 从事件处理的角度来看，服务器运行流程如下： 十一、Redis 与 Memcached 的区别两者都是非关系型内存键值数据库。有以下主要不同： 数据类型Memcached 仅支持字符串类型，而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。 数据持久化Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 分布式Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式的支持。 内存管理机制在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 十二、Redis 适用场景缓存将热点数据放到内存中。 消息队列List 类型是双向链表，很适合用于消息队列。 计数器Redis 这种内存数据库能支持计数器频繁的读写操作。 好友关系使用 Set 类型的交集操作很容易就可以知道两个用户的共同好友。 十三、数据淘汰策略可以设置内存最大使用量，当内存使用量超过时施行淘汰策略，具体有 6 种淘汰策略。 策略 描述 volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random 从已设置过期时间的数据集中任意选择数据淘汰 allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰 allkeys-random 从所有数据集中任意选择数据进行淘汰 noeviction 禁止驱逐数据 如果使用 Redis 来缓存数据时，要保证所有数据都是热点数据，可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法（LRU、TTL）实际实现上并非针对所有 key，而是抽样一小部分 key 从中选出被淘汰 key。抽样数量可通过 maxmemory-samples 配置。 十四、一个简单的论坛系统分析该论坛系统功能如下： 可以发布文章； 可以对文章进行点赞； 在首页可以按文章的发布时间或者文章的点赞数进行排序显示； 文章信息文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。 Redis 没有关系型数据库中的表这一概念来将同类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。 点赞功能当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。 为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。 对文章进行排序为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的） 参考资料 Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013. 黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014. REDIS IN ACTION 论述 Redis 和 Memcached 的差异 Redis 3.0 中文版- 分片 Redis 应用场景 Observer vs Pub-Sub]]></content>
      <categories>
        <category>数据库</category>
        <category>编程基础知识</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NOSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式]]></title>
    <url>%2F2017%2F12%2F01%2F1_Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JAVA设计模式设计模式软件架构模式基本概念及三者区别在做软件架构设计时,根据不同的抽象层次可分为三种不同层次的模式：架构模式(Architectural Pattern)、设计模式(Design Pattern)、代码模式(Coding Pattern)。 &emsp;&emsp;架构模式是一个系统的高层次策略，涉及到大尺度的组件以及整体性质和力学。架构模式的好坏可以影响到总体布局和框架 结构。 &emsp;&emsp;设计模式是中等尺度的结构策略。这些中等尺度的结构实现了一些大尺度组件的行为和它们之间的关系。模式的好坏不会影响到系统的总体布局和总体框架。设计模式定义出子系统或组件的微观结构。 &emsp;&emsp;代码模式（或成例）是特定的范例和与特定语言有关的编程技巧。代码模式的好坏会影响到一个中等尺度组件的内部、外部的结构或行为的底层细节，但不会影响到一个部件或子系统的中等尺度的结构，更不会影响到系统的总体布局和大尺度框架。 1. 架构模式(Architectural Pattern)一个架构模式描述软件系统里的基本的结构组织或纲要。架构模式提供一些事先定义好的子系统，指定它们的责任，并给出把它们组织在一起的法则和指南。称之为系统模式。 MVC模式,一个架构模式常常可以分解成很多个设计模式的联合使用。MVC模式常常包括调停者（Mediator）模式、策略（Strategy）模式、合成（Composite）模式、观察者（Observer）模式等。 Layers（分层）模式，有时也称Tiers模式 Blackboard（黑板）模式 Broker（中介）模式 Distributed Process（分散过程）模式 Microkernel（微核）模式 架构模式常常划分成如下的几种： 一、 模块结构(From Mud to Structure)型。帮助架构师将系统合理划分，避免形成一个对象的海洋。包括Layers（分层）模式、Blackboard（黑板）模式、Pipes/Filters（管道/过滤器）模式等。 二、分散系统（Distributed Systems）型。为分散式系统提供完整的架构设计，包括像Broker（中介）模式等。 三、人机互动（Interactive Systems）型，支持包含有人机互动界面的系统的架构设计，例子包括MVC（Model-View-Controller）模式、PAC（Presentation-Abstraction-Control）模式等。 四、Adaptable Systems型，支持应用系统适应技术的变化、软件功能需求的变化。如Reflection（反射）模式、Microkernel（微核）模式等。 2. 设计模式(Design Pattern)一个设计模式提供一种提炼子系统或软件系统中的组件的，或者它们之间的关系的纲要设计。设计模式描述普遍存在的在相互通讯的组件中重复出现的结构，这种结构解决在一定的背景中的具有一般性的设计问题。 设计模式常常划分成不同的种类，常见的种类有： 创建型设计模式，如工厂方法（Factory Method）模式、抽象工厂（Abstract Factory）模式、原型（Prototype）模式、单例（Singleton）模式，建造（Builder）模式等 结构型设计模式，如合成（Composite）模式、装饰（Decorator）模式、代理（Proxy）模式、享元（Flyweight）模式、门面（Facade）模式、桥梁（Bridge）模式等 行为型模式，如模版方法（Template Method）模式、观察者（Observer）模式、迭代子（Iterator）模式、责任链（Chain of Responsibility）模式、备忘录（Memento）模式、命令（Command）模式、状态（State）模式、访问者（Visitor）模式等等。 以上是三种经典类型，实际上还有很多其他的类型，比如Fundamental型、Partition型，Relation型等等。设计模式在特定的编程语言中实现的时候，常常会用到代码模式。比如单例（Singleton）模式的实现常常涉及到双检锁（Double-Check Locking）模式等。 3. 代码模式(Coding Pattern)代码模式（或成例）是较低层次的模式，并与编程语言密切相关。代码模式描述怎样利用一个特定的编程语言的特点来实现一个组件的某些特定的方面或关系。 较为著名的代码模式的例子包括双检锁（Double-Check Locking）模式等 原文网址:http://zhidao.baidu.com/link?url=ehOFeyNExgYkFdGD9SYAWGsWNBpeWyzMW1bUoqqAq_-VfrQsBU9CyBxys0zAx715sdBnh98bRzbX9mCYGR5jgq 一、架构模式将架构模式分为四类： 从混乱到有序类 包括Layers、Pipes and Filters和Blackboard 分布式系统 只包括Broker模式。 交互式系统 包括Model-View-Controller和Presentation-Abstraction-Control模式。 可适应系统 包括Reflection和Microkernel模式 1.从混乱到有序1.1 Layers模式分层（Layer）模式是最常见的一种架构模式。甚至说分层模式是很多架构模式的基础，本章下面讲到的一些内容实际上都和分层模式相关联。 分层描述的是这样一种架构设计过程：从最低级别的抽象开始，称为第1层。这是系统的基础。通过将第J层放置在第J-1层的上面逐步向上完成抽象阶梯，直到到达功能的最高级别，称为第N层。 因而分层模式就可以定义为：将解决方案的组件分隔到不同的层中。每一层中的组件应保持内聚性，并且应大致在同一抽象级别。每一层都应与它下面的各层保持松散耦合。 分层模式的关键点在于确定依赖：即通过分层，可以限制子系统间的依赖关系，使系统以更松散的方式耦合，从而更易于维护。 相对于分层，还有一种概念叫分区。分层是对架构的横向划分，而分区是对架构的纵向划分。 典型的分层方式是应用程序专用功能位于上层，跨越应用程序领域的功能位于中层，而配置环境专用功能位于低层。层的数量与组成取决于问题领域和解决方案的复杂程度。通常而言只有一个应用程序专用层。应当把子系统组织成分层结构，架构的上层是应用程序专用子系统，架构的低层是硬件和操作专用子系统，中间件层是通用服务。 对系统进行分层有如下基本原则： — 可见度。各子系统只能与同一层及其下一层的子系统存在依赖关系。 — 易变性。最上层放置随用户需求的改变而改变的元素。最底层放置随实施平台（硬件、语言、操作系统、数据库等）的改变而改变的元素。中间的夹层放置广泛适用于各种系统和实施环境的元素。如果在这些大类中进一步划分有助于对模型进行组织，则添加更多的层。 — 通用性。一般将抽象的模型元素放置在模型的低层。如果它们不针对于具体的实施，则倾向于将其放置在中间层。 — 层数。对于小型系统，三层就足够了。对于复杂系统，通常需要5-7层。无论复杂程度如何，如果超过10层，就需要慎重考虑了。层数越多，越需慎重。 常见的分层架构模式 客户端-服务器模型（Client-Server，C/S）。 三层模型：用户表示层、业务逻辑层、数据层。 多层结构的技术组成模型：表现层、中间层、数据层。 网络系统常用三层结构：核心层、汇聚层和接入层。 RUP典型分层方法：应用层、专业业务层、中间件层、系统软件层。 基于Java的B/S模式系统结构：浏览器端、服务器端、请求接收层、请求处理层。 某六层结构：功能层（用户界面）、模块层、组装层（软件总线）、服务层（数据处理）、数据层、核心层。 简单例子 比如，一个高中年级的管理结构。首先是普通的学生，然后是小组长，小组长上面是班长，班长一层上面是班主任，然后班主任一层上面是年纪主任。 1.2 Pipes and Filters模式 架构模式Pipes and Filters提供的结构适合用于处理数据流的系统。每个处理步骤封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输。通过重组过滤器，可打造多个相关的系统组。 背景处理数据流 问题 假设要打造的系统必须对输入数据进行处理或转换，以单个组件的方式实现这种系统可能不可行，原因有多个：系统必须由多名开发人员打造；整个系统要完成的任务分多个处理阶段；需求很可能发生变化。因此，需要提供灵活性，以便能够更换处理步骤或调整处理顺序。提供这样的灵活性后，便可使用既有处理组件打造出一些列系统。设计系统时，必须考虑如下作用力。 以后可通过更换或重组处理步骤来改进系统。 相比大型组件，在其他环境中重用小型处理步骤更容易。 不相邻的处理步骤不共享消息。 存在不同的输入数据源，如网络连接和提供温度的硬件传感器。 最终结果能够以各种方式和存储。 如果要求用户将中间结果存储到文件中，供以后进一步处理，将很容易出错。 应避免同时执行多个处理步骤，如并行或半并行地执行这些步骤。 解决方案 架构模式Pipes and Filters将系统面临的任务分为多个一次执行的处理步骤。这些步骤通过在系统中传输的数据相关联：一个步骤的输出是下一个步骤的输入。每个处理步骤都由过滤器组件实现。过滤器一边使用数据一边提供数据，而不是等到获得所有输入后才生成输出。这降低了延迟，实现了真正的并行处理。数据源、过滤器、数据接收器通过管道依次相连，每条管道都在相邻处理步骤之间传输数据。 结构 过滤器组件式流水线的处理单元，负责充实、提炼或转换输入数据。过滤器操作可由多种事件触发： - 下一个流水线元素从过滤器拉去输出。(被动过滤器) - 前一个流水线元素向过滤器推送输入。(被动过滤器) - 过滤器不间断地循环，从流水线上游拉去输入，并向下游推送输出。(主动过滤器) 管道指的是过滤器之间、数据源和第一个过滤器之间以及最后一个过滤器和数据接收器之间的连接。将两个主动过滤器组件相连时，管道负责让它们同步，这是使用先进先出缓冲区实现的。被动过滤器与主动过滤器相连时，可这样实现管道：由主动过滤器直接调用被动过滤器，但直接调用增加了重组过滤器的难度。 数据源指的是系统输入，提供结构或类型相同的数据序列，如包含文本行的文件或提供数字序列的传感器。 数据接收器从流水线末端收集结果，分主动接收器和被动数据接收器。 实现 Pipes and Filters架构实现起来很简单。可将系统服务(如消息队列或UNIX管道)用作管道连接，也可采取其他方式，如直接调用。 将系统要完成的任务划分为一系列处理阶段。 定义沿管道传递的数据的格式。 确定如何实现每条管道连接。 设计并实现过滤器。 实际错误处理机制。UNIX为错误消息定义了专用输出通道stderr。过滤器并行运行时，单个错误通道可能包含来自不同组件的错误消息，这即不明显又无法预测。 搭建处理流水线。 效果 优点： 不需要中间文件，但也可以使用。 可更换过滤器。 可重组过滤器 可重用过滤器组件 可快速创建流水线原型。 效率因并行处理得以提高。 缺点： 共享状态信息的开销高昂或缺乏灵活性。 通过并行处理提高效率的初衷常常成为泡影。 数据转换开销。 错误处理。 简单例子 比如，流水线作业，一道工序一道工序的进行，最后就生成出了产品。Linux下的管道命令”|”，将前一个命令的结果作为第二个命令的输入数据。 参考资料：http://blog.csdn.net/zsdjoo/article/details/45223809 1.3 Blackboard模式这种模式对于没有确定解决方案策略的问题是有用的。黑板模式由3个主要组成部分组成。 黑板——包含来自解决方案空间的对象的结构化全局内存 知识源——专门的模块和它们自己的表示 控制组件——选择、配置和执行模块 所有的组件都可以访问黑板。组件可以生成添加到黑板上的新数据对象。组件在黑板上查找特定类型的数据，并通过与现有知识源的模式匹配来查找这些数据。 使用场景： 语音识别 车辆识别和跟踪 蛋白质结构识别 声纳信号的解释 参考资料：10种常见的软件架构模式 2.分布式系统2.1 Broker模式zhg 自己的理解： 其实Broker模式就是在客户端和服务器之间增加了一个Broker，这样就可以将客户端和服务器进行解耦，服务器可以动态的增删或移动，只要注册到了Broker中，客户端就可以通过Broker来调用服务器的服务。 下面的内容参考自：分布式模式之Broker模式 ​ 引入一个Broker组件，解耦客户端和服务端。服务端注册自己到Broker，通过暴露接口的方式允许客户端接入服务。客户端是通过Broker发送请求的，Broker转发请求道服务端，并将请求的结果或异常回发给客户端。通过使用Broker模式，应用可以通过发送消息访问远程的服务。 这一架构模式允许动态的改变、添加、删除服务端，从客户端的角度，这些都是透明的。 结构： Broker模式定义了6中类：Client，Server，Client_Proxy，Server_Proxy，Broker，Bridge。 Server：l 责任：处理特定领域的问题，实现服务的细节，注册自己到Broker，处理请求并返回结果或异常。 l 协作类：Server_Proxy，Broker Client：Client是需要访问远程服务的应用程序，为此，Client发送请求到Broker，并从Broker上接收响应或异常。Client和Server只是逻辑上相关而已，实际上Client并不知道Server的确切位置。 l 责任：1. 实现用户端功能，2. 发送请求到Broker，3. 接收相应和异常。 l 协作类：Broker，Client_Proxy Broker：Broker可以被看成消息转发器。Broker也负责一些控制和管理操作。它能够定位服务端的位置，若发生异常，能够将异常捕获传给Client。Broker需要提供注册服务的接口给Server。如果请求来自其他的Broker，本地的Broker需要转发请求并最终将结果或异常回应给相应的远程Broker。Broker提供的服务和name service非常相像（如DNS、LDAP）。 l 责任：1. 注册服务。2. 提供服务API。3. 转发消息。4. 容错处理。5. 与其他Broker的交互。6。 定位服务。 l 协作类：Client_Proxy,Server_Proxy,Bridge Client_Proxy：连系Client和Broker，这一层保证了通讯的透明性，使Client调用远程服务就像调用本地的服务一样。 l 责任：1. 封装特定的系统调用。2. 封装通讯的参数、控制信息等。 l 协作类：Client,Broker。 Server_Proxy： Server_proxy是与Client_Proxy相对应的，它接受请求，解包消息，解析出参数并调用服务的实现接口。 l 责任：1. 封装特定的系统调用。2. 封装通讯的参数、控制信息等。3. 调用server的服务接口。 l 协作类：Server,Broker。 Bridge：Bridge用来连接各个Broker，一般这个组件是可选的。当系统是发杂的网络组成时，有可能需要这一角色。 l 责任：1. 封装特定的网络特性。2. 传递Broker之间的通讯。 l 协作类：Broker。 应用场景一：直接通讯方式。Client和Server相互理解他们之间的通讯协议。Broker主要完成Client和Server之间的握手。之后所有的消息、异常都是由Client与Server直接交互。（想象DNS）。简单对象交互如图： 应用场景二：l Broker启动，完成自身的初始化，之后进入事件循环，等待消息到来。 l Server启动，首先执行自身的初始化，然后注册自己到Broker。 l Broker接收Server的注册请求，将其加入到可使用服务的列表，并回应Ack给Server。 l Server接收Ack，进入事件监听循环，等待消息到来。 l Client调用远程服务对象的方法，Client_Proxy封装消息请其发送给Broker。 l Broker查询可使用的Server，将请求转发给Server。 l Server_Proxy解析消息，分离出参数和控制信息，并调用特定的Server实现接口。Server处理完的结果通过Server_proxy封装成消息转发到Server。 l Broker将相应消息转发给正确的Client_Proxy，Client受到响应继续其他逻辑。 简单对象交互如图： 应用场景三：l Broker A接收到请求，交由Server处理，但是发现该Server位于其他的网络节点。 l Broker A将请求转发给Bridge A，Bridge A将请求进行必要的格式化，传送给Bridge B。 l Bridge B将请求进行必要的格式化，转化成Broker B可以理解的格式，并转发给Broker B。Broker B执行场景二中的过程，处理的结果按如上逆序返回。 简单对象交互如图： 部署示意图： 总结：优点： 服务的位置透明性。 组件的可变性及扩展性。由于Server是注册到Broker上的，所以Server可以动态的增加、删除、改变。 Broker之间可交互。 可重用性。 由于组件的耦合度较小，调试和测试的工作也是可控的。 缺点: 效率；增加了一层Broker的消息转发，效率有所降低。 容错能力必须要特别考虑。 调试和测试的工作加大。 3.交互式系统3.1 Model-View-Controller模式基本介绍MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC模式最早由Trygve Reenskaug在1978年提出[1] ，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件设计模式。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。专业人员可以通过自身的专长分组： （控制器Controller）- 负责转发请求，对请求进行处理。 （视图View） - 界面设计人员进行图形界面设计。 （模型Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。 视图 ​ 在视图中其实没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。 模型 模型表示企业数据和业务规则。在MVC的三个部件中，模型拥有最多的处理任务。例如它可能用象EJBs和ColdFusionComponents这样的构件对象来处理数据库。被模型返回的数据是中立的，就是说模型与数据格式无关，这样一个模型能为多个视图提供数据。由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 控制器 控制器接受用户的输入并调用模型和视图去完成用户的需求。所以当单击Web页面中的超链接和发送HTML表单时，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。 为什么要使用 MVC 首先，最重要的一点是多个视图能共享一个模型，现在需要用越来越多的方式来访问你的应用程序。对此，其中一个解决之道是使用MVC，无论你的用户想要Flash界面或是WAP 界面；用一个模型就能处理它们。由于你已经将数据和业务规则从表示层分开，所以你可以最大化的重用你的代码了。 由于模型返回的数据没有进行格式化，所以同样的构件能被不同界面使用。例如，很多数据可能用HTML来表示，但是它们也有可能要用AdobeFlash和WAP来表示。模型也有状态管理和数据持久性处理的功能，例如，基于会话的购物车和电子商务过程也能被Flash网站或者无线联网的应用程序所重用。 因为模型是自包含的，并且与控制器和视图相分离，所以很容易改变你的应用程序的数据层和业务规则。如果你想把你的数据库从MySQL移植到Oracle，或者改变你的基于RDBMS数据源到LDAP，只需改变你的模型即可。一旦你正确的实现了模型，不管你的数据来自数据库或是LDAP服务器，视图将会正确的显示它们。由于运用MVC的应用程序的三个部件是相互独立，改变其中一个不会影响其它两个，所以依据这种设计思想你能构造良好的松耦合的构件。 对我来说，控制器也提供了一个好处，就是可以使用控制器来联接不同的模型和视图去完成用户的需求，这样控制器可以为构造应用程序提供强有力的手段。给定一些可重用的模型和视图，控制器可以根据用户的需求选择模型进行处理，然后选择视图将处理结果显示给用户。 MVC的优点1.低耦合性 视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。 2.高重用性和可适用性 随着技术的不断进步，现在需要用越来越多的方式来访问应用程序。MVC模式允许你使用各种不同样式的视图来访问同一个服务器端的代码。它包括任何 WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是 一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。例如，很多数据可能用HTML来表示，但是也有可能用WAP来表示，而这 些表示所需要的命令是改变视图层的实现方式，而控制层和模型层无需做任何改变。 3.较低的生命周期成本 MVC使开发和维护用户接口的技术含量降低。 4.快速的部署 使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。 5.可维护性 分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。 6.有利于软件工程化管理 由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化管理程序代码。 MVC的缺点 MVC的缺点是由于它没有明确的定义，所以完全理解MVC并不是很容易。使用MVC需要精心的计划，由于它的内部原理比较复杂，所以需要花费一些时间去思考。 你将不得不花费相当可观的时间去考虑如何将MVC运用到你的应用程序，同时由于模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难。每个构件在使用之前都需要经过彻底的测试。一旦你的构件经过了测试，你就可以毫无顾忌的重用它们了。 根据开发者经验，由于开发者将一个应用程序分成了三个部件，所以使用MVC同时也意味着你将要管理比以前更多的文件，这一点是显而易见的。这样好像我们的工作量增加了，但是请记住这比起它所能带给我们的好处是不值一提。 MVC并不适合小型甚至中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。 MVC设计模式是一个很好创建软件的途径，它所提倡的一些原则，像内容和显示互相分离可能比较好理解。但是如果你要隔离模型、视图和控制器的构件，你可能需要重新思考你的应用程序，尤其是应用程序的构架方面。如果你肯接受MVC，并且有能力应付它所带来的额外的工作和复杂性，MVC将会使你的软件在健壮性，代码重用和结构方面上一个新的台阶。 3.2 Presentation-Abstraction-Control模式参考书籍《面向模式的软件架构–模式系统》的2.4.2节Presentation-Abstraction-Control模式 架构模式Presentation-Abstraction-Control(PAC) 定义了一种适用于交互式软件系统的结构——由相互协作的智能体组成层次结构。每个智能体都负责应用程序功能的特定方面，并包含三个组件：表示组件、抽象组件和控制组件，这将智能体的人机交互方面同功能核心和通信方面分离了。 问题： ​ 一个代表政治选举的简单系统。这个系统由一个用于输入数据的电子表格以及多种显示最新结果的图表。用户通过图形界面与系统交互。 ​ 主持人需要知道实时的数据，可以查看柱状图表示结果，扇形图表示结果。计票员需要在表格中输入新的投票。 PAC模式的结构 将交互式应用程序设计成由PAC智能体组成的树形结构，其中包含一个顶层智能体、多个中间层智能体和很多的底层智能体。每个智能体负责应用程序功能的特定方面，并由三个组件组成：表示组件、抽象组件和控制组件。 应用程序的层次结构放映了智能体之间的依赖关系，每个智能体都依赖于它上一层到最顶层的所有智能体。 智能体的组成： 表示组件提供了PAC智能体的可视化行为； 抽象组件维护智能体的底层数据模型，并提供操作这些数据的功能； 控制组件是表示组件和抽象组件之间的桥梁，并提供了让智能体能够与其他PAC智能体通信的功能。 顶层PAC智能体提供了系统的核心功能，其他大部分智能体都依赖或操作这个核心。另外，顶层PAC智能体还包括不属于特定子任务的用户界面，如菜单栏、显示应用程序信息的对话框等。 底层PAC智能体表示用户可操作的独立语义概念，如电子表格和图表。底层智能体向用户呈现这些概念，并支持用户可以对这些智能体执行的所有操作，如缩放或移动图表。 中间层PAC智能体表示下一层智能体的组合或他们之间的关系，例如，中间层智能体可能维护相同数据的多个视图。 我们的政治选举系统中定义了一个顶层PAC智能体，让系统能够访问底层数据仓库。这个数据仓库本身并非系统的一部分。在最底层，我们定义了四个PAC智能体：一个用于输入数据的电子表格智能体以及三个以不同方式表示数据的试图智能体。这个系统只有一个中间层PAC智能体，它负责协调底层的三个视图智能体，确保他们一致。电子表格智能体直接与顶层PAC智能体相连。用户只能与底层智能体交互。 情景1 这个情景描绘了打开新的选举数据柱状图视图时,不同PAC智能体之间的协作,还详细描述了“状图”智体的内部行为。这包括5个阶段。 用户请求“视图协调器”智能体的表示组件打开一个新的柱状图。 “视图协调器”智能体的控制组件实例化“柱状图”智能体。 “视图协调器”智能体向新创建的“柱状图”智能体发送“打开”事件。 “柱状图“智能体的控制组件从顶层PAC智能体那里获取数据,而“视图协调器”智能体充当了底层智能体和顶层智能体之间的转交人。返回的数据存储在“柱上状图”智能体的抽象组件中,然后,该智能体的控制组件调用表示组件来显示柱状图。 表示组件在屏幕新建一个窗口,从抽象组件那里获取数据(这是通过向控制组件请求数据实现的),再在新窗口中显示数据。 ​ 这里显然存在优化空间,例如,可让视图协调器缓存来自顶层智能体的数据,还可在存储数据前调用底层智能体的表示组件。然而,当前的重点是诠释这个模式的基本理念。 已知应用：移动机器人( Mobile Robot) 。该系统[Crro85让操作员能够与移动机器人交互。移动机器人在封闭而危险的环境中漫步,而环境由墙壁、设备和人员(要么是闯入者,要么是事故受害人)组成。机器人根据自身安装的传感器以及系统操作员提供的信息漫步。软件让操作员能够： 向机器人描绘其工作环境以及其中的场所和场所间的通道; 修改环境 指出机器人的使命 控制使命的实施 观察使命的实施进度。 ​ 环境中的每堵墙、每条通道、每个场所都由一个底层PAC智能体表示,这些智能体一起将环境可视化。环境由中间层PAC智能体表示,它们控制组成环境的“墙壁”、“通道”和“场所”PAC智能体。用户对环境的控制由“面板”PAC智能体提供,这种智能体也位于层次结构底层。“环境”PAC智能体和“面板”PAC智能体组成了机器人的工作空间,工作空间由独立的中间层PAC智能体表示。为支持同一个环境的多个视图，由“多工作空间”PAC智能体协调同一个工作空间的多个视图。顶层PAC智能体封装了应用程序的功能核心,这是一个基于规则的智能监控器( intelligent supervisor)，负责驾驭和控制机器人。 效果架构模式 Presentation- Abstraction- Control有多个优点。 口 分离关注点 。应用领域的每个语义概念都由独立的智能体表示,每个智能体都维护自己的状态和数据,并与其他PAC智能体协作,但又不依赖于它们。每个PAC智能体还提供自己的人机交互,让你能够独立地为应用程序的每个语义概念或任务开发专用的数据和用户界面。口 支持修改和扩展。修改PAC智能体的表示组件或抽象组件不影响系统中的其他智能体。这让你能够分别修改或优化各个PAC智能体的底层数据模型,还可分别修改智能体的用户界面如从 command she改为菜单和对话框。 ​ 在既有的PAC架构中,可轻松地集成新智能体,而无需对既有PAC智能体做重大修改。所有PAC智能体都通过预定义的接口相互通信,另外,可动态地注册新的PAC智能体,以确保通信和协作。例如,要在我们的政治选举信息系统中添加新的视图PAC智能体,只需扩展“视图协调器”PAC智能体的表示组件的面板,让用户能够创建这种新视图,而处理新PAC智能体的功能(如向“视图协调器”PAC智能体注册以及传播变更和事件)都是现成的。 口 支持多任务 。可轻松地让PAC智能体在不同线程、进程甚至计算机中运行。给PAC智能添加PC功能只会影响其控制组件。 多任务还能让多用户应用程序受益。例如,在我们的政治选举信息系统中,新闻主播可能播报最新的预测,而数据输入人员可能输入最新的选举数据。这要求共享数据仓库(或其控制组件)负责串行化或同步。 这个模式的缺点如下。 口 系统更复杂度 。应用程序的每个语义概念都实现为独立的PAC智能体,这可能导致系统结构非常复杂。例如,如果图形编辑器将每个图形对象(如圆或正方形)都实现为独立的PAC智能体,系统将被海量智能体淹没。另外,必须对智能体进行协调和控制,这需要额外的协调智能体。请务必仔细考虑设计的层级粒度,决定在什么情况下不再将智能体细化为更多的底层智能体。 口 复杂的控制组件 。在PAC系统中,控制组件是当前智能体的抽象组件和表示组件之间以及不同智能体之间的通信媒介。因此,控制组件的实现质量对智能体之间能否有效协作影响重大,而智能体之间能否有效协作又决定了系统架构的整体质量。控制组件的各个角色应完全分离。这些角色的实现不应依赖于其他智能体的细节,如其名称或在分布式系统中的物理位置。控制组件的接口应独立于内部细节,确保智能体的协作者不依赖于其表示组件和抽象组件的接口。必要时控制组件应执行接口和数据适配。 口 效率 。PAC智能体之间的通信开销可能影响系统的效率。例如,底层智能体从顶级智能体获取数据时,这种数据交换将把从PAC层次结构底部到顶部路径中的所有智能体都拖下水。如果智能体是分布式的,传输数据时还需进行PC以及对数据进行封送、解封送、分段和重组。 这些都是严重的隐患。下面讨论什么情况下该使用 Presentation- Abstraction- Control模式、什么情况下不该使用时,考虑了这些因素。 口 适用性 。应用程序中不可分割的语义概念越小、这些语义概念的用户界面越相似,这个模式就越不适用。例如,如果图形编辑器将文档的每个对象都用独立的PAC智能体表示,其结构将非常细致而复杂,进而难以维护。另一方面,如果不可分割的语义概念很大，且需要自己的人机交互,PAC将提供一种易于维护和扩展的结构,并完全分离不同系统任务的关注点。 4.可适应系统4.1 Microkernel模式微内核架构（MicroKernel Architecture）有时也被成为插件架构模式（plug-in architecture pattern），通常用于实现基于产品的应用，如Eclipse和Firefox。然而许多公司也将内部的业务软件做成软件产品，提供版本、发版说明和插件特性。微内核架构模式通过插件向核心应用添加额外的功能，提供了可扩展性和功能的独立和分离。 模式描述微内核架构包含两部分组件：核心系统（core system）和插件模块（plug-in modules）。应用逻辑被分割为独立的插件模块和核心系统，提供了可扩展性、灵活性、功能隔离和自定义处理逻辑的特性。 图1 微内核架构模式（microkernel architecture pattern） 微内核架构的核心系统通常提供系统运行所需的最小功能集。许多操作系统使用的就是微内核架构，这也是它名字的由来。从商业应用程序的角度来看，核心系统一般是通用业务逻辑，没有特殊情况、特殊规则或复杂情形下的自定义代码。 插件模块是独立的模块，包含特定的处理、额外的功能和自定义代码，来向核心系统增强或扩展额外的业务能力。通常插件模块之间也是独立的，也有一些插件是依赖于若干其它插件的。重要的是，尽量减少插件之间的通信以避免依赖的问题。 核心系统需要知道哪些插件是可用的且如何使用。一种实现的方式是使用插件注册表。注册表中包含插件的一些信息，如名称、数据契约（输入数据和输出数据）、远程访问协议（决定插件如何与核心系统连接，XML或WSDL等）。 插件模块和核心系统的连接方式有多种，包括OSGi (open service gateway initiative)、messaging、web service、甚至点对点绑定（对象实例化）。选择哪种连接方式取决于构件的应用类型和是否分布式部署等特殊需求。 插件和核心系统之间的契约也是各种各样的，既可以是标准的也可以是自定义的。通常在使用第三方插件时需要自定义契约。这种情况下，通常创建一个该插件契约到你的标准契约的适配器，这样核心系统就不需要针对每个插件的定制编码了。创建标准契约时（通常为XML），要记得从一开始就设计好版本策略。 案例微内核架构最好的案例也许就是Eclipse啦。下载基础版本的Ecilpse或许只比一个功能花哨的编辑器强一点，一旦装上一些插件，它立刻就变成高度定制化的很有用的产品。浏览器也是微内核架构产品的典型案例。 这样的基于产品的软件例子数不胜数，但是大型商业应用呢？微内核结构也是适用的。这里再以保险公司的索赔处理为例。（书中的例子都不符合国情，看着挺费劲的。） 索赔处理过程很复杂，每个阶段都有很多不同的规则和条例来说明是否应该得到赔偿。例如汽车挡风玻璃被岩石击碎，有的州是允许赔偿的，有的是不允许的。标准的索赔过程几乎有无限的条件。 通常保险索赔应用都会使用一个大型的复杂的规则引擎来处理。但是规则引擎会像滚雪球一样越来越大，修改一个规则可能会影响其它的规则，或者一个简单的规则修改需要很多分析人员、开发人员和测试人员。使用微内核架构模式可以避免这样的问题。 如图2中所示，核心系统claims processing包含了处理索赔过程的基本业务逻辑。每个插件模块包含一个州的特殊规则。这个例子中，插件模块可以通过自定义代码或分离规则引擎实例来实现。最重要的是，每个州（美国）的独特的规则从核心系统中剥离出来，可以被添加或移除，修改时不影响或会稍微影响核心系统与其它插件。 图2 微内核架构案例 注意事项微内核架构模式的一个优秀之处在于它可以嵌入或者作为其它架构模式的一部分。例如事件驱动架构中的事件处理组件就可以使用微内核架构实现。 微内核架构为递进设计和增量开发提供了方便。可以先实现一个稳固的核心系统，然后在不对核心系统进行大量修改的情况下逐渐地增加功能和特性。 对于基于产品的应用，微内核架构是一开始的首选。尤其是这样的产品：随着时间逐渐地发布新功能，而且希望保证所有的用户都能获取到新功能。如果以后发现该架构不符合需求了，可以随时重构成其它架构。 模式分析下表展示了分层架构模式的通用架构特性的评级和分析。 整体灵活性 评级：高 分析：整体灵活性是对环境变化快速响应的能力。由于插件之间的低耦合，改变通常是隔离的，可以快速实现。通常，核心系统是稳定且快速的，具有一定的健壮性，几乎不需要修改。 易于部署 评级：高 分析：取决于实现方式，插件可以在运行时动态添加（热部署），最小化部署的停机时间。 可测试性 评级：高 分析：插件可以独立测试，也很容易被模拟，不需修改核心系统就可以演示或构建新特性的原型。 性能 评级：高 分析：虽然微内核架构本身不会使应用高性能，但通常使用微内核架构构建的应用性能都还不错，因为可以自定义或者裁剪掉不需要的功能。JBoss应用服务器就是这样的。 可伸缩性 评级：低 分析：因为大部分微内核架构的实现都是基于产品的，一般都很小，是一个独立的单元，因此不具有高可伸缩性。取决于插件的实现方式，有时在插件特性层可以提供伸缩性，但总体上来说该架构还是用于构建高可伸缩性应用的。 开发容易度 评级：低 分析：微内核架构需要深思熟虑的设计和契约的规划管理，因此实现起来比较复杂。契约的版本机制、插件的注册机制、插件的粒度、插件连接方式的选择都使得实现起来是复杂的。 参考资料：“微内核架构(Microkernel Architecture” 4.2 Reflection模式​ 架构模式 Reflection提供了一种动态地修改软件系统的结构和行为的机制。它支持对基本方面(如类型结构和函数调用机制)进行修改。采用这个模式时,应用程序分两部分元层和基层。元层提供有关选定系统属性的信息,让软件能够了解自己;基层包含应用和序逻辑,其实现依赖于元层,修改元层存储的信息将影响基层的行为。 别名Open Implementation(开放实现)Meta- Level Architectur(元层架构)。 模式描述其实，Reflection模式，将应用程序分为两层：底层是程序的逻辑结构，一般是保持不变；上一层封装一些数据处理方式、函数和数据类型。上层信息在底层程序逻辑结构中会用到，但是会随着其他原因发生变化，所以单独提取出来，如果需要变化时，修改上层的信息就可以了，不会影响底层程序逻辑。 底层称作基层，上层称作元层。 变种包含多个元层的反射 。有时候元层对象彼此依赖，为了协调这种依赖，在元层上面再建一层元层，即元元层。从理论上说，可以形成一个无线反射塔，但是实际中一般就只是一两个元层。 优点当需要修改软件的时候，不需要显示的修改，只需要修改元层的信息就可以了。修改软件系统很容易，且支持众多不同类型的修改。 缺点修改软件时，再元层所做的修改可能会带来破环，增加了组件数量。由于反射模式会增加组件数量，所以效率低下。还有，并不是支持对软件的所有修改，比如，不能修改程序的应用逻辑。并不是所有的语言都支持反射。 实际例子二、设计模式​ 设计模式描绘了一种反复出现的结构,可用于组织相互通信的组件,以解决特定背景下普适的设计问题[GHV9s]。 ​ 下面介绍8个设计模式: Whole-Part(整体一部分) Master- Slave(主一从)、 Proxy(代理）、 Command Processor(命令处理器)、 View Handler(视图管理者)、 Forwarder- Receiver(转发者—接收者)、 client-dispatcher- Server(客户端一分派器一服务器)和 publisher-subscriber(发布者—订阅者)。 ​ 设计模式为中型模式,规模比架构模式小,但所处的层次比编程语言特定的成例高。使用计模式不会影响软件系统的基本结构，但可能给子系统的架构带来重大影响。 像架构模式一样,我们将设计十模式也分为几类。 结构分解模式。这类模式有助于以恰当的方式将子系统和复杂组件分解为一系列相互协作的部分。据我们所知,这类模式中最常见的是 Whole-Pan,它非常适合组织复杂的组件。 工作组织模式。这类模式定义组件如何相互协作,以解决复杂的问题。我们将介绍其中的 Master- Slave,它可帮助组织必须能够容错或计算必须精确的服务,还有助于将服务划分为多个部分,这些部分彼此独立,可同时执行。 访问控制模式。这类模式监视并控制对服务或组件的访问。我们将介绍其中的 Proxy助它,客户端能够与组件的代表(而非组件本身)通信。 管理模式。这类模式处理一系列同质对象、服务和组件,我们将介绍其中两个: Command Processor和 View Handler,其中前者致力于管理和调度用户命令,后者描述了如何管理软件系统中的视图。 通信模式。这类模式帮助统筹组件间通信。下面两个模式致力于解决进程间通信问题 Forwarder- Receiver致力于点对点通信,而 client-dispatcher- Server描述了如何在客户端服务器模型中实现位置透明的通信。 Publisher- Subscriber模式有助于确保协作组件的数据一致,与[GHV95介绍的 Observer模式是一回事,因此我们只介绍该模式的精髓,并重点介绍其重要变种 Event Channel。 ​ 所有设计模式都有一个重要特征,那就是独立于应用领域。它们致力于组织而非实现应用程序功能。 ​大多数设计模式都独立于编程范式,通常都能够以面向对象的方式轻松地实现,但这里介绍的设计模式都足够通用,适用于更传统的编程范式,如过程型编程。 1. 结构分解模式如果将子系统和复杂组件分解为多个独立的小组件,而不是保留为一个整体,处理起来将容易。另外,更容易修改,更容易集成扩展,设计讠方案理解起来也容易得多。 本节介绍一个有助于对组件进行结构分解的设计模式。 Whole-Part设计模式有助于将组件聚合成语义整体。聚合组件( Whole)封装组成它的组件(Part),统筹它们之间的协作,并提供访问其功能的通用接口。从外部不能直接访问Part组件。 Whole-Part模式的适用范围广泛,几乎每个软件系统中都有适合使用这个模式进行组织的组件甚至子系统,由包含关系构成的层次结构尤其适合使用 whole-part模式。 另一个有助于结构分解的著名模式是 Composite [GHJV95]。 Composite模式将对象组织成表示部分—整体层次结构的树型结构,让客户端能够以统的方式与各个对象及其组合交互。 请注意, Whole-Pan和 Composite等模式并没有提供如何对特定子系统或组件进行结构分解的指南，你需要根据应用程序的具体需求确定组件结构的参与者。 1.1 Whole-Part模式​ Whole-Part设计模式有助于将组件聚合成语义整体。聚合组件( Whole)封装组成它的组件(Part),统筹它们之间的协作,并提供访问其功能的通用接口。从外部不能直接访问Part组件。 实际的例子 ​ 汽车由很多的部件构成，其中有轮子，车窗等。每一个部件都有自己的功能，但是汽车具有所有部件不具备的功能，汽车可以行驶。 两种角色：whole part ​ Whole表示小对象的聚合，这些小对象被称为Part。 在思考时，考虑Whole时，从Client端的角度出发，把Whole看作是一个整体。然后，在想Part时，从上到下思考，将Whole的功能分解为多个Part。 下面的OMT图说明了Whole与其Part之间的关系。 动态 ​ 假设现在要将一个线段以C点为中线旋转 $ \alpha $度。线段可以看作是由两个顶点构成的，线段为Whole对象，Part为两个顶点$p$和$q$。客户端请求旋转，并通过参数传递旋转中心和旋转角度。可以通过先旋转两个顶点，然后再重绘线段的方式，来旋转线段。简单起见，不演示如何将原来的线段从屏幕上珊瑚，也没有演示方法drawLine如何获取端点的坐标。 这个情景分为四个阶段： 客户端调用线段L的rotate方法，并通过参数传递角度$\alpha$和旋转中心$c$; 线段L调用p的rotate方法； 线段L调用q的rotate方法； 线段L将p和q作为新端点，并重绘自己。 已知应用 ​ 很多面向对象应用程序的重要抽象都遵循了认 hole- Part模式。例如,有些图形编辑器支持将不同类型的数据组合成多媒体文档,这些通常是依照 Composite设计模式GHv95]实现的。在CAD或动画系统中,构造的对象是使用总成一零件结构表示的。在应用程序中,对于使用层次结构表示为语义整体的所有方面，几乎都可采用Whole-Part模式的某个变种。 效果 whole-part模式有多个优点。 可修改Part。 Whole封装了Part,从而对客户端隐藏了它们。因此,可以修改 Whole的内部结构,而不会给客户端带来任何影响。可完全替换Part的实现,而无需修改其他Part和客户端。 分离关注点。 Whole-Part结构有助于分离关注点。每个关注点都由不同Par实现,因此可组合简单服务来实现复杂策略,这比将其作为一个整体实现更容易。 可重用性。模式 Whole- Par改善了可重用性,这表现在两个方面。首先,可在其他聚合对象中重用Part;其次,通过将Part封装在 Whole中,可避免客户端在其源代码中到处使用Part对象,这改善了 Whole的可重用性。 whole-part模式也存在如下缺点。 间接导致效率低下。由于 Whole充当其Part的包装器,在客户端请求和执行请求的Part之间增加了一层。相比整体结构,这可能增加运行阶段开销,在Pant本身也采用 whole-part结构时尤其如此。 分解为Part的工作很复杂。通常难以找到合适的方式将不同Par组合成 Whole,采用自下而上方式时尤其如此。这是因为将 Whole分解为Pant的最佳方式取决于众多因素,如应用领域、要实现的结构以及 Whole提供的功能。 1.2 Composite模式​ Composite模式是Whole-part模式的变种，这个模式也采用了Whole-Part层次结构，但可同等对待Whole及其Part，即Whole和Part实现了相同的抽象接口。 2. 工作组织模式本节介绍一个用于在系统内组织工作的模式 ​ Master- Slave模式有助于改善容错性以及计算的并彳行性和准确度。一个主组件将工作分配给多个相同的从组件,并根据这些从组件返回的结果计算最终结果。 ​ master-slave遵循“分而治之”的原则,将工作分成多个分别处理的子任务,并根据每项处理操作的结果计算整个服务的结果。 master-slave模式在并行和分布式计算领域得到了广泛应用。 ​ 模式 Master- Slave的另一个应用示例是实现所谓的“三重模块冗余”原则。这种方法将服务的执行工作委托给三个独立组件,仅当至少有两个组件提供的结果相同时才认为结果有效。 ​ Chain of Responsibility、 Command和 Mediator [GHJ9也属于工作组织模式。 ​ 口模式 Chain of Responsibility让让多个对象都有机会处理请求,避免了将请求发送方与接收方挂钩。接收方被串接在一起,请求沿链条不断传递,直到到达能够处理它的对象。 ​ 口模式 Command将请求封装为对象,让客户端能够利用参数发出不同的请求,还让你能够将请求排队或写入日志以及支持可撤销的操作。 ​ 口模式 Mediator定义了一个将一组对象的交互方式封装起来的对象。这个模式避免了对象彼此显式地引用,从而降低了耦合度,让你能够独立地修改对象之间的交互。 2.1 Master-Slave模式​ 设计模式 master-slave有助于改善容错性以及计算的并行性和准确度。一个主组件将工作分配给多个相同的从组件,并根据这些从组件返回的结果计算最终结果。 ​ Master-Slave模式分为两个部分，Master和slave。Master主要负责的是任务切分、调用slave和最后的合并结果。slave提供的是服务，供master调用。 下面的OMT图说明了Master-Slave模式定义的结构。 动态 ​ 为简单起见,在下面的情景中,我们假定从组件被依次调用。然而,要充分发挥 master-slave模式的威力,应同时调用所有从组件,如给它们分配多个不同的控制线程。这个情景包含6个阶段: 客户端向主组件请求服务; 主组件将任务均分为多个子任务 主组件将执行这些子任务的工作委托给多个从组件,启动这些从组件并等待它们返回结果; 从组件处理子任务,并将计算结果返回给主组件; 主组件根据从组件返回的部分结果计算整个任务的最终结果; 主组件将结果返回给客户端。 实际的例子： ​ 比如，要找出1000个数里面的最小数字。可以将1000个数字分给5个slave节点，每个节点找出200数字中的最小，然后返回给master端。最后，master在收到的5个数据中，找出最小的数字，这个数字就是那1000个数字中最小的数字了。 效果设计模式 Master- Slave有多个优点。 口 可更换性和可扩展性。提供一个从组件抽象类就能够更换现有从组件实现及添加新实现而无需修改主组件,这种修改也不会影响客户端。如果给从组件分配子任务和计算最终结果的算法是使用 Strateg模式[GHV95]实现的,修改这些算法也不会影响主组件和客户端。 口分离关注点。引入主组件将从组件和客户端的代码与完成下述任务的代码分离了:划分工作、将工作委托给从组件、从从组件收集结果、计算最终结果以及应对从组件失败或从组件结果不准确。 口效率。将 master-slave模式用于支持并行计算时,只要精心实现,就能提高服务的性能。然而,千万别忘了并行计算的开销(见后面)。 master-slave模式也存在四个缺点。 口可行性。并非在什么情况下都可使用 master-slave架构。必须划分工作、复制数据、启动从组件、控制从组件的执行、等待从组件的结果以及计算最终结果,所有这些操作都要占用处理时间和存储空间。 口依赖于计算机。支持并行计算时 master-slave模式严重依赖于计算机的架构,详情请参阅”变种”部分。这可能降低 Master- Slave结构的可修改性和可移植性 口难以实现。 master-slave模式实现起来不容易,用于支持并行计算时尤其如此。有很多方面需要考虑并精心实现,如如何划分工作、主组件和从组件应如何协作、应如何计算最终结果。必须应对各种错误,如从组件执行失败、主组件和从组件无法通信、无法启动并行从组件。因此,将模式 master-slave用于支持并行计算时,通常必须对目标计算机的架构有相当深入的认识。 口可移植性。由于可能依赖于底层硬件架构,难以甚至根本不可能将 master-slave结构移植到其他计算机。 Master-Save模式用于支持并行计算时尤其如此。前面介绍的针对CM5计算机进行了优化的简单旅行商程序面临同样的问题。 3. 访问控制​ 有些组件甚至子系统不能或不应该由客户端直接访问。例如,不应授权所有客户端使用组件的服务或获取它提供的特定信息。 本节介绍的设计模式有助于控制对特定组件的访问。 口 设计模式 Proxy让客户端与代表而非组件本身通信。引入这样的代理可达成很多目的,如提高效率、简化访问以及禁止未经授权的访问 GHV9s介绍的 Facade和 erator也属于访问控制模式。 口 模式 Facade提供了一个统一接口,用于访问子系统中的一组对象。 Facade定义了一个高级接口,让子系统更容易使用。 口 模式 Iterator在不暴露聚合对象底层表示的情况下,提供了一种顺序访问其元素的方式。 ​ 与模式Proxy一样,模式Facade和 Iterator的应用范围也非常广泛。 ​ Facade模式保护子系统的组件,以免被客户端直接访问;反过来,客户端不依赖于子系统的内部结构。收到服务请求后,门面组件将其转发给子系统中实现了该服务的组件。模式 Facade的粒度比Poxy粗,因为模式Poxy控制对单个组件的访问。 ​ 在面向对象的程序和类库中,几乎每个容器类都提供了选代器。选代器定义了客户端遍历和访问容器元素的顺序,例如,要访问二叉树的所有元素,可定义前序、中序和后序遍历选代器。 3.1 Proxy模式​ 设计模式 Proxy让客户端与代表而非组件本身通信。引入这样的代理可达成很多目的提高效率、简化访问以及禁止未经授权的访问。 ​ 实际例子： ​ 公司的工程人员需要经常查询数据库，其中很多访问都类似甚至相同，且经常重复。显然，这里存在优化访问时间和开销的空间，但是不想在工程师使用的应用程序中进行优化。在很大程度上，不应让应用程序用户和程序员知道进行了优化。 ​ 解决方案 ​ 让客户端与代表而非组件本身通信。这个代表(代理)提供了组件的接口,但执行额外的预处理和后处理,如访问控制检查或创建原件的只读副本。​ 结构 ​ 原件( original)实现了特定服务。这种服务可以是诸如返回或显示数据等简单操作,也可以是复杂的数据检索函数或涉及其他组件的计算。 ​ 客户端负责执行特定任务。为完成工作,客户端通过访问代理间接地调用原件的功能,且调用行为和语法与调用本地组件时相同。 ​ 代理提供与原件相同的接口,并确保客户端正确地访问原件。为此,代理维护着一个指向原件的引用。通常,原件和代理一一对|应,但也存在例外情况,如在变种 Remote Proxy和 Firewall Proxy中,详情请参阅“变种”部分。 ​ 抽象原件提供了代理和原件实现的接口。在C+-等子类型化和继承没有明显差别的语言中,代理和原件都继承抽象原件。客户端根据这个接口编写访问原件的代码。 ​ 下面的OMT图说明了这些类之间的关系: 动态 ​ 下图说明了Poxy结构的一个典型动态情景。请注意,代理执行的操作取决于于其实际规范。 口 执行任务期间,客户端请求代理执行了一项服务。 口收到服务请求后,代理对其进行预处理。预处理包括查找原件的地址或检查缓存看其中是否有请求的信息等操作。 口如果必须让原件执行请求,代理使用合适的通信协议将请求转发给原件,并采取合适的安全措施。 口收到请求后,原件执行请求并将响应发送给代理 口收到响应后,代理将其转发给客户端,但在此之前或之后可能执行额外的后处理操作如缓存结果、调用原件的析构函数或对资源解除锁定。 效果 ​ 模式Proxy加油如下有点： 效率更高、开销更低。 可以在代理中加入缓存机制。 将客户端与服务的位置分离。变种Remote Proxy模式将所有位置信息和寻址功能都放在代理中，客户端只用连接上代理就可以了，不需要清楚的知道服务器的位置。 将管理代码与功能代码分离。 从广义上说，所有proxy变种都具备这个优点。代理避免了客户端承担原本不属于它的任务。 4. 管理模式​ 系统通常必须处理一系列类似对象、服务甚至复杂组件。一个例子是,系统必须妥善地解读并调度来自用户或其他系统的事件;另一个例子是,在必须以各种方式显示应用程序特定数据的交互式系统中,必须妥善地处理这些视图图。 结构良好的软件系统通常使用独立的“管理器”组件来处理一系列同质对象。本节介绍两个这样的设计模式。 口 模式 Command Processor将服务的请求和执行分开。命令处理器组件将请求作为独立的对象进行管理,调度其执行并提供额外服务,如存储请求对象以便以后能够撤销请求。 口 模式 View Handler有助于管理软件系统中的视图。视图管理者组件让客户端能够打开、操作和关闭视图,它还负责协调视图间依赖关系以及统筹视图更新。 口 Command Processor和 Command模式[GlHV95都遵循了将服务请求」封装为命令对象的理念,但 Command processor还使用 Command模式打造了一个管理命令对象的结构。 口 模式 Memento让你能够在不违反封装原则的情况下,记录并外部化对象的内部状态,以便以后能够恢复对象的状态 ​ Memento有助于管理组件的状态。例如,撤销已执行的操作时可能需要恢复组件的状态。另一个例子是,客户端需要访问组件的状态,但又不能违反封装原则,在这种情况下, Memento你能够向客户端提供组件当前状态的副本。 4.1 Command Processor模式 （记笔记，就参考这一个小节的样子写了）​ 设计模式 Command Processor 将服务的请求和执行分开。命令处理器组件将请求作为独立的对象进行管理,调度其执行并提供额外服务,如存储请求对象以便以后能够撒销请求。 实际例子： ​ 文本编辑器会提供撤销操作，这就是一个命令。假设要开发一个编辑器TEDDI，可以支持多步撤销操作。 解决方案 ​ Command Processor模式建立在[GHV95介绍的设计模式 Command的基础之上。这两个模都遵循将请求封装为对象的理念。每当用户调用应用程序的功能,都将请求转换为命令对象。 ​ 在模式 Command Processor中,一个中央组件(命令处理器)负责管理所有命令对象,它调度命令的执行,可能存储命令对象以便能够撤销,还可能提供其他服务,如将命令序列写入日志以便测试。 结构 ​ 下图说明了该模式中重要的组件间关系，其中的命令处理器提供了一项额外服务——撤销。 动态 下图说明了实现了撤销机制的模式 Command Processor的一个典型情景 : 收到将选定单词转换为大写的请求,执行该请求,再撤销。具体步骤如下。 口控制器在事件循环中收到用户的请求,并创建命令对象“大写转换”( capitalize)l 口控制器将这个新命令对象传递给命令处理器,以便执行并做额外处理。 口命令处理器启动命令,并存储它以便能够撤销 口命令 capitalize从其供应者获取当前选定的文本,存储这些文本及其在文档中的位置再请求供应者将选定文本转换为大写。 口收到撤销请求后,控制器将该请求传递给命令处理器。命令处理器调用最后一个命令的撤销过程。 口命令 capitalize用存储的文本替换指定位置的文本,将供应者恢复到以前的状态 口如果不再需要该命令,命令处理器将把它删除 效果 ​ 模式command processor有很多的优点。请求方式灵活，不同的执行功能都可以生成命令对象，然后由命令处理器来进行处理。并且，易于编写相关的服务，例如很容易再命令处理器中实现日志功能。可测试性，由于可以添加日志，所以排查错误的时候，非常的方便。并发性，可以让不同命令在不同的进程中执行。 ​ 模式command processor也存在一些缺点。影响效率，与所有将组件解耦的模式一样，额外的间接性需要占用存储空间和处理时间。命令类可能太多，功能丰富的程序可能包含大量命令类。 4.2 View Handler模式​ 设计模式 View Handler 有助于管理软件系统提供的所有视图。视图管理者组件让客户端能够打开、操作和关闭视图，它还负责协调视图间依赖关系以及统筹视图更新。 示例 ​ 在多文档编辑器中，用户可以同时处理多个文档，其中每个文档都显示在不同的窗口中。为了有效地使用这种编辑器，用户需要窗口管理方面地支持。例如，用户可能想克隆窗口，以便使用同一个文档的多个视图；另外，一个窗口的变化可能影响其他窗口，因此需要一种高效地更新机制在窗口间传播变更。 结构 ​ 视图管理者是这个模式的核心组件,负责打开新视图。客户端可指定想要的视图,视图管理者将实例化相应的视图组件,正确地初始化,并让新视图显示自己。如果请求的视图已打开,视图管理者将把它置于最前面;如果请求的视图已打开但处于最小化状态,视图管理者将让它最大化。 ​ 视图管理者还提供了关闭视图的函数,这包括关闭单个视图以及关闭当前打开的所有视图(如退出应用程序时)的函数。 ​ 然而,视图管理者的主要职责是提供视图管理服务,如执行如下功能的函数:将特定视图置于最前面,平铺所有视图,拆分视图,刷新所有视图以及克隆视图以提供同一个文档的多个视图。如果这种管理功能的实现分散在众多不同的视图组件中中,将难以组织 ​ 视图管理者的另一项职责是协调。视图之间可能存在依赖关系,如多个视图显示复合文档(如ET+对象 vobjecttext[wGM88])的不同部分,平铺视图时,应将这些视图放在一起。如果用户修改了文档的一个视图,可能必须按预定义的顺序更新其他视图。例如,应首先更新显示的信息最全面的视图。 ​ 抽象视图( abstract view)组件定义了所有视图通用的接口。视图管理者使用这个接口来创建、协调和关闭视图,系统的底层平台也使用它来执行用户事件,如调整窗口大小。对于可能对视图执行的每项操作,都必须在抽象视图的接口中提供相应的函数。 ​ 具体视图( specific view)组件从抽象视图派生面来,并实现了抽象视图的接口。另外,每个视图都实现了各自的显示函数,这个函数从视图的供应者那里获取数据,为显示这些数据做好准备,再向用户显示它们。显示函数在打开或更新视图时被调用。 ​ 供应者( supplier)组件提供视图组件显示的数据。为此,供应者提供了一个接口,让诸如视图等客户端能够获取和修改数据。当内部状态发生变化时,它们还通知依赖组件。依赖组件为视图或视图管理者(在它负责统筹更新时)。 ​ 下面的OMT类图说明了模式View Handler的结构。 动态 情景1 说明了视图管理者如何新建视图,包含四个阶段 口客户端(可能是用户,也可能是系统的另一个组件)让视图管理者打开特定视图 口视图管理者实例化并初始化所需的视图。视图依照模式 Publisher subscr向其供应者的变更传播机制注册 口视图管理者将新视图加入其内部的打开视图列表中 口视图管理者让视图显示自己。视图打开一个新窗口,从供应者获取数据,为显示数据糖好准备,再向用户显示数据。 效果 模式 View Handler具有如下优点。 口 以统一的方式管理视图。所有视图的接口都相同,这让视图管理者以及系统的其他组件能够以统一的方式管理和操作所有视图,而不管它们显示的是什么,也不管它们是如何实现的。 口视图的可扩展性和可修改性。视图组件被组织成包含抽象基类的继承层次结构,这使得可添加新视图,而无需修改既有视图和视图管理者。各个视图被封装成独立的组件,修改它们的实现不会影响系统的其他组件。 口以应用程序特定的方式协调视图。视图由一个中央组件管理,因此可实现应用程序特定的视图协调策略。 模式 View Handler也存在如下缺点。 口适用范围有限。仅当系统必须支持大量不同的视图、视图在逻辑上相互依赖或需要给视图配置不同的供应者或输出设备时,才有必要使用模式 View Handler;如果系统必须实现应用程序特定的视图协调策略,这个模式也很有用。如果上述条件都不满足,使用模式View Handler只会徒增实现工作量和系统的内部复杂度。 口影响效率。视图管理者组件在创建视图的流程中增加了一个间接层,如果视图管理者负责统筹视图更新,还将在变更通知传播链条中增加一环。这降低了性能,但在大多数情况下,降低程度都微不足道。 5. 通信模式​ 因为很多的应用系统都是分布式系统，分布式子系统必须相互协作，需要彼此通信的机制。 5.1 Forwarder-Receiver模式 （转发者-接收者模式）​ 自己对转发者-接收者模式的理解：其实就是将应用程序的任务执行与消息传送机制进行了分离，在相互协作多个程序之间，是需要进行通信的，但是通信机制会随着平台和硬件的改变而发生变化，但是程序的任务执行不会随着通信机制的改变而变化。所以，就要将这种变化与不变进行分离，以增加应用程序的可移植性和适用性。 实际例子 ​ 一个系统由两台计算机组成，它们之间完成任务的时候需要通信。开发的系统，必须要能够适应网络通信机制的改变。 解决方案 ​ 分布式对等体相互协作以解决特定问题。对等体可充当请求服务的客户端:也可充当提供服务的服务器,还可融这两种角色于一身。将系统特定的功能封装在独立组件中,从而向对等体藏用于收发消息的底层PC机制的细节。这样的功能包括名称到物理位置的映射,通信信道的建立、消息的封送和解封送等。 结构 ​ 设计模式 Forwarder- Receiver包含三种组件:转发者、接收者和对等体。 动态特性 ​ 下面的场景说明了使用转发器一接收器结构的实例。两个对等体P1及P2相互通信。为此,P1使用转发器Forw1和接收器 Recv。P2处理所有用转发器Forw2和接收器Recv2传送的消息。 P1从远程对等体P2请求服务。为此,P1向它的转发器Forw1发出请求,并且指定接收者的名字。 Forw1确定远程对等体的物理位置并且列集消息。 Forw1将消息传递给远程接收器Recv2 早些时候P2已经请求其接收器Recv2等候即将到来的请求。现在,Recv2接收来自Fowl1的消息。 Recv2散集消息并将它转发给它的对等体P2。 此时,P1调用其接收器Recv1来等候一个响应 P2执行被请求的服务,并将结果及接收者P1的名字发送给转发器Foxw2。转发器列集结果并将它传送给Recv1。 Recv1接收来自P2的响应,散集响应并将它传送给P1。 效果 ​ 转发器一接收器设计模式有两个优点:​ 有效的进程间通信。这个模式提供了非常有效的进程间通信。组件间的通信以对等方式来构建,其中IPC消息的每个转发器都知道其潜在接收器的物理位置。因此,转发器不需要定位远程组件。然而,IPC功能与对等体的分离引入了间接方法的附加层。然而,相对于实际IPC的时间消耗,这个开销在大多数情况下应该忽略不计。 ​ KPC设备的封装。所有具体PC设备的附属物都被封装在转发器和接收器内。下层IPC机制的改变不会影响应用程序的其他组件,尤其不会影响通过转发器和接收器相互通信的对等体。 但是,转发器一接收器设计模式有一个很大的不足: ​ 不能支持灵活的组件重新配置。如果对等体的分布在运行期间变更,那么转发器一接收器系统是很难适应的。这样的改变潜在地影响所有对等体与“迁移后”的对等体的协作。正如客户机分配器服务器设计模式中描汽的那样,这个问题可以通过为转发器一接收器结构增加一个中心分配器组件来解决。 5.2 Client-Dispatcher-Server模式​ 设计模式 Client- dispatcher-server在客户端和服务器之间添加了一个中间层—分派器组件。它利用名称服务提供了位置透明性,并隐藏了在客户端和服务器之间建立通信连接的细节。 示例： ​ 一个系统由多个服务器提供服务，可在客户端与服务器之间提供一个中间层（分派器），服务器向分派器注册，客户端在分派器上查找服务器。分派器中保存着服务器名称与物理地址的映射，这样对于客户端来说，服务器的位置就是透明的了。 实际例子： ​ 打移动公司的电话10086，然后转人工服务，这就是一个客户端-分派器-服务器模式的例子。 结构: ​ 客户端的职责是执行领域特定的任务。为了执行任务，客户端访问服务器提供的操作。 ​ 服务器向客户端提供一组操作，并向分派器注册其名称和地址，这种注册工作可以由服务器自己完成也可以由其他组件完成。 ​ 客户端、服务器和分派器之间的静态关系如下图所示： 动态 设计模式 client- Dispatcher- Server的典型情景包含如下几个阶段。 口 服务器向分派器组件注册。 口 客户端请求分派器提供到指定服务器的通信信道 口 分派器在注册表中查找与客户端指定的名称相关联的服务器 口 分派器尝试建立一条到该服务器的通信链路。如果成功,就将该通信信道返回给客户端否则,向客户端发送一条错误消息。 口 客户端使用该通信信道直接向服务器发送请求。 口 收到请求后,服务器执行合适的服务。 口 服务执行完毕后,服务器将结果发回客户端 ​ 在实现Client-Dispatcher-Server模式的时候，要注意一下三者之间的协议： 效果 ​ 设计模式Client-Dispatcher-Server具有多个优点。 ​ 服务器可更换，可以更换或移动服务器，只要向分派器注册了就可以，不会影响到客户端。 ​ 位置透明，客户端不需要知道服务器的位置——它们不依赖于任何位置信息。 ​ 可重新配置，将服务器部署到哪个网络节点，可以推迟到系统的运行阶段。 ​ 容错性，网络或服务器出现故障时，可在其他网络节点启动新服务器，而不会对客户端有任何的影响。 ​ 设计模式Client-Dispatcher-Server也存在一些缺点。 ​ 间接性和显示建立连接降低了效率。由于增减中间组件，所以会降低效率，而在分派器很重要，可能成为性能瓶颈。 ​ 对分派器接口变化敏感。由于分派器在系统的作用很重要，如果它发生变化，可能会影响到系统。 5.3 Publisher-Subscriber模式​ 设计模式 Publisher- Subscriber有助于让相互协作的组件的状态保持同步。为此,它实现了单向变更传播:发布者的状态发生变化时可通知任意数量的订阅者。 别名 ​ Observer、Dependents。 问题 ​ 当一个地方的数据发生变化时，将影响大量依赖于这项数据的组件。典型的例子是用户界面元素：内部数据元素发生变化时，必须更新依赖于这些数据的所有视图。 解决方案 ​ 个组件扮演发布者((1HV9s)称之为监视对象)角色,发布者信息变化将影响的所有组件都是订阅者(GiHn95称之为观察者)。 ​ 发布者维护一个注册表,其中包含当前所有的订阅者组件。要成为订阅者,组件可使用发布者提供的订阅接口;组件还可以退订。 ​ 发布者修改状态后通知所有订阅者,订阅者再酌情获取修改后的数据。 这个模式提供了如下灵活性。 ​ 口 可像[GHuV951介绍的那样引入抽象类,以便轻松地添加发布者和订「阅者。​ 口 发布者可决定哪个内部状态发生变化时将通知订阅者;还可以将多项变更排队,等到队列中的变更达到一定数量后再调用otiy()。​ 口 同一个组件可以是很多发布者的订阅者。​ 口 同一个组件可同时扮演发布者和订阅者角色。​ 口 可订阅指定类型的事件,这样订阅者只会收到有关其感兴趣的事件的消息。​ 口 通知订阅者时,发布者可发送数据变更细节,也可只发送通知,让订阅者自己确定哪些数据发生了变化。 ​ 这里将变更传播机制笼统地分为推模型和拉模型。在推模型中,发布者通知订阅者时发送所有修改后的数据。订阅者无权选择是否及何时获取数据,面只能被动地接受。在拉模型中,发布者发出变更通知时只发送最基本的信息,订阅者再根据需要获取数据。有很多变种介于这两种模型之间。 ​ 推模型的动态行为几乎是固定不变的,而拉模型提供了更大的灵活性,但代价是在发布者和订阅者之间传输的消息更多。 ​ 对复杂的数据变更而言,推模型可能是槽糕的选择,在发布者发送大量数据,而订阅者对这些数据不感兴趣时尤其如此。即便只推送描述数据变更特性的信息,开销也可能太高。这种情况可使用拉模型,让订阅者去确定发生了哪些类型的数据变更。可使用决策树来逐渐获悉有关数据变更的大量细节。 ​ 一般而言,如果发布的信息在大部分情况下都是订阅者需要的,推模型将是更好的选择。仅当订阅者能够判断它们是否需要以及何时需要特定的信息时,才使用拉模型。 三、成例​ 成例是编程语言特定的低层模式，阐述了如何使用给定语言实现组件的特定方面面或组件之间的关系。 ​ 可以这样说：成例演示了编程语言特性的标准用法，因此也有助于教授编程语言。 ​ 成例要在平时工作中积累，或者看一下别人代码是怎么写。 ​ 具体的一个成例：引用计数器 ​ 在C++中，一个对象body可能被多个对象共享，可能一个对象消失的时候，会删除掉这个body对象，这样会导致其他的对象无法访问到这个共享body对象。同时也要保证当引用body的对象都小时的时候，要将body这个对象删除，以节省内存空间。 ​ 为了解决上述的问题，可以为body对象添加一个引用计数器，每当增加一个对象引用body，就将计数器增加1，引用body对象消失的时候，就将引用计数器减少1。当引用计数器为0的时候，就将body对象删除。 ​ Counted Pointer成例静态结构 ​ ​ 引用计数成例有很多的变种。 四、模式系统​ 模式系统将模式联系起来,阐述了模式之间的关系,模式的现方式及其对软件开发有何帮助。模式系统是描绘和打造软件架构的利器。​ 《面向模式的软件架构–模式系统》和GOF的《设计模式》中模式都归纳到下面得这个模式系统中了。GOF《设计模式》中得模式以斜体表示。 架构模式 设计模式 成例 从混沌到有序 Layers(21)Pipes and Filters(34)Blackboard(46) Interpreter 分布式系统 Broker(63)Pipes and Filters(34Microkernel(10) 交互式系统 MVC(79)PAC(93) 可适应系统 Microkernel (110) Reflection(124) 创建 Abstract Factory Prototype Builder Singleton Factory Method 结构分解 Whole-Part(145) Composite 工作组织 Master-Slave (158) Chain fo Responsibility Command Mediator 访问控制 Proxy(170) Facade Iterator 服务变更 Bridge Strategy State Template Method 服务扩展 Decorator Vistor 管理 Command Processor (179View Handler (188) Memento 适配 Adapter 通信 Publisher-Subscriber(219Forwarder-Receiver (199)Client-Dispatcher-Server(209) 资源管理 Flyweight Counted Pointer(228) 五、模式与软件架构软件架构的定义 ​ 软件架构描述了软件系统的子系统和组件以及它们之间的关系。通常使用不同的视图来说明子系统和组件,以展示软件系统的功能特征和非功能特征。系统的软件架构是人工制品,乃软件设计活动的结果。 组件的定义 ​ 组件是被封装起来的软件系统的一部分,包含一个接口。组件是用于打造系统的构件在编程语言层面,组件可能由模块、类、对象或一组相关的函数表示。 关系 ​ 关系描述了组件之间的联系,可能是静态的,也可能是动态的。静态关系会在源代码中直接显现出来,它们指出了架构中组件的布局;动态关系指出了组件之间的临时联系和动态交互,可能不容易通过源代码的静态结构看出来。 视图 ​ 视图呈现软件架构的某个方面，展示软件系统的某些具体特征。 《面向模式的软件架构–模式系统》 2018-2-4 读完 面向模式的软件架构——模式系统 读书笔记书的pdf放置位置：G:\桌面文件和文件夹\学习\java\面向模式的软件架构\面向模式的软件体系结构（卷1卷2中文） 主要内容：软件架构模式 这本书的主要模式及其实践功能：结构分解 设计模式Whole-Part(参见3.2节)有助于将组件聚合成语义整体。 工作组织 设计模式Master-Slave(参见3.3节)有助于改善容错性以及计算的并行性和准确度，一个主组件将工作分配给多个相同的从到组件，并根据这些从组件返回的结果计算最终结果。 访问控制 设计模式Pro×y(参见3.4节)让客户端与代表而非组件本省通信。引人这样的代理可达成很多目的，如提高效率，简化访问以及禁止未经授权的访问。 管理 设计模式Command Processor(参见3.5.1节)将服务的请求和执行分开，并提供额外的服务，如存储请求对象以便以后能够撤销请求。 设计模式View Handler(参见3.5.2节)有助于管理软件系统提供的所有视图，协调视图间依赖关系以及统筹视图更新。 在C十十中，成例[Cope92] Counted Pointer(参见4.4节)简化了动态分配的共享对象的内存管理。 通信 设计模式Forwarder-Receiver(参见3.6.1节)利用对等交互模型让软件系统能够透明地进行进程间通信。它通过引人转发者和接收者将对等体与底层通信机制解耦。 设计模式Client-Dispatcher-Server(参廷3.6.2节)在客户端和服务器之间添加了一个中间层——分派器组件。它利用名称服务提供了位置透明性，并隐藏了在客户端和服务器之间建立通信连接的细节。 设计模式Publisher-Subscriber(参见3.6.3节)有助于让相互协作的组件的状态保持同步。 从混沌到有序 架构模式Layers(参见2.2.1节)有助于将应工程序划分为多组子任务，其中每组子任务都位于特定抽象层。 架构模式Pipes and Filters(参见2.2.2节)提供的结构适合处理数据流的系统。 架构模式Blackboard(参见2.2.3节)对还未找到明确解决策略的问题很有帮助，多个专业子系统通过集思广议，获得可能的部分解或近似解。 分布式系统 架构模式Broker(参见2.3节)可用于设计这样的分布式软件系统、即包含通过远程服务调用交互的组件。 交互式系统 MvC架构模式Model-View-Controller(参见2.4.1节)将交互式应用程序划分为三种组件:核心功能组件、表示组件和控制组件，并使用变更传播机制确保这三部分一致。 PAC架构模式Presentation-Abstraction-Control(参见2.4.2节)定义了一种适用于交互式软件系统的结构：由相互协作的智能体组成的层次结构。每个智能体都负责应用程序功能的特定方面，并包含三个组件:表示组件、抽象组件和控制组件，这将智能体的人机交互方面同功能核心和通信方面分离了。 可适应系统 架构模式Microkernel(参见2.5.1节)适用于必须能够适应需求不断变化的系统，它将最基本的功能核心与扩展的功能和随客户而异的部分分离。微核还充当插座，用于插入扩展及协调它们之间的协作。 架构模式Reflection(参见2.5.2节)提供了一种动态修改软件系统的结构和行为的机制。它支持对基本方面(如类型结构和函数调用机制)进行修改。 第1章 模式1.1什么是模式模式诠释了特定背景、问题和解决方案三个要素之间的关系。 1.2模式之所以为模式模式设计两个方面，静态的方面：组件以及组件之间的关系。动态方面：模式的参与者如何协作。 下图总结了整个模式纲要： 1.3模式类型将模式分为三类： 架构模式 设计模式 成例 1.3.4 模式分类在软件开发中的用途着手确定粗粒度设计时，可使用架构模式；在整个设计阶段，都可使用设计模式；在实现阶段可使用成例（就是具体的实现方案）。 1.5 模式的描述模式描述模板如下：名称模式名你用简餐 别名模式的其他名称——如果有的话 示例一个真实的例、讯明li】聴确实存在，时即将介绍的模式礴i实有需求， 在整个模式的描述中、在必要或对大家有帮助的情况下，我们都将通过这个示例来说明解决方案和实现。 背景模式可能适用的情形。 问题模式解决的问题，包括涉及的作用力。 解决方案模式背后的基本解决原则。 结构详细说明模式的结构方面，包括每个参与组件的CRC卡【BeCu89】(参见本书后面的”表示法”)以及一个OMT类图[RBPEL91]。 动态通常是一些情景，描述了模式的运行阶段行为。我们还使用对象消息序列图(参见本书后面的”表示法。)对情景做进一步说明。 实现模式实现指南。这些指南只是建议，并非永恒的规则。你应根据需求调整实现：添加不同、额外或更详细的步骤，或调整步骤的顺序。 我们使用C++、Smalltalk、Java或pSather示例代码来演示可能的实现，它们通常描述了示例问题的细节。 示例解答对“解决方案”、“结构”、“动态”和”实现”等部分末涉及，但对解决示例问题至关重要的各个方面进行讨论。 变种简要地描述当前模式的变种或具体化(specialization)。 已知应用模式在既有系统中的应用。 效果模式提供的优点及潜在的缺点。 参见列举其他一些模式，它们要么解决了类似问题，要么有助于改进当前模式。 第2章 架构模式2.1 导言将架构模式分为四类： 从混乱到有序类 包括Layers、Pipes and Filters和Blackboard 分布式系统 只包括Broker模式。 交互式系统 包括Model-View-Controller和Presentation-Abstraction-Control模式。 可适应系统 包括Reflection和Microkernel模式 2.2 从混乱到有序2.2.1 Layers模式2.2.2 Pipes and Filters模式2.2.3 Blackboard模式2.3 分布式系统使用的是Broker模式 2.4 交互式系统2.4.1 Model-View-Controller模式 Model中封装了核心数据和功能 View主要是向用户显示数据和功能 Controller主要是处理用户的输入，并对事件进行处理，可能会修改模型中的数据。 View和Controller会向Model的变更传播机制进行注册，当Model发生改变的时候，遍历这些注册了的组件，并调用它们的更新。 2.4.2 Presentation-Abstraction-Control模式表示组件提供了PAC智能体的可视化行为；抽象组件维护智能体的底层数据模型，并提供操作这些数据的功能；控制组件是表示组件和抽象组件之间的桥梁，并提供了让智能体能够与其他PAC智能体通信的功能。 整个PAC系统又分成了顶层智能体，中间智能体和底层智能体。顶层智能体只要负责提供软件的全局数据模型。底层PAC智能体表示应用领域的特定语义概念，例如展示选举投票的柱状图。中间层智能体可承担两种不同的职责：组合和协调。每一个的智能体中都可以包含表示组件、抽象组件和控制组件，不一定三个组件都包含有。 PAC模式的主要作用是，完全分离不同系统任务的关注点。 2.5 可适应系统 Microkernel模式 Reflection模式 2.5.1 Microkernel模式主要是将基本的核心功能放在微核中，其他功能以服务的方式实现。 2.5.2 Reflection模式第3章 设计模式]]></content>
      <categories>
        <category>Java高级知识</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2017%2F11%2F17%2F2_Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Linux学习笔记 0. linux小知识点积累(1) 重新启动X窗口X 的画面中按下『[alt]+ [crtl] + [backspace] 』 三个组合按键， 就能够重新启动 X 窗口 1. Ubuntu创建新用户并增加管理员权限From http://www.linuxidc.com/Linux/2016-06/132218.htm$是普通管员，#是系统管理员，在Ubuntu下，root用户默认是没有密码的，因此也就无法使用（据说是为了安全）。想用root的话，得给root用户设置一个密码： sudo passwd root 然后登录时用户名输入root，再输入密码就行了。ubuntu建用户最好用adduser，虽然adduser和useradd是一样的在别的linux糸统下，但是我在ubuntu下用useradd时，并没有创建同名的用户主目录。 例子：adduser user1这样他就会自动创建用户主目录，创建用户同名的组。 root@ubuntu:~# sudo adduser linuxidc [sudo] password for xx: 输入xx用户的密码，出现如下信息 正在添加用户&quot;linuxidc&quot;… 正在添加新组&quot;linuxidc&quot; (1006)… 正在添加新用户&quot;linuxidc&quot; (1006) 到组&quot;linuxidc&quot;… 创建主目录&quot;/home/linuxidc&quot;… 正在从&quot;/etc/skel&quot;复制文件… 输入新的 UNIX 口令： 重新输入新的 UNIX 口令： 两次输入linuxidc的初始密码，出现的信息如下 passwd: password updated successfully Changing the user information for linuxidc Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Full Name []: 等信息一路回车 这个信息是否正确？ [Y/n] y 到此，用户添加成功。如果需要让此用户有root权限，执行命令： root@ubuntu:~# sudo vim /etc/sudoers 修改文件如下： # User privilege specification root ALL=(ALL) ALL linuxidc ALL=(ALL) ALL 保存退出，linuxidc用户就拥有了root权限。 2. Ubuntu14.04设置SSH无密码登录(1) 安装Openssh服务端首先，我们需要更新我们的本地库索引。所以如下所见，我们需要先输入“apt-get update” 1. $ sudo apt-get update 通过以下命令安装openssh-server： 2. $ sudo apt-get install openssh-server (2) 开启openssh服务在OpenSSH已经成功安装在Ubuntu14.04操作系统上了之后，我们要启动OpenSSH的服务。以下命令让你启动/开启服务。 1. $ sudo service ssh start 或 1. $ sudo /etc/init.d/ssh start (3) 配置密钥对安装并启动了OpenSSH服务以后。接下来就是要搞定公私钥对的时候了，在终端中运行以下命令： 1. mucao@study ~ $ ssh-keygen -t rsa 在运行完以上命令了以后，我们需要回答一系列的问题。首先选择保存密钥的路径，按回车将会选择默认路径即家目录的一个隐藏的.ssh文件夹。下一个提示是请输入口令提醒。我个人将此留空（直接回车）。之后密钥对就会创建，大功告成。 在密钥对生成以后，我们需要将客户端上的公钥复制到SSH服务端或者主机，来创建对客户端的信任关系。运行以下命令复制客户端的公钥到服务端。 1. mucao@study ~$ ssh-copy-id user@ip_address 在公钥上传之后，我们现在可以禁用通过密码登陆SSH的方式了。为此，我们需要通过以下命令用文本编辑器打开/etc/ssh/ssh_config。 1. mucao@study ~$ sudo vim /etc/ssh/sshd_config 主要找到下面的三行，修改成下面的样子 RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile %h/.ssh/authorized_keys (4) 重启SSH服务最后，在我们配置完SSH服务端后，为了使改动生效我们需要重启SSH服务。在终端或控制台运行以下命令重启。 1. mucao@study ~$ sudo service ssh restart 或 1. mucao@study ~$ sudo /etc/init.d/ssh restart 现在，我们可以试试不用密码仅用密钥对的方式登录ssh服务端了。 总结 太好了！我们成功的配置了无密码登录SSH。使用加密密钥对进行SSH服务器认证是非常安全的一种做法，如果你想为SSH的单一用户登录实施安全的认证这也是备受推崇的方式。所以，如果你还有什么问题或建议，请在意见框中向我们反馈。很欣慰你能读完，希望你能喜欢加密的SSH安全登录 :-) 提高Ubuntu的SSH登陆认证速度的办法 http://www.linuxidc.com/Linux/2014-09/106810.htm 开启SSH服务让Android手机远程访问 Ubuntu 14.04 http://www.linuxidc.com/Linux/2014-09/106809.htm 如何为Linux系统中的SSH添加双重认证 http://www.linuxidc.com/Linux/2014-08/105998.htm 在 Linux 中为非 SSH 用户配置 SFTP 环境 http://www.linuxidc.com/Linux/2014-08/105865.htm Linux 上SSH 服务的配置和管理 http://www.linuxidc.com/Linux/2014-06/103627.htm SSH入门学习基础教程 http://www.linuxidc.com/Linux/2014-06/103008.htm SSH免密码登录详解 http://www.linuxidc.com/Linux/2015-03/114709.htm 3. Ubuntu14.04安装hadoop2.6.5准备工作环境:ubuntu 14.04,创建用户 用户名: glusr 密 码: 123456 # adduser glusr 创建完用户后，修改/etc/sudoers文件： root@ubuntu:~# sudo visudo root ALL=(ALL) ALL glusr ALL=(ALL) ALL hadoop 2.6.5下载地址:http://mirrors.hust.edu.cn/apache/hadoop/common/ 修改host配置文件将机器名称与机器ip对应，方便后续对应； vim /etc/hosts 添加如下内容： 192.168.193.130 Master.Hadoop 192.168.193.131 Salve1.Hadoop 192.168.193.132 Salve2.Hadoop 然后将三台机器均进行相同的操作，测试机器间是否可以相互ping通，如下：分别用ping Salve1.Hadoop或ping 192.168.193.131尝试。 ssh无密码登陆 首先，在每一台机器上建立对localhost的无密码登陆。然后建立三台机器之间的无密码ssh登陆。 在master上执行： glusr@1307-03 ~$ ssh-keygen 然后一路回车，所有选项都采用默认值。接下来执行： glusr@1307-03:~$ cat id_rsa.pub &gt;&gt; authorized_keys 修改authorized_keys权限，默认权限是700 chmod 600 ~/.ssh/authorized_keys 修改ssh配置文件，需切换root用户 vim /etc/ssh/sshd_config 找到如下三项： RSAAuthentication yes # 启用 RSA 认证 PubkeyAuthentication yes # 启用公钥私钥配对认证方式 AuthorizedKeysFile .ssh/authorized_keys # 公钥文件路径 重启ssh服务 service sshd restart 测试是否成功 ssh localhost 中间填入yes，再次输入，不要求填写密码即成功。 接下来就是要执行三台之间的SSH无密码登陆了。在master上执行下面的命令： ssh-copy-id glusr@slave1 ssh-copy-id glusr@slave2 接下来，master使用SSH登录slave1,slave2就不用输入密码了。进行验证： ssh glusr@slave1 ssh glusr@slave1 同样的在slave1,slave2上执行相应的操作。所有操作完成后，三台机器之间就可以相互SSH无密码登陆了！ 安装jdk 切换至root用户 上传jdk文件将jdk文件上传到虚拟机上自定义的文件夹中，这里放到/home/hortonworks下，安装在/usr/java中; 将文件copy到其他机器上在各个节点上创建文件 mkdir /usr/java，并将jdk文件传输到Slave上，以Salve1为例 scp /home/hortonworks/jdk-7u67-linux-x64.tar.gz root@Salve1.Hadoop:/usr/java 解压文件解压至文件夹 /usr/java中,进入到文件路径下 cd /usr/java tar -zxvf /usr/java/jdk-7u67-linux-x64.tar.gz 删除导入的jdk文件 rm /usr/java/jdk-7u67-linux-x64.tar.gz 配置环境变量 vim /etc/profile 在文件底部加入JAVA_HOME、ClASS_PATH、PATH #set java environment export JAVA_HOME=/usr/java/jdk1.7.0_67 export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 使配置生效 source /etc/profile 验证 java是否安装成功 java -version ok验证成功 赋予hadoop用户操作权限 用root用户，进入/usr文件夹，将java文件夹操作权限赋予hadoop用户 chown -R hadoop:hadoop ./usr/java 安装hadoop集群 设置安装路径 各个节点上创建hadoop文件夹 mkdir /usr/hadoop 解压缩文件 将hadoop-2.6.5文件解压到/opt/hadoop文件夹下，Master上: tar -zxvf ~/hadoop-2.6.5.tar.gz -C /opt/hadoop 将hadoop文件夹赋予hadoop用户读权限 chown –R hadoop:hadoop hadoop 添加tmp文件夹 因为HDFS把namenode的格式化信息存在了系统的tmp目录下，该目录每次开机会被清空，因此每次重新启动机器，都需要重新格式化HDFS。解决方案是配置一个新的tmp目录给hadoop，这样无需每次重新格式化hdfs。 mkdir /usr/hadoop/hadoop-2.6.5/tmp hadoop环境配置 vim /etc/profile 在底部加入 #set hadoop path export HADOOP_HOME=/usr/hadoop/hadoop-2.6.5 export PATH=$HADOOP_HOME/sbin:$HADOOP_HOME/bin:$PATH hadoop配置 core-site.xml和hdfs-site.xml是站在HDFS角度上配置文件；core-site.xml和mapred-site.xml是站在MapReduce角度上配置文件 1、配置hadoop-env.sh vim /usr/hadoop/hadoop-2.6.5/etc/hadoop/hadoop-env.sh 配置java环境，在文件中找到export JAVA_HOME，更改为： export JAVA_HOME=/usr/java/jdk1.7.0_67 #自己java的home 2、配置core-site.xml 核心配置文件，设置临时目录及配置的是HDFS的地址和端口号，注：须将截图中的value中ip修改为192.168.193.130，也就是master节点的IP地址。 vim /usr/hadoop/hadoop-2.6.5/etc/hadoop/core-site.xml 节点configuration中添加内容如下： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop/hadoop-2.6.5/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;!-- file system properties --&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;!-- 下面要配置成自己master节点的IP地址 --&gt; &lt;value&gt;hdfs://192.168.0.104:9000&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 3、配置hdfs-site.xml 修改Hadoop中HDFS的配置，配置的备份方式默认为3,Salve少于3则会报错 vim /usr/hadoop/hadoop-2.6.5/etc/hadoop/hdfs-site.xml 配置文件内容： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 4、配置mapred-site.xml cp /usr/hadoop/hadoop-2.6.5/etc/hadoop/mapred-site.xml.template /usr/hadoop/hadoop-2.6.5/etc/hadoop/ mapred-site.xml vim /usr/hadoop/hadoop-2.6.5/etc/hadoop/ mapred-site.xml 添加如下内容 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;http://192.168.0.104:9001&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 5、配置Master文件 vim /usr/hadoop/hadoop-2.6.5/etc/hadoop/ masters 添加master主机ip，这里填入192.168.193.130 6、配置Salves文件 Master主机特有 vim /usr/hadoop/hadoop-2.6.5/etc/hadoop/slaves 添加： 192.168.193.131 192.168.193.132 192.168.193.133 9、配置Salve的hadoop，可以单机采用上述1-5；也可直接将master节点上的hadoop文件夹复制过去，salve机器上的slaves文件是无需配置的，但无所谓。 9.1、scp -r /usr/hadoop root@Salve1.Hadoop:/usr/ 9.2、切换至salve机器的root用户， 例如ssh :Salve1.Hadoop。 9.3、配置hadoop环境 vim /etc/profile 在底部加入 #set hadoop path export HADOOP_HOME=/usr/hadoop/hadoop-2.6.5 export PATH=$HADOOP_HOME/sbin:$HADOOP_HOME/bin:$PATH 9.4、usr下，将hadoop文件夹赋予hadoop用户读权限 chown -R hadoop:hadoop hadoop 启动和验证 关闭iptables服务 查看iptables状态：service iptables status 关闭iptables服务：chkconfig iptables off(重启后生效) 临时关闭ptables服务：service iptables stop 启动hadoop 2.1格式化namenode hadoop namenode -format 2.2启动：start-all.sh 发现存在警告：WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable； 解决方案:网上查找资料说是由于hadoop是32bit编译的，而系统为64位的所导致的；下载文件： http://dl.bintray.com/sequenceiq/sequenceiq-bin/hadoop-native-64-2.6.0.tar 下载完以后，解压到hadoop的native目录下，覆盖原有文件即可。重新启动，就没有警告了。 验证是否启动成功 jps查看启动项 master显示： slave显示： 也可运行命令查看个节点信息： hadoop dfsadmin -report 网页版检测： http:192.168.193.130:50070 其他： 若修改了ip，解决修改密码之后，无法上网的问题 1、切换root用户运行： system-config-network 会弹出对话框 选择Device configuration，回车 选择eth0，回车 只保留name，device，use dhcp在中括号中添加*，其他均修改为空 保存设置； 重启网络服务： service network restart ok，可以上网了，缺点：修改的ip失效，回复原始ip，所以就返回修改，使用原本的ip，如果最初使用原始的ip也就无需这步了. 应用mapreduce 启动hadoop集群 start-all.sh 在hadoop文件系统中增加文件 hadoop fs 查看hdfs操作系统命令集合 创建hdfs目录 hadoop fs -mkdir /input 上传文件 hadoop fs -put /usr/hadoop/hadoop-2.6.5/README.txt /input/ 修改文件名称 hadoop fs -mv /input/README.txt /input/readme.txt 查看文件 hadoop fs -ls /input 输出文件夹为output，无需新建，若已存在需删除 运行hadoop自带例子 hadoop jar /usr/hadoop/hadoop-2.6.5/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.5.jar wordcount /input /output 查看文件输出结果 hadoop fs -ls /output 查看词频统计结果 hadoop fs cat /output/part-r-00000 将hdfs上文件导出到本地 hadoop fs -get /output/part-r-00000 /home/hadoop/data/pacc 实例学习安装完成了，终于可以好好学习一些实例了。 参考网址：http://www.linuxidc.com/Linux/2017-03/142051.htm 4. SSH免密码登录详解From: http://www.linuxidc.com/Linux/2015-03/114709.htm 为了更好的理解SSH免密码登录原理，我们先来说说SSH的安全验证，SSH采用的是”非对称密钥系统”，即耳熟能详的公钥私钥加密系统，其安全验证又分为两种级别。 1. 基于口令的安全验证这种方式使用用户名密码进行联机登录，一般情况下我们使用的都是这种方式。整个过程大致如下： （1）客户端发起连接请求。 （2）远程主机收到用户的登录请求，把自己的公钥发给客户端。 （3）客户端接收远程主机的公钥，然后使用远程主机的公钥加密登录密码，紧接着将加密后的登录密码连同自己的公钥一并发送给远程主机。 （4）远程主机接收客户端的公钥及加密后的登录密码，用自己的私钥解密收到的登录密码，如果密码正确则允许登录，到此为止双方彼此拥有了对方的公钥，开始双向加密解密。 PS：当网络中有另一台冒牌服务器冒充远程主机时，客户端的连接请求被服务器B拦截，服务器B将自己的公钥发送给客户端，客户端就会将密码加密后发送给冒牌服务器，冒牌服务器就可以拿自己的私钥获取到密码，然后为所欲为。因此当第一次链接远程主机时，在上述步骤的第（3）步中，会提示您当前远程主机的”公钥指纹”，以确认远程主机是否是正版的远程主机，如果选择继续后就可以输入密码进行登录了，当远程的主机接受以后，该台服务器的公钥就会保存到 ~/.ssh/known_hosts文件中。 2. 基于密匙的安全验证这种方式你需要在当前用户家目录下为自己创建一对密匙，并把公匙放在需要登录的服务器上。当你要连接到服务器上时，客户端就会向服务器请求使用密匙进行安全验证。服务器收到请求之后，会在该服务器上你所请求登录的用户的家目录下寻找你的公匙，然后与你发送过来的公匙进行比较。如果两个密匙一致，服务器就用该公匙加密“质询”并把它发送给客户端。客户端收到“质询”之后用自己的私匙解密再把它发送给服务器。与第一种级别相比，第二种级别不需要在网络上传送口令。 PS：简单来说，就是将客户端的公钥放到服务器上，那么客户端就可以免密码登录服务器了，那么客户端的公钥应该放到服务器上哪个地方呢？默认为你要登录的用户的家目录下的 .ssh 目录下的 authorized_keys 文件中（即：~/.ssh/authorized_keys）。 3. 使用场景rsync自动备份时免密码登录，集群环境中需要主机间互相通信如：Hadoop，目前小编只涉及到这两处，日后有其它地方用到再来补充~ 3. 相关配置项SSHD服务的配置文件位于/etc/ssh/sshd_config 配置项一：PubkeyAuthentication 是否允许使用密钥验证方式登录 配置项二：AuthorizedKeysFile允许登录主机的公钥存放文件，默认为用户家目录下的 .ssh/authorized_keys 4. 权限问题.ssh文件夹 700 chmod 700 .ssh authorized_keys文件 644 chmod 644 .ssh/authorized_keys 5. 配置实现服务器：192.168.0.10 用户：server 客户端：192.168.0.11 用户：client ​ 客户端配置# 使用client用户登录并进入家目录 # cd /home/client # 建立认证公钥和私钥 # ssh-keygen -t rsa （会有提示输入密码，直接回车即可） # 之后会在家目录下建立 .ssh 文件夹，内有id_rsa（私钥）和id_rsa.pub（公钥）两个文件 # 将公钥文件上传到服务器上server的家目录 # scp ~/.ssh/id_rsa.pub server@192.168.0.10:~ 服务器端配置# 使用server用户登录并进入家目录 # cd /home/server # 建立 .ssh 文件夹 # mkdir .ssh; # 修改文件夹权限 # chmod 700 .ssh # 将客户端传过来的id_rsa.pub文件中的内容加入到authorized_keys中 # cat id_rsa.pub &gt;&gt; .ssh/authorized_keys # chmod 644 .ssh/authorized_keys 之后你从客户端使用 client 用户登录服务器的server用户时就不需要再输入密码了，但是第一次连接时还是会提示你进行远程主机公钥指纹核对并将其存入 ~/.ssh/known_hosts 文件。 5. linux服务名称后面为什么有”d”以 crontab 来说，他的主要执行程序名称应该是 cron 或 at 才对，为啥要加个 d 在后面？而成为 crond, atd 呢？就是因为 Linux 希望我们可以简单的判断该程序是否为 daemon， 所以，一般daemon 类型的程序都会加上 d 在文件名后头～包括服务器篇我们会看到的 httpd, vsftpd 等等都是 ^_^。 2017-11-29 &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习《鸟哥的Linux私房菜-基础篇》 6. make命令与makefile(Makefile)文件make 就是要将原始码编译成为可以被执行的可执行文件。执行make命令的时候，回去找到当前目录下的makefile文件，或者是Makefile文件。makefile文件的基本规则如下： 目标(target): 目标文件 1 目标文件 2 &lt;tab&gt; gcc -o 欲建立的执行文件 目标文件 1 目标文件 2 下面是一个示例： [root@study ~]# vim makefile main: main.o haha.o sin_value.o cos_value.o gcc -o main main.o haha.o sin_value.o cos_value.o -lm # 注意：第二行的 gcc 之前是 &lt;tab&gt; 按键产生的空格喔！ make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。 makefile文件规则基本上是这样的：(1) 在 makefile 当中的 # 代表批注；(2) &lt;tab> 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字(3) 目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。 在makefile文件里面可以有多个目标(target): # 1. 先编辑 makefile 来建立新的规则，此规则的目标名称为 clean ： [root@study ~]# vi makefile&gt; main: main.o haha.o sin_value.o cos_value.o gcc -o main main.o haha.o sin_value.o cos_value.o -lm clean: rm -f main main.o haha.o sin_value.o cos_value.o # 2. 以新的目标 (clean) 测试看看执行 make 的结果： [root@study ~]# make clean &lt;==就是这里！透过 make 以 clean 为目标 rm -rf main main.o haha.o sin_value.o cos_value.o 2017-12-18 &emsp;&emsp; 学习《鸟哥的Linux私房菜-基础篇》 7. dpkg与apt(1)简介dpkg是Debian的中级软件包管理器,类似RPM. dpkg是Debian软件包管理系统的中流砥柱,负责安全卸载软件包,配置,以及维护已安装的软件包.也是Debian系统中众多软件包管理工具的后端.有关dpkg的更多介绍参阅:http://www.dpkg.org 系统中所有packages的信息都在/var/lib/dpkg/目录下,其中子目录”/var/lib/dpkg/info”用于保存各个软件包的配置文件列表. .conffiles 记录了软件包的配置文件列表 .list 保存软件包中的文件列表,用户可以从.list的信息中找到软件包中文件的具体安装位置. .md5sums 记录了软件包的md5信息,这个信息是用来进行包验证的. .prerm 脚本在Debian报解包之前运行,主要作用是停止作用于即将升级的软件包的服务,直到软件包安装或升级完成. .postinst脚本是完成Debian包解开之后的配置工作,通常用于执行所安装软件包相关命令和服务重新启动. /var/lib/dpkg/available文件的内容是软件包的描述信息,该软件包括当前系统所使用的Debian安装源中的所有软件包,其中包括当前系统中已安装的和未安装的软件包. dpkg –i 手工安装deb包到系统中,不过有时会存在Dpends关系,建议使用apt-get 来安装.如果通过dpkg –i安装软件后由于Dpends关系没有安装成功,可通过apt-get –f install解决 (2)Apt和dpkg快速参考apt-cache search # ——(package 搜索包)apt-cache show #——(package 获取包的相关信息，如说明、大小、版本等)sudo apt-get install # ——(package 安装包)sudo apt-get install # —–(package - - reinstall 重新安装包)sudo apt-get -f install # —–(强制安装?#”-f = –fix-missing”当是修复安装吧…sudo apt-get remove #—–(package 删除包)sudo apt-get remove - - purge # ——(package 删除包，包括删除配置文件等)sudo apt-get autoremove –purge # —-(package 删除包及其依赖的软件包+配置文件等（只对6.10有效，强烈推荐）)sudo apt-get update #——更新源sudo apt-get upgrade #——更新已安装的包sudo apt-get dist-upgrade # ———升级系统sudo apt-get dselect-upgrade #——使用 dselect 升级apt-cache depends #——-(package 了解使用依赖)apt-cache rdepends # ——(package 了解某个具体的依赖?#当是查看该包被哪些包依赖吧…)sudo apt-get build-dep # ——(package 安装相关的编译环境)apt-get source #——(package 下载该包的源代码)sudo apt-get clean &amp;&amp; sudo apt-get autoclean # ——–清理下载文件的存档 &amp;&amp; 只清理过时的包sudo apt-get check #——-检查是否有损坏的依赖 apt-get install下载 以及所有倚赖的包裹，同时进行包裹的安装或升级。如果某个包裹被设置了 hold (停止标志，就会被搁在一边(即不会被升级)。更多 hold 细节请看下面。 apt-get remove [–purge]移除 以及任何倚赖这个包裹的其它包裹。–purge 指明这个包裹应该被完全清除 (purged) ，更多信息请看 dpkg -P。 apt-get update升级来自 Debian 镜像的包裹列表，如果你想安装当天的任何软件，至少每天运行一次，而且每次修改了/etc/apt/sources.list 后，必须执行。 apt-get upgrade [-u]升级所以已经安装的包裹为最新可用版本。不会安装新的或移除老的包裹。如果一个包改变了倚赖关系而需要安装一个新的包裹，那么它将不会被升级，而是标志为 hold。apt-get update 不会升级被标志为 hold 的包裹 (这个也就是 hold 的意思)。请看下文如何手动设置包裹为 hold。我建议同时使用 ‘-u’ 选项，因为这样你就能看到哪些包裹将会被升级。 apt-get dist-upgrade [-u]和 apt-get upgrade 类似，除了 dist-upgrade 会安装和移除包裹来满足倚赖关系。因此具有一定的危险性。 apt-cache search搜索满足 的包裹和描述。 apt-cache show显示 的完整的描述。 apt-cache showpkg显示 许多细节，以及和其它包裹的关系。 dselectconsole-aptaptitudegnome-aptAPT 的几个图形前端(其中一些在使用前得先安装)。这里 dselect 无疑是最强大的，也是最古老，最难驾驭。 普通 Dpkg 用法 dpkg -i安装一个 Debian 包裹文件，如你手动下载的文件。 dpkg -c列出安装包的内容。 dpkg -I从 中提取包裹信息。 dpkg -r移除一个已安装的包裹。 dpkg -P完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配制文件。 dpkg -L列出 安装的所有文件清单。同时请看 dpkg -c 来检查一个 .deb 文件的内容。 dpkg -s显示已安装包裹的信息。同时请看 apt-cache 显示 Debian 存档中的包裹信息，以及 dpkg -I 来显示从一个 .deb 文件中提取的包裹信息。 dpkg -S在包裹数据库中查找 ，并告诉你哪个包裹包含了这个文件。(注：查找的是事先已经安装的包裹) dpkg-reconfigure重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹安装提供了一个统一的配制界面)。你能够重新配制 debconf 它本身，如你想改变它的前端或提问的优先权。例如，重新配制 debconf，使用一个 dialog 前端，简单运行： dpkg-reconfigure –frontend=dialog debconf (如果你安装时选错了，这里可以改回来哟：) echo “ hold” | dpkg –set-selections设置 的状态为 hlod (命令行方式) dpkg –get-selections “”取的 的当前状态 (命令行方式) 支持通配符，如： Debian:~# dpkg --get-selections *wine* libwine hold libwine-alsa hold libwine-arts hold libwine-dev hold libwine-nas hold libwine-print hold libwine-twain hold wine hold wine+ hold wine-doc hold wine-utils hold 例如：大家现在用的都是 gaim-0.58 + QQ-plugin，为了防止 gaim 被升级，我们可以采用如下方法： 方法一： Debian:~# echo &quot;gaim hold&quot; | dpkg --set-selections 然后用下面命令检查一下： Debian:~# dpkg --get-selections &quot;gaim&quot; gaim hold 现在的状态标志是 hold，就不能被升级了。 如果想恢复怎么办呢? Debian:~# echo &quot;gaim install&quot; | dpkg --set-selections Debian:~# dpkg --get-selections &quot;gaim&quot; gaim install 这时状态标志又被重置为 install，可以继续升级了。 同志们会问，哪个这些状态标志都写在哪个文件中呢?在 /var/lib/dpkg/status 里，你也可以通过修改这个文件实现 hold。 有时你会发现有的软件状态标志是 purge，不要奇怪。如：事先已经安装了 amsn，然后把它卸了。 apt-get remove --purge amsn 那么状态标志就从 install 变成 purge。 方法二：在/etc/apt 下手动建一个 preferences 文件内容： Package: gaim Pin: version 0.58* 保存 (3) ubuntu给出的解释dpkg资料：Ubuntu官网资料 apt资料： Ubuntu官网资料 apt命令 apt是一个强大的命令行工具，其实就是Ububuntu的Advanced Packaging Tool(APT)。执行软件包的安装，卸载，更新，甚至是升级整个Ubuntu系统。 一些有用的例子： 1. 安装软件包 sudo apt install nmap 2. 移除软件包 sudo apt remove nmap 多个软件包：你可以安装和卸载用空格分隔的多个软件包。如果要移除配置文件，则要加上–purge选项。 3. 更新软件库列表软件库列表放置的目录是：/etc/apt/sources.list 和 /etc/apt/sources.list sudo apt update 4. 升级软件包升级软件包之前，首先应该用上面的命令去更新软件库列表。 sudo apt upgrade apt命令的执行日志放置在：/var/log/dpkg.log详细的使用信息，可以用下面的命令来获取。 apt help]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
        <category>编程常用知识</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编程小知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2017%2F11%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F</url>
    <content type="text"><![CDATA[一、存储引擎 InnoDB MyISAM 比较 二、数据类型 整型 浮点数 字符串 时间和日期 三、索引 索引分类 索引的优点 索引优化 B-Tree 和 B+Tree 原理 四、查询性能优化 五、切分 垂直切分 水平切分 切分的选择 存在的问题 六、故障转移和故障恢复 参考资料 一、存储引擎InnoDBInnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 表是基于聚簇索引建立的，它对主键的查询性能有很高的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够自动在内存中创建哈希索引以加速读操作的自适应哈希索引、能够加速插入操作的插入缓冲区等。 通过一些机制和工具支持真正的热备份。其它存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。 MyISAMMyISAM 提供了大量的特性，包括全文索引、压缩表、空间数据索引等。应该注意的是，MySQL 5.6.4 也添加了对 InnoDB 存储引擎的全文索引支持。 不支持事务。 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取查询的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以继续使用 MyISAM。 比较 事务：InnoDB 是事务型的。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 其它特性：MyISAM 支持压缩表和空间数据索引。 二、数据类型整型TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。 浮点数FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 字符串主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。 时间和日期MySQL 提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。 1. DATATIME能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATATIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 2. TIMESTAMP和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。 它和时区有关。 MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 三、索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 索引能够轻易将查询性能提升几个数量级。 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。对于中到大型的表，索引就非常有效。但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 索引分类1. B+Tree 索引 《高性能 MySQL》一书使用 B-Tree 进行描述，其实从技术上来说这种索引是 B+Tree。 B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。 可以指定多个列作为索引列，多个索引列共同组成键。B+Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。 除了用于查找，还可以用于排序和分组。 如果不是按照索引列的顺序进行查找，则无法使用索引。 2. 哈希索引基于哈希表实现，优点是查找非常快。 在 MySQL 中只有 Memory 引擎显式支持哈希索引。 InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 限制： 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显； 无法用于分组与排序； 只支持精确查找，无法用于部分查找和范围查找； 如果哈希冲突很多，查找速度会变得很慢。 3. 空间数据索引（R-Tree）MyISAM 存储引擎支持空间索引，可以用于地理数据存储。 空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 必须使用 GIS 相关的函数来维护数据。 4. 全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。 使用 MATCH AGAINST，而不是普通的 WHERE。 索引的优点 大大减少了服务器需要扫描的数据量； 帮助服务器避免进行排序和创建临时表（B+Tree 索引是有序的，可以用来做 ORDER BY 和 GROUP BY 操作）； 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，也就将相邻的列值都存储在一起）。 索引优化1. 独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 2. 前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 对于前缀长度的选取需要根据 索引选择性 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1，此时每个记录都有唯一的索引与其对应。 3. 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 12SELECT film_id, actor_ id FROM sakila.film_actorWhERE actor_id = 1 AND film_id = 1; 4. 索引列的顺序让选择性最强的索引列放在前面，例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment; 123 staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 5. 聚簇索引 聚簇索引并不是一种索引类型，而是一种数据存储方式。 术语“聚簇”表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引在同一个结构中保存了 B+Tree 索引和数据行。 因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 优点 可以把相关数据保存在一起，减少 I/O 操作。例如电子邮件表可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据也就能获取某个用户的全部邮件，如果没有使用聚聚簇索引，则每封邮件都可能导致一次磁盘 I/O。 数据访问更快。 缺点 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。 更新操作代价很高，因为每个被更新的行都会移动到新的位置。 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。 6. 覆盖索引索引包含所有需要查询的字段的值。 优点 因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若二级索引能够覆盖查询，则无需访问聚簇索引。 B-Tree 和 B+Tree 原理1. B-Tree 为了描述 B-Tree，首先定义一条数据记录为一个二元组 [key, data]。 B-Tree 是满足下列条件的数据结构： 所有叶节点具有相同的深度，也就是说 B-Tree 是平衡的； 一个节点中的 key 从左到右非递减排列； 如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。 在 B-Tree 中按 key 检索数据的算法非常直观：首先在根节点进行二分查找，如果找到则返回对应节点的 data，否则在相应区间的指针指向的节点递归进行查找。 由于插入删除新的数据记录会破坏 B-Tree 的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持 B-Tree 性质。 2. B+Tree 与 B-Tree 相比，B+Tree 有以下不同点： 每个节点的指针上限为 2d 而不是 2d+1； 内节点不存储 data，只存储 key，叶子节点不存储指针。 3. 带有顺序访问指针的 B+Tree 一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 基础上进行了优化，在叶子节点增加了顺序访问指针，做这个优化的目的是为了提高区间访问的性能。 4. 为什么使用 B-Tree 和 B+Tree红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构。 页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为 4k），主存和磁盘以页为单位交换数据。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。 B-Tree 中一次检索最多需要 h-1 次 I/O（根节点常驻内存），渐进复杂度为 O(h)=O(logdN)。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。而红黑树这种结构，h 明显要深的多。并且于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，效率明显比 B-Tree 差很多。 B+Tree 更适合外存索引，原因和内节点出度 d 有关。由于 B+Tree 内节点去掉了 data 域，因此可以拥有更大的出度，拥有更好的性能。 四、查询性能优化Explain用来分析 SQL 语句，分析结果中比较重要的字段有： select_type : 查询类型，有简单查询、联合查询和子查询 key : 使用的索引 rows : 扫描的行数 减少返回的列慢查询主要是因为访问了过多数据，除了访问过多行之外，也包括访问过多列。 最好不要使用 SELECT * 语句，要根据需要选择查询的列。 减少返回的行最好使用 LIMIT 语句来取出想要的那些行。 还可以建立索引来减少条件语句的全表扫描。例如对于下面的语句，不使用索引的情况下需要进行全表扫描，而使用索引只需要扫描几行记录即可，使用 Explain 语句可以通过观察 rows 字段来看出这种差异。 1SELECT * FROM sakila.film_actor WHERE film_id = 1; 拆分大的 DELETE 或 INSERT 语句如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 1DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH); 12345rows_affected = 0do &#123; rows_affected = do_query( "DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")&#125; while rows_affected &gt; 0 五、切分随着时间和业务的发展，数据库中的表会越来越多，并且表中的数据量也会越来越大，那么读写操作的开销也会随着增大。 垂直切分将表按功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立商品数据库 payDB、用户数据库 userDB 等，分别用来存储项目与商品有关的表和与用户有关的表。 水平切分把表中的数据按照某种规则存储到多个结构相同的表中，例如按 id 的散列值、性别等进行划分。 切分的选择如果数据库中的表太多，并且项目各项业务逻辑清晰，那么垂直切分是首选。 如果数据库的表不多，但是单表的数据量很大，应该选择水平切分。 存在的问题1. 事务问题在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。 2. 跨库跨表连接问题在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上。这时，表的连接操作将受到限制，我们无法连接位于不同分库的表，也无法连接分表粒度不同的表，导致原本只需要一次查询就能够完成的业务需要进行多次才能完成。 3. 额外的数据管理负担和数据运算压力最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算。 六、故障转移和故障恢复故障转移也叫做切换，当主库出现故障时就切换到备库，使备库成为主库。故障恢复顾名思义就是从故障中恢复过来，并且保证数据的正确性。 提升备库或切换角色提升一台备库为主库，或者在一个主-主复制结构中调整主动和被动角色。 虚拟 IP 地址和 IP 托管为 MySQL 实例指定一个逻辑 IP 地址，当 MySQL 实例失效时，可以将 IP 地址转移到另一台 MySQL 服务器上。 中间件解决方案通过代理，可以路由流量到可以使用的服务器上。 在应用中处理故障转移将故障转移整合到应用中可能导致应用变得太过笨拙。 参考资料 BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013. How Sharding Works MySQL 索引背后的数据结构及算法原理 20+ 条 MySQL 性能优化的最佳经验 数据库为什么分库分表？mysql的分库分表方案]]></content>
      <categories>
        <category>数据库</category>
        <category>编程基础知识</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架]]></title>
    <url>%2F2017%2F11%2F06%2F1_Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Java集合框架Java集合自己学习1. TreeSet集合重要操作TreeSet属于Set集合框架，可以保持元素的有序性。TreeSet是依赖TreeMap实现的，TreeMap内部（TreeMap分析）是采用红黑树实现的。 这篇博客主要介绍一下TreeSet的一些重要操作。 1. Ceiling(E e)和floor(E e)操作 这个Ceiling()操作可以获取在TreeSet集合中比指定元素大于或等于的元素中的最小元素。相对应的floor()操作可以获取在TreeSet集合中比指定元素小于或等于的元素中的最大元素。 形象的理解，这就是把指定元素当作是地板或者是天花板，然后在TreeSet集合中去截取元素。 2. first()和last()操作 这两个操作分别是返回集合中第一个元素（最小）和最后一个元素（最大）。 3. lower(E e)和higher(E e)操作 lower()返回在集合中严格小于e(不包含e)的元素中的最大元素。相应的higher()返回集合中严格大于e的元素中的最小元素。要是它们找不到合适的元素，那么就都返回null。 4. pollFirst()和pollLast()操作 可以类比队列中的poll()操作。pollFirst()返回并移除集合中的第一个元素（最小），pollLast()返回并移除集合中的最后一个元素（最大）。 5. headSet(E e)和tailSet(E e)操作 headSet()返回集合中所有严格小于e的元素的一个视图(SortedSet&lt; E&gt;)。tailSet()相对应的返回所有严格大于e的所有元素的一个视图。 它都还有另外一个版本 headSet(E toElement, boolean inclusive)和 tailSet(E fromElement, boolean inclusive)。如果inclusive为true，那么这两个版本函数返回的视图中就会包含等于e的元素。 6. 求子集操作subSet(E fromElement, E toElement) 会返回一个从fromElement到toElement范围的元素集合视图(SortedSet&lt; E&gt;)。 也有另外一个版本 subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)。两个boolean值变量分别表示是否包含等于fromElement和toElement的集合元素。 一、Java集合框架综述​ JDK的集合框架在平时使用的频率很高，这些类非常的实用，掌握其实现能更好的优化程序；另一方面是学习借鉴JDK是如何实现了这么一套优雅高效的类库，提升编程能力。 ​ 在介绍具体适合类之前，本篇文章对Java中的集合框架做一个大致描述，从一个高的角度俯视这个框架，了解了这个框架的一些理念与约定，会大大帮助后面分析某个具体类，让我们开始吧。 集合框架（collections framework）​ 首先要明确，集合代表了一组对象（和数组一样，但数组长度不能变，而集合能）。Java中的集合框架定义了一套规范，用来表示、操作集合，使具体操作与实现细节解耦。 ​ 其实说白了，可以把一个集合看成一个微型数据库，操作不外乎“增删改查”四种操作，我们在学习使用一个具体的集合类时，需要把这四个操作的时空复杂度弄清楚了，基本上就可以说掌握这个类了。 设计理念​ 主要理念用一句话概括就是：提供一套“小而美”的API。API需要对程序员友好，增加新功能时能让程序员们快速上手。 ​ 为了保证核心接口足够小，最顶层的接口（也就是Collection与Map接口）并不会区分该集合是否可变（mutability）,是否可更改（modifiability）,是否可改变大小（resizability）这些细微的差别。相反，一些操作是可选的，在实现时抛出UnsupportedOperationException即可表示集合不支持该操作。集合的实现者必须在文档中声明那些操作是不支持的。 为了保证最顶层的核心接口足够小，它们只能包含下面情况下的方法： 基本操作，像之前说的“增删改查” There is a compelling performance reason why an important implementation would want to override it. ​ 此外，所有的集合类都必须能提供友好的交互操作，这包括没有继承Collection类的数组对象。因此，框架提供一套方法，让集合类与数组可以相互转化，并且可以把Map看作成集合。 两大基类Collection与Map​ 在集合框架的类继承体系中，最顶层有两个接口： Collection表示一组纯数据 Map表示一组key-value对 一般继承自Collection或Map的集合类，会提供两个“标准”的构造函数： 没有参数的构造函数，创建一个空的集合类 有一个类型与基类（Collection或Map）相同的构造函数，创建一个与给定参数具有相同元素的新集合类 因为接口中不能包含构造函数，所以上面这两个构造函数的约定并不是强制性的，但是在目前的集合框架中，所有继承自`Collection`或`Map`的子类都遵循这一约定。 Collection ​ java-collection-hierarchy 如上图所示，Collection类主要有三个接口： Set表示不允许有重复元素的集合（A collection that contains no duplicate elements） List表示允许有重复元素的集合（An ordered collection (also known as a sequence)） Queue JDK1.5新增，与上面两个集合类主要是的区分在于Queue主要用于存储数据，而不是处理数据。（A collection designed for holding elements prior to processing.） Map Map并不是一个真正意义上的集合（are not true collections），但是这个接口提供了三种“集合视角”（collection views ），使得可以像操作集合一样操作它们，具体如下： 把map的内容看作key的集合（map’s contents to be viewed as a set of keys） 把map的内容看作value的集合（map’s contents to be viewed as a collection of values） 把map的内容看作key-value映射的集合（map’s contents to be viewed as a set of key-value mappings） 集合的实现（Collection Implementations）实现集合接口的类一般遵循&lt;实现方式&gt;+&lt;接口&gt;的命名方式，通用的集合实现类如下表： Interface Hash Table Resizable Array Balanced Tree Linked List Hash Table + Linked List Set HashSet TreeSet LinkedHashSet List ArrayList LinkedList Deque ArrayDeque LinkedList Map HashMap TreeMap LinkedHashMap 参考资料： Java集合框架综述 java集合框架详解一、集合框架图 简化图： 说明：对于以上的框架图有如下几点说明 1. 所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。2. 集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。3. 抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。4. 实现类：8个实现类（实线表示），对接口的具体实现。==5. Collection 接口是一组允许重复的对象。====6. Set 接口继承 Collection，集合元素不重复。====7. List 接口继承 Collection，允许重复，维护元素插入顺序。====8. Map接口是键－值对象，与Collection接口没有什么关系。==9. Set、List和Map可以看做集合的三大类：List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。 二、总体分析 大致说明：看上面的框架图，先抓住它的主干，即Collection和Map。 1、Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。（1）List是一个==有序的队列==，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。 （2）Set是一个==不允许有重复元素的集合==。Set的实现类有HastSet和TreeSet。==HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。== 2、Map是一个映射接口，即==key-value键值对==。Map中的每一个元素包含“==一个key==”和“==key对应的value==”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。 3、接下来，再看Iterator。它是==遍历集合的工具==，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是==因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的==。 4、再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，==Enumeration只能在Hashtable, Vector, Stack中使用==。 5、最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。 有了上面的整体框架之后，我们接下来对每个类分别进行分析。 三、Collection接口​ Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set，注意Map不是Collection的子接口，这个要牢记。 Collection接口中的方法如下: ​ 其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。 ​ 另外，Collection中有一个iterator()函数，它的作用是==返回一个Iterator接口==。通常，我们==通过Iterator迭代器来遍历集合==。ListIterator是List接口所特有的，==在List接口中，通过ListIterator()返回一个ListIterator对象。== ​ Collection接口中函数的详细说明如下表： ​|返回值类型 | 方法名与含义|| ————– | ———————————————————— || boolean | add(E o) 确保此 collection 包含指定的元素（可选操作）。 || boolean | addAll(Collection&lt;? extends E&gt; c) 将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。 || void | clear() 移除此 collection 中的所有元素（可选操作）。 || boolean | contains(Object o) 如果此 collection 包含指定的元素，则返回 true。 || boolean | containsAll(Collection&lt;?&gt; c)如果此 collection 包含指定 collection 中的所有元素，则返回true。 | | boolean| **equals**(Object o) 比较此 collection 与指定对象是否相等。 | | int| **hashCode**() 返回此 collection 的哈希码值。 | | boolean| **isEmpty**() 如果此 collection 不包含元素，则返回true。 | | Iterator| **iterator**() 返回在此 collection 的元素上进行迭代的迭代器。 | | boolean| **remove**(Object o) 从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。 | | boolean| **removeAll**(Collection&lt;?&gt; c) 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。 | | boolean| **retainAll**(Collection&lt;?&gt; c) 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。 | | int| **size**() 返回此 collection 中的元素数。 | | Object[]` | toArray() 返回包含此 collection 中所有元素的数组。 || T[]` | **toArray**(T[] a) 返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。 |123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566​ Collection接口有两个常用的子接口，下面详细介绍。#### 1.List接口​ ==List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。== ​ List接口继承于Collection接口，它可以定义一个**允许重复的有序集合**。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。​ List接口为Collection直接接口。List所代表的是**有序的Collection**，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。**（1）ArrayList**​ ArrayList是一个**动态数组**，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以**如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。**​ size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。​ **ArrayList擅长于随机访问。同时ArrayList是非同步的。****（2）LinkedList**​ 同样实现List接口的LinkedList与ArrayList不同，==ArrayList是一个动态数组，而LinkedList是一个双向链表。==所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。​ 由于实现的方式不同，**LinkedList不能随机访问**，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。​ 与ArrayList一样，**LinkedList也是非同步的**。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(...));​ **LinkedList是可以当作队列使用的**。offer(E e)会在队尾插入元素，也就是在链表尾部插入元素。poll()会返回并移除队首元素，也就是链表的第一个元素。peek()会查看队首元素（链表第一个元素），但是不会移除它。​ **LinkedList也可以当作栈使用**。pop()会返回并删除栈顶元素，也就是链表第一个元素。push(E e)会将元素插入到栈顶，也就是链表第一个位置。其实LinkedList作为栈(stack)使用的时候，是把第一个元素位置当作栈顶位置的。如果只是查看栈顶元素，使用peek()就行了。 **（3）Vector**​ 与ArrayList相似，但是**Vector是同步**的。所以说**Vector是线程安全的动态数组**。它的操作与ArrayList几乎一样。**（4）Stack**​ Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。![ist接口实现类关系]( \image\java集合框架\List接口实现类关系图.png)#### 2.Set接口​ Set是一种**不包括重复元素的Collection**。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是**仅有一个**。由于Set接口的特殊性，**所有传入Set集合中的元素都必须不同**，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。​ ==Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。==​ 此外需要说明一点，在set接口中的不重复是有特殊要求的。 举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 为了更好地理解，请看下面的例子：```javapublic class Test&#123; public static void main(String[] args) &#123; Set&lt;String&gt; set=new HashSet&lt;String&gt;(); set.add(&quot;Hello&quot;); set.add(&quot;world&quot;); set.add(&quot;Hello&quot;); System.out.println(&quot;集合的尺寸为:&quot;+set.size()); System.out.println(&quot;集合中的元素为:&quot;+set.toString()); &#125; &#125; ​ 运行结果： ​ 集合的尺寸为:2 集合中的元素为:[world, Hello] ​ 分析：由于String类中重写了hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个Hello是加不进去的。 ​ 再看一个例子：12345678910111213141516public class TestSet &#123; public static void main(String[] args)&#123; Set&lt;String&gt; books = new HashSet&lt;String&gt;(); //添加一个字符串对象 books.add(new String("Struts2权威指南")); //再次添加一个字符串对象， //因为两个字符串对象通过equals方法比较相等，所以添加失败，返回false boolean result = books.add(new String("Struts2权威指南")); System.out.println(result); //下面输出看到集合只有一个元素 System.out.println(books); &#125;&#125; ​ 运行结果： ​ false [Struts2权威指南] ​ 说明：程序中，book集合两次添加的字符串对象明显不是一个对象（程序通过new关键字来创建字符串对象），当使用==运算符判断返回false，使用equals方法比较返回true，所以不能添加到Set集合中，最后只能输出一个元素。 （1）HashSet ​ HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(==这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致==)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 ==HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。== ​ ==HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。== ​ HashSet使用和理解中容易出现的误区: ​ a.HashSet中存放null值 HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。 ​ b.HashSet中存储元素的位置是固定的 HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。 ​ c.必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals (Object)=true将导致一些问题。 （2）LinkedHashSet ​ LinkedHashSet继承自HashSet，其底层是==基于LinkedHashMap来实现的==，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，==LinkedHashSet将会以元素的添加顺序访问集合的元素。== （3）TreeSet ​ TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 ​ 注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。 3. Queue接口​ 队列的特点是，只能在队尾插入元素，在队首移除元素。Queue接口里面重要的方法是：入队offer(E e)，出队poll()，查看队首元素peek()。 ​ element()也是查看队首元素，和peek()的区别是，当队列为空的时候peek()返回null，而element()会抛出异常。 ​ remove()也是返回并移除元素，和poll()的区别是，当队列为空的时候poll()返回null，而remove()会抛出异常。 ​ 下面是Queue接口方法摘要： Modifier and Type Method and Description boolean add(E e)Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. E element()Retrieves, but does not remove, the head of this queue. boolean offer(E e)Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. E peek()Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. E poll()Retrieves and removes the head of this queue, or returns null if this queue is empty. E remove()Retrieves and removes the head of this queue. (1) LinkedList作为队列 ​ LinkedLIst是链表，它实现了Queue接口，可以作为一个队列来使用。作为队列时，队列尾部就是链表的尾部，队列首部就是链表的首部。主要的方法就是：入队offer(E e)，出队poll()，查看队首元素peek()。 ​ 并且LinkedList也是可以当作双端队列来使用的。 (2) PriorityQueue优先级队列 ​ PriorityQueue内部是使用堆实现的，会依据元素的自然顺序排序，或者在构造PriorityQueue时指定比较器Comparator。主要的操作还是，入队offer，出队poll，查看队首元素peek。队首元素就是具体元素顺序中的最小那一个元素。（The head of this queue is the least element with respect to the specified ordering. ） ​ this implementation provides O(log(n)) time for the enqueuing and dequeuing methods (offer, poll, remove() and add); linear time for the remove(Object) and contains(Object) methods; and constant time for the retrieval methods (peek, element, and size). 四、Map接口​ Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它==不能存在相同的key值，当然value值可以相同。== 1.HashMap​ 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 2.LinkedHashMap​ LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。 LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。 根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。 由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 3.TreeMap​ TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。 ​ 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 ​ 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 ​ TreeMap判断两个元素相等的标准：==两个key通过compareTo()方法返回0，则认为这两个key相等。== ​ 如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。 五、Iterator 与 ListIterator详解1.Iterator​ Iterator的定义如下： 1public interface Iterator&lt;E&gt; &#123;&#125; ​ Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口如下： ​ boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 Object next()：返回集合里下一个元素。 void remove()：删除集合里上一次next方法返回的元素。 ​ 使用示例：1234567891011121314151617public class IteratorExample &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("aaa"); a.add("bbb"); a.add("ccc"); System.out.println("Before iterate : " + a); Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) &#123; String t = it.next(); if ("bbb".equals(t)) &#123; it.remove(); &#125; &#125; System.out.println("After iterate : " + a); &#125;&#125; ​ 输出结果如下： 12Before iterate : [aaa, bbb, ccc]After iterate : [aaa, ccc] ​ 注意： ​ （1）Iterator只能单向移动。 ​ （2）Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常。 2.ListIterator​ ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator. ​ ListIterator接口定义如下:1234567891011121314151617181920public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); void set(E e); void add(E e);&#125; ​ 由以上定义我们可以推出ListIterator可以: ​ (1)双向移动（向前/向后遍历）. ​ (2)产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引. ​ (3)可以使用set()方法替换它访问过的最后一个元素. ​ (4)可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素. ​ 使用示例：1234567891011121314151617181920212223242526272829public class ListIteratorExample &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("aaa"); a.add("bbb"); a.add("ccc"); System.out.println("Before iterate : " + a); ListIterator&lt;String&gt; it = a.listIterator(); while (it.hasNext()) &#123; System.out.println(it.next() + ", " + it.previousIndex() + ", " + it.nextIndex()); &#125; while (it.hasPrevious()) &#123; System.out.print(it.previous() + " "); &#125; System.out.println(); it = a.listIterator(1); while (it.hasNext()) &#123; String t = it.next(); System.out.println(t); if ("ccc".equals(t)) &#123; it.set("nnn"); &#125; else &#123; it.add("kkk"); &#125; &#125; System.out.println("After iterate : " + a); &#125;&#125; ​ 输出结果如下：12345678Before iterate : [aaa, bbb, ccc]aaa, 0, 1bbb, 1, 2ccc, 2, 3ccc bbb aaa bbbcccAfter iterate : [aaa, bbb, kkk, nnn] 六、异同点1. ArrayList和LinkedList（1）ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。（2）对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。（3）对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 2. HashTable与HashMap相同点： （1）都实现了Map、Cloneable、java.io.Serializable接口。（2）都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。 不同点： （1）历史原因:HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。（2）同步性:HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。（3）对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。（4）基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。 ​ Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代M器)去遍历。 然而由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。 ​ AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。 （5）支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 3.HashMap、Hashtable、LinkedHashMap和TreeMap比较​ Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。 ​ Hashtable 与 HashMap类似，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。 ​ LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。 ​ TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 ​ 一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。 ​ TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。 ​ LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.HashMap;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.TreeMap;public class MapTest &#123; public static void main(String[] args) &#123; //HashMap HashMap&lt;String,String&gt; hashMap = new HashMap(); hashMap.put("4", "d"); hashMap.put("3", "c"); hashMap.put("2", "b"); hashMap.put("1", "a"); Iterator&lt;String&gt; iteratorHashMap = hashMap.keySet().iterator(); System.out.println("HashMap--&gt;"); while (iteratorHashMap.hasNext())&#123; Object key1 = iteratorHashMap.next(); System.out.println(key1 + "--" + hashMap.get(key1)); &#125; //LinkedHashMap LinkedHashMap&lt;String,String&gt; linkedHashMap = new LinkedHashMap(); linkedHashMap.put("4", "d"); linkedHashMap.put("3", "c"); linkedHashMap.put("2", "b"); linkedHashMap.put("1", "a"); Iterator&lt;String&gt; iteratorLinkedHashMap = linkedHashMap.keySet().iterator(); System.out.println("LinkedHashMap--&gt;"); while (iteratorLinkedHashMap.hasNext())&#123; Object key2 = iteratorLinkedHashMap.next(); System.out.println(key2 + "--" + linkedHashMap.get(key2)); &#125; //TreeMap TreeMap&lt;String,String&gt; treeMap = new TreeMap(); treeMap.put("4", "d"); treeMap.put("3", "c"); treeMap.put("2", "b"); treeMap.put("1", "a"); Iterator&lt;String&gt; iteratorTreeMap = treeMap.keySet().iterator(); System.out.println("TreeMap--&gt;"); while (iteratorTreeMap.hasNext())&#123; Object key3 = iteratorTreeMap.next(); System.out.println(key3 + "--" + treeMap.get(key3)); &#125; &#125;&#125; 输出结果：123456789101112131415HashMap--&gt;3--c2--b1--a4--dLinkedHashMap--&gt;4--d3--c2--b1--aTreeMap--&gt;1--a2--b3--c4--d 4.HashSet、LinkedHashSet、TreeSet比较Set接口Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。 HashSetHashSet有以下特点：==-&gt; 不能保证元素的排列顺序，顺序有可能发生变化。====-&gt; 不是同步的。====-&gt; 集合元素可以是null，但只能放入一个null。== ​ 当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，==HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。== ​ 注意，如果要把一个对象放入HashSet中，==重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同==。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。 LinkedHashSet LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，==当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素==。 LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。 TreeSet类 TreeSet是SortedSet接口的唯一实现类，==TreeSet可以确保集合元素处于排序状态==。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。 ==TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。==自然排序 自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素==按照升序排列==。 Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是负数，则表明obj1小于obj2。==如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0。==定制排序 自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.test; import java.util.HashSet; import java.util.LinkedHashSet; import java.util.TreeSet; /** * @description 几个set的比较 * HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放； * LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代； * TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。 * */ public class SetDemo &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(); hs.add("B"); hs.add("A"); hs.add("D"); hs.add("E"); hs.add("C"); hs.add("F"); System.out.println("HashSet 顺序:\n"+hs); LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;String&gt;(); lhs.add("B"); lhs.add("A"); lhs.add("D"); lhs.add("E"); lhs.add("C"); lhs.add("F"); System.out.println("LinkedHashSet 顺序:\n"+lhs); TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); ts.add("B"); ts.add("A"); ts.add("D"); ts.add("E"); ts.add("C"); ts.add("F"); System.out.println("TreeSet 顺序:\n"+ts); &#125; &#125; 输出结果： 123HashSet 顺序:[D, E, F, A, B, C]LinkedHashSet 顺序:[B, A, D, E, C, F]TreeSet 顺序:[A, B, C, D, E, F] 5、Iterator和ListIterator区别​ 我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。但是在使用的时候也是有不同的。List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面： ==（1）ListIterator有add()方法，可以向List中添加对象，而Iterator不能====（2）ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。====（3）ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。====（4）都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。==因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。 6、Collection 和 Collections区别（1）java.util.Collection 是一个==集合接口（集合类的一个顶级接口）==。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是==为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set==。 Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└Set （2）java.util.Collections 是一个==包装类==（工具类/帮助类）。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。 代码示例：12345678910111213141516171819import java.util.ArrayList; import java.util.Collections; import java.util.List; public class TestCollections &#123; public static void main(String args[]) &#123; //注意List是实现Collection接口的 List list = new ArrayList(); double array[] = &#123; 112, 111, 23, 456, 231 &#125;; for (int i = 0; i &lt; array.length; i++) &#123; list.add(new Double(array[i])); &#125; Collections.sort(list); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(list.get(i)); &#125; // 结果：23.0 111.0 112.0 231.0 456.0 &#125; &#125; 参考资料：java集合框架综述 Java集合框架常被问到的面试问题 Java集合框架是最常被问到的Java面试问题，要理解Java技术强大特性就有必要掌握集合框架。这里有一些实用问题，常在核心Java面试中问到。 1、什么是Java集合API Java集合框架API是用来表示和操作集合的统一框架，它包含接口、实现类、以及帮助程序员完成一些编程的算法。简言之，API在上层完成以下几件事： ● 编程更加省力，提高城程序速度和代码质量 ● 非关联的API提高互操作性 ● 节省学习使用新API成本 ● 节省设计新API的时间 ● 鼓励、促进软件重用 具体来说，有6个集合接口，最基本的是Collection接口，由三个接口Set、List、SortedSet继承，另外两个接口是Map、SortedMap，这两个接口不继承Collection，表示映射而不是真正的集合。 2、什么是Iterator 一些集合类提供了内容遍历的功能，通过java.util.Iterator接口。这些接口允许遍历对象的集合。依次操作每个元素对象。当使用 Iterators时，在获得Iterator的时候包含一个集合快照。通常在遍历一个Iterator的时候不建议修改集合本身。 3、Iterator与ListIterator有什么区别？ Iterator：只能正向遍历集合，适用于获取移除元素。ListIerator：继承Iterator，可以双向列表的遍历，同样支持元素的修改。 4、什么是HashMap和Map？ Map是接口，Java 集合框架中一部分，用于存储键值对，HashMap是用哈希算法实现Map的类。 5、HashMap与HashTable有什么区别？对比Hashtable VS HashMap 两者都是用key-value方式获取数据。Hashtable是原始集合类之一（也称作遗留类）。HashMap作为新集合框架的一部分在Java2的1.2版本中加入。它们之间有一下区别： ● HashMap和Hashtable大致是等同的，除了非同步和空值（HashMap允许null值作为key和value，而Hashtable不可以）。 ● HashMap没法保证映射的顺序一直不变，但是作为HashMap的子类LinkedHashMap，如果想要预知的顺序迭代（默认按照插入顺序），你可以很轻易的置换为HashMap，如果使用Hashtable就没那么容易了。 ● HashMap不是同步的，而Hashtable是同步的。 ● 迭代HashMap采用快速失败机制，而Hashtable不是，所以这是设计的考虑点。 6、在Hashtable上下文中同步是什么意思？ 同步意味着在一个时间点只能有一个线程可以修改哈希表，任何线程在执行hashtable的更新操作前需要获取对象锁，其他线程等待锁的释放。 7、什么叫做快速失败特性 从高级别层次来说快速失败是一个系统或软件对于其故障做出的响应。一个快速失败系统设计用来即时报告可能会导致失败的任何故障情况，它通常用来停止正常的操作而不是尝试继续做可能有缺陷的工作。当有问题发生时，快速失败系统即时可见地发出错误告警。在Java中，快速失败与iterators有关。如果一个iterator在集合对象上创建了，其它线程欲“结构化”的修改该集合对象，并发修改异常 （ConcurrentModificationException） 抛出。 8、怎样使Hashmap同步？ HashMap可以通过Map m = Collections.synchronizedMap（hashMap）来达到同步的效果。 9、什么时候使用Hashtable，什么时候使用HashMap 基本的不同点是Hashtable同步HashMap不是的，所以无论什么时候有多个线程访问相同实例的可能时，就应该使用Hashtable，反之使用HashMap。非线程安全的数据结构能带来更好的性能。 如果在将来有一种可能—你需要按顺序获得键值对的方案时，HashMap是一个很好的选择，因为有HashMap的一个子类 LinkedHashMap。所以如果你想可预测的按顺序迭代（默认按插入的顺序），你可以很方便用LinkedHashMap替换HashMap。反观要是使用的Hash table就没那么简单了。同时如果有多个线程访问HashMap，Collections.synchronized Map（）可以代替，总的来说HashMap更灵活。 10、为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector 你应该使用ArrayList而不是Vector是因为默认情况下你是非同步访问的，Vector同步了每个方法，你几乎从不要那样做，通常有想要同步的是整个操作序列。同步单个的操作也不安全（如果你迭代一个Vector，你还是要加锁，以避免其它线程在同一时刻改变集合）.而且效率更慢。当然同样有锁的开销即使你不需要，这是个很糟糕的方法在默认情况下同步访问。你可以一直使用Collections.sychronizedList来装饰一个集合。 事实上Vector结合了“可变数组”的集合和同步每个操作的实现。这是另外一个设计上的缺陷。Vector还有些遗留的方法在枚举和元素获取的方法，这些方法不同于List接口，如果这些方法在代码中程序员更趋向于想用它。尽管枚举速度更快，但是他们不能检查如果集合在迭代的时候修改了，这样将导致问题。尽管以上诸多原因，oracle也从没宣称过要废弃Vector。 参考资料： Java集合类详解]]></content>
      <categories>
        <category>Java高级知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 基础知识]]></title>
    <url>%2F2017%2F10%2F18%2F2_Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、常用操作以及概念 求助 关机 PATH 运行等级 sudo GNU 包管理工具 发行版 VIM 三个模式 二、分区 磁盘的文件名 分区表 开机检测程序 挂载 三、文件 文件权限概念 文件属性以及权限的修改 目录的权限 文件默认权限 目录配置 文件时间 文件与目录的基本操作 获取文件内容 指令与文件搜索 四、磁盘与文件系统 文件系统的组成 inode 目录的 inode 与 block 实体链接与符号链接 五、压缩与打包 压缩 打包 六、Bash 特性 变量操作 指令搜索顺序 数据流重定向 七、管线指令 提取指令 排序指令 双向输出重定向 字符转换指令 分区指令 八、正则表达式 grep printf awk 九、进程管理 查看进程 进程状态 SIGCHLD wait() waitpid() 孤儿进程 僵死进程 十、I/O 复用 概念理解 I/O 模型 select poll epoll select 和 poll 比较 eopll 工作模式 select poll epoll 应用场景 参考资料 零、小知识点在linux中如果一个命令的输入文件是来自于标准输入流，则可以使用“-”符号来代替。例如：1cat /etc/group|paste /etc/passwd /etc/shadow -|head -n 3 一、常用操作以及概念求助1. –help指令的基本用法与选项介绍。 2. manman 是 manual 的缩写，将指令的具体信息显示出来。 当执行 man date 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下： 代号 类型 1 用户在 shell 环境中可以操作的指令或者可执行文件 5 配置文件 8 系统管理员可以使用的管理指令 3. infoinfo 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。 关机1. sync为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。 2. shutdown12345# /sbin/shutdown [-krhc] [时间] [警告讯息]-k ： 不会关机，只是发送警告讯息，通知所有在线的用户-r ： 将系统的服务停掉后就重新启动-h ： 将系统的服务停掉后就立即关机-c ： 取消已经在进行的 shutdown 指令内容 3. 其它关机指令reboot、halt、poweroff。 PATH可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。 1/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin 运行等级 0：关机模式 1：单用户模式（可用于破解 root 密码） 2：无网络支持的多用户模式 3：有网络支持的多用户模式（文本模式，工作中最常用的模式） 4：保留，未使用 5：有网络支持的 X-windows 多用户模式（桌面） 6：重新引导系统，即重启 sudo使用 sudo 允许一般用户使用 root 可执行的命令，只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。 GNUGNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议，包含了以下内容： 以任何目的运行此程序的自由； 再复制的自由； 改进此程序，并公开发布改进的自由。 包管理工具RPM 和 DPKG 为最常见的两类软件包管理工具。RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为很多 Linux 系统 (RHEL) 的既定软件标准。与 RPM 进行竞争的是基于 Debian 操作系统 (UBUNTU) 的 DEB 软件包管理工具－ DPKG，全称为 Debian Package，功能方面与 RPM 相似。 YUM 基于 RPM 包管理工具，具有依赖管理功能，并具有软件升级的功能。 发行版Linux 发行版是 Linux 内核及各种应用软件的集成版本。 基于的包管理工具 商业发行版 社区发行版 DPKG Ubuntu Debian RPM Red Hat Fedora / CentOS VIM 三个模式 一般指令模式（Command mode）：进入 VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 二、分区磁盘的文件名Linux 中每个硬件都被当做一个文件，包括磁盘。常见磁盘的文件名如下： SCSI/SATA/USB 磁盘：/dev/sd[a-p] IDE 磁盘：/dev/hd[a-d] 其中文件名后面的序号的确定与磁盘插入的顺序有关，而与磁盘所插入的插槽位置无关。 分区表磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。 1. MBRMBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中 MBR 占 446 bytes，分区表占 64 bytes。 分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它将其它空间用来记录分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。 Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。 2. GPT不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA）。 GPT 第 1 个区块记录了 MBR，紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。 GPT 没有扩展分区概念，都是主分区，最多可以分 128 个分区。 开机检测程序1. BIOSBIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的 MBR，由 MBR 执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。 MBR 中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动 MBR 中的开机管理程序时，就可以选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。 安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉 MBR，而 Linux 可以选择将开机管理程序安装在 MBR 或者其它分区的启动扇区，并且可以设置开机管理程序的选单。 2. UEFIUEFI 相比于 BIOS 来说功能更为全面，也更为安全。 挂载挂载利用目录作为分区的进入点，也就是说，进入目录之后就可以读取分区的数据。 三、文件文件权限概念把用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。 使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x. 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段。 3：链接数； root：文件拥有者； root：所属群组； 17：文件大小； May 6 00:14：文件最后被修改的时间； .config：文件名。 常见的文件类型及其含义有： d：目录； -：文件； l：链接文件； 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件属性以及权限的修改1. 修改文件所属群组12# chgrp [-R] groupname dirname/filename-R：递归修改 2. 修改文件拥有者不仅可以修改文件拥有者，也可以修改文件所属群组。 1# chown [-R] 用户名:群组名 dirname/filename 3. 修改权限可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 1# chmod [-R] xyz dirname/filename 范例：将 .bashrc 文件的权限修改为 -rwxr-xr–。 1# chmod 754 .bashrc 也可以使用符号来设定权限。 12345678# chmod [ugoa] [+-=] [rwx] dirname/filename- u：拥有者- g：所属群组- o：其他人- a：所有人- +：添加权限- -：移除权限- =：设定权限 范例：为 .bashrc 文件的所有用户添加写权限。 1# chmod a+w .bashrc 目录的权限文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。 目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。 文件默认权限 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 可以通过 umask 设置或者查看文件的默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r– 。 目录配置为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下： / (root, 根目录) /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程序运行过程中的数据文件。 文件时间 modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 文件与目录的基本操作1. ls列出文件或者目录的信息，目录的信息就是其中包含的文件。 1234# ls [-aAdfFhilnrRSt] file|dir-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据 2. cp复制操作。 如果源文件有两个以上，则目的文件一定要是目录才行。 12345678cp [-adfilprsu] source destination-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 3. rm移除操作。 12# rm [-fir] 文件或目录-r ：递归删除 4. mv移动操作。 123# mv [-fiu] source destination# mv [options] source1 source2 source3 .... directory-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 获取文件内容1. cat取得文件内容。 12# cat [-AbEnTv] filename-n ：打印出行号，连同空白行也会有行号，-b 不会 2. tac是 cat 的反向操作，从最后一行开始打印。 3. more可以一页一页查看文件内容，和文本编辑器类似。 4. less和 more 类似。比more更好一点的是，less可以向前翻页。 5. head可以取得文件前几行。 12# head [-n number] filename-n ：后面接数字，代表显示几行的意思 6. tail是 head 的反向操作，只是取得是后几行。 7. od可以以字符或者十六进制的形式显示二进制文件。 8. touch修改文件时间或者建立新文件。 123456# touch [-acdmt] filename-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date="日期或时间"-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 指令与文件搜索1. which指令搜索。 12# which [-a] command-a ：将所有指令列出，而不是只列第一个 2. whereiswhereis 搜索文件的速度比较快，因为它只搜索几个特定的目录。 1# whereis [-bmsu] dirname/filename 3. locatelocate 可以用关键字或者正则表达式进行搜索。 locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 12# locate [-ir] keyword-r：接正则表达式 4. findfind 可以使用文件的属性和权限进行搜索。 12# find [basedir] [option]example: find . -name "shadow*" （一）与时间有关的选项 1234-mtime n ：列出在 n 天前的那一天修改过内容的文件-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件-newer file ： 列出比 file 更新的文件 +4、4 和 -4 的指示的时间范围如下： （二）与文件拥有者和所属群组有关的选项 123456-uid n-gid n-user name-group name-nouser ：搜索拥有者不存在 /etc/passwd 的文件-nogroup：搜索所属群组不存在于 /etc/group 的文件 （三）与文件权限和名称有关的选项 123456-name filename-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k-type TYPE-perm mode ：搜索权限等于 mode 的文件-perm -mode ：搜索权限包含 mode 的文件-perm /mode ：搜索权限包含任一 mode 的文件 四、磁盘与文件系统文件系统的组成对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统，因此只有文件系统能被挂载，而分区不能被挂载。 文件系统有以下三个结构： superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等； inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 号码； block：记录文件的内容，文件太大时，会占用多个 block。 当要读取一个文件的内容时，先在 inode 中去查找文件内容所在的所有 block，然后把所有 block 的内容读出来。 磁盘碎片是指一个文件内容所在的 block 过于分散。 inodeExt2 文件系统支持的 block 大小有 1k、2k 和 4k 三种，不同的 block 大小限制了单一文件的大小。而每个 inode 大小是固定为 128 bytes。 inode 中记录了文件内容所在的 block，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块当成 inode 用来记录引用信息。 inode 具体包含以下信息： 该文件的存取模式 (read/write/excute)； 该文件的拥有者与群组 (owner/group)； 该文件的容量； 该文件建立或状态改变的时间 (ctime)； 最近一次的读取时间 (atime)； 最近修改的时间 (mtime)； 定义文件特性的旗标 (flag)，如 SetUID…； 该文件真正内容的指向 (pointer)。 目录的 inode 与 block建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。 实体链接与符号链接123# ln [-sf] source_filename dist_filename-s ：默认是 hard link，加 -s 为 symbolic link-f ：如果目标文件存在时，先删除目标文件 1. 实体链接它和普通文件类似，实体链接文件的 inode 都指向源文件所在的 block 上，也就是说读取文件直接从源文件的 block 上读取。 删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制：不能跨越 File System、不能对目录进行链接。 1234# ln /etc/crontab .# ll -i /etc/crontab crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 2. 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。 当源文件被删除了，链接文件就打不开了。 可以为目录建立链接。 123# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 五、压缩与打包压缩Linux 底下有很多压缩文件的扩展名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 1. gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 123456$ gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 2. bzip2提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。 12$ bzip2 [-cdkzv#] filename-k ：保留源文件 3. xz提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。 查看命令：xzcat、xzmore、xzless、xzgrep。 1$ xz [-dtlkc#] filename 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。 123456789101112$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩-z ：使用 zip；-j ：使用 bzip2；-J ：使用 xz；-c ：新建打包文件；-t ：查看打包文件里面有哪些文件；-x ：解打包或解压缩的功能；-v ：在压缩/解压缩的过程中，显示正在处理的文件名；-f : filename：要处理的文件；-C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 六、Bash可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。 特性 命令历史：记录使用过的命令。本次登录所执行的命令都会暂时存放到内存中，~/.bash_history 文件中记录的是前一次登录所执行过的命令。 命令与文件补全：快捷键：tab。 命名别名：例如 lm 是 ls -al 的别名。 shell scripts。 通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件。 变量操作 对一个变量赋值直接使用 = ； 对变量取用需要在变量前加上 \$ ，也可以用 \${} 的形式； 输出变量使用 echo 命令。 123$ var=abc$ echo $var$ echo $&#123;var&#125; 变量内容如果有空格，必须需要使用双引号或者单引号。 双引号内的特殊字符可以保留原本特性，例如 var=”lang is \$LANG”，则 var 的值为 lang is zh_TW.UTF-8； 单引号内的特殊字符就是特殊字符本身，例如 var=’lang is \$LANG’，则 var 的值为 lang is \$LANG。 可以使用 `指令` 或者 \$(指令) 的方式将指令的执行结果赋值给变量。例如 version=\$(uname -r)，则 version 的值为 3.10.0-229.el7.x86_64。 可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。 Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令： 12345$ declare [-aixr] variable-a ： 定义为数组类型-i ： 定义为整数类型-x ： 定义为环境变量-r ： 定义为 readonly 类型 使用 [ ] 来对数组进行索引操作： 123$ array[1]=a$ array[2]=b$ echo $&#123;array[1]&#125; 指令搜索顺序 以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ； 由别名找到该指令来执行； 由 Bash 内建的指令来执行； 按 \$PATH 变量指定的搜索路径的顺序找到第一个指令来执行。 数据流重定向重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 1 代码 运算符 标准输入 (stdin) 0 &lt; 或 &lt;&lt; 标准输出 (stdout) 1 &gt; 或 &gt;&gt; 标准错误输出 (stderr) 2 2&gt; 或 2&gt;&gt; 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 1$ find /home -name .bashrc &gt; list 2&gt;&amp;1 七、管线指令管线是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管线。在命令之间使用 | 分隔各个管线命令。 1$ ls -al /etc | less 提取指令cut 对数据进行切分，取出想要的部分。提取过程一行一行地进行。 1234$ cut-d ：分隔符-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间-c ：以字符为单位取出区间 范例 1：last 将显示的登入者的信息，要求仅显示用户名。 123456$ lastroot pts/1 192.168.201.101 Sat Feb 7 12:35 still logged inroot pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)$ last | cut -d ' ' -f 1 范例 2：将 export 输出的讯息，取得第 12 字符以后的所有字符串。 12345678$ exportdeclare -x HISTCONTROL="ignoredups"declare -x HISTSIZE="1000"declare -x HOME="/home/dmtsai"declare -x HOSTNAME="study.centos.vbird".....(其他省略).....$ export | cut -c 12 排序指令sort 进行排序。 123456789$ sort [-fbMnrtuk] [file or stdin]-f ：忽略大小写-b ：忽略最前面的空格-M ：以月份的名字来排序，例如 JAN，DEC-n ：使用数字-r ：反向排序-u ：相当于 unique，重复的内容只出现一次-t ：分隔符，默认为 tab-k ：指定排序的区间 范例：/etc/passwd 内容是以 : 来分隔的，以第三栏来排序。 12345$ cat /etc/passwd | sort -t ':' -k 3root:x:0:0:root:/root:/bin/bashdmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bashalex:x:1001:1002::/home/alex:/bin/basharod:x:1002:1003::/home/arod:/bin/bash uniq 可以将重复的数据只取一个。 123$ uniq [-ic]-i ：忽略大小写-c ：进行计数 范例：取得每个人的登录总次数 1234567$ last | cut -d ' ' -f 1 | sort | uniq -c16 (unknown47 dmtsai4 reboot7 root1 wtmp 双向输出重定向输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。 1$ tee [-a] file 字符转换指令tr 用来删除一行中的字符，或者对字符进行替换。 12$ tr [-ds] SET1 ...-d ： 删除行中 SET1 这个字符串 范例，将 last 输出的信息所有小写转换为大写。 1$ last | tr '[a-z]' '[A-Z]' col 将 tab 字符转为空格字符。 12$ col [-xb]-x ： 将 tab 键转换成对等的空格键 expand 将 tab 转换一定数量的空格，默认是 8 个。 12$ expand [-t] file-t ：tab 转为空格的数量 join 将有相同数据的那一行合并在一起。 12345$ join [-ti12] file1 file2-t ：分隔符，默认为空格-i ：忽略大小写的差异-1 ：第一个文件所用的比较字段-2 ：第二个文件所用的比较字段 paste 直接将两行粘贴在一起。 12$ paste [-d] file1 file2-d ：分隔符，默认为 tab 分区指令split 将一个文件划分成多个文件。 1234$ split [-bl] file PREFIX-b ：以大小来进行分区，可加单位，例如 b, k, m 等-l ：以行数来进行分区。- PREFIX ：分区文件的前导名称 示例：123456789101112范例一：我的 /etc/services 有六百多 K，若想要分成 300K 一个文件时？[dmtsai@study ~]$ cd /tmp; split -b 300k /etc/services services[dmtsai@study tmp]$ ll -k services*-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul 9 22:52 servicesaa-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul 9 22:52 servicesab-rw-rw-r--. 1 dmtsai dmtsai 55893 Jul 9 22:52 servicesac# 那个档名可以随意取的啦！我们只要写上前导文字，小文件就会以# xxxaa, xxxab, xxxac 等方式来建立小文件的！范例二：如何将上面的三个小文件合成一个文件， 档名为 servicesback[dmtsai@study tmp]$ cat services* &gt;&gt; servicesback# 很简单吧？就用数据流重导向就好啦！ 简单！ 八、正则表达式grep使用正则表示式把匹配的行提取出来。 1234567$ grep [-acinv] [--color=auto] 搜寻字符串 filename-a ： 将 binary 文件以 text 文件的方式进行搜寻-c ： 计算找到个数-i ： 忽略大小写-n ： 输出行号-v ： 反向选择，亦即显示出没有 搜寻字符串 内容的那一行--color=auto ：找到的关键字加颜色显示 范例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串） 123456$ grep -n 'the' regular_express.txt8:I can't finish the test.12:the symbol '*' is represented as start.15:You are the best is mean you are the no. 1.16:The world Happy is the same with "glad".18:google is the best tools for search keyword 因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。 1$ grep -n 'go\&#123;2,5\&#125;g' regular_express.txt printf用于格式化输出。 它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。 1234$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt) DmTsai 80 60 92 77.33 VBird 75 55 80 70.00 Ken 60 90 70 73.33 awk可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。 1$ awk ' 条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...' filename awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：\$n，n 为字段号，从 1 开始，\$0 表示一整行。 范例 1：取出登录用户的用户名和 ip 12345678$ last -n 5dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged indmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)$ last -n 5 | awk '&#123;print $1 "\t" $3&#125; awk 变量： 变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 范例 2：输出正在处理的行号，并显示每一行有多少字段 123456$ last -n 5 | awk '&#123;print $1 "\t lines: " NR "\t columns: " NF&#125;'dmtsai lines: 1 columns: 10dmtsai lines: 2 columns: 10dmtsai lines: 3 columns: 10dmtsai lines: 4 columns: 10dmtsai lines: 5 columns: 9 可以使用条件，其中等于使用 ==。 范例 3：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。 1234$ cat /etc/passwd | awk &apos;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&apos;root 0bin 1daemon 2 九、进程管理查看进程1. ps查看某个时间点的进程信息 示例一：查看自己的进程 1# ps -l 示例二：查看系统所有进程 1# ps aux 示例三：查看特定的进程 1# ps aux | grep threadx 2. top实时显示进程信息 示例：两秒钟刷新一次 1# top -d 2 3. pstree查看进程树 示例：查看所有进程树 1# pstree -A 4. netstat查看占用端口的进程 1# netstat -anp | grep port 进程状态 状态 说明 R running or runnable (on run queue) D uninterruptible sleep (usually IO) S interruptible sleep (waiting for an event to complete) Z defunct/zombie, terminated but not reaped by its parent T stopped, either by a job control signal or because it is being traced SIGCHLD当一个子进程改变了它的状态时：停止运行，继续运行或者退出，有两件事会发生在父进程中： 得到 SIGCHLD 信号； waitpid() 或者 wait() 调用会返回。 其中子进程发送的 SIGCHLD 信号包含了子进程的信息，包含了进程 ID、进程状态、进程使用 CPU 的时间等。 在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息。父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。 wait()1pid_t wait(int *status) 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。 如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 - 1，同时 errno 被置为 ECHILD。 参数 status 用来保存被收集进程退出时的一些状态，如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，我们就可以设定这个参数为 NULL： 1pid = wait(NULL); waitpid()1pid_t waitpid(pid_t pid,int *status,int options) 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。 pid 参数指示一个子进程的 ID，表示只关心这个子进程的退出 SIGCHLD 信号。如果 pid=-1 时，那么贺 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。 options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。 孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 僵死进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。 僵死进程通过 ps 命令显示出来的状态为 Z。 系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵死进程，只需要将其父进程杀死，此时所有的僵死进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵死进程所占有的资源，从而结束僵死进程。 十、I/O 复用概念理解I/O Multiplexing 又被称为 Event Driven I/O，它可以让单个进程具有处理多个 I/O 事件的能力。 当某个 I/O 事件条件满足时，进程会收到通知。 如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时连接几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。 I/O 模型 阻塞（Blocking） 非阻塞（Non-blocking） 同步（Synchronous） 异步（Asynchronous） 阻塞非阻塞是等待 I/O 完成的方式，阻塞要求用户程序停止执行，直到 I/O 完成，而非阻塞在 I/O 完成之前还可以继续执行。 同步异步是获知 I/O 完成的方式，同步需要时刻关心 I/O 是否已经完成，异步无需主动关心，在 I/O 完成时它会收到通知。 1. 同步-阻塞这是最常见的一种模型，用户程序在使用 read() 时会执行系统调用从而陷入内核，之后就被阻塞直到系统调用完成。 应该注意到，在阻塞的过程中，其他程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。 2. 同步-非阻塞非阻塞意味着用户程序在执行系统调用后还可以继续执行，内核并不是马上执行完 I/O，而是以一个错误码来告知用户程序 I/O 还未完成。为了获得 I/O 完成事件，用户程序必须调用多次系统调用去询问内核，甚至是忙等，也就是在一个循环里面一直询问并等待。 由于 CPU 要处理更多的用户程序的询问，因此这种模型的效率是比较低的。 3. 异步该模式下，I/O 操作会立即返回，之后可以处理其它操作，并且在 I/O 完成时会收到一个通知，此时会中断正在处理的操作，然后继续之前的操作。 select poll epoll这三个都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。 1. select1int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); fd_set 表示描述符集合； readset、writeset 和 exceptset 这三个参数指定让操作系统内核测试读、写和异常条件的描述符； timeout 参数告知内核等待所指定描述符中的任何一个就绪可花多少时间； 成功调用返回结果大于 0；出错返回结果为 -1；超时返回结果为 0。 123456789101112131415161718192021222324252627282930313233343536fd_set fd_in, fd_out;struct timeval tv;// Reset the setsFD_ZERO( &amp;fd_in );FD_ZERO( &amp;fd_out );// Monitor sock1 for input eventsFD_SET( sock1, &amp;fd_in );// Monitor sock2 for output eventsFD_SET( sock2, &amp;fd_out );// Find out which socket has the largest numeric value as select requires itint largest_sock = sock1 &gt; sock2 ? sock1 : sock2;// Wait up to 10 secondstv.tv_sec = 10;tv.tv_usec = 0;// Call the selectint ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv );// Check if select actually succeedif ( ret == -1 ) // report error and abortelse if ( ret == 0 ) // timeout; no event detectedelse&#123; if ( FD_ISSET( sock1, &amp;fd_in ) ) // input event on sock1 if ( FD_ISSET( sock2, &amp;fd_out ) ) // output event on sock2&#125; 每次调用 select() 都需要将 fd_set *readfds, fd_set *writefds, fd_set *exceptfds 链表内容全部从用户进程内存中复制到操作系统内核中，内核需要将所有 fd_set 遍历一遍，这个过程非常低效。 返回结果中内核并没有声明哪些 fd_set 已经准备好了，所以如果返回值大于 0 时，程序需要遍历所有的 fd_set 判断哪个 I/O 已经准备好。 在 Linux 中 select 最多支持 1024 个 fd_set 同时轮询，其中 1024 由 Linux 内核的 FD_SETSIZE 决定。如果需要打破该限制可以修改 FD_SETSIZE，然后重新编译内核。 2. poll1int poll (struct pollfd *fds, unsigned int nfds, int timeout); 12345struct pollfd &#123; int fd; //文件描述符 short events; //监视的请求事件 short revents; //已发生的事件&#125;; 1234567891011121314151617181920212223242526272829// The structure for two eventsstruct pollfd fds[2];// Monitor sock1 for inputfds[0].fd = sock1;fds[0].events = POLLIN;// Monitor sock2 for outputfds[1].fd = sock2;fds[1].events = POLLOUT;// Wait 10 secondsint ret = poll( &amp;fds, 2, 10000 );// Check if poll actually succeedif ( ret == -1 ) // report error and abortelse if ( ret == 0 ) // timeout; no event detectedelse&#123; // If we detect the event, zero it out so we can reuse the structure if ( pfd[0].revents &amp; POLLIN ) pfd[0].revents = 0; // input event on sock1 if ( pfd[1].revents &amp; POLLOUT ) pfd[1].revents = 0; // output event on sock2&#125; 它和 select() 功能基本相同。同样需要每次将 struct pollfd *fds 复制到内核，返回后同样需要进行轮询每一个 pollfd 是否已经 I/O 准备好。poll() 取消了 1024 个描述符数量上限，但是数量太大以后不能保证执行效率，因为复制大量内存到内核十分低效，所需时间与描述符数量成正比。poll() 在 pollfd 的重复利用上比 select() 的 fd_set 会更好。 如果在多线程下，如果一个线程对某个描述符调用了 poll() 系统调用，但是另一个线程关闭了该描述符，会导致 poll() 调用结果不确定，该问题同样出现在 select() 中。 3. epoll123int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.// The function argument is ignored (it was not before, but now it is), so put your favorite number hereint pollingfd = epoll_create( 0xCAFE );if ( pollingfd &lt; 0 ) // report error// Initialize the epoll structure in case more members are added in futurestruct epoll_event ev = &#123; 0 &#125;;// Associate the connection class instance with the event. You can associate anything// you want, epoll does not use this information. We store a connection class pointer, pConnection1ev.data.ptr = pConnection1;// Monitor for input, and do not automatically rearm the descriptor after the eventev.events = EPOLLIN | EPOLLONESHOT;// Add the descriptor into the monitoring list. We can do it even if another thread is// waiting in epoll_wait - the descriptor will be properly addedif ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 ) // report error// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)struct epoll_event pevents[ 20 ];// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event arrayint ready = epoll_wait( pollingfd, pevents, 20, 10000 );// Check if epoll actually succeedif ( ret == -1 ) // report error and abortelse if ( ret == 0 ) // timeout; no event detectedelse&#123; // Check if any events detected for ( int i = 0; i &lt; ret; i++ ) &#123; if ( pevents[i].events &amp; EPOLLIN ) &#123; // Get back our connection pointer Connection * c = (Connection*) pevents[i].data.ptr; c-&gt;handleReadEvent(); &#125; &#125;&#125; epoll 仅仅适用于 Linux OS。 它是 select 和 poll 的增强版，更加灵活而且没有描述符限制。它将用户关心的描述符放到内核的一个事件表中，从而只需要在用户空间和内核空间拷贝一次。 select 和 poll 方式中，进程只有在调用一定的方法后，内核才对所有监视的描述符进行扫描。而 epoll 事先通过 epoll_ctl() 来注册描述符，一旦基于某个描述符就绪时，内核会采用类似 callback 的回调机制，迅速激活这个描述符，当进程调用 epoll_wait() 时便得到通知。 新版本的 epoll_create(int size) 参数 size 不起任何作用，在旧版本的 epoll 中如果描述符的数量大于 size，不保证服务质量。 epoll_ctl() 执行一次系统调用，用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理。 epoll_wait() 取出在内核中通过链表维护的 I/O 准备好的描述符，将他们从内核复制到程序中，不需要像 select/poll 对注册的所有描述符遍历一遍。 epoll 对多线程编程更有友好，同时多个线程对同一个描述符调用了 epoll_wait 也不会产生像 select/poll 的不确定情况。或者一个线程调用了 epoll_wait 另一个线程关闭了同一个描述符也不会产生不确定情况。 select 和 poll 比较1. 功能它们提供了几乎相同的功能，但是在一些细节上有所不同： select 会修改 fd_set 参数，而 poll 不会； select 默认只能监听 1024 个描述符，如果要监听更多的话，需要修改 FD_SETSIZE 之后重新编译； poll 提供了更多的事件类型。 2. 速度poll 和 select 在速度上都很慢。 它们都采取轮询的方式来找到 I/O 完成的描述符，如果描述符很多，那么速度就会很慢； select 只使用每个描述符的 3 位，而 poll 通常需要使用 64 位，因此 poll 需要复制更多的内核空间。 3. 可移植性几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。 epoll 工作模式epoll_event 有两种触发模式：LT（level trigger）和 ET（edge trigger）。 1. LT 模式当 epoll_wait() 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait() 时，会再次响应应用程序并通知此事件。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。 2. ET 模式当 epoll_wait() 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait() 时，不会再次响应应用程序并通知此事件。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 select poll epoll 应用场景很容易产生一种错觉认为只要用 epoll 就可以了，select poll 都是历史遗留问题，并没有什么应用场景，其实并不是这样的。 1. select 应用场景select() poll() epoll_wait() 都有一个 timeout 参数，在 select() 中 timeout 的精确度为 1ns，而 poll() 和 epoll_wait() 中则为 1ms。所以 select 更加适用于实时要求更高的场景，比如核反应堆的控制。 select 历史更加悠久，它的可移植性更好，几乎被所有主流平台所支持。 2. poll 应用场景poll 没有最大描述符数量的限制，如果平台支持应该采用 poll 且对实时性要求并不是十分严格，而不是 select。 需要同时监控小于 1000 个描述符。那么也没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。 需要监控的描述符状态变化多，而且都是非常短暂的。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。epoll 的描述符存储在内核，不容易调试。 3. epoll 应用场景程序只需要运行在 Linux 平台上，有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。 4. 性能对比 epoll Scalability Web Page 参考资料 鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009. Linux 平台上的软件包管理 Boost application performance using asynchronous I/O Synchronous and Asynchronous I/O.aspx) Linux IO 模式及 select、poll、epoll 详解 poll vs select vs event-based Linux 之守护进程、僵死进程与孤儿进程 Linux process states GUID Partition Table 详解 wait 和 waitpid 函数]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++知识学习]]></title>
    <url>%2F2017%2F09%2F26%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FC%2B%2B%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[C++知识学习一、基础知识向函数传递数组的方式c++不允许向函数传递一个完整的数组作为参数，但是用户可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针 如果想要在函数中传递一个一维数组作为参数，用户必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编辑器将要接受一个整型指针，同样的，用户也可以传递一个多维数组作为形式参数 方式1123void myFunction (int *param)&#123;&#125; 形式参数是一个指针 方式2123void myFunction (int param[10])&#123;&#125; 形式参数是一个已定义大小的数组 方式3123void myFunction(int param[])&#123;&#125; 形式参数是一个未定义大小的数组 实例：12345678910111213141516171819202122double getAverage (int arr[],int size)&#123; int i,sum=0; double avg; for (i=0;i&lt;size;++i)&#123; sum+=arr[i]; &#125; avg=double (sum)/size; return avg;&#125;//调用上面的函数# include &lt;iostream&gt;using namespace std;double getAverage(int arr[],int size);int main()&#123; int balance[5]=&#123;1000.0,2,3,17,50&#125;; double avg; avg=getAverage(balance,5); cout&lt;&lt;"平均值"&lt;&lt;avg&lt;&lt;endl; return 0;&#125; 显示结果 平均值214.4 就函数而言，数组的长度是无关紧要的，因为c++不会对形式参数执行边界检查 Linux 下编译C++程序使用 gcc test.cpp编译C++源代码会报错，因为gcc是C语言的编译器，所以要换成g++编译程序。 正确的编译方式为：1g++ test.cpp -o joyce 然后运行程序的时候使用：1./joyce C++ 判断指针为空的写法​ C++之父的C++圣经《C++程序设计语言 特别版》中说： 大家不要听某些人说判断指针是否为空用(p==NULL)或(p!=NULL)的格式，C++之父认为这样写是不好的，提倡直接写(p)或(!p)的形式。 在win32开发中，if ( NULL == p )是极好的写法。但不要写成：if ( p == NULL ) C++之父主要是反对使用“NULL”，因为在某些特殊的开发环境叫，“NULL”并非补定义成地址0，也可能是一个跟平台相关的，用于标记非法地址的其它地址。但按照C++标准的规定，只有等于0的地址可以被随便delete多次，因此如果是别的地址，那至少C++标准就给不了任何说法。至于是if(p == 0)和if(p != 0)，还是if(p)或者if(!p)，这个找不出什么重大区别，个人觉得。 不过，从代码的可扩展性上讲，写成后者可能好一些，因为如果有一天你决定改用一些原生指针的包装类（比如类似那种auto_ptr模板的）来代替直接操作原生指针，而那个类可能重载了operator！，后者可能让你直接利用这些设施 林锐提倡if ( p == NULL )是从代码的可读性上考虑的，一看就是在判断一个指针，而不是判断一个bool值，它提倡只有bool值才使用if(p)或者if(!p)的形式。 BS是从可移植方面考虑。 if( p == NULL )，一眼就可以看出这是在判断一个指针，但如果写成if(!p)，那你必须要知道p倒底是什么才能知道这个判断的含义。另外，不要写成if( p == NULL )这样的形式，应该写成：if ( NULL == p )。 如果你误写成了if ( NULL = p )，那编译时就会提示你，但如果是前者，这个错误就隐藏起来了。]]></content>
      <categories>
        <category>编程语言</category>
        <category>编程基础知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA开发工具学习]]></title>
    <url>%2F2017%2F07%2F25%2FIDEA%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[IDEA开发工具0. 经常使用的操作生成接收方法返回值的变量：Refactor -&gt; Extract -&gt; Variable 对应的快捷键是 Ctrl + Alt + V 搜索某个类 ：ctrl + N 然后输入类名，java类库中的类也可以搜索，并且可以看得到源码。 1. 对于project和module的理解自己觉的idea中project类似与eclipse中的workspace，而module就类似与eclipse中的project了。推荐的就是在一个idea中的project放置和该项目相关的模块，如果要创建新的工程，那么就再新开一个project就好了！ 2. 一个模块(module)依赖另外一个模块(module)因为存在一个关系，所以一定要再一个模块上设置那个被依赖的模块。 设置方法是：&emsp;&emsp;鼠标选中当前模块的名称–&gt;File–&gt;Project Structure –&gt; Modules –&gt; 在中间那一列模块名称中选中当前模块 –&gt; Dependencies –&gt; 点击右侧”+”加号，然后选中要依赖的模块，最后还要在依赖的模块名称前面的方框中选中。最后，点击apply就好了！效果如下图所示： 3. IntelliJ Idea 常用快捷键列表Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 – 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行 Shift+Enter，向下插入新行psvm/sout，main/System.out.println(); Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+”+/-”，当前方法展开、折叠Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器 【重构】Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联 【查找】Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法 转自： http://www.open-open.com/lib/view/open1396578860887.html 4. IntelliJ Idea多行编辑要使用多行编辑，按住alt键不放，然后用鼠标拉出多行，就可以对选中的这几行进行同时编辑了。]]></content>
      <categories>
        <category>开发工具</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>开发技巧</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Octave学习]]></title>
    <url>%2F2017%2F06%2F25%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FOctave%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Octave学习常用命令清屏命令: ctrl+l Octave入门基础一，简介1.1 Octave是什么?Octave是一款用于数值计算和绘图的开源软件。和Matlab一样,Octave 尤其精于矩阵运算:求解联立方程组、计算矩阵特征值和特征向量等等。 1.2 Octave的适用对象Octave和Matlab被工程人员和科研人员广泛使用来进行各种工业和学术上的数值计算和仿真。如,NASA 使用它来开发飞行器的对接系统;Jaguar Racing使用它来可视化和分析从 F1 赛车传来的数 据;Sheffield大学用它来开发用于识别癌细胞的软件。Octave这样的软件让编写数值处理程序变得简单,并提供数据可视化的多种方式。 1.3 Octave的下载与安装参照网上相关教程； 二，简单计算2.1 Octave使用方式Octave最简单的使用方式就是像使用一个计算器一样在命令提示符下输入相应的计算式。Octave能识别通常的计算表达式。例如,在终端输入 octave:##&gt;2+2 并按回车键, 你将得到以下的结果ans=4 各种计算符号的优先级与常规的一致,比如括号有最大优先级,其次为乘方,其次为乘除运算,最后为加减运算 2.2 内建函数Octave中有很多内建函数，可以通过输入函数名和括号中的输入参数来调用函数,例如: octave:##&gt; exp(1) ans=2.71813 又如另一个更长的表达式:计算 1.2 sin(40◦ + ln(2.42)), 输入octave:##&gt;1.2sin(40pi/180+log(2.4^2)) ans=0.76618 其中基本的数学函数有：sin, cos, tan, log, exp, abs, floor, ceil等； 如果你要退出Octave,只需要在命令提示符下输入quit或者exit即可。 三，Octave变量3.1 变量同C++，Java等变成语言一样我们可以定义变量，但Octave 为解释性语言。因此Octave中变量的类型是不用声明的，但Octave中变量名是区分大小的,即变量a和变量A是不同的变量。 octave:##&gt; deg=pi/180 deg=0.017453 如果你需要从当前的变量空间中删除某个变量,clear命令能移出所有的变量,或者移出某个特定变量, 如: clear namels将移出名为 name 的某个变量。 3.2 载入和保存数据当你退出Octave的时候,你将丢失你所创建的变量。如果你需要在工作的中途退出Octave,那么你可以保存当前会话的数据并在之后重新载入它。如果你输入 octave:##&gt; save anynamels 这将整个工作空间上的变量存储到当前目录下一个名为anyname.mat 的文件中 (注意.mat是Octave自动添加的)。这样你可以退出Octave,之后重新启动Octave程序,通过输入 octave:##&gt; loadanyname 将重新载入之前保存的命名空间,并从你中断的地方重新开始工作。同样的,你可以载入或者保存特定的变量。格式为 octave:##&gt;save filename var1 var2 … 例如,如果你想存储deg变量,那么你可以输入 octave:##&gt; save degconv degls 这样将deg变量存储于名为degconv.mat的文件中,你可以通过以下命令重新载入变量 octave:##&gt; loaddegconv Octave 同样能从文件中导入数据,这样的功能在你使用其他的数据来源进行画图或者计算的时候变得非常有用。 例如： X=load(‘featureX.txt’); 3.3 获得帮助如果你不清楚某个命令或者函数的用法，可也用help命令来获得其详细的用法。 help commandname 例如：help plot 3.4 分号和隐藏结果分号在通常的编程语言中被用来表示程序块或者单个语句的结束。在 Octave 中分号不是必需的,但它也有一个特殊的功能。我们目前的例子中,我们只要输入一个 Octave 命令并不以分号结尾的话,Octave 总 会将语句执行的结果随即显示出来。但是,如果我们在一行语句的末尾添上分号,Octave将不会显出相应的 结果。 四 数组和向量及矩阵前面介绍过Octave的优势就是可以很方便的进行矩阵的相关计算。 4.1 构造向量构造矩阵或者向量的方法有很多。其中最直接简单的方法就是在一个方括号 [] 中给出其元素,例如 octave:##&gt; a=[1 4 5] a=1 4 5 octave:##&gt; b=[2,1,0] b=2 1 0 octave:##&gt; c=[4;7;10] c=4 7 10 在方括号中由空格或者逗号隔开的一组数据被定义为行向量; 而由分号或者回车隔开的一组数据被定义为列向量。你可以通过已经定义的向量来定义新的向量,例如 octave:##&gt; a=[1 4 5] a=1 4 5 octave:##&gt; d=[a 6] d=1 4 5 6 4.2 冒号表达式利用冒号能够非常方便的创建一些特殊的向量 octave:##&gt; e=2:6 e=2 3 4 5 6 冒号表达式的规则是告诉octave创建一个以第一个数字开始并以一递增至第二个数的向量。在第一和第 二个数之间可以插入第三个参数来声明向量中元素之间的递增量,形如 a : b : c。 4.3 向量构造函数zeros(M,N) 创建一个MXN的全零矩阵 ones(M,N) 创建一个MXN的全一矩阵 linspace(x1,x2,N) 创建一个N个元素的向量，均匀分布于x1和下x2 eye(M) 创建一个MXM的单位矩阵 rand(M,N) 创建一个MXN的矩阵，元素为随机值 4.4 向量中的元素操作向量中的元素通过括号(),而第一个元素的编号为1, 而不是像C或者 C++那样从0开始。例如 octave:##&gt;a=[1:2:6 -1 0] a= 1 3 5 -1 0 我们可以通过以下命令访问到该向量的第三个元素 octave:##&gt; a(3) ans=5 冒号的表示法同样可以用于声明向量中的元素的范围 octave:##&gt;a(3:5) ans=5 -1 0 octave:##&gt;a(1:2:5) ans= 1 5 0 4.5 向量的计算将一组数据存入一个向量之后能够使用很多的Octave函数来进行计算。在C++中如果你想进行相同的计算,例如每个元素乘以2, 你需要使用for循环来对每个元素操作。在Octave中虽然也可以使用for循环来实现,但是Octave本身由有简单的向量操作方式。 向量中每个都乘以一个数可以通过对该向量乘以一个数来实现。以之前定义的 a 向量为例: octave:1&gt; a=[1:2:6 -1 0] a= 1 3 5 -1 0 octave:2&gt; a*2 ans=2 6 10 -2 0 对向量中所有元素都除以一个数的操作与乘法类似。使用+−算符,你同样可以对该向量中的每个元素都加上或者减去一个数值。两个向量的相乘遵循矩阵的乘法法则,向量乘法并不是对应元素的相乘。如果要进行对应元素的乘除法,你可以使用.* 以及./ 算符注意每个算符前的‘.’表示为一个元素对元素的计算。例如: octave:3&gt; b=1:5 b= 1 2 3 4 5 octave:4&gt; a.*b ans=1 6 15 -4 0 逐个元素的乘方计算同样也很有用。该计算的算符为,例如 octave:5&gt; b.^2 ans =1 4 9 16 25 octave:6&gt; 2.^b ans =2 4 8 16 32 octave:7&gt; a.^b ans = 1 9 125 1 0 只要两个向量又相同的大小和形状,它们就可以进行元素之间的(element-by-element) 加减乘除和乘方运算。 4.6 函数操作向量前面讲到过的函数也是可以适用于向量。 例如：exp, log,abs等 octave:##&gt;abs([-1 2 -3]) ans=1 2 3 此外max, length,size, sum, mean, std, floor, ceil等函数也许要掌握，可以通过help命令获得详细用法。 4.7 矩阵的转置一个向量的转置将其由行向量转为列向量或者由列向量转换为行向量。矩阵的转置将其行和列交换。在数学上,矩阵A的转置表示为AT 在octave中转置操作用上引号实现: octave:6&gt; A=[5 7 9;-1 3 -2] A= 5 7 9 -1 3 - 2 octave:7&gt; A’ ans =5 -1 7 3 9 -2 此外inv求矩阵的逆，det求矩阵的特征值，trace求矩阵的迹。 五 画图Octave通过调用另一个开源软件 GNUPLOT来实现非常丰富的画图功能。最基本的画图命令是 plot(x,y), 其中 x,y 分别为横轴和纵轴数据。可以进行相应地颜色和样式的选择如:’ro’代表们红色圆圈，’b.’代表蓝色点点等；可以通过title，xlabel，ylabel添加标题以及x,y轴名称；legend命令为该图片添加相应的图例。 5.1保存当前的图片内容并将新创建的图片层叠到原图片上如果你想保存当前的图片内容并将新创建的图片层叠到原图片上,你可以通过使用 hold on命令来实现。使用该命令,我们可以实现在同一幅图上呈现由两个plot 命令绘制的线条。 octave:##&gt; x=linspace(-10,10); octave:##&gt; plot(x,sin(x),’r-’); octave:##&gt; hold on octave:##&gt; plot(x,sin(x)./x,’b*’) octave:##&gt;title(‘Figure’) octave:##&gt;xlabel(‘X’) octave:##&gt;ylabel(‘Y’) octave:##&gt;legend(‘sin(x)’,’sin(x)/x’) 5.2 subplot(2,3,2)表示在一个格子中画图subplot(2,3,2)表示在一个格子中画图。因此该条语句的意思是分成一个2X3的格子，并在第2个格子里画图；其中子格的顺序为从左到右从上到下递增，即 1 2 3 4 5 6 例如： octave:##&gt; x=linspace(-10,10); octave:##&gt; subplot(2,1,1) octave:##&gt; plot(x,sin(x)); octave:##&gt; subplot(2,1,2) octave:##&gt; plot(x,sin(x)./x) 5.3 多幅图片可以用figure命令来实现.5.4 绘制曲面octave:##&gt; x=2:0.2:4; octave:##&gt;y=1:0.2:3; octave:##&gt;[X,Y]=meshgrid(x,y);% make the grid octave:##&gt; Z=(X-3).^2-(Y-2).^2; octave:##&gt; subplot(2,2,1);surf(Z);title(‘surf’) octave:##&gt; subplot(2,2,2);mesh(Z);title(‘mesh’) octave:##&gt; subplot(2,2,3);meshz(Z);title(‘meshz’) octave:##&gt; subplot(2,2,4);contour(Z);title(‘contour’) 六 Octave脚本如果你有一些重复输入的命令的,你可以将这一系列的命令存入一个Octave 脚本之中。这种包含 Octave 命令的文本文件是 Octave 程序的基本形式。当你在 Octave 中执行这样的脚本的时候,其效果与将这些命令一行行输入 Octave 中的效果是一样的。而且当你对一系列要输入 Octave 的命令不是很拿的准的时候,在一个脚本中修改这些命令会比在 Octave 终端中重新调出及修改命令要简单方便许多。 Octave的脚本是普通的文本文件,但是他们需要有一个.m 的后缀 (e.g.run.m)。因此,它们通常也被称为M文件。除去后缀的文件名部分是你在执行该命令时需要向 Octave 终端输入的部分。 你可以在任何的文本编辑器 (如,emacs, vi,notepad) 中创建并编辑一个脚本文件。在Octave中可以通过以下命令 octave:##&gt; edit 在新窗口中调出文本编辑器emacs。如果你想编辑一个已存在的脚本,你可以在edit命令后加上脚本的名字。例如,比如你有个名为 run.m的脚本,输入edit run 将调出编辑器并打开该文件供你编辑。 然后在 Octave中输入 run执行脚本: octave:##&gt; run Octave将运行该脚本中的命令并得到相应的结果。 七 控制语句到目前为止我们所看到的程序或者表达式都是一些简单的顺序执行的操作。向量和矩阵的使用能够让Octave执行更加高级的计算,但是要实现更加复杂的功能,我们还需要一些标准的程序语言。Octave提供了通常的循环和选择语句。其语法类似于我们熟知的C,C++,Java等编程语言。 在这里仅仅举一个例子： octave:##&gt; x=1; octave:##&gt; while 1+x&gt;1 x=x/2; end octave:##&gt;x x= 1.1102e-16 八 Octave函数Octave中的脚本能实现一些简单的程序,但是比脚本更加强大的是用户自定义函数。自定义函数能够让你在命令行、其他函数中和脚本中调用。 在Octave函数中参数是通过值传递的而不是通过reference传递并能返回多个返回值。Octave函数如同脚本一样,是写入一个纯文本文件中的,不同的是函数文件的第一行遵循如下的格式 function[output1,output2,…]=name(input1,input2,…) 每个函数都卸载了不同的M文件中,而且该M文件名不须与函数名一致。例如名为sind()的函数必需被定义在名为sind.m的M文件中。每个函数接受一定的参数输入并输出一定的数值。 当你需要重复性的执行一定表达式,这表明你需要将这与的操作封装为一个函数。封装为函数之后 Octave 将更加易用,增加了代码的可读性并可以供他人使用。 我们可以创建这么一个函数,创建一个名为 sind.m 的 文本文件并包含以下内容: function s=sind(x) % SIND(x)Calculates sine(x) in degrees s=sin(x*pi/180); end 然后就可以使用该函数了，例如： octave:##&gt; sind(0) ans=0 octave:##&gt; sind(45) ans= 0.7071 octave:##&gt; t=sind([30 60 90]) t= 0.50000.8660 1.0000 参考资料：Octave入门基础 Octave简单使用1. 四则运算: 1 + 2 1 * 2 1 / 2 1 - 2 2. 变量 a = 1 a = 1; % 不显示赋值结果 clear a % 删除a这个变量 3. 注释: %4. 相等 / 不等 : 1 == 2 %结果是0,表示为假 1 ~= 2 %结果为15. 逻辑 / 位运算: 1 || 0 % 1 1 &amp;&amp; 0 % 0 xor(1, 0) % 1, 异或6. 打印变量: a disp(a) disp(sprintf(‘pi is %.2f’, pi))7. 矩阵: A = [1,2;3,4;5,6] % 3*2矩阵 A = ones(2,3) % 2*3矩阵,元素均为1. A = 3ones(2,3) % 23矩阵,元素均为3. A = rand(3,3) %3*3矩阵,元素随机.均值为0.5,幅度在0~1间. A = randn(3,3) % 3*3, 元素均值为0方差为1,服从高斯分布. A = eye(5) %5阶单位矩阵.8. 向量: v = [1,2,3] %行向量 v = [1;2;3] %列向量 v = 1:0.1:1 %从1开始,步长为0.1,直到1.得到一个行向量 v = 1:6 % 1 2 3 4 5 6 得到这个行向量9. 直方图: hist(1+2*randn(2,10)) hist(1+2*randn(2,10), 20) %第二个参数指定条数.10. 帮助命令: help ‘命令’ help eye help rand11. size: size(A) %返回3 2, A是3*2的矩阵 size(A,1) % 3, A的行数 lenght(v) % 3, v是3维向量 lenght(A) % 3, A最大的维度是312. pwd cd ls 与Linux功能相同 load xx.dat 可以加载文件 who / whos 可以显示当前工作空间的所有变量 save A testSave.mat % A存储在testSave文件中13. 矩阵操作 索引: A(1,2) A(1,:) 第一行 “:”表示所有元素 A([1 3],:) 第一行和第三行所有元素 A = [A, [1;2;3]] % A右侧添加一列 A(:) A所有元素放到一个向量中 C = [A B] 行连接 C = [A;B] 列连接14. 矩阵计算 A*B A.*B % .表示对每个元素操作 A.^2 % 每个元素取平方 1./A % A每个元素取倒数 log(A) % 对数 exp(A) % e的幂次 abs(A) % 绝对值 -A % 等价-1*A A’ % A的转置 [val, indx] = max(v) % 向量v中最大值与索引. max(A) % A为矩阵,将对A中每一列求最大值 v &lt; 2 % 每个元素与2相比,小于2为真返回1,否则为0.得到相同向量/矩阵. [r,c] = find(v &lt; 2) % 返回小于2的元素的索引. sum(A) % 所有元素和 sum(A, 1) sum(A, 2) % 每列/行的元素和 prod(A) % 所有元素乘积 floor(A) / cell(A) % 向下 向上取整 max(A,B) % 每个元素比较,取大值 max(A,[],1) % 对每列取最大值 max(A,[],2) % 每行取最大值 max(A) % 默认是对每列取最大值 flipud(eye(3)) % 矩阵上下翻转 pinv(A) % A求逆矩阵15. 画图：plot plot（x,y） % x向量为x轴取值，y向量为y轴取值 hold on % 多个图间hold on，可以将后续图叠加画到前一幅图中 xlable(‘’) ylable(‘’) % x y轴名称 title(‘’) % 图的标题 legend(‘line1’,’line2’) % 标记图中每条线的名称 print -dpng ‘name.png’ % 保存成png图片 close % 关闭图像 figure(1) figue(2) % 给图像编号，可以同时显示多个图像 subplot(m,n,i) % 图像划分为m*n个格子，当前使用第i个作图。 axis([-1 1 2 3]) % 调整轴坐标范围 x轴-1到1，y轴2到316. 条件控制 for, if, else v = [1:5]; for i = v, if i &gt;= 4, break; elseif i == 2, continue end disp(i) end; while i=1 while i&lt;=5, disp(i) i = i+1; end 17. 函数定义 新建文件 testFunction.m 内容： function [x,y] = testFunction(a,b) x = a * b; y = a + b; 调用：a = testFunction(2,3) 参考资料:机器学习入门笔记(三)—-Octave简单使用]]></content>
      <categories>
        <category>编程语言</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Octave</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程知识]]></title>
    <url>%2F2017%2F05%2F26%2F%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[编程知识0. 编程小技巧编写代码的时候，在一个函数里面尽量不要有副作用。否则，以后很难追踪到副总用是从在哪儿写的。 设计模式就是将变化的与不变的进行分离。 Matlab中下标是从1开始的。 1. URI和URL的区别第一篇 https://www.cnblogs.com/gaojing/archive/2012/02/04/2413626.html这两天在写代码的时候，由于涉及到资源的位置，因此，需要在Java Bean中定义一些字段，用来表示资源的位置，比如：imgUrl，logoUri等等。但是，每次定义的时候，心里都很纠结，是该用imgUrl还是imgUri呢？ 同样的，另外一个问题：String HttpServletRequest.getRequestURI()；和StringBuffer HttpServletRequest.getRequestURL();返回的内容有何不同？为什么会如此？ 带着这些问题到网上去搜了下，没发现让自己看了明白的解释，于是，想到了Java类库里有两个对应的类java.net.URI和java.net.URL，终于，在这两个类里的javadoc里找到了答案。 URIs, URLs, and URNs 首先，URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。而URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。而URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，schema必须被指定。 ok，现在回答文章开头提出的问题，到底是imgUrl好呢，还是imgUri好？显然，如果说imgUri是肯定没问题的，因为即使它实际上是url，那它也是uri的一种。那么用imgUrl有没有问题呢？此时则要看它的可能取值，如果是绝对路径，能够定位的，那么用imgUrl是没问题的，而如果是相对路径，那还是不要用ImgUrl的好。总之，用imgUri是肯定没问题的，而用imgUrl则要视实际情况而定。 第二个，从HttpServletRequest的javadoc中可以看出，getRequestURI返回一个String，“the part of this request’s URL from the protocol name up to the query string in the first line of the HTTP request”，比如“POST /some/path.html?a=b HTTP/1.1”，则返回的值为”/some/path.html”。现在可以明白为什么是getRequestURI而不是getRequestURL了，因为此处返回的是相对的路径。而getRequestURL返回一个StringBuffer，“The returned URL contains a protocol, server name, port number, and server path, but it does not include query string parameters.”，完整的请求资源路径，不包括querystring。 总结一下：URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，所以，是绝对的，而通常说的relative URL，则是针对另一个absolute URL，本质上还是绝对的。 注：这里的绝对(absolute)是指包含scheme，而相对(relative)则不包含scheme。 URI抽象结构 [scheme:]scheme-specific-part[#fragment] [scheme:][//authority][path][?query][#fragment] authority为[user-info@]host[:port] 参考资料： http://docs.oracle.com/javase/1.5.0/docs/api/java/net/URI.html http://en.wikipedia.org/wiki/Uniform_Resource_Identifier http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletRequest.html ps: java.net.URL类不提供对标准RFC2396规定的特殊字符的转义，因此需要调用者自己对URL各组成部分进行encode。而java.net.URI则会提供转义功能。因此The recommended way to manage the encoding and decoding of URLs is to use java.net.URI. 可以使用URI.toURL()和URL.toURI()方法来对两个类型的对象互相转换。对于HTML FORM的url encode/decode可以使用java.net.URLEncoder和java.net.URLDecoder来完成，但是对URL对象不适用。 第二篇 https://www.cnblogs.com/hust-ghtao/p/4724885.html译者：华科小涛：http://www.cnblogs.com/hust-ghtao/：太棒了 初学http协议，就被这两个相似的术语搞蒙了，查了很多资料，总算搞清楚了。（找资料还是英文啊，靠谱。。。）。 本篇博客翻译自：https://danielmiessler.com/study/url_vs_uri/，是在是一片简单实用的好文，对帮我们弄清概念很有帮助： 译文： 一直存在很多技术上的争论，其中最为妙的恐怕就是web地址应该叫什么的问题。通常情况就是这样：有人把地址栏的内容叫“URL”，这时候有些人就来劲了：“不！其实那时URI。。。” 对于这种纠正的反应呢，通常也有这么几种情况，心眼小的就寻思这人赶紧走吧，淡定点的就耸耸肩表示同意，火气大的就拔刀相向了好不？ 那这篇文章呢，就对这个只是提供一个简单的总结，毕竟互黑也要黑到点子上是吧。 URI，URL，URN 从上面的那幅图可以看出来，一共有三个不同的概念URI,URL,URN。这讨论这样的问题时，最好的方法就是回到原点啊，这里我们在RFC 3986: Uniform Resource Identifier (URI): Generic Syntax里面收集了点资料： “A Uniform Resource Identifier (URI) 是一个紧凑的字符串用来标示抽象或物理资源。” “A URI 可以进一步被分为定位符、名字或两者都是. 术语“Uniform Resource Locator” (URL) 是URI的子集, 除了确定一个资源,还提供一种定位该资源的主要访问机制(如其网络“位置”)。“ 那我们无所不知的维基百科把这段消化的很好，并描述的更加形象了： “URI可以分为URL,URN或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。” 通过这些描述我们可以得到一些结论： 首先，URL是URI的一种（通过那个图就看的出来吧）。所以有人跟你说URL不是URI，他就错了呗。但也不是所有的URI都是URL哦，就好像蝴蝶都会飞，但会飞的可不都是蝴蝶啊，你让苍蝇怎么想！让URI能成为URL的当然就是那个“访问机制”，“网络位置”。e.g. http:// or ftp://.。URN是唯一标识的一部分，就是一个特殊的名字。 下面就来看看例子吧，当来也是来自权威的RFC： ftp://ftp.is.co.za/rfc/rfc1808.txt (also a URL because of the protocol)http://www.ietf.org/rfc/rfc2396.txt (also a URL because of the protocol)ldap://[2001:db8::7]/c=GB?objectClass?one (also a URL because of the protocol)mailto:John.Doe@example.com (also a URL because of the protocol)news:comp.infosystems.www.servers.unix (also a URL because of the protocol)tel:+1-816-555-1212telnet://192.0.2.16:80/ (also a URL because of the protocol)urn:oasis:names:specification:docbook:dtd:xml:4.1.2 这些全都是URI, 其中有些事URL. 哪些? 就是那些提供了访问机制的. 总结 下面到了回答问题的时候了： 当我们替代web地址的时候，URI和URL那个更准确？ 基于我读的很多的文章，包括RFC，我想说URI更准确。 别急，我有我的理由： 我们经常使用的URI不是严格技术意义上的URL。例如：你需要的文件在files.hp.com. 这是URI，但不是URL–系统可能会对很多协议和端口都做出正 确的反应。 你去http://files.hp.com 和ftp://files.hp.com.可能得到完全不同的内容。这种情况可能更加普遍，想想不同谷歌域名上的不同服务啊。 所以，用URI吧，这样你通常技术上是正确的，URL可不一定。最后“URL”这个术语正在被弃用。所以明智吧少年！ 结语 If you don’t mind being “that guy”, URI is probably the more accurate term to use. But if you are in the linguist / “use what’s understood” camp, feel free to go with URL. 参考： https://en.wikipedia.org/wiki/Uniform_Resource_Identifier https://danielmiessler.com/study/url_vs_uri/]]></content>
      <categories>
        <category>编程知识</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>编程小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmware虚拟机使用]]></title>
    <url>%2F2017%2F04%2F28%2Fvmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[vmware虚拟机使用1. 在vmware 14下客户机黑屏。原因：虚拟机内界面的显示其实是通过“内部网络传输”的方式实现的，因此，无法显示虚拟机的界面，很有可能是网络方面的组件出现了问题。我们排查如下： 以管理员身份运行命令提示符（cmd.exe），输入命令 netsh winsock show catalog可以看到VMware注册了两个LSP：vSockets DGRAM、vSockets STREAM，路径是%windir%\system32\vsocklib.dll 观察有没有其他模块也注册了vSockets DGRAM、vSockets STREAM，如果有，就卸载掉这个模块所属的软件。 （可选）在命令提示符输入netsh winsock reset，并重启计算机 （可选）重装VMware Workstation 14 安装了迅游加速器，它注册了vSockets DGRAM，与VMware产生了冲突，卸载迅游加速器后VMware不再黑屏 解决方法：在管理员命令行下，输入 netsh winsock reset ，就可以解决黑屏问题了。 保险一点的话，再重启一下电脑。 2. putty无法连接VMware中的linux​ 这个可能是由于linux没有安装ssh server服务。 ​ 执行安装命令： ​ sudo apt-get install openssh-server ​ 如果没安装过ssh，那么就会安装，如果提示已经安装过了，那就接着执行： ​ ps -e |grep ssh 如果只有ssh-agent那ssh-server还没有启动，需要/etc/init.d/ssh start，如果看到sshd那说明ssh-server已经启动了。]]></content>
      <categories>
        <category>操作系统</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vmware</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown使用笔记]]></title>
    <url>%2F2017%2F04%2F26%2FMarkDown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MarkDown使用笔记1. 为MarkDown文件添加目录将下面这些代码复制到,option-&gt;advanced -&gt; html head edit中然后，需要生成带目录的html文件时，export-&gt; html，保存在i5ting-i5ting_ztree_toc-d9e57d4（绝对路径：G:\桌面文件和文件夹\学习\知识积累_md文件\ztree_toc）文件夹中就行了。 如果不想生成目录，那么就直接使用浏览器浏览就行了，不用export -&gt; html。 &lt;script type=&quot;text/javascript&quot; src=&quot;./js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/jquery.ztree.core-3.5.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./src/ztree_toc.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/zTreeStyle/zTreeStyle.css&quot; type=&quot;text/css&quot;&gt; &lt;style&gt; .ztree li a.curSelectedNode { padding-top: 0px; background-color: #FFE6B0; color: black; height: 16px; border: 1px #FFB951 solid; opacity: 0.8; } .ztree{ overflow: auto; height:100%; min-height: 200px; top: 0px; } &lt;/style&gt; &lt;style&gt; #td1 , #td2 { border: 0px solid #ccc; padding: 6px 13px; } #tr1 { border-top: 0px solid #ccc; background-color: #fff; } &lt;/style&gt; &lt;SCRIPT type=&quot;text/javascript&quot; &gt; $(document).ready(function(){ //1. 将body里面的内容取出来 $(&quot;body&quot;).hide(); var old_context = $(&quot;body&quot;).html(); //2. 将body里面的内容删除掉 $(&quot;body&quot;).html(&quot;&quot;); //3. 向body里面添加table $(&quot;body&quot;).prepend(&quot;&lt;TABLE id=&apos;table1&apos; border=0 height=600px align=left&gt;&lt;/TABLE&gt;&quot;); $(&quot;table&quot;).append(&quot;&lt;TR id=&apos;tr1&apos;&gt;&lt;/TR&gt;&quot;); $(&quot;tr&quot;).append(&quot;&lt;TD id=&apos;td1&apos;&gt;&lt;/TD&gt;&quot;); $(&quot;#td1&quot;).append(&quot;&lt;ul id=&apos;tree&apos; class=&apos;ztree&apos;&gt;&lt;/ul&gt;&quot;); $(&quot;tr&quot;).append(&quot;&lt;TD id=&apos;td2&apos; align=left valign=top &gt;&lt;/TD&gt;&quot;); //4. 将原来body里面的内容插入到table里面 $(&quot;#td2&quot;).append(&quot;&quot;+old_context); //$(&quot;#td1&quot;).hide(); $(&apos;#tree&apos;).ztree_toc({ is_auto_number : false , is_expand_all : false }); //$(&quot;#tree_2_switch&quot;).removeClass(); $(&quot;#tree_2_ul&quot;).css(&quot;display&quot;,&quot;none&quot;); //$(&quot;#td1&quot;).show(); //$(&quot;#catalogue&quot;).attr(&quot;color&quot;,&quot;#000000&quot;); $(&quot;#tree&quot;).css(&quot;width&quot;,&quot;300px&quot;);//设置目录那一栏的宽度 $(&quot;body&quot;).show(); }); &lt;/SCRIPT&gt; 效果图： 2. HTML怎么设置字与字之间的间距代替空格空格： &amp;nbsp CSS:letter-spacing字与字&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; word-spacing词与词 行距:line-height:1.5; 段落: &lt;p style=&quot;margin-top:30px;text-indent:2em;&quot;&gt;文字&lt;/p&gt; 字与字之间： &lt;span style=&quot;margin-right:20px;&quot;&gt;文字1&lt;/span&gt;文字2 文字与单词间距，样式加这个：letter-spacing:20PX (这是字符与字符，对中 英 适用) 单词与单词间距，样式加这个：word-spacing :20PX (这是单词与单词)； 3. MarkDown中打印空格半角空格(英文) &amp;nbsp; 全角空格(中文) &amp;emsp; 4. 在markdown中进行注释可以使用下面这种方式： a [^_^]: b c d 显示的 a c d 应当间隔一样长。如下： a c d 其实markdown是兼容html的，所以也可以使用html的注释来进行markdown的注释。]]></content>
      <categories>
        <category>写作技能</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
        <tag>标记性语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F03%2F23%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 80%; } } 正则表达式表达式全集 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\`n”之外的任何单个字符。要匹配包括“`n”在内的任何字符，请使用像“(. &#124;\n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“( &#124; )”来组合一个模式的各个部分是很有用。例如“industr(?:y &#124;ies)”就是一个比“industry &#124; industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95 &#124; 98 &#124; NT &#124; 2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95 &#124; 98 &#124; NT &#124; 2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95 &#124; 98 &#124; NT &#124; 2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95 &#124; 98 &#124; NT &#124; 2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x &#124; y 匹配x或y。例如，“z &#124; food”能匹配“z”或“food”。“(z &#124; f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。. \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}&#124;[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})\$/ /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/ URL /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/ IP 地址 /((2[0-4]\d&#124;25[0-5]&#124;[01]?\d\d?)\.){3}(2[0-4]\d&#124;25[0-5]&#124;[01]?\d\d?)//^(?:(?:25[0-5]&#124;2[0-4][0-9]&#124;[01]?[0-9][0-9]?)\.){3}(?:25[0-5]&#124;2[0-4][0-9]&#124;[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;&#124;\s+\/&gt;)$/ 删除代码\注释 (?&lt;!http:&#124;\S)//.*$ Unicode编码中的汉字范围 /^[\u2E80-\u9FFF]+$/ 参考资料：正则表达式]]></content>
      <categories>
        <category>编程基础知识</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
