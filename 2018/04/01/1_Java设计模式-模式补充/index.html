<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="设计模式," />





  <link rel="alternate" href="/atom.xml" title="ZhongZhenGang's Notes" type="application/atom+xml" />






<meta name="description" content="设计模式补充-23种设计模式设计模式补充​    这一个知识总结是对前面设计模式总结没有介绍的设计模式进行一个补充介绍。主要参考第四章模式系统里面的归纳，补充的设计模式主要来自于GOF的《设计模式》。 设计模式概括设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式补充-23种设计模式">
<meta property="og:url" content="http://yoursite.com/2018/04/01/1_Java设计模式-模式补充/index.html">
<meta property="og:site_name" content="ZhongZhenGang&#39;s Notes">
<meta property="og:description" content="设计模式补充-23种设计模式设计模式补充​    这一个知识总结是对前面设计模式总结没有介绍的设计模式进行一个补充介绍。主要参考第四章模式系统里面的归纳，补充的设计模式主要来自于GOF的《设计模式》。 设计模式概括设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/单一职责原则-示例图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/开放封闭原则-示例图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/里氏替换原则-示例图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/接口隔离原则-示例图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/依赖倒置原则-示例.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/Interpreter模式UML结构图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/简单工厂模式结构图.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/工厂方法模式UML类图.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/产品结构示意图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/抽象工厂结构.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/抽象工厂模式起源图1.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/抽象工厂模式-产品等级.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/抽象工厂模式的解决方案.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/建造者模式结构图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/建造者模式时序图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/原型模式结构图.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/浅克隆与深克隆.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/文件系统目录层级结构.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/组合模式结构图.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/适配器模式实际例子-1.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/适配器模式实际例子-2.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/适配器模式的类图.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/对象适配器类图.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/装饰者模式的装饰链.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/装饰者模式结构.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/装饰者模式-咖啡例子.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/装饰者模式-咖啡例子-运行结果图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/代理模式结构.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/门面模式-病人到医院看病.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/门面模式-医院接待员.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/门面模式-结构示意图1.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/门面模式-结构示意图2.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/桥接模式-UML类图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/单纯享元模式-uml类图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/复合享元模式-uml类图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/策略模式结构.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/策略模式-实际例子.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/模板方法模式结构图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/观察者模式结构图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/迭代子模式-白箱聚集结构.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/白箱聚集与外禀迭代子-示意图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/黑箱聚集与内禀迭代子-结构示意图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/内禀迭代子-实现代码结构图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/责任链模式-结构示意图.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/责任链模式实例1.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/责任链模式实例1-类图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/命令模式结构.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/备忘录模式结构.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/白箱-备忘录模式.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/黑箱-备忘录模式.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/多重检查点-备忘录模式.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/自述历史-备忘录模式.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/状态模式结构.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/状态模式-电梯实例-类图1.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/状态模式-电梯示例-类图2.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/状态模式-以状态作为导向的类图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/状态模式-状态过度固定-示意图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/状态模式-状态过度不固定-示意图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/访问者模式结构示意图.png">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/中介者模式-问题背景1.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/中介者模式-问题背景2.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/中介者模式-问题背景3.jpg">
<meta property="og:image" content="http://yoursite.com/image/java设计模式/中介者模式的结构.png">
<meta property="og:updated_time" content="2018-07-03T12:25:59.907Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式补充-23种设计模式">
<meta name="twitter:description" content="设计模式补充-23种设计模式设计模式补充​    这一个知识总结是对前面设计模式总结没有介绍的设计模式进行一个补充介绍。主要参考第四章模式系统里面的归纳，补充的设计模式主要来自于GOF的《设计模式》。 设计模式概括设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式">
<meta name="twitter:image" content="http://yoursite.com/image/java设计模式/单一职责原则-示例图.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/01/1_Java设计模式-模式补充/"/>





  <title>设计模式补充-23种设计模式 | ZhongZhenGang's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhongZhenGang's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/1_Java设计模式-模式补充/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhongzhengang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhg_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhongZhenGang's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式补充-23种设计模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T17:02:13+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java高级知识/" itemprop="url" rel="index">
                    <span itemprop="name">Java高级知识</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java高级知识/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="设计模式补充-23种设计模式"><a href="#设计模式补充-23种设计模式" class="headerlink" title="设计模式补充-23种设计模式"></a>设计模式补充-23种设计模式</h1><h2 id="设计模式补充"><a href="#设计模式补充" class="headerlink" title="设计模式补充"></a>设计模式补充</h2><p>​    这一个知识总结是对前面设计模式总结没有介绍的设计模式进行一个补充介绍。主要参考第四章模式系统里面的归纳，补充的设计模式主要来自于GOF的《设计模式》。</p>
<h2 id="设计模式概括"><a href="#设计模式概括" class="headerlink" title="设计模式概括"></a>设计模式概括</h2><p>设计模式分为三大类：</p>
<p><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>其实还有两类：并发型模式和线程池模式。</p>
<h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><p>​    那么,什么是设计模式呢?</p>
<p>​    从广义角度讲设计模式是可解决一类软件问题并能重复使用的设计方案;</p>
<p>​    从狭义角度讲设计模式是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述,是在类和对象的层次描述的可重复使用的软件设计问题的解决方案.</p>
<p>​    模式体现的是程序整体的构思,也会出现在分析或者是概要设计阶段,包括创建型模式、结构型模式和行为型模式.</p>
<p>​    ==模式的核心思想是通过增加抽象层,把变化部分从那些不变部分里分离出来.==</p>
<p>​    模式的四大基本要素包括：</p>
<p>​    1.<strong>模式名称（Pattern Name）</strong></p>
<p>​    2.<strong>问题（Problem）</strong>：描述应该在何时使用模式,解释了设计问题和问题存在的前因后果,可能还描述模式必须满足的先决条件</p>
<p>​    3.<strong>解决方案（Solution）</strong>：描述了设计的组成成分、相互关系及各自的职责和协作方式.模式就像一个模板,可应用于多种场合,所以解决方案并不描述一个具体的设计或实现,而是提供设计问题的抽象描述和解决问题所采用的元素组合（类和对象）.</p>
<p>​    4.<strong>效果（Consequences）</strong>：描述模式的应用效果及使用模式应权衡的问题.</p>
<h2 id="设计模式的SOLID原则"><a href="#设计模式的SOLID原则" class="headerlink" title="设计模式的SOLID原则"></a>设计模式的SOLID原则</h2><pre><code> **S.O.L.I.D **是面向对象设计(OOD)和面向对象编程(OOP)中的几个重要编码原则(Programming Priciple)的首字母缩写。
前辈们总结出来的，遵循五大原则可以使程序解决紧耦合，更加健壮。
</code></pre><p>​                                面向对象设计的原则<br>| 简称 | 全称 | 解释 |<br>| —- | ———————————– | ———— |<br>| SRP  | The Single Responsibility Principle | 单一职责原则 |<br>| OCP  | The Open Closed Principle           | 开放封闭原则 |<br>| LSP  | The Liskov Substitution Principle   | 里氏替换原则 |<br>| ISP  | The Interface Segregation Principle | 接口分离原则 |<br>| DIP  | The Dependency Inversion Principle  | 依赖倒置原则 |</p>
<p><strong>一、单一职责原则（SRP）</strong></p>
<p><strong>定义：</strong>不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 </p>
<p><strong>问题由来：</strong>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 </p>
<p><strong>解决方案：</strong>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p>
<p>遵循单一职责原的优点有： </p>
<ol>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； </li>
<li>提高类的可读性，提高系统的可维护性； </li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ol>
<p>​    需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。</p>
<p><strong>实际例子</strong></p>
<p>​    如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能抑制或者削弱这个类完成其他职责的能力。例如餐厅服务员负责把订单给厨师去做，而不是服务员又要订单又要炒菜。</p>
<p><img src="\image\java设计模式\单一职责原则-示例图.png" alt="单一职责原则-示例图"></p>
<p><strong>二、开闭原则（OCP）</strong></p>
<p><strong>定义：</strong>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 </p>
<p><strong>问题由来：</strong>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。 </p>
<p><strong>解决方案：</strong>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p><strong>实际例子</strong></p>
<p>​    对扩展开放，对修改关闭。意为一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。例如一开始做了普通计算器程序，突然添加新需求，要再做一个程序员计算器，这时不应该修改普通计算器内部，应该使用面向接口编程，组合实现扩展。</p>
<p><img src="\image\java设计模式\开放封闭原则-示例图.png" alt="开放封闭原则-示例图"></p>
<p><strong>三、里氏替换原则（LSP）</strong></p>
<p><strong>定义：</strong>所有引用基类的地方必须能透明地使用其子类的对象。 </p>
<p><strong>问题由来：</strong>有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p><strong>解决方案：</strong>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p>
<p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： </p>
<ol>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 </li>
<li>子类中可以增加自己特有的方法。 </li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 </li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ol>
<p><strong>实际例子</strong></p>
<p>​    所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。例如机动车必须有轮胎和发动机，子类宝马和奔驰不应该改写没轮胎或者没发动机。</p>
<p><img src="\image\java设计模式\里氏替换原则-示例图.png" alt="里氏替换原则-示例图"></p>
<p><strong>四、接口隔离原则（ISP）</strong></p>
<p><strong>定义：</strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 </p>
<p><strong>问题由来：</strong>类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 </p>
<p><strong>解决方案：</strong>将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
<p>​    很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p>
<p>​    采用接口隔离原则对接口进行约束时，要注意以下几点： </p>
<ol>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 </li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 </li>
<li><p>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>
<pre><code>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。
</code></pre></li>
</ol>
<p><strong>实际例子</strong></p>
<p>​    类不应该依赖不需要的接口，知道越少越好。例如电话接口只约束接电话和挂电话，不需要让依赖者知道还有通讯录。</p>
<p><img src="\image\java设计模式\接口隔离原则-示例图.png" alt="接口隔离原则-示例图"></p>
<p><strong>五、依赖倒置原则（DIP）</strong></p>
<p><strong>定义：</strong>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 </p>
<p><strong>问题由来：</strong>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 </p>
<p><strong>解决方案：</strong>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<p>​    传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p>
<p>​    在实际编程中，我们一般需要做到如下3点：<br>​    1. 低层模块尽量都要有抽象类或接口，或者两者都有。<br>​    2. 变量的声明类型尽量是抽象类或接口。<br>​    3. 使用继承时遵循里氏替换原则。</p>
<p>​    依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p>
<p><strong>实际例子</strong></p>
<p>​    指的是高级模块不应该依赖低级模块，而是依赖抽象。抽象不能依赖细节，细节要依赖抽象。比如类A内有类B对象，称为类A依赖类B，但是不应该这样做，而是选择类A去依赖抽象。例如垃圾收集器不管垃圾是什么类型，要是垃圾就行。</p>
<p><img src="\image\java设计模式\依赖倒置原则-示例.png" alt="依赖倒置原则-示例"></p>
<p><strong>附、迪米特法则（最少知道原则）（Demeter Principle）</strong></p>
<p><strong>定义：</strong>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<p><strong>问题由来：</strong>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 </p>
<p><strong>解决方案：</strong>尽量降低类与类之间的耦合。</p>
<p><strong>总结</strong></p>
<p>​    单一职责原则告诉我们实现类要职责单一；</p>
<p>​    里氏替换原则告诉我们不要破坏继承体系；</p>
<p>​    依赖倒置原则告诉我们要面向接口编程；</p>
<p>​    接口隔离原则告诉我们在设计接口的时候要精简单一；</p>
<p>​    开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p>
<p>​    迪米特法则告诉我们要降低耦合。</p>
<p>参考资料：<a href="http://blog.csdn.net/Eastmount/article/details/41575053" target="_blank" rel="noopener">设计模式之SOLID原则再回首</a></p>
<p>​           <a href="http://blog.csdn.net/cj1029/article/details/49865913" target="_blank" rel="noopener">设计模式原则SOLID</a></p>
<p>​           <a href="http://blog.csdn.net/YegodYue/article/details/66887047" target="_blank" rel="noopener">设计模式之SOLID原则</a></p>
<h2 id="Interpreter-解释器-模式"><a href="#Interpreter-解释器-模式" class="headerlink" title="Interpreter(解释器)模式"></a>Interpreter(解释器)模式</h2><p><strong>实际的例子</strong></p>
<p>​    在执行加减乘除四则运算，或者执行正则表达式的时候，都是将表示的文本内容进行解释，然后再进行执行的。</p>
<p><strong>定义</strong></p>
<p>​    Interpreter(解释器)模式是一种特殊的设计模式，它建立一个解释器（Interpreter），对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。解释器模式属于行为模式，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<p><strong>组成结构</strong></p>
<p>​    Interpreter 模式UML结构图如图1所示：</p>
<p><img src="\image\java设计模式\Interpreter模式UML结构图.png" alt="Interpreter模式UML结构图"></p>
<p>​    一个解释器模式中包含的<strong>四种角色</strong></p>
<ul>
<li><p>抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器和非终结符解释器完成。</p>
</li>
<li><p>终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</p>
<p>自己的理解：终结符就是不可以再拆分、单一的符号，也就是语言的<strong>基本元素</strong>。</p>
</li>
<li><p>非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</p>
<p>自己的理解：非终结符，就是具有逻辑功能的、并不是表示数值的符号，实际上非终结符定义的是<strong>语言的规则</strong>。</p>
</li>
<li><p>环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。</p>
<p>​</p>
</li>
</ul>
<p><strong>例子</strong></p>
<p>​    我们需要一个能够解释加法和减法的解释器，那么最好的方式就是用解释器模式来实现。</p>
<p>​    先来看看抽象表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以环境为准，本方法解释给定的任何一个表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验两个表达式在结构上是否相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回表达式的hash code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将表达式转换成字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    因为需要解释加法和减法，因此实现类也有Plus和Minus两个非终结符表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression left,right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plus</span><span class="params">(Expression left , Expression right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Plus)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> left.equals(((Plus)obj).left) &amp;&amp;</span><br><span class="line">                right.equals(((Plus)obj).right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left.interpret(ctx) + right.interpret(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + left.toString() + <span class="string">" + "</span> + right.toString() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Expression left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Minus</span><span class="params">(Expression left, Expression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Minus) &#123;</span><br><span class="line">            <span class="keyword">return</span> left.equals(((Minus) obj).left) &amp;&amp; right.equals(((Minus) obj).right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> left.interpret(ctx) - right.interpret(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + left.toString() + <span class="string">" - "</span> + right.toString() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    除此之外我们还需要变量与常量两个终结符表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> <span class="keyword">extends</span> <span class="title">Expression</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Constant</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Constant)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value == ((Constant)obj).value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(value).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> <span class="keyword">extends</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Variable</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Variable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(</span><br><span class="line">                    ((Variable)obj).name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.lookup(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    环境角色基本可以存放文法中各个终结符所对应的具体值，下面的类就是用一个map来负责<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Variable,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Variable,Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Variable var , <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        map.put(var, <span class="keyword">new</span> Integer(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lookup</span><span class="params">(Variable var)</span> <span class="keyword">throws</span> IllegalArgumentException</span>&#123;</span><br><span class="line">        Integer value = map.get(var);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    Client客户端的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> Context();</span><br><span class="line">        Variable x = <span class="keyword">new</span> Variable(<span class="string">"x"</span>);</span><br><span class="line">        Variable y = <span class="keyword">new</span> Variable(<span class="string">"y"</span>);</span><br><span class="line">        Constant c = <span class="keyword">new</span> Constant(<span class="number">1</span>);</span><br><span class="line">        ctx.assign(x, <span class="number">2</span>);</span><br><span class="line">        ctx.assign(y, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        Expression exp = <span class="keyword">new</span> Plus(<span class="keyword">new</span> Plus(c,x) , <span class="keyword">new</span> Minus(y,x));</span><br><span class="line">        System.out.println(exp.toString() + <span class="string">"="</span> + exp.interpret(ctx));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    输出结果如下</p>
<p><code>((1 + x) + (y - x))=4</code></p>
<p><strong>优缺点</strong></p>
<p>​    解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了。比如我们现在需要修改Plus的含义，那么只需要修改Plus类即可，如果要增加乘法操作，那么也只需要增加一个Multiple类就行。<br>​    但是，解释器模式会引起类的膨胀，每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来非常多的麻烦。同时，从例子我们也可以看到，整个表达式的运算过程采用了递归调用方法，每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。由于使用了大量的循环和递归，效率是一个不容忽视的问题。特别是用于解释一个解析复杂、冗长的语法时，效率是难以忍受的。</p>
<p><strong>Interpreter 模式适用性：</strong></p>
<p>(1).可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</p>
<p>(2). 一些重复出现的问题可以用一种简单的语言来进行表达。</p>
<p>(3).一个语言的文法较为简单。</p>
<p>(4).执行效率不是关键问题。（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。）</p>
<p><strong>Interpreter 模式使用总结：</strong></p>
<p>​        尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。</p>
<p><strong>总结</strong></p>
<p>​    解释器模式，将语言的表示与执行进行了分离。语言的表示会不停的变化，语言的执行也是会发生变化的。不变的是，语言的表示一定要的解释才能够执行。在解释器模式中要注意终结符和非终结符的区分。</p>
<p>参考资料：<a href="https://www.jianshu.com/p/c138a1d2be5e" target="_blank" rel="noopener">解释器模式</a></p>
<p>​           <a href="http://blog.csdn.net/fanyun_01/article/details/51862242" target="_blank" rel="noopener">Interpreter 模式详解–设计模式</a></p>
<h2 id="简单工厂模式（Simple-Factory）"><a href="#简单工厂模式（Simple-Factory）" class="headerlink" title="简单工厂模式（Simple Factory）"></a>简单工厂模式（Simple Factory）</h2><p><strong>定义</strong></p>
<p>​    简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式（同属于创建型模式的还有工厂方法模式，抽象工厂模式，单例模式，建造者模式）。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p><strong>模式结构</strong></p>
<p><img src="\image\java设计模式\简单工厂模式结构图.jpg" alt="简单工厂模式结构图"></p>
<p>​    从上图可以看出，简单工厂模式由三部分组成：具体工厂、具体产品和抽象产品。</p>
<ul>
<li>工厂类（Creator）角色：担任这个角色的是简单工厂模式的核心，含有与应用紧密相关的商业逻辑。工厂类在客户端的直接调用下创建产品对象，它往往由一个具体Java类实现。</li>
<li>抽象产品（AbstractProduct）角色：担任这个角色的类是由简单工厂模式所创建的对象的父类，或它们共同拥有的接口。抽象产品角色可以用一个Java接口或者Java抽象类实现。</li>
<li><p>具体产品（ConcreteProduct）角色：简单工厂模式所创建的任何对象都是这个角色的实例，具体产品角色由一个具体Java类实现。</p>
<p>产品类：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMW</span><span class="params">()</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW320</span> <span class="keyword">extends</span> <span class="title">BMW</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMW320</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;BMW320"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW523</span> <span class="keyword">extends</span> <span class="title">BMW</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BMW523</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;BMW523"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    工厂类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BMW <span class="title">createBMW</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">case</span> <span class="number">320</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BMW320();  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">523</span>:  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BMW523();  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">default</span>:  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    客户类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        BMW bmw320 = Factory.createBMW(<span class="number">320</span>);  </span><br><span class="line">        BMW bmw523 = Factory.createBMW(<span class="number">523</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>解决的问题</strong></p>
<p>​    将对象的使用与创建进行分离。例如，想要一辆奔驰车时，只需要向造车工厂传入奔驰车的型号，然后工厂就可以造出来一辆符合要求的奔驰车了，而不用去关注对象创建过程中的细节。</p>
<p><strong>简单工厂的优点/缺点：</strong></p>
<p>​    优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。<br>​    缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则。</p>
<p><strong>适用场景</strong></p>
<p>在以下情况下可以使用简单工厂模式：</p>
<p>1、工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p>
<p>2、客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p>
<p><strong>总结：</strong></p>
<p>​    客户端要求的具体产品会不断的变化，可能这一次需要车型A，下一次就需要车型B了，而且在工厂中建造不同车型的方法也不一样。但是，一辆车如果需要使用，那么一定要被建造。简单工厂模式就是固定了产品会被工厂创建的这种关系，同时将产品的消费和生产进行了分离。</p>
<p>参考资料:  <a href="http://blog.csdn.net/xingjiarong/article/details/49999121" target="_blank" rel="noopener">设计模式（一）简单工厂模式</a></p>
<p>​           <a href="http://blog.csdn.net/jason0539/article/details/23020989" target="_blank" rel="noopener">JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式)</a></p>
<h2 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h2><p><strong>定义</strong></p>
<p>​    工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类来规定创建对象的公共接口，而子类则负责生成具体的对象。</p>
<p><strong>解决的问题</strong></p>
<p>​    上文介绍的简单工厂模式存在一系列问题：</p>
<ul>
<li>工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；</li>
<li>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。</li>
<li>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<p>为了解决上述的问题，我们又使用了一种新的设计模式：工厂方法模式。</p>
<p><strong>模式原理</strong></p>
<p>​    UML类图</p>
<p><img src="\image\java设计模式\工厂方法模式UML类图.jpg" alt="工厂方法模式UML类图"></p>
<p>​    模式的组成</p>
<table>
<thead>
<tr>
<th>组成（角色）</th>
<th>关系</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象产品（Product）</td>
<td>具体产品的父类</td>
<td>描述具体产品的公共接口</td>
</tr>
<tr>
<td>具体产品（Concrete Product）</td>
<td>抽象产品的子类；工厂类创建的目标类</td>
<td>描述生产的具体产品</td>
</tr>
<tr>
<td>抽象工厂（Creator）</td>
<td>具体工厂的父类</td>
<td>描述具体工厂的公共接口</td>
</tr>
<tr>
<td>具体工厂（Concrete Creator）</td>
<td>抽象工厂的子类；被外界调用</td>
<td>描述具体工厂；实现FactoryMethod工厂方法创建产品的实例</td>
</tr>
</tbody>
</table>
<p>使用步骤</p>
<p>步骤1： 创建抽象工厂类，定义具体工厂的公共接口；<br>步骤2： 创建抽象产品类 ，定义具体产品的公共接口；<br>步骤3： 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品；<br>步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；<br>步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例</p>
<p><strong>实际例子</strong></p>
<p><em>实例概况</em></p>
<p>背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；<br>冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；<br>解决方案：小成决定置办塑料分厂B来生产B类产品； </p>
<blockquote>
<p>即工厂方法模式</p>
</blockquote>
<p><em>使用步骤</em></p>
<p>步骤1： 创建抽象工厂类，定义具体工厂的公共接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">Manufacture</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>步骤2： 创建抽象产品类 ，定义具体产品的公共接口；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体产品A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductA</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProductB</span> <span class="keyword">extends</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂A类 - 生产A类产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">Manufacture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂B类 - 生产B类产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">Manufacture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产工作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//客户要产品A</span></span><br><span class="line">        FactoryA mFactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        mFactoryA.Manufacture().Show();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//客户要产品B</span></span><br><span class="line">        FactoryB mFactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        mFactoryB.Manufacture().Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生产出了产品A</span><br><span class="line">生产出了产品C</span><br></pre></td></tr></table></figure></p>
<p><strong>优点</strong></p>
<ul>
<li><p>更符合开-闭原则<br>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可</p>
<blockquote>
<p>简单工厂模式需要修改工厂类的判断逻辑</p>
</blockquote>
</li>
<li><p>符合单一职责原则<br>每个具体工厂类只负责创建对应的产品</p>
<blockquote>
<p>简单工厂中的工厂类存在复杂的switch逻辑判断</p>
</blockquote>
</li>
<li><p>不使用静态工厂方法，可以形成基于继承的等级结构。</p>
<blockquote>
<p>简单工厂模式的工厂类使用静态工厂方法</p>
</blockquote>
</li>
</ul>
<p>总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p>
<p><strong>缺点</strong></p>
<ul>
<li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
<li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li>
<li>一个具体工厂只能创建一种具体产品</li>
</ul>
<p><strong>应用场景</strong></p>
<p>在了解了优缺点后，我总结了工厂方法模式的应用场景：</p>
<ul>
<li>当一个类不知道它所需要的对象的类时<br>在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；</li>
<li>当一个类希望通过其子类来指定创建对象时<br>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<p><strong>答疑解惑</strong></p>
<p>使用工厂方法模式，看上去会感觉到这不是更麻烦了吗，直接在外界创建具体的抽象子类不行吗？还用这么麻烦的创建工厂子类，然后再用工厂子类去创建抽象子类。</p>
<p><strong>我将从两方面回答这个问题：</strong></p>
<ol>
<li>假设现在项目比较大，在外界很多地方都直接使用了抽象子类直接进行运算，这种方式在写代码的时候确实很快也很爽。但是，假设有一天，产品经理过来说要改需求，我现在不要加减乘除这四种运算了，我要换成更高级的其他运算。。。如果这样改起来改动就大了，需要把所有直接使用抽象子类实例化的地方都做修改。</li>
<li>这只是一种设计模式的思路，在程序的开发中没有一种设计模式是万能的，在适合的地方用适合的设计模式，或根据业务需求自己制定一套模式，这才是最好的。只有最适合业务的模式，才是最好的模式。</li>
</ol>
<p><strong>总结</strong></p>
<p>​    工厂方法模式是对简单工厂模式的改进，使得模式对修改关闭，对扩展开放。在工厂方法模式中，变化的是：随着具体产品的不同，那么对应的具体工厂也就不同。不变的是：产品与工厂的关系没有发生改变，产品还是要从工厂生产。这个模式依然可以使得对象的使用与创建分离。不过，相对于简单工厂模式，工厂方法模式更加往上抽象了一层。</p>
<p>参考资料: <a href="http://blog.csdn.net/jason0539/article/details/23020989" target="_blank" rel="noopener">JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式)</a></p>
<p>​         <a href="http://blog.csdn.net/carson_ho/article/details/52343584" target="_blank" rel="noopener">工厂方法模式（Factory Method）-最易懂的设计模式解析</a></p>
<p>​        <a href="https://www.jianshu.com/p/03519d5e47b6" target="_blank" rel="noopener">工厂模式三部曲－工厂方法模式</a></p>
<h2 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h2><p><strong>例子背景</strong></p>
<p>​    着客户的要求越来越高，宝马车需要不同配置的空调和发动机等配件。于是这个工厂开始生产空调和发动机，用来组装汽车。这时候工厂有两个系列的产品:空调和发动机。宝马320系列配置A型号空调和A型号发动机，宝马230系列配置B型号空调和B型号发动机。 </p>
<p><strong>问题 </strong></p>
<p>​     抽象工厂模式是工厂方法模式的升级版本，他用来创建==一组相关或者相互依赖的对象==。比如宝马320系列使用空调型号A和发动机型号A，而宝马230系列使用空调型号B和发动机型号B，那么使用抽象工厂模式，在为320系列生产相关配件时，就无需制定配件的型号，它会自动根据车型生产对应的配件型号A。</p>
<p><strong>抽象工厂（Abstract Factory）模式结构</strong></p>
<pre><code>抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品具体类型的情况下，创建多个产品族中的产品对象。这就是抽象工厂模式的用意。
</code></pre><p>​        每个模式都是针对一定问题的解决方案。抽象工厂模式面对的问题是多产品等级结构的系统设计。<br>​        在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。<br>​        产品族：是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的CPU和ADM芯片的主板，组成一个家族。Intel的CPU和Intel芯片的主板，又组成一个家族。而这两个家族都来自于两个产品等级：CPU，主板。一个等级结构是由相同的结构的产品组成，示意图如下：</p>
<p><img src="\image\java设计模式\产品结构示意图.png" alt="产品结构示意图"></p>
<pre><code>理解这个产品结构是理解抽象工厂模式的关键所在，所以我不惜花费时间来画此图。如果领悟不到此图的含义，就无法区分工厂方法模式和抽象工厂模式的区别。
</code></pre><p>​        从上图可以看出，抽象工厂模式的每个工厂创造出来的都是一族产品，而不是一个或者一组。组是可以随意组合的！其实两个就这点点差别，呵呵，估计现在你已经差不多明白了抽象工厂模式的含义。</p>
<p>​    抽象工厂模式中各个组件之间的结构如下图所示：</p>
<p>​         <img src="\image\java设计模式\抽象工厂结构.png" alt="抽象工厂结构"></p>
<p><strong>抽象工厂模式代码</strong></p>
<p>​    产品类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发动机以及型号  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineA</span> <span class="keyword">extends</span> <span class="title">Engine</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineA</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;EngineA"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineBextends</span> <span class="title">Engine</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineB</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;EngineB"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//空调以及型号  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aircondition</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirconditionA</span> <span class="keyword">extends</span> <span class="title">Aircondition</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirconditionA</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;AirconditionA"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirconditionB</span> <span class="keyword">extends</span> <span class="title">Aircondition</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirconditionB</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"制造--&gt;AirconditionB"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    创建工厂类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂的接口  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//制造发动机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//制造空调 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span></span>; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为宝马320系列生产配件  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBMW320</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EngineA();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirconditionA();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//宝马523系列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBMW523</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EngineB();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Aircondition <span class="title">createAircondition</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AirconditionB();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    客户:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//生产宝马320系列配件</span></span><br><span class="line">        FactoryBMW320 factoryBMW320 = <span class="keyword">new</span> FactoryBMW320();  </span><br><span class="line">        factoryBMW320.createEngine();</span><br><span class="line">        factoryBMW320.createAircondition();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//生产宝马523系列配件  </span></span><br><span class="line">        FactoryBMW523 factoryBMW523 = <span class="keyword">new</span> FactoryBMW523();  </span><br><span class="line">        factoryBMW320.createEngine();</span><br><span class="line">        factoryBMW320.createAircondition();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>抽象工厂模式的起源</strong></p>
<p>​    下面引用一段<a href="http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" target="_blank" rel="noopener">抽象工厂模式</a>的起源：</p>
<p>​    抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。</p>
<p>​    在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。</p>
<p><img src="\image\java设计模式\抽象工厂模式起源图1.png" alt="抽象工厂模式起源图1"></p>
<p>​    可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。</p>
<p><img src="\image\java设计模式\抽象工厂模式-产品等级.png" alt="抽象工厂模式-产品等级"></p>
<p>​    系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图：</p>
<p><img src="\image\java设计模式\抽象工厂模式的解决方案.png" alt="抽象工厂模式的解决方案"></p>
<p>​    显然，一个系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行。所以，系统实际上只能消费属于同一个产品族的产品。</p>
<p>​    在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了。</p>
<p><strong>总结</strong></p>
<p>​    抽象工厂模式，使得一个工厂可以创建一组相关或联系的对象，功能更加的强大。如果采用工厂方法模式，创建一组相关或联系的对象，会产生很多的工厂对象。说白了，抽象工厂模式也是一个工厂模式。</p>
<p>​    无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p>
<p>​       所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。</p>
<p>参考资料： <a href="http://blog.csdn.net/jason0539/article/details/44976775" target="_blank" rel="noopener">JAVA设计模式之抽象工厂模式</a></p>
<p>​            <a href="http://blog.51cto.com/lavasoft/11674" target="_blank" rel="noopener">Java设计模式圣经连载（03）－抽象工厂模式</a>    </p>
<p>​          《设计模式》</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>问题</strong></p>
<p>​    许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在计算机中只有一个打印机，那么管理打印机的程序就应该只有一个，否则会出现多个文件被同时打印的情况。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<p><strong>概念</strong></p>
<p>​    单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p>
<p>​    j单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。<br>　　单例模式有以下特点：<br>　　1、单例类只能有一个实例。<br>　　2、单例类必须自己创建自己的唯一实例。<br>　　3、单例类必须给所有其他对象提供这一实例。<br>　　单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p>
<p><strong>基本的实现思路</strong></p>
<p>​    单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。</p>
<p>​    单例的实现主要是通过以下两个步骤：</p>
<ol>
<li>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</li>
<li>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li>
</ol>
<p><strong>注意事项</strong></p>
<p>​    单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建    方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>
<p><strong>一、懒汉式单例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123;  </span><br><span class="line">             single = <span class="keyword">new</span> Singleton();</span><br><span class="line">         &#125;  </span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。</p>
<p>​    事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。</p>
<p>​    但是以上懒汉式单例的实现没有考虑线程安全问题，<strong>它是线程不安全</strong>的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全。</p>
<p>1、在getInstance方法上加同步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (single == <span class="keyword">null</span>) &#123;  </span><br><span class="line">             single = <span class="keyword">new</span> Singleton();</span><br><span class="line">         &#125;  </span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、双重检查锁定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton single=<span class="keyword">null</span>;<span class="comment">//注意有volatile关键字</span></span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                  singleton = <span class="keyword">new</span> Singleton(); </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    注意，使用双重检查锁定这种方式的时候，为了达到真正的线程安全，还需要在声明私有变量<em>singleton</em> 使用关键字volatile。然synchronized已经起到了多线程下原子性、有序性、可见性的作用，为什么还要加volatile呢，原因可参考<a href="http://www.iteye.com/topic/652440和http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html。" target="_blank" rel="noopener">http://www.iteye.com/topic/652440和http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html。</a></p>
<p>3、静态内部类(==zhg: 使用这种==)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> LazyHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这种比上面1、2都好一些，既实现了线程安全，又避免了同步带来的性能影响。    </p>
<p><strong>二、饿汉式单例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例类.在类初始化时，已经自行实例化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 single = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。</p>
<p>​    优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
<p>​    缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<p><strong>三、登记式单例(可忽略)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似Spring里面的方法，将类名注册，下次从里面直接获取。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Singleton3&gt; map = <span class="keyword">new</span> HashMap&lt;String,Singleton3&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Singleton3 single = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        map.put(single.getClass().getName(), single);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保护的默认构造子</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态工厂方法,返还此类惟一的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = Singleton3.class.getName();</span><br><span class="line">            System.out.println(<span class="string">"name == null"</span>+<span class="string">"---&gt;name="</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map.get(name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                map.put(name, (Singleton3) Class.forName(name).newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一个示意性的商业方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">about</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, I am RegSingleton."</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton3 single3 = Singleton3.getInstance(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(single3.about());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。 
</code></pre><p>​    这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。</p>
<p><strong>四、枚举方式单例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。</p>
<p><strong>饿汉式和懒汉式区别</strong></p>
<p>​    从名字上来说，饿汉和懒汉，</p>
<p>​    饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。</p>
<p>​    另外从以下两点再区分以下这两种方式：</p>
<p>​    1、线程安全：</p>
<p>​    饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，</p>
<p>​    懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。</p>
<p>​    2、资源加载和性能：</p>
<p>​    饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，</p>
<p>​    而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。</p>
<p>​    至于1、2、3这三种实现又有些区别，</p>
<p>​    第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的，</p>
<p>​    第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗</p>
<p>​    第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。</p>
<p><strong>什么是线程安全？</strong></p>
<p>​    如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>​    或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。</p>
<p><strong>总结</strong></p>
<p>​    由结果可以得知单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。</p>
<p>对于单例模式的几种实现方式，知道饿汉式和懒汉式的区别，线程安全，资源加载的时机，还有懒汉式为了实现线程安全的3种方式的细微差别。</p>
<p>参考资料：<a href="http://blog.csdn.net/jason0539/article/details/23297037" target="_blank" rel="noopener">JAVA设计模式之单例模式</a></p>
<p>​           <a href="http://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">单例模式的八种写法比较</a></p>
<h2 id="建造者-builder-模式"><a href="#建造者-builder-模式" class="headerlink" title="建造者(builder)模式"></a>建造者(builder)模式</h2><p><strong>定义</strong></p>
<p>​    在阎宏博士的《JAVA与模式》一书中开头是这样描述建造（Builder）模式的：</p>
<p>　　建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p>
<p>​    产品的内部表象：</p>
<p>​    一个产品常有不同的组成成分作为产品的零件，这些零件有可能是对象，也有可能不是对象，它们通常又叫做产品的内部表象（internal representation）。不同的产品可以有不同的内部表象，也就是不同的零件。使用建造模式可以使客户端不需要知道所生成的产品有哪些零件，每个产品的对应零件彼此有何不同，是怎么建造出来的，以及怎么组成产品。</p>
<p><strong>实际的例子</strong></p>
<p>​    有些情况下，一个对象会有一些重要的性质，在它们没有恰当的值之前，对象不能作为一个完整的产品使用。比如，一个电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，而在最起码的收件人地址得到赋值之前，这个电子邮件不能发送。</p>
<p>​    在进入肯德基点一个套餐时，每一个套餐的基本东西都是鸡翅、汉堡、可乐等，只不过不同的套餐中这些东西的组成不同，分量也不同。我们不用知道他们的具体组成方式，只用了解套餐就可以了。</p>
<p><strong>建造模式的结构</strong></p>
<p><img src="\image\java设计模式\建造者模式结构图.png" alt="建造者模式结构图"></p>
<p>​    在这个示意性的系统中，最终的产品Product只有两个部件，即part1和part2。相应的建造方法也有两个：buildPart1()和buildPart2()。同时可以看到该模式涉及到四个角色，它们分别是：</p>
<ul>
<li><p>Builder：抽象Builder类，规范产品的组建，一般是由子类实现。</p>
</li>
<li><p>ConcreteBulider: 抽象Builder类的实现类，实现抽象Builder类定义的所有方法，并且返回一个组建好的对象</p>
</li>
<li><p>Dirextor: 指挥者类，用于统一组装流程</p>
</li>
<li><p>Product: 产品类</p>
</li>
</ul>
<p>​    建造模式利用一个导演者对象和具体建造者对象一个个地建造出所有的零件，从而建造出完整的产品对象。建造者模式将产品的结构和产品的零件的建造过程对客户端隐藏起来。</p>
<p><strong>源代码</strong></p>
<p>产品类Product<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 定义一些关于产品的操作</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">private</span>  String part1;</span><br><span class="line">    <span class="keyword">private</span>  String part2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> part1;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart1</span><span class="params">(String part1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part1 = part1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> part2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart2</span><span class="params">(String part2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.part2 = part2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象建造者类Builder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">retrieveResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 具体建造者类ConcreteBuilder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品零件建造方法1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建产品的第一个零件</span></span><br><span class="line"> 　　　　product.setPart1(<span class="string">"编号：9527"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品零件建造方法2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建产品的第二个零件</span></span><br><span class="line"> 　　　　product.setPart2(<span class="string">"名称：XXX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品返还方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">retrieveResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>导演者类Director<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有当前需要使用的建造器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入建造器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder 建造器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品构造方法，负责调用各个零件建造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildPart1();</span><br><span class="line">        builder.buildPart2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端类Client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line">        Product product = builder.retrieveResult();</span><br><span class="line">        System.out.println(product.getPart1());</span><br><span class="line">        System.out.println(product.getPart2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>时序图</strong></p>
<p><img src="\image\java设计模式\建造者模式时序图.png" alt="建造者模式时序图"></p>
<p>​    客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。</p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<ul>
<li><p>使用建造者模式可以使客户端不必知道产品内部组成的细节。</p>
</li>
<li><p>具体的建造者类之间是相互独立的，容易扩展。</p>
</li>
<li><p>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p>
</li>
</ul>
<p>​    缺点：</p>
<ul>
<li>产生多余的Build对象以及Dirextor类。</li>
</ul>
<p><strong>总结</strong></p>
<p>​    在一个复杂对象的创建过程中，复杂对象的每一个部分可能会经常性的变化，但是将复杂对象各个部分组装到一起的算法比较稳定，这个时候就可以将具体每个部分的建造放在较低层次，组装流程放在较高层次。使得具体部分的建造改变不会影响整个复杂对象的创建。</p>
<p>​    建造模式在将复杂对象的装配过程封装在Dirctor中，并且客户端不用关注复杂对象建造的具体细节。</p>
<p>参考资料： <a href="http://blog.csdn.net/itachi85/article/details/50644745" target="_blank" rel="noopener">设计模式（三）建造者模式</a></p>
<p>​             <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html" target="_blank" rel="noopener">《JAVA与模式》之建造模式</a></p>
<h2 id="原型-Prototype-模式"><a href="#原型-Prototype-模式" class="headerlink" title="原型(Prototype)模式"></a>原型(Prototype)模式</h2><p><strong>定义</strong></p>
<p>​    原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。所谓原型模式，就是java中的克隆技术，以某个对象为原型。复制出新的对象。显然新的对象具备原型对象的特点。效率高（避免了重新执行构造过程步骤）</p>
<p>​    克隆类似于new，但和new不同。new创建新的对象属性采用的是默认值。克隆出来的对象的属性值完全和原型对象相同。并且克隆出的新对象不会影响原型对象，克隆后。还可以再修改克隆对象的值。</p>
<p>​    要实现原型模式，必须实现Cloneable接口，而这个接口里面是空的。</p>
<p>​    Cloneable接口是一个空接口，使用Cloneable接口都不用导入包。而clone方法是属于Object对象的。如果要克隆某个对象的话必须实现Cloneable接口。</p>
<p><strong>结构</strong></p>
<p><img src="\image\java设计模式\原型模式结构图.jpg" alt="原型模式结构图"></p>
<p>​    原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：</p>
<ul>
<li>实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</li>
<li>重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。</li>
</ul>
<p>​    原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现。经常与其他模式混用，它的原型类Prototype也常用抽象类来替代。</p>
<p><strong>原型模式的注意事项</strong></p>
<ul>
<li>使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。</li>
<li>深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（8种基本数据类型byte,char,short,int,long,float,double，boolean），对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。</li>
</ul>
<p>​    如果我们要克隆某个对象有<strong>浅克隆和深克隆</strong></p>
<p>​    浅克隆：<strong>copy该对象，然后保留该对象原有的引用。也就是说不克隆该对象的属性。</strong></p>
<p>​    深克隆：<strong>copy该对象，并且把该对象的所有属性也克隆出一份新的。</strong></p>
<p><img src="\image\java设计模式\浅克隆与深克隆.jpg" alt="浅克隆与深克隆"></p>
<p><strong>实现代码：</strong></p>
<p>​    用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</p>
<p>1、浅克隆代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 原型模式:浅克隆</span></span><br><span class="line"><span class="comment"> * Cloneable是一个空接口（标记接口），是一个规范。但是如果要克隆这个类对象的话必须实现Cloneable接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写Object对象的clone方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用Object对象的clone方法</span></span><br><span class="line">        Object obj = <span class="keyword">super</span>.clone();<span class="comment">//这个super.clone()会将当前对象的属性进行拷贝，不过是浅拷贝。</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略get，set方法和构造方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试原型模式（浅克隆）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1274397294739L</span>);</span><br><span class="line">        Sheep s1 = <span class="keyword">new</span> Sheep(<span class="string">"原型羊"</span>,date);</span><br><span class="line">        Sheep s2 = (Sheep) s1.clone();<span class="comment">//克隆一个羊</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s1.getSname());</span><br><span class="line">        System.out.println(<span class="string">"原日期："</span>+s1.getBirthday());</span><br><span class="line">        date.setTime(<span class="number">34732834827389L</span>);<span class="comment">//改变原有date的值</span></span><br><span class="line">        System.out.println(<span class="string">"改变后的日期："</span>+date.toString());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//克隆羊的信息</span></span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s2.getSname());</span><br><span class="line">        System.out.println(s2.getBirthday());<span class="comment">//此时的birthday日期使用的是改变后的日期对象引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的结果为：克隆的对象仍然保留了原有对象的引用，值随着改变而改变<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.fz.prototype.Sheep@<span class="number">153f</span>67e</span><br><span class="line">原型羊</span><br><span class="line">原日期：Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br><span class="line"></span><br><span class="line">改变后的日期：Mon Aug <span class="number">22</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">27</span> CST <span class="number">3070</span></span><br><span class="line">---------------------------------</span><br><span class="line">com.fz.prototype.Sheep@<span class="number">18f</span>51f</span><br><span class="line">原型羊</span><br><span class="line">Mon Aug <span class="number">22</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">27</span> CST <span class="number">3070</span></span><br></pre></td></tr></table></figure></p>
<p>2、深克隆代码实现：克隆对象的同时，把该对象的属性也连带着克隆出新的。</p>
<p>深克隆只需要在clone方法中将该对象的属性也克隆即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 重写Object对象的clone方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">//直接调用Object对象的clone方法</span></span><br><span class="line">    Object obj = <span class="keyword">super</span>.clone();</span><br><span class="line">    <span class="comment">//深克隆：把对象下的所有属性也克隆出来</span></span><br><span class="line">    Sheep22 s = (Sheep22) obj;</span><br><span class="line">    s.birthday = (Date) <span class="keyword">this</span>.birthday.clone();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试代码不变，结果则会变了。克隆了之后把原来的日期改变后，克隆的对象2的属性则不会被影响。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">com.fz.prototype.Sheep2@<span class="number">15</span>bdc50</span><br><span class="line">原型羊</span><br><span class="line">原日期：Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br><span class="line"></span><br><span class="line">改变后的日期：Mon Aug <span class="number">22</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">27</span> CST <span class="number">3070</span></span><br><span class="line">---------------------------------</span><br><span class="line">com.fz.prototype.Sheep2@<span class="number">18f</span>51f</span><br><span class="line">原型羊</span><br><span class="line">Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br></pre></td></tr></table></figure></p>
<p>3、通过序列化和反序列化来实现深克隆对象：序列化需要原型对象实现Serializable接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试原型模式（利用序列化和反序列化实现深克隆）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1274397294739L</span>);</span><br><span class="line">        Sheep s1 = <span class="keyword">new</span> Sheep(<span class="string">"原型羊"</span>,date);</span><br><span class="line">        <span class="comment">//      Sheep s2 = (Sheep) s1.clone();//克隆一个羊</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用序列化和反序列化实现深复制</span></span><br><span class="line">        <span class="comment">//1、将s1对象序列化为一个数组</span></span><br><span class="line">        <span class="comment">//通过ObjectOutputStream流将s1对象读出来给ByteArrayOutputStream流</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream    oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(s1);</span><br><span class="line">        <span class="comment">//ByteArrayOutputStream流将对象信息转成byte数组，这样byte数组里就包含了对象的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、将字节数组中的内容反序列化为一个Sheep对象</span></span><br><span class="line">        <span class="comment">//通过ByteArrayInputStream流读入bytes字节数组中数据，然后传给ObjectInputStream对象输入流</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream    ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="comment">//通过ObjectInputStream返回一个Sheep对象</span></span><br><span class="line">        Sheep s2 = (Sheep) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原型羊的信息</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(<span class="string">"原日期："</span>+s1.getBirthday());</span><br><span class="line">        date.setTime(<span class="number">34732834827389L</span>);<span class="comment">//改变原有date的值</span></span><br><span class="line">        System.out.println(<span class="string">"改变后的日期："</span>+date.toString());</span><br><span class="line">        <span class="comment">//克隆羊的信息</span></span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s2.getBirthday());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过序列化和反序列化的结果，最终结果还是和深克隆一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">com.fz.prototype.Sheep@<span class="number">1</span>a116c9</span><br><span class="line"></span><br><span class="line">原日期：Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br><span class="line"></span><br><span class="line">改变后的日期：Mon Aug <span class="number">22</span> <span class="number">17</span>:<span class="number">40</span>:<span class="number">27</span> CST <span class="number">3070</span></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">com.fz.prototype.Sheep@<span class="number">7</span>eb6e2</span><br><span class="line"></span><br><span class="line">Fri May <span class="number">21</span> <span class="number">07</span>:<span class="number">14</span>:<span class="number">54</span> CST <span class="number">2010</span></span><br></pre></td></tr></table></figure></p>
<p><strong>测试克隆对象的效率</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fz.prototype;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 测试clone对象的效率</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testNew</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Laptop l = <span class="keyword">new</span> Laptop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"new 对象耗时："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//clone 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testClone</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Laptop l = <span class="keyword">new</span> Laptop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Laptop temp = (Laptop) l.clone();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"clone 对象耗时："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testNew(<span class="number">1000</span>);</span><br><span class="line">        testClone(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟创建Laptop对象的时候比较耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后结果为：</p>
<p>new 对象耗时：10063</p>
<p>clone 对象耗时：10</p>
<p><strong>总结</strong></p>
<p>​    原型模式解决的问题是，复杂的对象需要多次创建，如果使用new创建，则会很耗时。使用原型模式，则可以极大的提升效率，并且可以向客户端隐藏创建对象的细节。</p>
<p>​    在使用原型模式的时候，要注意实现Clonable接口，并且要注意浅克隆和深克隆的区别。并且，使用原型模式的时候，构造函数的private权限会失效，这个时候就需要注意单例模式的实现了。在实现单例模式的时候，尽量不要再使用原型模式。</p>
<p>​    原型模式适用场景：如果某个对象new的过程中很耗时，则可以考虑使用原型模式。</p>
<p>​    Spring框架中bean对象的创建就两种模式：<strong>单例模式或者原型模式</strong>。</p>
<p>参考资料： <a href="http://blog.csdn.net/jason0539/article/details/23158081" target="_blank" rel="noopener">JAVA设计模式之原型模式</a></p>
<p>​            <a href="http://www.cnblogs.com/cxxjohnson/p/6403949.html" target="_blank" rel="noopener">原型模式（Prototype）</a></p>
<h2 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h2><p><strong>实际例子</strong></p>
<p>​    对于树形结构，在代码中有容器节点和叶子节点之分，容器节点可以有子节点，而叶子节点没有，所以两者是有区分的，而在实际使用中，我们更希望一致的对待他们，因为如若区别对待，在程序上会非常复杂。组合模式则是为了解决此类问题而生的，它可以让叶子对象和容器对象的使用具有一致性。他是组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。</p>
<p>​    比较常见的例子就是，电脑中的文件系统，一级目录里面有普通的文本文件、照片文件，还有二级目录。在做某些操作时，例如查看一个文件夹中所有文件大小（包括子目录中的文件），如果能将里面的文件统一对待，那么在迭代遍历的时候就会非常的方便。</p>
<p><img src="\image\java设计模式\文件系统目录层级结构.jpg" alt="文件系统目录层级结构"></p>
<p><strong>模式定义</strong></p>
<p>​    组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。<br>​    在组合模式中引入了抽象构件类Component，它是所有容器类和叶子类的公共父类，客户端针对Component进行编程。</p>
<p><strong>模式结构</strong></p>
<p><img src="\image\java设计模式\组合模式结构图.jpg" alt="组合模式结构图"></p>
<p><strong>Component</strong> 抽象构件，叶子构件和容器构件的接口或抽象类</p>
<p><strong>Leaf</strong> 叶子构件，叶子节点没有子节点</p>
<p><strong>Composite</strong> 容器构件，容器节点可以有子节点，子节点也可以是容<br>器构件。</p>
<p><strong>适用场景</strong></p>
<p>​    在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。 </p>
<p>​    在一个使用面向对象语言开发的系统中需要处理一个树形结构。 </p>
<p><strong>实现代码</strong></p>
<p>​    抽象角色，抽象文件： 具体文件和具体文件夹都继承该抽象文件角色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">showFileName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>树枝角色：具体文件夹<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;File&gt; fileList = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFile</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.add(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印文件夹下的文件名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayFiles</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(File file : <span class="keyword">this</span>.fileList)&#123;</span><br><span class="line">            file.showFileName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>叶子角色：具体文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TXTFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TXTFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVIFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVIFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端，模拟文件/文件夹树形结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pichen.dp.structuralpattern.combination;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Folder folder = <span class="keyword">new</span> Folder(<span class="string">"一级目录"</span>);</span><br><span class="line">        File txtFile = <span class="keyword">new</span> TXTFile(<span class="string">"二级文件txt"</span>);</span><br><span class="line">        File aviFile = <span class="keyword">new</span> AVIFile(<span class="string">"二级文件avi"</span>);</span><br><span class="line">        Folder txtFolder = <span class="keyword">new</span> Folder(<span class="string">"二级txt目录"</span>);</span><br><span class="line">        Folder aviFolder = <span class="keyword">new</span> Folder(<span class="string">"二级avi目录"</span>);</span><br><span class="line">    </span><br><span class="line">        File txtFile1 = <span class="keyword">new</span> TXTFile(<span class="string">"三级文件txt1"</span>);</span><br><span class="line">        File txtFile2 = <span class="keyword">new</span> TXTFile(<span class="string">"三级文件txt2"</span>);</span><br><span class="line">        File txtFile3 = <span class="keyword">new</span> TXTFile(<span class="string">"三级文件txt3"</span>);</span><br><span class="line">        File aviFile1 = <span class="keyword">new</span> AVIFile(<span class="string">"三级文件avi1"</span>);</span><br><span class="line">        File aviFile2 = <span class="keyword">new</span> AVIFile(<span class="string">"三级文件avi2"</span>);</span><br><span class="line">        </span><br><span class="line">        folder.addFile(txtFile);</span><br><span class="line">        folder.addFile(aviFile);</span><br><span class="line">        folder.addFile(txtFolder);</span><br><span class="line">        folder.addFile(aviFolder);</span><br><span class="line">        </span><br><span class="line">        txtFolder.addFile(txtFile1);</span><br><span class="line">        txtFolder.addFile(txtFile2);</span><br><span class="line">        txtFolder.addFile(txtFile3);</span><br><span class="line">        </span><br><span class="line">        aviFolder.addFile(aviFile1);</span><br><span class="line">        aviFolder.addFile(aviFile2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"一级目录下的文件:"</span>);</span><br><span class="line">        folder.displayFiles();</span><br><span class="line">        System.out.println(<span class="string">"\n二级txt目录下的文件:"</span>);</span><br><span class="line">        txtFolder.displayFiles();</span><br><span class="line">        System.out.println(<span class="string">"\n二级avi目录目录下的文件:"</span>);</span><br><span class="line">        aviFolder.displayFiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打印结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一级目录下的文件:</span><br><span class="line">二级文件txt</span><br><span class="line">二级文件avi</span><br><span class="line">二级txt目录</span><br><span class="line">二级avi目录</span><br><span class="line"></span><br><span class="line">二级txt目录下的文件:</span><br><span class="line">三级文件txt1</span><br><span class="line">三级文件txt2</span><br><span class="line">三级文件txt3</span><br><span class="line"></span><br><span class="line">二级avi目录目录下的文件:</span><br><span class="line">三级文件avi1</span><br><span class="line">三级文件avi2</span><br></pre></td></tr></table></figure></p>
<p><strong>总结</strong></p>
<p>​    树形结构由容器节点和叶子节点组成，组合模式将容器节点和叶子节点都转化为一种节点来使用。这样一来便可以将精力更专注于树的结构，而不是节点的类型上了。</p>
<p>​    使用组合模式构建的树形结构，很容易就可以进行遍历操作，可以将叶子和容器节点同等的对待。</p>
<p>参考资料：<a href="http://www.cnblogs.com/chenpi/p/5196870.html" target="_blank" rel="noopener">【设计模式】组合模式</a></p>
<p>​          <a href="http://blog.csdn.net/u012984054/article/details/52235590" target="_blank" rel="noopener">结构型模式之——组合模式</a></p>
<h2 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h2><p><strong>概述</strong></p>
<p>​    将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p>
<p><strong>解决的问题</strong></p>
<p>​    即Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p>
<p>​          下面是两个非常形象的例子</p>
<p><img src="\image\java设计模式\适配器模式实际例子-1.jpg" alt="适配器模式实际例子-1"></p>
<p><img src="\image\java设计模式\适配器模式实际例子-2.jpg" alt="适配器模式实际例子-2"></p>
<p><strong>模式的结构</strong></p>
<p>​     （1）类的适配器模式（采用继承实现）</p>
<p>​     （2）对象适配器（采用对象组合方式实现）</p>
<p>​    适配器模式的类图</p>
<p><img src="\image\java设计模式\适配器模式的类图.jpg" alt="适配器模式的类图"></p>
<p><strong>模式中的角色</strong></p>
<p>​    目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。</p>
<p>　　需要适配的类（Adaptee）：需要适配的类或适配者类。</p>
<p>　　适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。　　</p>
<p><strong>实现代码</strong></p>
<p>​    一、类的适配器模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"被适配类具有 特殊功能..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口，或称为标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标类，只提供普通功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"普通类 具有 普通功能..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类，继承了被适配类，同时实现标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.specificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类public class Client &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用普通功能类</span></span><br><span class="line">		Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">		concreteTarget.request();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 使用特殊功能类，即适配类</span></span><br><span class="line">		Target adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">		adapter.request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通类 具有 普通功能...  </span><br><span class="line">被适配类具有 特殊功能...</span><br></pre></td></tr></table></figure></p>
<p>​    上面这种实现的适配器称为类适配器，因为 Adapter 类既继承了 Adaptee （被适配类），也实现了 Target 接口（因为 Java 不支持多继承，所以这样来实现），在 Client 类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。另外一种适配器模式是对象适配器，它不是使用多继承或继承再实现的方式，而是使用直接关联，或者称为委托的方式，类图如下：</p>
<p><img src="\image\java设计模式\对象适配器类图.jpg" alt="对象适配器类图"></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器类，直接关联被适配类，同时实现标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接关联被适配类</span></span><br><span class="line">	<span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 这里是使用委托的方式完成特殊功能</span></span><br><span class="line">		<span class="keyword">this</span>.adaptee.specificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用普通功能类</span></span><br><span class="line">		Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">		concreteTarget.request();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 使用特殊功能类，即适配类，</span></span><br><span class="line">		<span class="comment">// 需要先创建一个被适配类的对象作为参数</span></span><br><span class="line">		Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">		adapter.request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    测试结果与上面的一致。从类图中我们也知道需要修改的只不过就是 Adapter 类的内部结构，即 Adapter 自身必须先拥有一个被适配类的对象，再把具体的特殊功能<strong>委托</strong>给这个对象来实现。使用对象适配器模式，可以使得 Adapter 类（适配类）根据传入的 Adaptee 对象达到适配多个不同被适配类的功能，当然，此时我们可以为多个被适配类提取出一个接口或抽象类。这样看起来的话，似乎对象适配器模式更加灵活一点。</p>
<p><strong>一个实际的例子</strong></p>
<p>​    我们就拿日本电饭煲的例子进行说明，日本电饭煲电源接口标准是110V电压，而中国标准电压接口是220V，所以要想在中国用日本电饭煲，需要一个电源转换器。</p>
<p>​    定义日本和中国两种接口及其实现</p>
<p>​    我们先定义日本220V电源接口和实现。</p>
<p>​    110V接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日本110V电源接口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JP110VInterface</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>​    110Ｖ接口实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class JP110VInterfaceImpl implements JP110VInterface &#123;</span><br><span class="line">   public void connect() &#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;接通电源，开始工作....&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    我们再定义中国220V电源接口和实现。</p>
<p>​    220V接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CN220VInterface</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    220V接口实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CN220VInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">CN220VInterface</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"接通电源，开始工作......"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    定义一个电压适配器</p>
<p>​    要想在中国使用日本电饭煲，需要把电饭煲110v的电源接口适配成我们220V的电源接口，这就需要一个电源适配器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了能够适配定电饭煲110v电源接口，我们需要继承110v接口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdaptor</span> <span class="keyword">implements</span> <span class="title">JP110VInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CN220VInterface cn220VInterface;<span class="comment">//用220V接口进行适配</span></span><br><span class="line">    PowerAdaptor(CN220VInterface cn220VInterface)&#123;</span><br><span class="line">        <span class="keyword">this</span>.cn220VInterface=cn220VInterface;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cn220VInterface.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    适配器继承的是要适配的接口，并持有对客户的接口的引用。使用的是关联一个对象的方式。</p>
<p>​    电饭煲</p>
<p>​    下面正式开始啦，现在我们有一个日本电饭煲，用的是110v的电源接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricCooker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> JP110VInterface jp110VInterface;<span class="comment">//日本电饭煲，用的是日本110V标准电源接口</span></span><br><span class="line">   ElectricCooker(JP110VInterface jp110VInterface)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.jp110VInterface=jp110VInterface;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;</span><br><span class="line">      jp110VInterface.connect();<span class="comment">//接通电源</span></span><br><span class="line">      System.out.println(<span class="string">"开始做饭......"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    <em>电饭煲用的是110V接口</em></p>
<p>​    电饭煲配合适配器工作</p>
<p>​    测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptorTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       CN220VInterface cn220VInterface=<span class="keyword">new</span> CN220VInterfaceImpl();<span class="comment">//中国的220V电源</span></span><br><span class="line">       PowerAdaptor adaptor=<span class="keyword">new</span> PowerAdaptor(cn220VInterface);<span class="comment">//电源适配器</span></span><br><span class="line">       ElectricCooker cooker=<span class="keyword">new</span> ElectricCooker(adaptor);<span class="comment">//使用110V接口的电饭煲</span></span><br><span class="line">       cooker.cook();<span class="comment">//使用了适配器，在220V的环境下可以工作啦</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    <em>适配器继承了110V接口，就可以用于日本电饭煲；适配器又持有220V接口的引用，就可以用220V进行工作。</em></p>
<p>​    运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接通电源，开始工作......</span><br><span class="line">开始做饭......</span><br></pre></td></tr></table></figure></p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    通过适配器，可以是两个不兼容的类在一起工作。可以复用现有的类来适应原来不能提供的接口。将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。</p>
<p>​    缺点：</p>
<p>​    适配的过程比较复杂。过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
<p>​    由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类</p>
<p><strong>总结</strong></p>
<p>​    适配者模式，类似于在两个不能兼容的类之间做了一个中间者，来兼容这两个类。适配者模式分离了被适配者和目标接口变化的影响。例如，被适配者发生变化时，由于有适配器的存在，不会影响到目标接口。</p>
<p>参考资料： <a href="http://blog.csdn.net/jason0539/article/details/22468457" target="_blank" rel="noopener">JAVA设计模式初探之适配器模式</a></p>
<p>​            <a href="http://blog.csdn.net/suifeng3051/article/details/51497041" target="_blank" rel="noopener">设计模式之适配器模式(adaptor pattern)</a></p>
<h2 id="装饰者模式-Decorator-Pattern"><a href="#装饰者模式-Decorator-Pattern" class="headerlink" title="装饰者模式(Decorator Pattern)"></a>装饰者模式(Decorator Pattern)</h2><p><strong>简单介绍</strong></p>
<p>​    Decorator Pattern叫装饰模式，或装饰者模式，以前叫包装器模式（Wrapper，GoF在92-93年由Wrapper改为Decorator）。</p>
<p>​    装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<p>​    Decorator模式的工作原理是：可以创建始于Decorator对象（负责新的功能的对象）终于原对象的一个对象“链”。</p>
<p><img src="\image\java设计模式\装饰者模式的装饰链.jpg" alt="装饰者模式的装饰链"></p>
<p>​    装饰者模式隐含的是通过一条条装饰链去实现具体对象，每一条装饰链都始于一个Componet对象，每个装饰者对象后面紧跟着另一个装饰者对象，而对象链终于ConcreteComponet对象。 </p>
<p><strong>定义</strong></p>
<p>==装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供比继承更有弹性的替代方案。==</p>
<p><strong>适用性</strong></p>
<ol>
<li>需要扩展一个类的功能，或给一个类添加附加职责。</li>
<li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销。</li>
<li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</li>
</ol>
<p><strong>结构</strong></p>
<p><img src="\image\java设计模式\装饰者模式结构.png" alt="装饰者模式结构"></p>
<p>在装饰模式中的各个角色有：<br>　　（1）抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。<br>　　（2）具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。<br>　　（3）装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。<br>　　（4）具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</p>
<p><strong>例子</strong></p>
<p>​    咖啡的例子：当我们去咖啡厅的时候。不知道是不是会遇到这种问题呢？本来你点一杯普通的coffe，然后他的价格是10元，但是你尝了之后发现有点苦，想要加点红糖，然后加这个糖的价格是2元；然后过了一会你的朋友过来了，他叫了一杯普通coffee，然后加了点牛奶（假设可以加），这个牛奶的价格是3元，如果叫你设计一个程序负责这部分的内容，你会怎么做呢？</p>
<p>​    会不会有人这么想，java不是面向对象的语言吗？我们可以通过设计对象来啊，首先创建coffee一个抽象类，然后在列出可能添加调料的可能食品，然后付款的时候，调用方法不就行了吗？确实这样做是可以的，但是前面说了耦合度高，这个时候，就到了我们的装饰者出场了。</p>
<p>首先画出关系图：</p>
<p><img src="\image\java设计模式\装饰者模式-咖啡例子.png" alt="装饰者模式-咖啡例子"></p>
<p>我们要做的就是点咖啡1的时候加sugar，点咖啡2的时候加milk</p>
<p>（1）创建coffee的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line">	String coffeeInformation = <span class="string">"普通咖啡"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCoffeeInformation</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> coffeeInformation;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现类coffee1，coffee2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">coffee1</span> <span class="keyword">extends</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">coffee1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		coffeeInformation = <span class="string">"coffee1"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">coffee2</span> <span class="keyword">extends</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">coffee2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		coffeeInformation = <span class="string">"coffee2"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">12.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）调料类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThings</span> <span class="keyword">extends</span> <span class="title">coffee</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getCoffeeInformation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">milk</span> <span class="keyword">extends</span> <span class="title">AddThings</span></span>&#123;</span><br><span class="line">	coffee coff;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">milk</span><span class="params">(coffee c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.coff = c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCoffeeInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String addThings = coff.getCoffeeInformation()+<span class="string">"添加"</span>+<span class="string">"milk"</span>;</span><br><span class="line">		<span class="keyword">return</span> addThings;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3.0</span>+coff.cost();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sugar</span> <span class="keyword">extends</span> <span class="title">AddThings</span> </span>&#123;</span><br><span class="line">	coffee coff;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">sugar</span><span class="params">(coffee c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.coff = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCoffeeInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String addThings = coff.getCoffeeInformation()+<span class="string">"添加"</span>+<span class="string">"sugar"</span>;</span><br><span class="line">		<span class="keyword">return</span> addThings;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2.0</span>+coff.cost();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zqu.yqy.scdn.test.test006;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cost</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		coffee c1 = <span class="keyword">new</span> coffee1();</span><br><span class="line">		coffee c2 = <span class="keyword">new</span> coffee2();</span><br><span class="line">		coffee a1 = <span class="keyword">new</span> sugar(c1);</span><br><span class="line">		coffee a2 = <span class="keyword">new</span> milk(c1);</span><br><span class="line">		<span class="comment">//coffee a3 = new milk(c2);</span></span><br><span class="line">		System.out.println(a1.getCoffeeInformation()+<span class="string">" "</span>+a1.cost());</span><br><span class="line">		System.out.println(a2.getCoffeeInformation()+<span class="string">" "</span>+a2.cost());</span><br><span class="line">		<span class="comment">//System.out.println(a3.getCoffeeInformation()+" "+a3.cost());</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果截图：</p>
<p><img src="\image\java设计模式\装饰者模式-咖啡例子-运行结果图.png" alt="装饰者模式-咖啡例子-运行结果图"></p>
<p>​    你会发现很神奇的实现了，我们要的功能，可能有的人会好奇，为什么我们的调料类也要继承coffee的呢？这个问题问得好，但是我相信你把我注释掉的那部分代码再执行一遍，你会很神奇的发现，我们的coffee1或者是coffee2还能添加牛奶呢。这你实践一下就会明白的，这样的目的怎么，是不是非常棒！！！</p>
<p><strong>优缺点</strong></p>
<p>​    优点：可以动态的给对象添加一些功能，并且添加功能的顺序可以动态的进行调整。</p>
<p>​    缺点：继承层级比较深。暂时还没有发现其他的缺点。</p>
<p><strong>总结</strong></p>
<p>​    装饰者模式利用关联被装饰的对象，使得可以给被装饰的对象添加新的功能。并且被装饰后，还可以当作原来对象的类型来使用。</p>
<p>参考资料：<a href="http://blog.csdn.net/cooldragon/article/details/52174157" target="_blank" rel="noopener">设计模式总结之Decorator Pattern（装饰者模式）</a></p>
<p>​           <a href="http://blog.csdn.net/YQYnsmile/article/details/52673529" target="_blank" rel="noopener">简单理解设计模式之装饰者模式</a></p>
<h2 id="代理模式-Proxy-pattern"><a href="#代理模式-Proxy-pattern" class="headerlink" title="代理模式( Proxy pattern)"></a>代理模式( Proxy pattern)</h2><p><strong>定义</strong></p>
<p>​    ==给某一个对象提供一个代理，并由代理对象控制对原对象的访问==。对应到现实生活中，代理模式就类似于中介。</p>
<p>​    可以详细控制访问某个类（对象）的方法，在调用这个方法前作的前置处理（统一的流程代码放到代理中处理）。调用这个方法后做后置处理。</p>
<p>​    例如：<u>明星的经纪人，租房的中介等等都是代理</u></p>
<p><strong>结构</strong></p>
<p><img src="\image\java设计模式\代理模式结构.png" alt="代理模式结构"></p>
<p>代理模式包含如下角色：</p>
<p>​    <strong>Subject</strong>：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。</p>
<p>​    <strong>RealSubject</strong>：真实主题角色，是实现抽象主题接口的类。</p>
<p>​    <strong>ProxySubject</strong>：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</p>
<p>​    实现动态代理的关键技术是反射。</p>
<p><strong>静态代理</strong></p>
<p>​    代理模式有几种，虚拟代理，计数代理，远程代理，动态代理。主要分为两类，静态代理和动态代理。静态代理比较简单，是由程序员编写的代理类，并在程序运行前就编译好的，而不是由程序动态产生代理类，这就是所谓的静态。</p>
<p>​    考虑这样的场景，管理员在网站上执行操作，在生成操作结果的同时需要记录操作日志，这是很常见的。此时就可以使用代理模式，代理模式可以通过聚合和继承两种方式实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**方式一：聚合式静态代理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Goser    (mailto:goskalrie@163.com)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Since</span> 2016年9月7日</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//1.抽象主题接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.真实主题类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">implements</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Admin do something."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.以聚合方式实现的代理主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminPoly</span> <span class="keyword">implements</span> <span class="title">Manager</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Admin admin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdminPoly</span><span class="params">(Admin admin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.admin = admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Log:admin操作开始"</span>);</span><br><span class="line">        admin.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"Log:admin操作结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.测试代码</span></span><br><span class="line">        Admin admin = <span class="keyword">new</span> Admin();</span><br><span class="line">        Manager m = <span class="keyword">new</span> AdminPoly(admin);</span><br><span class="line">        m.doSomething();</span><br><span class="line">    <span class="comment">//方式二：继承式静态代理</span></span><br><span class="line">    <span class="comment">//与上面的方式仅代理类和测试代码不同</span></span><br><span class="line">    <span class="comment">//1.代理类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminProxy</span> <span class="keyword">extends</span> <span class="title">Admin</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Log:admin操作开始"</span>);</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"Log:admin操作开始"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.测试代码</span></span><br><span class="line">        AdminProxy proxy = <span class="keyword">new</span> AdminProxy();</span><br><span class="line">        proxy.doSomething();</span><br></pre></td></tr></table></figure></p>
<p>​    聚合实现方式中代理类聚合了被代理类，且代理类及被代理类都实现了同一个接口，可实现灵活多变。继承式的实现方式则不够灵活。</p>
<p><strong>动态代理</strong></p>
<p>​    一般来说，对代理模式而言，一个主题类与一个代理类一一对应，这也是静态代理模式的特点。</p>
<p>​    但是，也存在这样的情况，有n各主题类，但是代理类中的“前处理、后处理”都是一样的，仅调用主题不同。也就是说，多个主题类对应一个代理类，共享“前处理，后处理”功能，动态调用所需主题，大大减小了程序规模，这就是动态代理模式的特点。</p>
<p><strong>JDK动态代理</strong></p>
<p><strong>实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 抽象主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span>  <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 真实主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        System.out.println(<span class="string">"汽车行驶中…"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.事务处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数：</span></span><br><span class="line"><span class="comment">     *proxy 被代理的对象</span></span><br><span class="line"><span class="comment">     *method 被代理对象的方法</span></span><br><span class="line"><span class="comment">     *args 方法的参数</span></span><br><span class="line"><span class="comment">     * 返回：</span></span><br><span class="line"><span class="comment">     *Object 方法返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"汽车开始行驶…"</span>);</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        <span class="keyword">long</span> stopTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"汽车结束行驶…汽车行驶时间："</span> + (stopTime - startTime) + <span class="string">"毫秒！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> TimeHandler(car);</span><br><span class="line">        Class&lt;?&gt; cls = car.getClass();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *loader 类加载器</span></span><br><span class="line"><span class="comment">         *interfaces 实现接口</span></span><br><span class="line"><span class="comment">         *h InvocationHandler</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Moveable m = (Moveable) Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(), h);</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码讲解：</p>
<p>在测试代码中，Proxy.newProxyInstance()方法需要3个参数：类加载器（要进行代理的类）、被代理类实现的接口，事务处理器。所以先实例化Car，实例化InvocationHandler的子类TimeHandler，将各参数传入Proxy的静态方法newProxyInstance()即可获得Car的代理类，前面的静态代理，代理类是我们编写好的，而动态代理则不需要我们去编写代理类，是在程序中动态生成的。</p>
<p><strong>JDK动态代理步骤</strong></p>
<p>1.       创建一个实现InvocationHandler接口的类，它必须实现invoke()方法</p>
<p>2.       创建被代理的类及接口</p>
<p>3.       调用Proxy的静态方法，创建一个代理类</p>
<p>4.        通过代理调用方法</p>
<p>​    在JDK动态代理中，发现生成的代理类字节码中类的声明为：</p>
<p><code>public final class $Proxy1 extends Proxy</code></p>
<p>​    可以看到生成的代理类是继承了Proxy类的，这就是说明了为什么使用JDK动态代理不能实现继承式动态代理，原因是Java不允许多继承，而生成的代理类本身就已经继承了Proxy类。也就是说在Proxy.newProxyInstance（）转递的类型参数应该是被代理类实现的接口。</p>
<p><strong>cglib动态代理</strong></p>
<p>​    前面分析到，因为Java只允许单继承，而JDK生成的代理类本身就继承了Proxy类，因此，使用JDK实现的动态代理不能完成继承式的动态代理，但是我们可以使用cglib来实现继承式的动态代理。</p>
<p>​    大名鼎鼎的Spring中就含有cglib动态代理，在此也以Spring中自带的cglib完成动态代理的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.具体主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Train</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"火车行驶中…"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.生成代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截所有目标类方法的调用</span></span><br><span class="line"><span class="comment">     * 参数：</span></span><br><span class="line"><span class="comment">     * obj目标实例对象</span></span><br><span class="line"><span class="comment">     *method 目标方法的反射对象</span></span><br><span class="line"><span class="comment">     * args方法的参数</span></span><br><span class="line"><span class="comment">     * proxy代理类的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//代理类调用父类的方法</span></span><br><span class="line">        System.out.println(<span class="string">"日志开始"</span>);</span><br><span class="line">        proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">"日志结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CGLibProxy proxy = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">        Train t = (Train) proxy.getProxy(Train.class);</span><br><span class="line">        t.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>小结</p>
<p>​    动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样对每一个方法或方法组合进行处理。Proxy 很美很强大，但是仅支持 interface 代理。Java 的单继承机制注定了这些动态代理类们无法实现对 class 的动态代理。好在有cglib为Proxy提供了弥补。class与interface的区别本来就模糊，在java8中更是增加了一些新特性，使得interface越来越接近class，当有一日，java突破了单继承的限制，动态代理将会更加强大。</p>
<p><strong>总结</strong></p>
<p>​    代理模式就类似于中介，会控制被代理对象的访问，可以添加前置处理和后置处理。真正强大的是动态代理。</p>
<p>参考资料：<a href="http://www.importnew.com/26116.html" target="_blank" rel="noopener">说说 JAVA 代理模式</a></p>
<p>​           <a href="http://blog.csdn.net/goskalrie/article/details/52458773" target="_blank" rel="noopener">Java设计模式——代理模式实现及原理</a></p>
<p>​          <a href="http://www.cnblogs.com/chinajava/p/5880887.html" target="_blank" rel="noopener">说说cglib动态代理</a></p>
<h2 id="门面模式-Facade-Pattern-外观模式"><a href="#门面模式-Facade-Pattern-外观模式" class="headerlink" title="门面模式( Facade Pattern  外观模式)"></a>门面模式( Facade Pattern  外观模式)</h2><p><strong>定义</strong></p>
<p>​    门面模式(Facade Pattern)：==为子系统中的一组接口提供一个一致的界面==，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。门面模式又称为<strong>外观模式</strong>，它是一种对象结构型模式。</p>
<p><strong>模式动机</strong></p>
<p>​    现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其“分而治之”，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。</p>
<p>　　首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。</p>
<p><img src="\image\java设计模式\门面模式-病人到医院看病.png" alt="门面模式-病人到医院看病"></p>
<p>​    上图描述的是病人在医院里的体验，图中的方框代表医院。</p>
<p>　　解决这种不便的方法便是引进门面模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是门面模式的体现，病人只接触接待员，由接待员与各个部门打交道。</p>
<p><img src="\image\java设计模式\门面模式-医院接待员.png" alt="门面模式-医院接待员"></p>
<p><strong>结构</strong></p>
<p>​    门面模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明。</p>
<p><img src="\image\java设计模式\门面模式-结构示意图1.png" alt="门面模式-结构示意图1"></p>
<p>​    由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，那么此时示例的整体结构图如下：</p>
<p><img src="\image\java设计模式\门面模式-结构示意图2.png" alt="门面模式-结构示意图2"></p>
<p>在这个对象图中，出现了两个角色：</p>
<ul>
<li><strong>门面(Facade)角色</strong> ：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。（门面对象不干活，而是将活让子系统干）</li>
<li><strong>子系统(SubSystem)角色</strong> ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。</li>
</ul>
<p><strong>实例分析</strong></p>
<p>​    这次我们来关注一下土豪的个人生活，话说土豪下班回到家里后首先要做的就是把灯打开，我们假设他一共需要打开三个灯，然后就是打开热水器烧水准备洗澡，在等待的过程还会打开电视机看新闻。如果我们用一般的方法来实现的话，代码就会是下面这个样子。</p>
<p>​    这是电灯的类，里边有打开的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Light has been opened!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    这是热水器的类，里边有打开的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heater</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Heater has been opened!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    这是电视机的类，里边有打开的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TV has been opened!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    在主函数里就要创建各种对象，并且调用他们的额open方法。我们看到主函数为了实现土豪下班回家这一个功能需要和三个电灯，一个热水器和一台电视机打交道，非常的复杂，所以这时候我们就应该使用门面模式。相当于给土豪弄一个总开关，一键打开所有的东西。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Light light1 = <span class="keyword">new</span> Light();</span><br><span class="line">        Light light2 = <span class="keyword">new</span> Light();</span><br><span class="line">        Light light3 = <span class="keyword">new</span> Light();</span><br><span class="line">        Heater heater = <span class="keyword">new</span> Heater();</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要一步一步的操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        light1.open();</span><br><span class="line">        light2.open();</span><br><span class="line">        light3.open();</span><br><span class="line">        heater.open();</span><br><span class="line">        tv.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    在门面类中我们创建一个统一的open方法，来调度所有的开关。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light1, light2, light3;</span><br><span class="line">    <span class="keyword">private</span> Heater heater;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light1 = <span class="keyword">new</span> Light();</span><br><span class="line">        light2 = <span class="keyword">new</span> Light();</span><br><span class="line">        light3 = <span class="keyword">new</span> Light();</span><br><span class="line">        heater = <span class="keyword">new</span> Heater();</span><br><span class="line">        tv = <span class="keyword">new</span> TV();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light1.open();</span><br><span class="line">        light2.open();</span><br><span class="line">        light3.open();</span><br><span class="line">        heater.open();</span><br><span class="line">        tv.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    这样在主函数类只需要使用门面类就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.designpattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一步操作就可以完成所有的准备工作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        facade.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong></p>
<p>​    一个系统可以有几个门面类?</p>
<p>​    在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。</p>
<p>​    为子系统增加新行为</p>
<p>​    初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。</p>
<p><strong>优缺点</strong></p>
<p>​    门面模式的优点：</p>
<p>　　●　　松散耦合</p>
<p>　　门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</p>
<p>　　●　　简单易用</p>
<p>　　门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。</p>
<p>　　●　　更好的划分访问层次</p>
<p>　　通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。</p>
<p>​    缺点：</p>
<ul>
<li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ul>
<p><strong>总结</strong></p>
<p>​    门面模式可以给子系统中的多个接口提供一个一致的对外界面，既方便客户端对于子系统的使用，也可以将客户端与子系统内部功能解耦，客户端不用知道子系统的细节，只需要跟门面对象沟通就可以了。</p>
<p>参考资料：<a href="http://blog.csdn.net/jason0539/article/details/22775311" target="_blank" rel="noopener">JAVA设计模式之门面模式（外观模式）</a></p>
<p>​           <a href="http://blog.csdn.net/xingjiarong/article/details/50066133" target="_blank" rel="noopener">设计模式（七）门面模式（Facade Pattern 外观模式）</a></p>
<h2 id="桥接模式（Bridge"><a href="#桥接模式（Bridge" class="headerlink" title="桥接模式（Bridge)"></a>桥接模式（Bridge)</h2><p><strong>定义</strong></p>
<p>​    ==桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化==。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>​    这个定义可能刚开始看不太懂，可以结合下面的结构图和实际例子来理解。其实一个模式的定义是从一个高度抽象的层面描述模式的本质。</p>
<p>　    这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p><strong>结构</strong></p>
<p>​    桥接模式的UML图如下：</p>
<p><img src="\image\java设计模式\桥接模式-UML类图.png" alt="桥接模式-UML类图"></p>
<p>​    桥接模式（Bridge)是一种结构型设计模式。Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。</p>
<p>​    桥接模式的角色和职责：</p>
<p>​    1.Client 调用端</p>
<p>​    这是Bridge模式的调用者。</p>
<p>​    2.抽象类（Abstraction）</p>
<p>​    抽象类接口（接口这货抽象类）维护队行为实现（implementation）的引用。它的角色就是桥接类。</p>
<p>​    3.Refined Abstraction</p>
<p>​    这是Abstraction的子类。</p>
<p>​    4.Implementor</p>
<p>​    行为实现类接口（Abstraction接口定义了基于Implementor接口的更高层次的操作）</p>
<p>​    5.ConcreteImplementor</p>
<p>​    Implementor的子类</p>
<p><strong>示例代码如下</strong></p>
<p>​    首先定义Implementor接口，其中定义了其实现类必须要实现的接口operation()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>
<p>​    下面定义Implementor接口的两个实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         System.out.println(<span class="string">"this is concreteImplementorA's operation..."</span>);</span><br><span class="line"><span class="number">5</span>     &#125;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateImplementorB</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         System.out.println(<span class="string">"this is concreteImplementorB's operation..."</span>);</span><br><span class="line"><span class="number">5</span>     &#125;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>
<p>下面定义桥接类Abstraction，其中有对Implementor接口的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Implementor implementor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Implementor <span class="title">getImplementor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> implementor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImplementor</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.implementor = implementor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        implementor.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    下面是Abstraction类的子类RefinedAbstraction：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         <span class="keyword">super</span>.getImplementor().operation();</span><br><span class="line"><span class="number">5</span>     &#125;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>
<p>​    下面给出测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Abstraction abstraction = <span class="keyword">new</span> RefinedAbstraction();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用第一个实现类</span></span><br><span class="line">        abstraction.setImplementor(<span class="keyword">new</span> ConcreateImplementorA());</span><br><span class="line">        abstraction.operation();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//调用第二个实现类</span></span><br><span class="line">        abstraction.setImplementor(<span class="keyword">new</span> ConcreateImplementorB());</span><br><span class="line">        abstraction.operation();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    其运行结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is concreteImplementorA<span class="string">'s operation...</span></span><br><span class="line"><span class="string">this is concreteImplementorB'</span>s operation...</span><br></pre></td></tr></table></figure></p>
<p>​    这样，通过对Abstraction桥接类的调用，实现了对接口Implementor的实现类ConcreteImplementorA和ConcreteImplementorB的调用。实现了抽象与行为实现的分离。</p>
<p><strong>实际例子</strong></p>
<p>​    个人理解：桥接是一个接口，它与一方应该是绑定的，也就是解耦的双方中的一方必然是继承这个接口的，这一方就是实现方，而另一方正是要与这一方解耦的抽象方，如果不采用桥接模式，一般我们的处理方式是直接使用继承来实现，这样双方之间处于强链接，类之间关联性极强，如要进行扩展，必然导致类结构急剧膨胀。采用桥接模式，正是为了避免这一情况的发生，将一方与桥绑定，即实现桥接口，另一方在抽象类中调用桥接口（指向的实现类），这样桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响。</p>
<p>　　下面的实例能真正体现着一点：</p>
<p>　　实例准备：我们假设有一座桥，桥左边为A，桥右边为B，A有A1，A2，A3等，表示桥左边的三个不同地方，B有B1，B2，B3等，表示桥右边的三个不同地方，假设我们要从桥左侧A出发到桥的右侧B，我们可以有多重方案，A1到B1，A1到B2，A1到B3，A2到B1…等等，以此为例，代码如下：</p>
<p>桥接口：Qiao</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Qiao</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="comment">//目的地B</span></span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">void</span> <span class="title">targetAreaB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure>
<p>目的地B1,B2,B3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目的地B1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaB1</span> <span class="keyword">implements</span> <span class="title">Qiao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetAreaB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要去B1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目的地B2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaB2</span> <span class="keyword">implements</span> <span class="title">Qiao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetAreaB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要去B2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目的地B3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaB3</span> <span class="keyword">implements</span> <span class="title">Qiao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetAreaB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要去B3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象来源地A：AreaA</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaA</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="comment">//引用桥接口</span></span><br><span class="line"><span class="number">3</span>     Qiao qiao;</span><br><span class="line"><span class="number">4</span>     <span class="comment">//来源地</span></span><br><span class="line"><span class="number">5</span>     <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fromAreaA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>
<p>来源地A1，A2，A3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 来源地A1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaA1</span> <span class="keyword">extends</span> <span class="title">AreaA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fromAreaA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我来自A1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 来源地A2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaA2</span> <span class="keyword">extends</span> <span class="title">AreaA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fromAreaA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我来自A2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 来源地A3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaA3</span> <span class="keyword">extends</span> <span class="title">AreaA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fromAreaA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我来自A3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类：Clienter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clienter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AreaA a = <span class="keyword">new</span> AreaA2();</span><br><span class="line">        a.qiao = <span class="keyword">new</span> AreaB3();</span><br><span class="line">        a.fromAreaA();</span><br><span class="line">        a.qiao.targetAreaB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我来自A2</span><br><span class="line">我要去B3</span><br></pre></td></tr></table></figure>
<p>如何，只要你认真看完了实例，你就明白了这种模式的好处，现在我们要添加来源地和目的地，只要继续继承AreaA和实现Qiao即可，之前我所说的绑定，正式此处将桥与目的地绑定在一起，使用一个接口完成。</p>
<p>　　其实要完成桥接模式，注意点并不多，重在理解模式的使用场景。</p>
<p>　　注意点：</p>
<p>　　　　1、定义一个桥接口，使其与一方绑定，这一方的扩展全部使用实现桥接口的方式。</p>
<p>　　　　2、定义一个抽象类，来表示另一方，在这个抽象类内部要引入桥接口，而这一方的扩展全部使用继承该抽象类的方式。</p>
<p>　　其实我们可以发现桥接模式应对的场景有方向性的，桥绑定的一方都是被调用者，属于被动方，抽象方属于主动方。</p>
<p>　　其实我的JDK提供的JDBC数据库访问接口API正是经典的桥接模式的实现者，接口内部可以通过实现接口来扩展针对不同数据库的具体实现来进行扩展，而对外的仅仅只是一个统一的接口调用，调用方过于抽象，可以将其看做每一个JDBC调用程序（这是真实实物，当然不存在抽象）</p>
<p><strong>优缺点</strong></p>
<p>1.桥接模式的优点</p>
<p>​    （1）实现了抽象和实现部分的分离</p>
<p>​    桥接模式分离了抽象部分和实现部分，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，分别定义接口，这有助于系统进行分层设计，从而产生更好的结构化系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。</p>
<p>​    （2）更好的可扩展性</p>
<p>​    由于桥接模式把抽象部分和实现部分分离了，从而分别定义接口，这就使得抽象部分和实现部分可以分别独立扩展，而不会相互影响，大大的提供了系统的可扩展性。</p>
<p>​    （3）可动态的切换实现</p>
<p>​    由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。</p>
<p>​    （4）实现细节对客户端透明，可以对用户隐藏实现细节。</p>
<p>​    </p>
<p>2.桥接模式的缺点</p>
<p>​    （1）桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。</p>
<p>​    （2）桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。</p>
<p><strong>桥接模式的使用场景</strong></p>
<p>​    （1）如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</p>
<p>​    （2）抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</p>
<p>​    （3）一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<p><strong>总结</strong></p>
<p>​    桥接模式，就是将实现行为的一方，与需要这些行为的抽象一方进行解耦。具体行为在变化，需要执行行为的实体一方也在变化，但是实体方需要具体行为对象的这个关系不会发生变化。桥接模式就是将这种变化与关系的不变化进行分离。使得变化的行为方和实体方可以独立变化，而相互不影响。</p>
<p>参考资料：<a href="http://www.cnblogs.com/V1haoge/p/6497919.html" target="_blank" rel="noopener">Java设计模式之《桥接模式》及应用场景</a></p>
<p>​           <a href="http://www.cnblogs.com/lixiuyu/p/5923160.html" target="_blank" rel="noopener">设计模式之桥接模式</a></p>
<h2 id="享元模式-Flyweight-Pattern"><a href="#享元模式-Flyweight-Pattern" class="headerlink" title="享元模式(Flyweight Pattern)"></a>享元模式(Flyweight Pattern)</h2><p><strong>定义</strong></p>
<p>​    ==采用一个共享来避免大量拥有相同内容对象的开销==。这种开销中最常见、直观的就是内存的损耗。享元模式以共享的方式高效的支持大量的细粒度对象。</p>
<p><strong>实际例子</strong></p>
<p>​    比如在文档编辑器的设计过程中，我们如果为没有字母创建一个对象的话，系统可能会因为大量的对象而造成存储开销的浪费。例如一个字母“a”在文档中出现了100000次，而实际上我们可以让这一万个字母“a”共享一个对象，当然因为在不同的位置可能字母“a”有不同的显示效果（例如字体和大小等设置不同），在这种情况我们可以为将对象的状态分为“外部状态”和“内部状态”，将可以被共享（不会变化）的状态作为内部状态存储在对象中，而外部对象（例如上面提到的字体、大小等）我们可以在适当的时候将外部对象最为参数传递给对象（例如在显示的时候，将字体、大小等信息传递给对象）。</p>
<p><strong>适用场景</strong></p>
<p>​    当以下所有的条件都满足时，可以考虑使用享元模式：</p>
<p>（1）.一个系统有大量的对象。</p>
<p>（2）.这些对象耗费大量的内存。</p>
<p>（3）.这些对象的状态中的大部分都可以外部化。</p>
<p>（4）.这些对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。</p>
<p>（5）.软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。</p>
<p>满足以上的这些条件的系统可以使用享元对象。</p>
<p>最后，使用享元模式需要维护一个记录了系统已有的所有享元的表，而这需要耗费资源。因此，应当在有足够多的享元实例可供共享时才值得使用享元模式。</p>
<p><strong>结构</strong></p>
<p>​    ==单纯Flyweight享元模式==典型的UML结构图如图1所示：</p>
<p><img src="\image\java设计模式\单纯享元模式-uml类图.png" alt="单纯享元模式-uml类图"></p>
<p>​    单纯Flyweight享元模式抽象基类及接口：</p>
<pre><code>抽象享元(Flyweight)角色：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态(External State)的操作可以通过调用商业方法以参数形式传入。
</code></pre><p>​    具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享的。</p>
<p>​    享元工厂(FlyweightFactory)角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个复合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应 当创建一个合适的享元对象。</p>
<p>​    客户端(Client)角色：本角色需要维护一个对所有享元对象的引用。本角色需要自行存储所有享元对象的外蕴状态。</p>
<p>​    复合Flyweight享元模式典型的UML结构图如图2所示：</p>
<p><img src="\image\java设计模式\复合享元模式-uml类图.png" alt="复合享元模式-uml类图"></p>
<p>​    复合Flyweight享元模式抽象基类及接口：</p>
<p>​    抽象享元角色：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态(External State)的操作可以通过方法的参数传入。抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。</p>
<p>​    具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。有时候具体享元角色又叫做单纯具体享元角色，因为复合享元角色是由单纯具体享元角色通过复合而成的。</p>
<p>​    复合享元(UnsharableFlyweight)角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称做不可共享的享元对象。</p>
<p>​    享元工厂(FlyweightFactoiy)角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象请求一个享元对象的时候，享元工厂角色需要检查系统中是否已经有一个符合要求的享元对象，如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个新的合适的享元对象。</p>
<p>​    客户端(Client)角色：本角色还需要自行存储所有享元对象的外蕴状态。</p>
<p><strong>示例代码</strong></p>
<p>​    单纯Flyweight享元模式典型的示例代码如下：</p>
<p>​    先定义一个抽象的Flyweight类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flyweight;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span></span>&#123;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    实现一个具体类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flyweight;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        string = str;</span><br><span class="line">　  &#125;</span><br><span class="line">　   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　 		System.out.println(<span class="string">"Concrete---Flyweight : "</span> + string);</span><br><span class="line">　	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    实现一个工厂方法类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flyweight;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hashtable flyweights = <span class="keyword">new</span> Hashtable();<span class="comment">//----------------------------1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyweightFactory</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyWeight</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Flyweight flyweight = (Flyweight) flyweights.get(obj);<span class="comment">//----------------2</span></span><br><span class="line">        <span class="keyword">if</span>(flyweight == <span class="keyword">null</span>)&#123;<span class="comment">//---------------------------------------------------3</span></span><br><span class="line">            <span class="comment">//产生新的ConcreteFlyweight</span></span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight((String)obj);</span><br><span class="line">            flyweights.put(obj, flyweight);<span class="comment">//--------------------------------------5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;<span class="comment">//---------------------------------------------------------6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFlyweightSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flyweights.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    这个工厂方法类非常关键，这里详细解释一下：<br>　　在1处定义了一个Hashtable用来存储各个对象；在2处选出要实例化的对象，在6处将该对象返回，如果在Hashtable中没有要选择的对象，此时变量flyweight为null，产生一个新的flyweight存储在Hashtable中，并将该对象返回。<br>　　最后看看Flyweight的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Flyweight;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span></span>&#123;</span><br><span class="line">    FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory(); </span><br><span class="line">    Flyweight fly1;</span><br><span class="line">    Flyweight fly2;</span><br><span class="line">    Flyweight fly3;</span><br><span class="line">    Flyweight fly4;</span><br><span class="line">    Flyweight fly5;</span><br><span class="line">    Flyweight fly6;</span><br><span class="line">    <span class="comment">/** */</span><span class="comment">/** Creates a new instance of FlyweightPattern */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyweightPattern</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fly1 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">        fly2 = factory.getFlyWeight(<span class="string">"Qutr"</span>);</span><br><span class="line">        fly3 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">        fly4 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">        fly5 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">        fly6 = factory.getFlyWeight(<span class="string">"Google"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFlyweight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fly1.operation();</span><br><span class="line">        fly2.operation();</span><br><span class="line">        fly3.operation();</span><br><span class="line">        fly4.operation();</span><br><span class="line">        fly5.operation();</span><br><span class="line">        fly6.operation();</span><br><span class="line">        <span class="keyword">int</span> objSize = factory.getFlyweightSize();</span><br><span class="line">        System.out.println(<span class="string">"objSize = "</span> + objSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"The FlyWeight Pattern!"</span>);</span><br><span class="line">        FlyweightPattern fp = <span class="keyword">new</span> FlyweightPattern();</span><br><span class="line">        fp.showFlyweight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    下面是运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Concrete---Flyweight : Google</span><br><span class="line">Concrete---Flyweight : Qutr</span><br><span class="line">Concrete---Flyweight : Google</span><br><span class="line">Concrete---Flyweight : Google</span><br><span class="line">Concrete---Flyweight : Google</span><br><span class="line">Concrete---Flyweight : Google</span><br><span class="line">objSize = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>​    我们定义了6个对象，其中有5个是相同的，按照Flyweight模式的定义“Google”应该共享一个对象，在实际的对象数中我们可以看出实际的对象却是只有2个。</p>
<p>　　Flyweight(享元)模式是如此的重要，因为它能帮你在一个复杂的系统中大量的节省内存空间。在JAVA语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在JAVA中字符串常量都是存在常量池中的，JAVA会确保一个字符串常量在常量池中只有一个拷贝。</p>
<p>​    复合式享元相当于多个单纯享元的集合。也就是说复合享元相当于对单纯享元进行了一个再分组，在复合享元的每个分组里又是一个独立的单纯享元模式。相关关键代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCompositeFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Flyweight&gt; labels = <span class="keyword">new</span> HashMap&lt;Integer, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key, Flyweight flyweight)</span> </span>&#123;</span><br><span class="line">        labels.put(key, flyweight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String extrinsicState)</span> </span>&#123;</span><br><span class="line">        Flyweight flyweight = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object key : labels.keySet()) &#123;</span><br><span class="line">            flyweight = labels.get(key);</span><br><span class="line">            flyweight.operation(extrinsicState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    对于其构建工厂也需要进行重新设计，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Flyweight&gt; labels = <span class="keyword">new</span> HashMap&lt;Integer, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单纯享元工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">factory</span><span class="params">(String intrinsicState)</span> </span>&#123;</span><br><span class="line">         ... ...</span><br><span class="line">         <span class="keyword">return</span> fly;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复合享元工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">compositeFactory</span><span class="params">(List&lt;String&gt; intrinsicStates)</span> </span>&#123;</span><br><span class="line">        ConcreteCompositeFlyweight flyweight = <span class="keyword">new</span> ConcreteCompositeFlyweight();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (String intrinsicState : intrinsicStates) &#123;</span><br><span class="line">            flyweight.add(intrinsicState.hashCode(), factory(intrinsicState));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compositeFlyweight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; intrinsicStates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        intrinsicStates.add(<span class="string">"Hello"</span>);</span><br><span class="line">        intrinsicStates.add(<span class="string">"Java"</span>);</span><br><span class="line">        intrinsicStates.add(<span class="string">"DesignPattern"</span>);</span><br><span class="line">        intrinsicStates.add(<span class="string">"Flyweight"</span>);</span><br><span class="line">    </span><br><span class="line">        FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight flyweight1 = factory.compositeFactory(intrinsicStates);</span><br><span class="line">        Flyweight flyweight2 = factory.compositeFactory(intrinsicStates);</span><br><span class="line">        System.out.println(<span class="string">"flyweight1 == flyweight2 ? "</span> + (flyweight1 == flyweight2));</span><br><span class="line">    </span><br><span class="line">        flyweight1.operation(<span class="string">"复合享元-1"</span>);</span><br><span class="line">        flyweight2.operation(<span class="string">"复合享元-2"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>​    执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flyweight1 == flyweight2 ? <span class="keyword">false</span></span><br><span class="line">内蕴状态：Java</span><br><span class="line">外蕴状态：复合享元-<span class="number">1</span></span><br><span class="line">内蕴状态：Flyweight</span><br><span class="line">外蕴状态：复合享元-<span class="number">1</span></span><br><span class="line">内蕴状态：Hello</span><br><span class="line">外蕴状态：复合享元-<span class="number">1</span></span><br><span class="line">内蕴状态：DesignPattern</span><br><span class="line">外蕴状态：复合享元-<span class="number">1</span></span><br><span class="line">内蕴状态：Java</span><br><span class="line">外蕴状态：复合享元-<span class="number">2</span></span><br><span class="line">内蕴状态：Flyweight</span><br><span class="line">外蕴状态：复合享元-<span class="number">2</span></span><br><span class="line">内蕴状态：Hello</span><br><span class="line">外蕴状态：复合享元-<span class="number">2</span></span><br><span class="line">内蕴状态：DesignPattern</span><br><span class="line">外蕴状态：复合享元-<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例1：一个咖啡的例子</strong></p>
<p>​    在这个咖啡摊(CoffeeStall)所使用的系统里，有一系列的咖啡”风味(Flavor)”。客人到摊位上购买咖啡，所有的咖啡均放在台子上，客人自己拿到咖啡后就离开摊位。咖啡有内蕴状态，也就是咖啡的风味；咖啡没有环境因素，也就是说没有外蕴状态。如果系统为每一杯咖啡都创建一个独立的对象的话，那么就需要创建出很多的细小对象来。这样就不如把咖啡按照种类(即”风味”)划分，每一种风味的咖啡只创建一个对象，并实行共享。</p>
<p>​    使用咖啡摊主的语言来讲，所有的咖啡都可按”风味”划分成如Capucino、Espresso等，每一种风味的咖啡不论卖出多少杯，都是全同、不可分辨的。所谓共享，就是咖啡风味的共享，制造方法的共享等。因此，享元模式对咖啡摊来说，就意味着不需要为每一份单独调制。摊主可以在需要时，一次性地调制出足够一天出售的某一种风味的咖啡。</p>
<p>​    很显然，这里适合使用单纯享元模式。</p>
<p><strong>示例2：咖啡店的例子</strong></p>
<p>​    在前面的咖啡摊项目里，由于没有供客人坐的桌子，所有的咖啡均没有环境的影响。换言之，咖啡仅有内蕴状态，也就是咖啡的种类，而没有外蕴状态。下面考虑一个规模稍稍大一点的咖啡屋(Coffee Shop)项目。屋子里有很多的桌子供客人坐，系统除了需要提供咖啡的”风味”之外，还需要跟踪咖啡被送到哪一个桌位上，因此，咖啡就有了桌子作为外蕴状态。</p>
<p>​    由于外蕴状态的存在，没有外蕴状态的单纯享元模式不再符合要求。系统的设计可以利用有外蕴状态的单纯享元模式。</p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    Flyweight享元模式的优点在于它大幅度地降低内存中对象的数量。</p>
<p>​    缺点：</p>
<p>​    Flyweight享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。Flyweight享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。    </p>
<p><strong>总结</strong></p>
<p>​    Flyweight享元模式就是共享一些对象，来达到减少资源的消耗。其中共享的对象一旦创建就不会改变了。其实解决的问题就是，大量不同的对象却有很多共同的内容，将共同的内容抽取出来形成对象，并共享。主要注意的是FlyweightFactory对象，其中使用一个键值对集合来存储共享对象。</p>
<p>参考资料：<a href="https://www.2cto.com/kf/201606/521524.html" target="_blank" rel="noopener">Flyweight模式详解</a>    </p>
<p>​           <a href="http://blog.csdn.net/ai92/article/details/224598" target="_blank" rel="noopener">深入浅出享元模式</a></p>
<p>​           <a href="http://blog.csdn.net/lemon_tree12138/article/details/51241598#%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">Java设计模式——享元模式</a></p>
<p>​                  <a href="http://blog.csdn.net/jason0539/article/details/22908915" target="_blank" rel="noopener">JAVA设计模式之享元模式</a></p>
<h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式( Strategy )"></a>策略模式( Strategy )</h2><p><strong>定义</strong></p>
<p>​    策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。</p>
<p>​    分析下定义，策略模式定义和封装了一系列的算法，它们是可以相互替换的，也就是说它们具有共性，而它们的共性就体现在策略接口的行为上，另外为了达到最后一句话的目的，也就是说让算法独立于使用它的客户而独立变化，我们需要让客户端依赖于策略接口。</p>
<p><strong>问题</strong></p>
<p>​    在软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。</p>
<p>​    这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p>
<p>​    如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？</p>
<p><strong>方案</strong></p>
<p>​    把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。</p>
<p>​    比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。</p>
<p><strong>结构</strong></p>
<p>​    策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。</p>
<p><img src="\image\java设计模式\策略模式结构.png" alt="策略模式结构"></p>
<p>​    这个模式涉及到三个角色：</p>
<p>　    ●　　<strong>环境(Context)角色：</strong>持有一个Strategy的引用。</p>
<p>　　●　　<strong>抽象策略(Strategy)角色：</strong>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</p>
<p>　　●　　<strong>具体策略(ConcreteStrategy)角色：</strong>包装了相关的算法或行为。</p>
<p><strong>源代码</strong> </p>
<p>​    抽象策略类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    具体策略类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环境角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有一个具体策略的对象</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体策略对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy    具体策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        strategy.strategyInterface();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>实际例子</strong></p>
<p>​    假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p>
<p>　　根据描述，折扣是根据以下的几个算法中的一个进行的：</p>
<p>　　算法一：对初级会员没有折扣。</p>
<p>　　算法二：对中级会员提供10%的促销折扣。</p>
<p>　　算法三：对高级会员提供20%的促销折扣。</p>
<p>　　使用策略模式来实现的结构图如下：</p>
<p><img src="\image\java设计模式\策略模式-实际例子.png" alt="策略模式-实际例子"></p>
<p>​    实现代码</p>
<p>​    抽象折扣类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算图书的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> booksPrice    图书的原价</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    计算出打折后的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    初级会员折扣类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimaryMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"对于初级会员的没有折扣"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    中级会员折扣类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntermediateMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">"对于中级会员的折扣为10%"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice * <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    高级会员折扣类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"对于高级会员的折扣为20%"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    价格类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Price</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有一个具体的策略对象</span></span><br><span class="line">    <span class="keyword">private</span> MemberStrategy strategy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体的策略对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy    具体的策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Price</span><span class="params">(MemberStrategy strategy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算图书的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> booksPrice    图书的原价</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    计算出打折后的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quote</span><span class="params">(<span class="keyword">double</span> booksPrice)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.calcPrice(booksPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择并创建需要使用的策略对象</span></span><br><span class="line">        MemberStrategy strategy = <span class="keyword">new</span> AdvancedMemberStrategy();</span><br><span class="line">        <span class="comment">//创建环境</span></span><br><span class="line">        Price price = <span class="keyword">new</span> Price(strategy);</span><br><span class="line">        <span class="comment">//计算价格</span></span><br><span class="line">        <span class="keyword">double</span> quote = price.quote(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"图书的最终价格为："</span> + quote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。</p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    策略模式将相关的算法作为一个算法族进行管理。算法实现之间可以相互替换，使得程序结构灵活，并且客户端不会依赖算法的具体实现。</p>
<p>​    缺点：</p>
<p>​    客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。</p>
<p><strong>适用场景</strong></p>
<p>​    1.针对同一类型问题的多种处理方式，仅仅是具体行为有差别时；<br>​    2.需要安全地封装多种同一类型的操作时；<br>​    3.出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。</p>
<p><strong>总结</strong></p>
<p>​    某一个任务或功能，可以有多种算法来实现，并且不同算法之间还有很大的差异。这个时候可以使用策略模式来管理这组相关的算法实现，并且可以使得使用策略的客户端不依赖于具体的算法实现。</p>
<p>​    变化的是实现相同功能的不同算法，不变的是客户端对于这个功能的使用与需求。策略模式可以将这个问题的变化的内容和不变的内容分开。</p>
<p>参考资料：<a href="http://blog.csdn.net/u012124438/article/details/70039943" target="_blank" rel="noopener">设计模式学习之策略模式</a></p>
<p>​           <a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">《JAVA与模式》之策略模式</a></p>
<p>​                   <a href="http://blog.csdn.net/jason0539/article/details/45007553" target="_blank" rel="noopener">Java设计模式之策略模式</a></p>
<h2 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式( Template Method )"></a>模板方法模式( Template Method )</h2><p><strong>定义</strong></p>
<p>​    定义一个算法中的操作框架，而将一些步骤延迟到子类中。使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。（Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure）</p>
<p><strong>问题</strong></p>
<p>​    某一些流程的骨架是确定的，但是每一步骤具体的细节会随着情况的改变发生大的变化。例如煮饭，都是第一步烧水，第二步做主食，第三步做菜。但是主食做什么，菜又做什么，这些要看具体的情况而定。</p>
<p><strong>方案</strong></p>
<p>​    准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</p>
<p><strong>结构</strong></p>
<p>​    模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p>
<p>　　模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p>
<p>　　模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示：</p>
<p><img src="\image\java设计模式\模板方法模式结构图.png" alt="模板方法模式结构图"></p>
<p>这里涉及到两个角色：</p>
<p>　　抽象模板(Abstract Template)角色有如下责任：</p>
<p>　　■　　定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</p>
<p>　　■　　定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p>
<p>　　具体模板(Concrete Template)角色又如下责任：</p>
<p>　　■　　实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</p>
<p>　　■　　每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p>
<p><strong>实际例子</strong></p>
<p>​    举个例子，以准备去学校所要做的工作（prepareGotoSchool）为例，假设需要分三步：穿衣服（dressUp），吃早饭（eatBreakfast），带上东西（takeThings）。学生和老师要做得具体事情肯定有所区别。</p>
<p>​    抽象类AbstractClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//抽象类定义整个流程骨架</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareGotoSchool</span><span class="params">()</span></span>&#123;</span><br><span class="line">          dressUp();</span><br><span class="line">          eatBreakfast();</span><br><span class="line">          takeThings();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//以下是不同子类根据自身特性完成的具体步骤</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dressUp</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eatBreakfast</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">takeThings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    具体类ConcreteClass<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dressUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(“穿校服<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">     @Override</span></span><br><span class="line"><span class="string">     protected void eatBreakfast() &#123;</span></span><br><span class="line"><span class="string">          System.out.println(“吃妈妈做好的早饭"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">takeThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(“背书包，带上家庭作业和红领巾<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">AbstractPerson</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dressUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(“穿工作服<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">     @Override</span></span><br><span class="line"><span class="string">     protected void eatBreakfast() &#123;</span></span><br><span class="line"><span class="string">          System.out.println(“做早饭，照顾孩子吃早饭"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">takeThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(“带上昨晚准备的考卷<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>​    测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Student student = <span class="keyword">new</span> Student()</span><br><span class="line">     student.prepareGotoSchool();</span><br><span class="line">    </span><br><span class="line">     Teacher teacher  = <span class="keyword">new</span> Teacher()</span><br><span class="line">     teacher.prepareGotoSchool();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>优缺点</strong></p>
<p>​    在全面解析完模板方法模式后，我来分析下其优缺点：</p>
<p>​    优点：</p>
<ul>
<li><p>提高代码复用性<br>将相同部分的代码放在抽象的父类中</p>
</li>
<li><p>提高了拓展性<br>将不同的代码放入不同的子类中，通过对子类的扩展增加新的行为</p>
</li>
<li><p>实现了反向控制<br>通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，实现了反向控制 &amp; 符合“开闭原则”</p>
<p>缺点 ： </p>
<p>引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度。</p>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复；</li>
<li>控制子类的扩展。 </li>
</ul>
<p><strong>总结</strong></p>
<p>​    模板方法模式将那些不变的，稳定的内容或步骤放在一个抽象类中。将那些需要随着具体情况发生变化的内容延迟到子类实现。主要是抽象类中的骨架部分非常重要。<br>​    有一些流程，虽然步骤的具体细节会不停的变化，但是向上抽象一层，则发现步骤是固定的。模板方法模式就是将这些固定的步骤抽象出来并且固定，让那些细节可以在子类中随着具体情况发生改变。</p>
<p>参考资料：<a href="http://www.cnblogs.com/jswang/p/7697732.html" target="_blank" rel="noopener">模板方法模式</a></p>
<p>​                  <a href="http://blog.csdn.net/carson_ho/article/details/54910518" target="_blank" rel="noopener">模板方法模式（Template Method） - 最易懂的设计模式解析</a></p>
<pre><code>[Java设计模式之模板方法模式（Template Method）](http://blog.csdn.net/jason0539/article/details/45037535)
</code></pre><h2 id="观察者模式（-Observer-Pattern-）"><a href="#观察者模式（-Observer-Pattern-）" class="headerlink" title="观察者模式（ Observer Pattern ）"></a>观察者模式（ Observer Pattern ）</h2><p><strong>定义</strong></p>
<p>​    ==定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。==</p>
<p>​    在这里先讲一下面向对象设计的一个重要原则——单一职责原则。因此系统的每个对象应该将重点放在问题域中的离散抽象上。因此理想的情况下，一个对象只做一件事情。这样在开发中也就带来了诸多的好处：提供了重用性和维护性，也是进行重构的良好的基础。</p>
<p>​    因此几乎所有的设计模式都是基于这个基本的设计原则来的。</p>
<p>​    观察者模式是关于多个对象想知道一个对象中数据变化情况的一种成熟的模式。观察者模式中有一个称作“主题”的对象和若干个称作“观察者”的对象，“主题”和“观察者”间是一种一对多的依赖关系，当“主题”的状态发生变化时，所有“观察者”都得到通知。前面所述的“求职中心”相当于观察者模式的一个具体“主题”；每个“求职者”相当于观察者模式中的一个具体“观察者”。</p>
<p><strong>问题</strong></p>
<p>​    一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>解决方案</strong></p>
<p>​    一个被观察者管理所有相依于它的观察者物件，并且在本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p>
<p><strong>结构</strong></p>
<p>观察者模式结构的类图如下所示：</p>
<p><img src="\image\java设计模式\观察者模式结构图.png" alt="观察者模式结构图"></p>
<p>图例说明</p>
<ul>
<li>图片中的空心三角箭头，代表着继承（extends）或实现（Implement）关系， 由继承者/实现者 指向 被继承者/被继承者。</li>
<li>图片中的实心三角箭头且箭头末尾没有圆圈的， 代表着单一的引用关系， 但是被引用的对象也有可能被其他对象引用。</li>
<li>图片中的实心三角箭头且箭头末尾有圆圈的， 代表着一对多的引用关系。</li>
<li>图片中的末端有圆圈的虚线是一个对方法体内容用伪代码说明的关系</li>
</ul>
<p>观察者模式的结构中包含四种角色：</p>
<p>​    （1）主题（Subject）：主题是一个接口，该接口规定了具体主题需要实现的方法，比如，添加、删除观察者以及通知观察者更新数据的方法。</p>
<p>​    （2）观察者（Observer）：观察者是一个接口，该接口规定了具体观察者用来更新数据的方法。</p>
<p>​    （3）具体主题（ConcreteSubject）：具体主题是实现主题接口类的一个实例，该实例包含有可以经常发生变化的数据。具体主题需使用一个集合，比如ArrayList，存放观察者的引用，以便数据变化时通知具体观察者。</p>
<p>​    （4）具体观察者（ConcreteObserver）：具体观察者是实现观察者接口类的一个实例。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，使自己成为它的观察者，或让这个具体主题将自己从具体主题的集合中删除，使自己不再是它的观察者。</p>
<p><strong>适用场景</strong></p>
<p>​    1) 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</p>
<p>​    2) 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</p>
<p>​    3) 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</p>
<p><strong>实际例子</strong></p>
<p>​    珠宝商运送一批钻石，有黄金强盗准备抢劫，珠宝商雇佣了私人保镖，警察局也派人护送，于是当运输车上路的时候，强盗保镖警察都要观察运输车一举一动，</p>
<p>​    抽象的观察者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watcher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    抽象的被观察者(主题，subject)，在其中声明方法（添加、移除观察者，通知观察者）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWatcher</span><span class="params">(Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWatcher</span><span class="params">(Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyWatchers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    具体的观察者</p>
<p>​    保镖<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          System.out.println(“运输车有行动，保安贴身保护<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>​    强盗<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          System.out.println(“运输车有行动，强盗准备动手<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>​    警察<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Police</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          System.out.println(“运输车有行动，警察护航<span class="string">");</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>​    具体的被观察者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> List&lt;Watcher&gt; list = <span class="keyword">new</span> ArrayList&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWatcher</span><span class="params">(Watcher watcher)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          list.add(watcher);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWatcher</span><span class="params">(Watcher watcher)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          list.remove(watcher);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyWatchers</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (Watcher watcher : list)</span><br><span class="line">          &#123;</span><br><span class="line">               watcher.update();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          Transporter transporter = <span class="keyword">new</span> Transporter();</span><br><span class="line">    </span><br><span class="line">          Police police = <span class="keyword">new</span> Police();</span><br><span class="line">          Security security = <span class="keyword">new</span> Security();</span><br><span class="line">          Thief thief = <span class="keyword">new</span> Thief();</span><br><span class="line">    </span><br><span class="line">          transporter.addWatcher(police);</span><br><span class="line">          transporter.addWatcher(security);</span><br><span class="line">          transporter.addWatcher(thief);</span><br><span class="line">    </span><br><span class="line">          transporter.notifyWatchers();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>我推你拉模型</strong></p>
<p>​    例子中没有关于数据和状态的变化通知，只是简单通知到各个观察者，告诉他们被观察者有行动。<br>观察者模式在关于目标角色、观察者角色通信的具体实现中，有两个版本。</p>
<p>​    一种情况便是目标角色在发生变化后，仅仅告诉观察者角色“我变化了”，观察者角色如果想要知道具体的变化细节，则就要自己从目标角色的接口中得到。这种模式被很形象的称为：拉模式——就是说变化的信息是观察者角色主动从目标角色中“拉”出来的。</p>
<p>​    还有一种方法，那就是我目标角色“服务一条龙”，通知你发生变化的同时，通过一个参数将变化的细节传递到观察者角色中去。这就是“推模式”——管你要不要，先给你啦。</p>
<p>​    这两种模式的使用，取决于系统设计时的需要。如果目标角色比较复杂，并且观察者角色进行更新时必须得到一些具体变化的信息，则“推模式”比较合适。如果目标角色比较简单，则“拉模式”就很合适啦。</p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    （1）具体主题和具体观察者是松耦合关系。由于主题接口仅仅依赖于观察者接口，因此具体主题只是知道它的观察者是实现观察者接口的某个类的实例，但不需要知道具体是哪个类。同样，由于观察者仅仅依赖于主题接口，因此具体观察者只是知道它依赖的主题是实现主题接口的某个类的实例，但不需要知道具体是哪个类。</p>
<p>​    （2）观察者模式满足“开-闭原则”。主题接口仅仅依赖于观察者接口，这样，就可以让创建具体主题的类也仅仅是依赖于观察者接口，因此，如果增加新的实现观察者接口的类，不必修改创建具体主题的类的代码。。同样，创建具体观察者的类仅仅依赖于主题接口，如果增加新的实现主题接口的类，也不必修改创建具体观察者类的代码。</p>
<p>​    ( 3 )  可以将一个对象的改变通知到依赖它的对象。这是观察者模式完成的基本任务，并且由于抽象观察者与抽象主题的存在，具体观察者和具体主题可以独立变化，而不影响另外一方。</p>
<p>​    缺点：</p>
<p>​    增加了类结构层级，使得设计时比较复杂。</p>
<p><strong>总结</strong></p>
<p>​    在观察者模式对应的问题中，具体观察者会发生改变，并且具体主题也会发生改变。但是主题一定是要被观察者来关注的，这个关系是不会发生改变的。观察者模式向上抽象了一层，利用抽象观察者接口和抽象主题接口，使得主题与观察者的一对多关系被固定下来。同时也将观察者与主题的具体类别解耦，使得一方的改变不会影响到另外一方。</p>
<p>参考资料：<a href="http://blog.csdn.net/lengxiao1993/article/details/55511101" target="_blank" rel="noopener">设计模式拾荒之观察者模式( Observer Pattern )： MVC的进一步泛化</a></p>
<p>​           <a href="http://www.cnblogs.com/liuzhen1995/p/5975352.html" target="_blank" rel="noopener">设计模式学习笔记（二：观察者模式）</a></p>
<pre><code>[深入浅出观察者模式](http://blog.csdn.net/ai92/article/details/375691)
</code></pre><p>​           <a href="http://blog.csdn.net/jason0539/article/details/45055233" target="_blank" rel="noopener">Java设计模式之观察者模式</a></p>
<h2 id="迭代子-Iterator-模式"><a href="#迭代子-Iterator-模式" class="headerlink" title="迭代子(Iterator)模式"></a>迭代子(Iterator)模式</h2><p><strong>定义</strong></p>
<p>​    在软件构建过程中，集合对象内部结构常常变化各异，但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作提供了可能。</p>
<p>​    使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。</p>
<p>​    迭代子(Iterator)模式又叫游标(Cursor)模式，是对象的行为模式。==迭代子模式可以提供一种方法顺序访问一个聚集对象中各个元素 , 而又不需暴露该对象的内部表示。==</p>
<p><strong>聚集和JAVA聚集</strong></p>
<p>​    多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。数组就是最基本的聚集，也是其他的JAVA聚集对象的设计基础。</p>
<p>　　JAVA聚集对象是实现了共同的java.util.Collection接口的对象，是JAVA语言对聚集概念的直接支持。从1.2版开始，JAVA语言提供了很多种聚集，包括Vector、ArrayList、HashSet、HashMap、Hashtable等，这些都是JAVA聚集的例子。</p>
<p><strong>问题背景</strong></p>
<p>​    顺序访问聚集中的对象，主要用于集合中。一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。 迭代子模式为遍历集合提供了统一的接口方法。从而使得客户端不需要知道聚集的内部结构就能就能对聚集进行遍历等操作。Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 </p>
<p>​    例如，如果没有使用Iterator，遍历一个数组的方法是使用索引：<br>​    for(int i=0; i&lt;array.size(); i++) {<br>​        … get(i) … </p>
<p>​    }<br>​    而访问一个链表（LinkedList）又必须使用while循环： </p>
<p>​    while((e=e.next())!=null) { … e.data() … } </p>
<p>​    以上两种方法客户端都必须事先知道集合的内部结构，访问代码和集合本身是紧耦合，无法将访问逻辑从集合类和客户端代码中分离出来，每一种集合对应一种遍历方法，客户端代码无法复用。 </p>
<p>​    更恐怖的是，如果以后需要把ArrayList更换为LinkedList，则原来的客户端代码必须全部重写。 </p>
<p>​    为解决以上问题，Iterator模式总是用同一种逻辑来遍历集合：<br>​    for(Iterator it = c.iterater(); it.hasNext(); ) { … } </p>
<p>​    奥秘在于客户端自身不维护遍历集合的”指针”，所有的内部状态（如当前元素位置，是否有下一个元素）都由Iterator来维护，而这个Iterator由集合类通过工厂方法生成，因此，它知道如何遍历整个集合。 </p>
<p>​    客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。</p>
<p><strong>迭代子模式的结构</strong></p>
<p>​    迭代子模式有两种实现方式，分别是<strong>白箱聚集与外禀迭代子</strong>和<strong>黑箱聚集于内禀迭代子。</strong></p>
<p>​    <strong>白箱聚集与外禀(bing, 三声)迭代子</strong></p>
<p>​    如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做白箱聚集。聚集对象向外界提供同样的宽接口，如下图所示：</p>
<p><img src="\image\java设计模式\迭代子模式-白箱聚集结构.png" alt="迭代子模式-白箱聚集结构">    </p>
<p>​    由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代子叫做<strong>游标迭代子（Cursor Iterator）</strong>。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做<strong>外禀迭代子（Extrinsic Iterator）</strong>。</p>
<p>​    现在看一看白箱聚集与外禀迭代子的实现。一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代子可以通过聚集的遍历方法实现迭代功能。</p>
<p>　    因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代子角色往往仅仅保持迭代的游标位置。</p>
<p>　　一个典型的由白箱聚集与外禀迭代子组成的系统如下图所示，在这个实现中具体迭代子角色是一个外部类，而具体聚集角色向外界提供遍历聚集元素的接口。</p>
<p><img src="\image\java设计模式\白箱聚集与外禀迭代子-示意图.png" alt="白箱聚集与外禀迭代子-示意图"></p>
<p>​    注意，从上图可以看出，在具体迭代子中关联了一个具体的聚集对象！</p>
<p>​    迭代子模式涉及到以下几个角色：</p>
<p>　　●　　抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。</p>
<p>　　●　　具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。</p>
<p>　　●　　聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。</p>
<p>　　●　　具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。</p>
<p>　　●　　客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。</p>
<p>​    <strong>源代码</strong></p>
<p>​    抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，创建相应迭代子对象的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    具体聚集角色类，实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title">Aggregate</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] objArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入聚合对象的具体内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteAggregate</span><span class="params">(Object[] objArray)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objArray = objArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法：向外界提供聚集元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElement</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index &lt; objArray.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> objArray[index];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法：向外界提供聚集的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objArray.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    抽象迭代子角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    具体迭代子角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有被迭代的具体的聚合对象</span></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate agg;</span><br><span class="line">    <span class="comment">//内部索引，记录当前迭代到的索引位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录当前聚集对象的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(ConcreteAggregate agg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.agg = agg;</span><br><span class="line">        <span class="keyword">this</span>.size = agg.size();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> agg.getElement(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (index &gt;= size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(index &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　    客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object[] objArray = &#123;<span class="string">"One"</span>,<span class="string">"Two"</span>,<span class="string">"Three"</span>,<span class="string">"Four"</span>,<span class="string">"Five"</span>,<span class="string">"Six"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建聚合对象</span></span><br><span class="line">        Aggregate agg = <span class="keyword">new</span> ConcreteAggregate(objArray);</span><br><span class="line">        <span class="comment">//循环输出聚合对象中的值</span></span><br><span class="line">        Iterator it = agg.createIterator();</span><br><span class="line">        <span class="keyword">while</span>(!it.isDone())&#123;</span><br><span class="line">            System.out.println(it.currentItem());</span><br><span class="line">            it.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代子对象。在得到迭代子的实例后，客户端开始迭代过程，打印出所有的聚集元素。</p>
<p>​    <strong>外禀迭代子的意义</strong></p>
<p>​    一个常常会问的问题是：既然白箱聚集已经向外界提供了遍历方法，客户端已经可以自行进行迭代了，为什么还要应用迭代子模式，并创建一个迭代子对象进行迭代呢？</p>
<p>　　客户端当然可以自行进行迭代，不一定非得需要一个迭代子对象。但是，迭代子对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代子责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代子作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。</p>
<p>　　此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代子模式和一个外界的迭代子对象是有意义的。具有同一迭代接口的不同迭代子对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。</p>
<p><strong>黑箱聚集与内禀迭代子</strong></p>
<p>​    如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的<strong>窄接口</strong>。</p>
<p>　　聚集对象为迭代子对象提供一个宽接口，而为其他对象提供一个窄接口。换言之，聚集对象的内部结构应当对迭代子对象适当公开，以便迭代子对象能够对聚集对象有足够的了解，从而可以进行迭代操作。但是，聚集对象应当避免向其他的对象提供这些方法，因为其他对象应当经过迭代子对象进行这些工作，而不是直接操控聚集对象。</p>
<p><img src="\image\java设计模式\黑箱聚集与内禀迭代子-结构示意图.png" alt="黑箱聚集与内禀迭代子-结构示意图"></p>
<p>　    在JAVA语言中，实现双重接口的办法就是将迭代子类设计成聚集类的内部成员类。这样迭代子对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构。下面给出一个示意性的实现，说明这种双重接口的结构时怎么样产生的，以及使用了双重接口结构之后迭代子模式的实现方案。这种同时保证聚集对象的封装和迭代子功能的实现的方案叫做<strong>黑箱实现方案</strong>。</p>
<p>　　由于迭代子是聚集的内部类，迭代子可以自由访问聚集的元素，所以迭代子可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代子是在聚集的结构之内定义的，因此这样的迭代子又叫做<strong>内禀迭代子（Intrinsic Iterator）。</strong></p>
<p>​    为了说明黑箱方案的细节，这里给出一个示意性的黑箱实现。在这个实现里，聚集类ConcreteAggregate含有一个内部成员类ConcreteIterator，也就是实现了抽象迭代子接口的具体迭代子类，同时聚集并不向外界提供访问自己内部元素的方法。</p>
<p><img src="\image\java设计模式\内禀迭代子-实现代码结构图.png" alt="内禀迭代子-实现代码结构图"></p>
<p>​    从上图可以看出，相对于外禀迭代子，内禀迭代子由于是聚集对象的内部类，所以它(ConcreteIterator)不用持有具体聚集对象的引用。</p>
<p>​    <strong>源代码</strong></p>
<p>​    抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，创建相应迭代子对象的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    抽象迭代子角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    具体聚集角色类，实现了抽象聚集角色所要求的接口，也就是createIterator()方法。此外，聚集类有一个内部成员类ConcreteIterator，这个内部类实现了抽象迭代子角色所规定的接口；而工厂方法createIterator()所返还的就是这个内部成员类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">​    </span><br><span class="line">    <span class="keyword">private</span> Object[] objArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入聚合对象的具体内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteAggregate</span><span class="params">(Object[] objArray)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objArray = objArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部成员类，具体迭代子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">//内部索引，记录当前迭代到的索引位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录当前聚集对象的大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">this</span>.size = objArray.length;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> objArray[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (index &gt;= size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(index &lt; size)</span><br><span class="line">            &#123;</span><br><span class="line">                index ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object[] objArray = &#123;<span class="string">"One"</span>,<span class="string">"Two"</span>,<span class="string">"Three"</span>,<span class="string">"Four"</span>,<span class="string">"Five"</span>,<span class="string">"Six"</span>&#125;;</span><br><span class="line">        <span class="comment">//创建聚合对象</span></span><br><span class="line">        Aggregate agg = <span class="keyword">new</span> ConcreteAggregate(objArray);</span><br><span class="line">        <span class="comment">//循环输出聚合对象中的值</span></span><br><span class="line">        Iterator it = agg.createIterator();</span><br><span class="line">        <span class="keyword">while</span>(!it.isDone())&#123;</span><br><span class="line">            System.out.println(it.currentItem());</span><br><span class="line">            it.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.operation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代子对象。在得到迭代子的实例后，客户端开始迭代过程，打印出所有的聚集元素。</p>
<p><strong>主动迭代子和被动迭代子</strong></p>
<p>​    主动迭代子和被动迭代子又称作外部迭代子和内部迭代子。</p>
<p>　　所谓主动（外部）迭代子，指的是由客户端来控制迭代下一个元素的步骤，客户端会明显调用迭代子的next()等迭代方法，在遍历过程中向前进行。</p>
<p>　　所谓被动（内部）迭代子，指的是由迭代子自己来控制迭代下一个元素的步骤。因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传递给迭代子，迭代子在迭代的时候会在每个元素上执行这个操作，类似于JAVA的回调机制。</p>
<p>　　总体来说外部迭代器比内部迭代器要灵活一些，因此我们常见的实现多属于主动迭代子。</p>
<p><strong>静态迭代子和动态迭代子</strong></p>
<p>​    ●　　静态迭代子由聚集对象创建，并持有聚集对象的一份快照(snapshot)，在产生后这个快照的内容就不再变化。客户端可以继续修改原聚集的内容，但是迭代子对象不会反映出聚集的新变化。</p>
<p>　　静态迭代子的好处是它的安全性和简易性，换言之，静态迭代子易于实现，不容易出现错误。但是由于静态迭代子将原聚集复制了一份，因此它的短处是对时间和内存资源的消耗。</p>
<p>　　●　　动态迭代子则与静态迭代子完全相反，在迭代子被产生之后，迭代子保持着对聚集元素的引用，因此，任何对原聚集内容的修改都会在迭代子对象上反映出来。</p>
<p>　　完整的动态迭代子不容易实现，但是简化的动态迭代子并不难实现。大多数JAVA设计师遇到的迭代子都是这种简化的动态迭代子。为了说明什么是简化的动态迭代子，首先需要介绍一个新的概念：<strong>Fail Fast</strong>。</p>
<p><strong>Fail Fast</strong></p>
<p>​    JAVA语言以接口java.util.Iterator的方式支持迭代子模式，Collection接口要求提供iterator()方法，此方法在调用时返还一个Iterator类型的对象。而作为Collection接口的子类型，AbstractList类的内部成员类Itr便是实现Iterator接口的类。</p>
<p>　Itr类的源代码如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element to be returned by subsequent call to next.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Index of element returned by most recent call to next or</span></span><br><span class="line"><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span></span><br><span class="line"><span class="comment">         * to remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">         * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">         * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != size();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            E next = get(cursor);</span><br><span class="line">            lastRet = cursor++;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>　    从Itr类的源代码中可以看到，方法checkForComodification()会检查聚集的内容是否刚刚被外界直接修改过(不是通过迭代子提供的方法修改的)。如果在迭代开始后，聚集的内容被外界绕过迭代子对象而直接修改的话，这个方法会立即抛出ConcurrentModificationException()异常。</p>
<p>​    这就是说，AbstractList.Itr迭代子是一个Fail Fast的迭代子。</p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    （1）迭代子模式简化了聚集的接口。迭代子具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。</p>
<p>　　（2）每一个聚集对象都可以有一个或多个迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。</p>
<p>　　（3）由于遍历算法被封装在迭代子角色里面，因此迭代的算法可以独立于聚集角色变化。</p>
<p>​    缺点：</p>
<p>​    暂时想到的缺点就是，会增加结构层次，并且在聚集类中增加方法，并且会关联到迭代子对象。</p>
<p><strong>总结</strong></p>
<p>​    迭代子模式可以为不同的聚集对象提供一个遍历集合中所有元素的统一接口，使得客户端在遍历集合元素时，不需要考虑集合的内部实现和访问方式。</p>
<p>​    聚集对象的内部结构在变化，访问方式也在变化，但是客户端始终是需要对集合元素进行遍历的需求不会变化。迭代子模式很好的屏蔽了集合内部变化对客户端遍历元素的影响。</p>
<p>​    要注意下外禀迭代子和内禀迭代子的实现。</p>
<p>参考资料：<a href="http://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html" target="_blank" rel="noopener">《JAVA与模式》之迭代子模式</a></p>
<p>​           <a href="http://www.cnblogs.com/JAYIT/p/5081695.html" target="_blank" rel="noopener">java设计模式—-迭代子模式</a></p>
<p>​           <a href="http://blog.csdn.net/jason0539/article/details/45070441" target="_blank" rel="noopener">Java设计模式之迭代子模式</a></p>
<h2 id="责任链模式（Chain-fo-Responsibility）"><a href="#责任链模式（Chain-fo-Responsibility）" class="headerlink" title="责任链模式（Chain fo Responsibility）"></a>责任链模式（Chain fo Responsibility）</h2><p><strong>定义</strong></p>
<p>​    使多个对象都有机会处理请求，从而避免了请求的发送和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>
<p><strong>模式解析</strong></p>
<p>​    责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>
<p>　　责任链模式的要点主要是：</p>
<p>　　1、有多个对象共同对一个任务进行处理。</p>
<p>　　2、这些对象使用链式存储结构，形成一个链，每个对象知道自己的下一个对象。</p>
<p>　　3、一个对象对任务进行处理，可以添加一些操作后将对象传递个下一个任务。也可以在此对象上结束任务的处理，并结束任务。</p>
<p>　　3、客户端负责组装链式结构，但是客户端不需要关心最终是谁来处理了任务。</p>
<p><strong>结构</strong></p>
<p>​    责任链模式结构的类图，如下图所示：</p>
<p><img src="\image\java设计模式\责任链模式-结构示意图.jpg" alt="责任链模式-结构示意图"></p>
<p>​    责任链模式涉及到的角色：</p>
<p>​    抽象处理者角色(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。</p>
<p>​    具体处理者角色(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。</p>
<p><strong>源代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有后继的责任对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示意处理请求的方法，虽然这个示意方法是没有传入参数的</span></span><br><span class="line"><span class="comment">     * 但实际是可以传入参数的，根据具体需要来选择是否传递参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 赋值方法，设置后继的责任对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    具体处理者角色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理方法，调用此方法处理请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否有后继的责任对象</span></span><br><span class="line"><span class="comment">         * 如果有，就转发请求给后继的责任对象</span></span><br><span class="line"><span class="comment">         * 如果没有，则处理请求</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>)</span><br><span class="line">        &#123;            </span><br><span class="line">            System.out.println(<span class="string">"放过请求"</span>);</span><br><span class="line">            getSuccessor().handleRequest();            </span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;            </span><br><span class="line">            System.out.println(<span class="string">"处理请求"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//组装责任链</span></span><br><span class="line">        Handler handler1 = <span class="keyword">new</span> ConcreteHandler();</span><br><span class="line">        Handler handler2 = <span class="keyword">new</span> ConcreteHandler();</span><br><span class="line">        handler1.setSuccessor(handler2);</span><br><span class="line">        <span class="comment">//提交请求</span></span><br><span class="line">        handler1.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    可以看出，客户端创建了两个处理者对象，并指定第一个处理者对象的下家是第二个处理者对象，而第二个处理者对象没有下家。然后客户端将请求传递给第一个处理者对象。</p>
<p>​    由于本示例的传递逻辑非常简单：只要有下家，就传给下家处理；如果没有下家，就自行处理。</p>
<p>​    因此，第一个处理者对象接到请求后，会将请求传递给第二个处理者对象。由于第二个处理者对象没有下家，于是自行处理请求。活动时序图如下所示。</p>
<p><strong>实际例子</strong></p>
<p>​    申请聚餐费用的管理，申请聚餐费用的大致流程一般是，由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。<br>​    不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。</p>
<p><img src="\image\java设计模式\责任链模式实例1.png" alt="责任链模式实例1"></p>
<p>​    当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。申请人只要直接与项目经理交互就可以，其余的工作在黑盒中，究竟流程是怎样的，最后是由谁审批通过的，申请人无需关心。</p>
<p><img src="\image\java设计模式\责任链模式实例1-类图.png" alt="责任链模式实例1-类图"></p>
<p>​    抽象处理者角色类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有下一个处理请求的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置下一个处理请求的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理聚餐费用的申请</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user    申请人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fee    申请的钱数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>        成功或失败的具体通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">handleFeeRequest</span><span class="params">(String user , <span class="keyword">double</span> fee)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    具体处理者角色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFeeRequest</span><span class="params">(String user, <span class="keyword">double</span> fee)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//项目经理权限比较小，只能在500以内</span></span><br><span class="line">        <span class="keyword">if</span>(fee &lt; <span class="number">500</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意张三的请求</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"张三"</span>.equals(user))</span><br><span class="line">            &#123;</span><br><span class="line">                str = <span class="string">"成功：项目经理同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;    </span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他人一律不同意</span></span><br><span class="line">                str = <span class="string">"失败：项目经理不同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//超过500，继续传递给级别更高的人处理</span></span><br><span class="line">            <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFeeRequest</span><span class="params">(String user, <span class="keyword">double</span> fee)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//部门经理的权限只能在1000以内</span></span><br><span class="line">        <span class="keyword">if</span>(fee &lt; <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意张三的请求</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"张三"</span>.equals(user))</span><br><span class="line">            &#123;</span><br><span class="line">                str = <span class="string">"成功：部门经理同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;    </span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他人一律不同意</span></span><br><span class="line">                str = <span class="string">"失败：部门经理不同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//超过1000，继续传递给级别更高的人处理</span></span><br><span class="line">            <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFeeRequest</span><span class="params">(String user, <span class="keyword">double</span> fee)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//总经理的权限很大，只要请求到了这里，他都可以处理</span></span><br><span class="line">        <span class="keyword">if</span>(fee &gt;= <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为了测试，简单点，只同意张三的请求</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"张三"</span>.equals(user))</span><br><span class="line">            &#123;</span><br><span class="line">                str = <span class="string">"成功：总经理同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;    </span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他人一律不同意</span></span><br><span class="line">                str = <span class="string">"失败：总经理不同意【"</span> + user + <span class="string">"】的聚餐费用，金额为"</span> + fee + <span class="string">"元"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果还有后继的处理对象，继续传递</span></span><br><span class="line">            <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    客户端类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先要组装责任链</span></span><br><span class="line">        Handler h1 = <span class="keyword">new</span> GeneralManager();</span><br><span class="line">        Handler h2 = <span class="keyword">new</span> DeptManager();</span><br><span class="line">        Handler h3 = <span class="keyword">new</span> ProjectManager();</span><br><span class="line">        h3.setSuccessor(h2);</span><br><span class="line">        h2.setSuccessor(h1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始测试</span></span><br><span class="line">        String test1 = h3.handleFeeRequest(<span class="string">"张三"</span>, <span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"test1 = "</span> + test1);</span><br><span class="line">        String test2 = h3.handleFeeRequest(<span class="string">"李四"</span>, <span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"test2 = "</span> + test2);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">        </span><br><span class="line">        String test3 = h3.handleFeeRequest(<span class="string">"张三"</span>, <span class="number">700</span>);</span><br><span class="line">        System.out.println(<span class="string">"test3 = "</span> + test3);</span><br><span class="line">        String test4 = h3.handleFeeRequest(<span class="string">"李四"</span>, <span class="number">700</span>);</span><br><span class="line">        System.out.println(<span class="string">"test4 = "</span> + test4);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">        </span><br><span class="line">        String test5 = h3.handleFeeRequest(<span class="string">"张三"</span>, <span class="number">1500</span>);</span><br><span class="line">        System.out.println(<span class="string">"test5 = "</span> + test5);</span><br><span class="line">        String test6 = h3.handleFeeRequest(<span class="string">"李四"</span>, <span class="number">1500</span>);</span><br><span class="line">        System.out.println(<span class="string">"test6 = "</span> + test6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    1、降低耦合度。它将请求的发送者和接收者解耦。</p>
<p>​    2、简化了对象。使得对象不需要知道链的结构。</p>
<p>​    3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</p>
<p>​    4、增加新的请求处理类很方便。</p>
<p>​    缺点：</p>
<p>​    1、不能保证请求一定被接收。</p>
<p>​    2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</p>
<p>​    3、可能不容易观察运行时的特征，有碍于除错。</p>
<p><strong>适用场景</strong></p>
<p>​    当有多个对象需要对某一个任务进行检查或者处理的时候，可以使用责任链模式来简化对象的关系。并且也可以使得任务发送者与任务接送者之间的解耦。</p>
<p><strong>总结</strong></p>
<p>​    责任链模式可以处理任务多个处理对象之间的组织关系，并且可以简化客户端的考虑。处理任务的对象可能会增加、减少，或者发生其他的结构变化，但是由于责任链的存在，客户端不需要考虑这些变化带来的影响，客户端只知道任务最终是会被处理的，这件事情是确定的。</p>
<p>参考资料： <a href="http://blog.csdn.net/lmb55/article/details/51052866" target="_blank" rel="noopener">大话设计模式—责任链模式</a></p>
<p>​            <a href="http://www.cnblogs.com/jyyzzjl/p/5187340.html" target="_blank" rel="noopener">[工作中的设计模式]责任链模式chain</a></p>
<p>​                <a href="https://www.jianshu.com/p/9d6987fd17a8" target="_blank" rel="noopener">设计模式之责任链模式</a></p>
<p>​                    <a href="http://blog.csdn.net/jason0539/article/details/45091639" target="_blank" rel="noopener">Java设计模式之责任链模式、职责链模式</a></p>
<h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式( Command )"></a>命令模式( Command )</h2><p><strong>定义</strong></p>
<p>​    命令模式是一个高内聚的模式，其定义为：Encapsulate a request as an object,there by letting you parameterize clients with different requests,queue or log requests,and support undoable operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请 求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）</p>
<p><strong>问题</strong></p>
<p>​    在软件设计中，我们经常会遇到某些对象发送请求，然后某些对象接受请求后执行，但发送请求的对象可能并不知道接受请求的对象是谁，执行的是什么动作。此时可通过 <strong>命令模式</strong> 来实现，让发送者和接受者完全的松耦合，这样可大大增强程序的灵活性。</p>
<p><strong>结构</strong></p>
<p>​    命令模式的示意性类图如下所示：</p>
<p><img src="\image\java设计模式\命令模式结构.jpg" alt="命令模式结构"></p>
<p>​     在命令模式结构图中包含如下几个角色：</p>
<ul>
<li><p>Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。</p>
</li>
<li><p>ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。</p>
</li>
<li><p>Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。</p>
</li>
<li><p>Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</p>
</li>
</ul>
<p>​    命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。</p>
<p><strong>适用情况</strong></p>
<p>​    1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</p>
<p>​    2.系统需要在不同的时间指定请求、将请求排队和执行请求。</p>
<p>​    3.系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</p>
<p>​    4.系统需要将一组操作组合在一起，即支持宏命令。</p>
<p><strong>实际例子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行命令的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令接收者Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tv</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">int</span> currentChannel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   System.out.println(<span class="string">"The televisino is on."</span>);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   System.out.println(<span class="string">"The television is off."</span>);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeChannel</span><span class="params">(<span class="keyword">int</span> channel)</span> </span>&#123;</span><br><span class="line">　　   <span class="keyword">this</span>.currentChannel = channel;</span><br><span class="line">　　   System.out.println(<span class="string">"Now TV channel is "</span> + channel);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开机命令ConcreteCommand</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandOn</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Tv myTv;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">CommandOn</span><span class="params">(Tv tv)</span> </span>&#123;</span><br><span class="line">　　   myTv = tv;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   myTv.turnOn();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关机命令ConcreteCommand</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandOff</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Tv myTv;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">CommandOff</span><span class="params">(Tv tv)</span> </span>&#123;</span><br><span class="line">　　   myTv = tv;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   myTv.turnOff();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//频道切换命令ConcreteCommand</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandChange</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Tv myTv;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">int</span> channel;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">CommandChange</span><span class="params">(Tv tv, <span class="keyword">int</span> channel)</span> </span>&#123;</span><br><span class="line">　　   myTv = tv;</span><br><span class="line"> 　　  <span class="keyword">this</span>.channel = channel;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   myTv.changeChannel(channel);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看作是遥控器Invoker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Command onCommand, offCommand, changeChannel;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">Control</span><span class="params">(Command on, Command off, Command channel)</span> </span>&#123;</span><br><span class="line"> 　　  onCommand = on;</span><br><span class="line"> 　　  offCommand = off;</span><br><span class="line">　　   changeChannel = channel;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   onCommand.execute();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　   offCommand.execute();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 　　  changeChannel.execute();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类Client</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  　　 <span class="comment">// 命令接收者Receiver</span></span><br><span class="line"> 　　  Tv myTv = <span class="keyword">new</span> Tv();</span><br><span class="line"> 　　  <span class="comment">// 开机命令ConcreteCommond</span></span><br><span class="line">  　　 CommandOn on = <span class="keyword">new</span> CommandOn(myTv);</span><br><span class="line">  　　 <span class="comment">// 关机命令ConcreteCommond</span></span><br><span class="line">  　　 CommandOff off = <span class="keyword">new</span> CommandOff(myTv);</span><br><span class="line">  　　 <span class="comment">// 频道切换命令ConcreteCommond</span></span><br><span class="line"> 　　  CommandChange channel = <span class="keyword">new</span> CommandChange(myTv, <span class="number">2</span>);</span><br><span class="line"> 　　  <span class="comment">// 命令控制对象Invoker</span></span><br><span class="line">　　   Control control = <span class="keyword">new</span> Control(on, off, channel);</span><br><span class="line"></span><br><span class="line">  　　 <span class="comment">// 开机</span></span><br><span class="line">  　　 control.turnOn();</span><br><span class="line"> 　　  <span class="comment">// 切换频道</span></span><br><span class="line"> 　　  control.changeChannel();</span><br><span class="line"> 　　  <span class="comment">// 关机</span></span><br><span class="line"> 　　  control.turnOff();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The televisino is on.</span><br><span class="line">Now TV channel is <span class="number">2</span></span><br><span class="line">The television is off.</span><br></pre></td></tr></table></figure></p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    1.降低对象之间的耦合度。</p>
<p>​    2.新的命令可以很容易地加入到系统中。</p>
<p>​    3.可以比较容易地设计一个组合命令。</p>
<p>​    4.调用同一方法实现不同的功能</p>
<p>​    缺点：</p>
<p>​    使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</p>
<p><strong>总结</strong></p>
<p>​    命令模式的本质就是将命令封装起来了，这样在命令发送者和接受者之间就构建了一个桥梁，使得他们解耦。所以每一个命令都不同，但是将命令封装并抽象一个层次，那么就可以对命令做一些共性的操作，比如撤销、记录和排队等。主要的作用还是在解耦命令的发送者和接受者。</p>
<p>参考资料：<a href="http://www.cnblogs.com/f-zhao/p/6203208.html" target="_blank" rel="noopener">设计模式-命令模式</a></p>
<p>​           <a href="http://blog.csdn.net/wwh578867817/article/details/51533263" target="_blank" rel="noopener">设计模式 —— 命令模式（Command Pattern）</a></p>
<p>​           <a href="http://www.cnblogs.com/lfxiao/p/6825644.html" target="_blank" rel="noopener">java设计模式之命令模式</a></p>
<p>​           <a href="http://blog.csdn.net/jason0539/article/details/45110355" target="_blank" rel="noopener">Java设计模式之命令模式</a></p>
<h2 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式( Memento )"></a>备忘录模式( Memento )</h2><p><strong>定义</strong></p>
<p>​    备忘录（Memento）模式又称标记（Token）模式。GOF给备忘录模式的定义为：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<p><strong>问题</strong></p>
<p>​    一个对象中一般都封装了很多属性，这些属性的值会随着程序的运行而变化。当我们需要保存某一时刻对象的某些值的时候，我们就再创建一个对象，将当前对象中的一些属性保存到新的对象中，当我们需要恢复的时候再从新的对象中取出属性值即可。这种想法就是备忘录模式。</p>
<p><strong>结构</strong></p>
<p>​    备忘录模式的类图：</p>
<p><img src="\image\java设计模式\备忘录模式结构.png" alt="备忘录模式结构"></p>
<p>角色分类</p>
<p>​    1) 备忘录（Memento）角色：备忘录角色存储“备忘发起角色”的内部状态。“备忘发起角色”根据需要决定备忘录角色存储“备忘发起角色”的哪些内部状态。为了防止“备忘发起角色”以外的其他对象访问备忘录。备忘录实际上有两个接口，“备忘录管理者角色”只能看到备忘录提供的窄接口——对于备忘录角色中存放的属性是不可见的。“备忘发起角色”则能够看到一个宽接口——能够得到自己放入备忘录角色中属性。</p>
<p>　　2) 备忘发起（Originator）角色：“备忘发起角色”创建一个备忘录，用以记录当前时刻它的内部状态。在需要时使用备忘录恢复内部状态。</p>
<p>　　3) 备忘录管理者（Caretaker）角色：负责保存好备忘录。不能对备忘录的内容进行操作或检查。</p>
<p><strong>备忘录模式的分类</strong></p>
<p>​    1.”白箱”备忘录模式的实现 </p>
<p><img src="\image\java设计模式\白箱-备忘录模式.png" alt="白箱-备忘录模式"></p>
<p>​    2.“黑箱”备忘录模式的实现</p>
<p><img src="\image\java设计模式\黑箱-备忘录模式.png" alt="黑箱-备忘录模式"></p>
<p>​    3.“多重”检查点 </p>
<p><img src="\image\java设计模式\多重检查点-备忘录模式.png" alt="多重检查点-备忘录模式"></p>
<p>​    4.”自述历史”模式 </p>
<p><img src="\image\java设计模式\自述历史-备忘录模式.png" alt="自述历史-备忘录模式"></p>
<p><strong>举例</strong></p>
<p>​    “白箱”备忘录模式的实现</p>
<p>​    备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。因此这个实现又叫做“白箱实现”。 </p>
<p>​    “白箱”实现将发起人角色的状态存储在一个大家都看得到的地方，因此是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。因此白箱实现仍然是有意义的。 </p>
<p>​    下面给出一个示意性的“白箱实现”。</p>
<p>​    demo 入口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类似白箱备忘录模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">3</span>;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(state);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建备忘录对象的 缓存起来</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            caretaker.saveMemento(originator.creatMementoObject());</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 进行设置重新还原</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            originator.setState(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">"发起人更改状态："</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">        originator.restoreMemento(caretaker.retrieveMemento());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    管理者，负责发起者的管理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管理者 负责管理Caretaker</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录的取值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">retrieveMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录的赋值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    备忘录，对发起者进行缓存的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 备忘录</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">this</span>.state = state;</span><br><span class="line">    ​    System.out.println(<span class="string">"备忘录 当前保存 状态："</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    发起者，负责备忘录的创建，修改，恢复<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起者</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">creatMementoObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将发起人恢复到备忘录对象所记载的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = memento.getState();</span><br><span class="line">        System.out.println(<span class="string">"恢复 备忘录 状态："</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    “黑箱”备忘录模式的实现</p>
<p>​    备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。这样的实现叫做“黑箱实现”。 </p>
<p>​    在JAVA语言中，实现双重接口的办法就是将备忘录角色类设计成发起人角色类的内部成员类。 </p>
<p>​    将Memento设成Originator类的内部类，从而将Memento对象封装在Originator里面；在外部提供一个标识接口 MementoIF给Caretaker以及其他对象。这样，Originator类看到的是Menmento的所有接口，而Caretaker以及其他 对象看到的仅仅是标识接口MementoIF所暴露出来的接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto.black;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类似黑箱备忘录模式</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     * ​</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">3</span>;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(state);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建备忘录对象的 缓存起来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        caretaker.saveMemento(originator.creatMementoObject());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 进行设置重新还原</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        originator.setState(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">" 黑箱发起人更改状态："</span> + originator.getState());</span><br><span class="line"></span><br><span class="line">        originator.restoreMemento(caretaker.retrieveMemento());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto.black;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemotoIF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto.black;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起者</span></span><br><span class="line"><span class="comment"> *  内部类如何拿到外部类的引用   https://zhidao.baidu.com/question/513464853.html</span></span><br><span class="line"><span class="comment"> *  已经外部类如何访问内部类中的成员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">creatMementoObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将发起人恢复到备忘录对象所记载的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(MemotoIF momIf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(((Memento) momIf).getState());</span><br><span class="line">        System.out.println(<span class="string">"黑箱恢复 备忘录 状态："</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​    <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> <span class="keyword">implements</span> <span class="title">MemotoIF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ​    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    ​    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    ​        <span class="keyword">this</span>.state = state;</span><br><span class="line">    ​        System.out.println(<span class="string">"黑箱备忘录 当前保存 状态："</span> + state);</span><br><span class="line">    ​    &#125;</span><br><span class="line"></span><br><span class="line">    ​    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​        <span class="keyword">return</span> state;</span><br><span class="line">    ​    &#125;</span><br><span class="line"></span><br><span class="line">    ​    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ​        <span class="keyword">this</span>.state = state;</span><br><span class="line">    ​    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wc.momoto.black;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 管理者 负责管理Caretaker</span></span><br><span class="line"><span class="comment"> * ​</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weichyang</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MemotoIF memento;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录的取值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MemotoIF <span class="title">retrieveMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录的赋值方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemento</span><span class="params">(MemotoIF memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多重检查点</strong></p>
<p>​    前面所给出的白箱和黑箱的示意性实现都是只存储一个状态的简单实现，也可以叫做只有一个检查点。常见的系统往往需要存储不止一个状态，而是需要存储多个状态，或者叫做有多个检查点。<br>　　备忘录模式可以将发起人对象的状态存储到备忘录对象里面，备忘录模式可以将发起人对象恢复到备忘录对象所存储的某一个检查点上。</p>
<p><strong>”自述历史”模式</strong></p>
<p>​    所谓“自述历史”模式(History-On-Self Pattern)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(Originator)角色、负责人(Caretaker)角色和备忘录 (Memento)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历 史”模式里面，发起人角色自己兼任负责人角色。 </p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    1、备忘录模式可以把发起人内部信息对象屏蔽起来，从而可以保持封装的边界。<br>​    2、简化了发起人类。当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</p>
<p>​    优点：</p>
<p>​    1、如果状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象比较昂贵。</p>
<p><strong>总结</strong></p>
<p>​    备忘录模式就是将一个对象的状态保存在它的外部，这样方便以后恢复这个对象的状态。由于备忘录角色和管理角色的存在，所以当发起者角色的状态变化方式不一样的时候，客户端仍然可以按照之前的方式来操作对象，而不需要进行改变。</p>
<p>​    可以说，备忘录模式使得客户端恢复对象状态的方式固定不变，而对象状态发生改变的方式可以改变并不会影响到客户端。</p>
<p>参考资料：<a href="http://blog.csdn.net/o279642707/article/details/60767258#t2" target="_blank" rel="noopener">23种设计模式之—备忘录模式</a></p>
<pre><code>[JAVA设计模式之：备忘录模式](http://blog.csdn.net/true100/article/details/50561081)
</code></pre><p>​          <a href="http://blog.csdn.net/u010425776/article/details/48008713" target="_blank" rel="noopener">“备忘录模式”就这么简单</a></p>
<h2 id="状态模式-state-pattern"><a href="#状态模式-state-pattern" class="headerlink" title="状态模式( state pattern )"></a>状态模式( state pattern )</h2><p><strong>定义</strong></p>
<p>​    允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式是一种对象行为型模式。</p>
<p>​    也就是说状态模式封装的非常好，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样。</p>
<p><strong>问题</strong></p>
<p>​    一个对象的内部状态会影响到它的行为，并且行为还会改变这个对象的状态。状态之间存在着复杂的切换关系。</p>
<p><strong>方案</strong></p>
<p>​    将对象的状态抽象出来，对象状态的改变也封装到状态对象中去。这样客户端和对象就不在关注状态改变的细节，以及状态和行为之间的改变也不需要关注。</p>
<p><strong>使用场景</strong></p>
<p>​    （1）对象的行为依赖于它的状态，并且可以在运行时根据状态改变行为。</p>
<p>​    （2）代码中包含大量与对象状态有关的if/else语句，这些条件对应于对象的各种状态，这些冗余条件语句的出现导致代码的可维护性和灵活性变差，这种情况适合使用状态模式进行优化。</p>
<p><strong>结构</strong></p>
<p>​    下图是状态模式结构的简单示意图</p>
<p><img src="\image\java设计模式\状态模式结构.jpg" alt="状态模式结构"></p>
<p>状态模式涉及的角色：</p>
<p>​    （1）Context类，定义客户端所感兴趣的接口，并且内部维护一个具体状态类的实例，从而维护了对象的现有状态。</p>
<p>​    （2）State：抽象状态类或状态接口，用以抽象封装行为。</p>
<p>​    （3）ConcreteState类：具体状态类，实现了State中的抽象方法。</p>
<p><strong>实际例子</strong></p>
<p>​    实例1</p>
<p>​    我们使用一个常见的场景，比如我们用手机打开了CSDN，找到了一篇文章，觉得写的不错，当我们点击“收藏”时，会突然跳出一个登录界面，这时我们才发觉原来我们还没有登录，如果我们已经登录成功，在点击“收藏”，就会有相应的业务逻辑处理。</p>
<p>​    实例2</p>
<p>​     我们每天都在乘电梯，电梯就涉及到状态（停止、运行等）和动作（敞开、关闭等）。那我们来看看电梯有哪些动作（映射到Java 中就是有多少方法）:开门、关门、运行、停止，就这四个动作，好，我们就用程序来实现一下电梯的动作，先看类图设计：</p>
<p><img src="\image\java设计模式\状态模式-电梯实例-类图1.png" alt="状态模式-电梯实例-类图1"></p>
<p>​    非常简单的类图，定义一个接口，然后是一个实现类，然后业务类Client 就可以调用，并运行起来，简单也来看看我们的程序,先看接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 定义一个电梯的接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先电梯门开启动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯门有开启，那当然也就有关闭了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯要能上能下，跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯还要能停下来，停不下来那就扯淡了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    然后看实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 电梯的实现类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lift</span> <span class="keyword">implements</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯门关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门关闭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门开启</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门开启..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯开始跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯上下跑起来..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>​    电梯的开、关、跑、停都实现了，开看业务是怎么调用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 模拟电梯的动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILift lift = <span class="keyword">new</span> Lift();</span><br><span class="line">        <span class="comment">//首先是电梯门开启，人进去</span></span><br><span class="line">        lift.open();</span><br><span class="line">        <span class="comment">//然后电梯门关闭</span></span><br><span class="line">        lift.close();</span><br><span class="line">        <span class="comment">//再然后，电梯跑起来，向上或者向下</span></span><br><span class="line">        lift.run();</span><br><span class="line">        <span class="comment">//最后到达目的地，电梯挺下来</span></span><br><span class="line">        lift.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>  ​    运行的结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电梯门开启...</span><br><span class="line">电梯门关闭...</span><br><span class="line">电梯上下跑起来...</span><br><span class="line">电梯停止了...</span><br></pre></td></tr></table></figure></p>
<p>​    太简单的程序了，是个程序员都会写这个程序，这么简单的程序还拿出来show，是不是太小看我们的智商了？！非也，非也，我们继续往下分析，这个程序有什么问题，你想呀电梯门可以打开，但不是随时都可以开，是有前提条件的的，你不可能电梯在运行的时候突然开门吧？！电梯也不会出现停止了但是不开门的情况吧？！那要是有也是事故嘛，再仔细想想，电梯的这四个动作的执行都是有前置条件，具体点说说在特定状态下才能做特定事，那我们来分析一下电梯有什么那些特定状态：</p>
<p>​    门敞状态—按了电梯上下按钮，电梯门开，这中间有5 秒的时间（当然你也可以用身体挡住电梯门，那就不是5 秒了），那就是门敞状态；在这个状态下电梯只能做的动作是关门动作，做别的动作？那就危险喽</p>
<p>​    门闭状态—电梯门关闭了，在这个状态下，可以进行的动作是：开门（我不想坐电梯了）、停止（忘记按路层号了）、运行</p>
<p>​       运行状态—电梯正在跑，上下窜，在这个状态下，电梯只能做的是停止；</p>
<p>​    停止状态—电梯停止不动，在这个状态下，电梯有两个可选动作：继续运行和开门动作；</p>
<p>​    我们用一张表来表示电梯状态和动作之间的关系：  </p>
<table>
<thead>
<tr>
<th></th>
<th>开门(open)</th>
<th>关门(close)</th>
<th>运行(run)</th>
<th>停止(stop)</th>
</tr>
</thead>
<tbody>
<tr>
<td>门敞状态</td>
<td>○</td>
<td>☆</td>
<td>○</td>
<td>○</td>
</tr>
<tr>
<td>门闭状态</td>
<td>☆</td>
<td>○</td>
<td>☆</td>
<td>☆</td>
</tr>
<tr>
<td>运行状态</td>
<td>○</td>
<td>○</td>
<td>○</td>
<td>☆</td>
</tr>
<tr>
<td>停止状态</td>
<td>☆</td>
<td>○</td>
<td>☆</td>
<td>○</td>
</tr>
</tbody>
</table>
<p>​    电梯状态和动作对应表（○表示不允许，☆表示允许动作）</p>
<p>​    看到这张表后，我们才发觉，哦~~，我们的程序做的很不严谨，好，我们来修改一下，先看类图：</p>
<p><img src="\image\java设计模式\状态模式-电梯示例-类图2.png" alt="状态模式-电梯示例-类图2"></p>
<pre><code>增加了状态的类图
</code></pre><p>​    在接口中定义了四个常量，分别表示电梯的四个状态：门敞状态、关闭状态、运行状态、停止状态，然后在实现类中电梯的每一次动作发生都要对状态进行判断，判断是否运行执行，也就是动作的执行是否符合业务逻辑，实现类中的四个私有方法是仅仅实现电梯的动作，没有任何的前置条件，因此这四个方法是不能为外部类调用的，设置为私有方法。我们先看接口的改变：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common2;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 定义一个电梯的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯的四个状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> OPENING_STATE = <span class="number">1</span>; <span class="comment">//门敞状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CLOSING_STATE = <span class="number">2</span>; <span class="comment">//门闭状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RUNNING_STATE = <span class="number">3</span>; <span class="comment">//运行状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> STOPPING_STATE = <span class="number">4</span>; <span class="comment">//停止状态；</span></span><br><span class="line">    <span class="comment">//设置电梯的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br><span class="line">    <span class="comment">//首先电梯门开启动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯门有开启，那当然也就有关闭了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯要能上能下，跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯还要能停下来，停不下来那就扯淡了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>增加了四个静态常量，增加了一个方法setState，设置电梯的状态。我们再来看实现类是如何实现的：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common2;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 电梯的实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lift</span> <span class="keyword">implements</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//电梯在什么状态下才能关闭</span></span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.state)&#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//如果是则可以关门，同时修改电梯状态</span></span><br><span class="line">            <span class="keyword">this</span>.closeWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(CLOSING_STATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE: <span class="comment">//如果电梯就是关门状态，则什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE: <span class="comment">//如果是正在运行，门本来就是关闭的，也说明都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE: <span class="comment">//如果是停止状态，本也是关闭的，什么也不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门开启</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//电梯在什么状态才能开启</span></span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.state)&#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//如果已经在门敞状态，则什么都不做</span></span><br><span class="line">           <span class="comment">//do nothing;</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则可以开启</span></span><br><span class="line">           <span class="keyword">this</span>.openWithoutLogic();</span><br><span class="line">           <span class="keyword">this</span>.setState(OPENING_STATE);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> RUNNING_STATE: <span class="comment">//正在运行状态，则不能开门，什么都不做</span></span><br><span class="line">           <span class="comment">//do nothing;</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> STOPPING_STATE: <span class="comment">//停止状态，淡然要开门了</span></span><br><span class="line">           <span class="keyword">this</span>.openWithoutLogic();</span><br><span class="line">           <span class="keyword">this</span>.setState(OPENING_STATE);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯开始跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.state)&#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//如果已经在门敞状态，则不你能运行，什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则可以运行</span></span><br><span class="line">            <span class="keyword">this</span>.runWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(RUNNING_STATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE: <span class="comment">//正在运行状态，则什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE: <span class="comment">//停止状态，可以运行</span></span><br><span class="line">            <span class="keyword">this</span>.runWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(RUNNING_STATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.state)&#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//如果已经在门敞状态，那肯定要先停下来的，什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE: <span class="comment">//如是电梯时关闭状态，则当然可以停止了</span></span><br><span class="line">            <span class="keyword">this</span>.stopWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(CLOSING_STATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE: <span class="comment">//正在运行状态，有运行当然那也就有停止了</span></span><br><span class="line">            <span class="keyword">this</span>.stopWithoutLogic();</span><br><span class="line">            <span class="keyword">this</span>.setState(CLOSING_STATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE: <span class="comment">//停止状态，什么都不做</span></span><br><span class="line">            <span class="comment">//do nothing;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纯粹的电梯关门，不考虑实际的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeWithoutLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门关闭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纯粹的店门开，不考虑任何条件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openWithoutLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门开启..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纯粹的运行，不考虑其他条件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWithoutLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯上下跑起来..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单纯的停止，不考虑其他条件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopWithoutLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    程序有点长，但是还是很简单的，就是在每一个接口定义的方法中使用witch…case 来进行判断，是否运行运行指定的动作。我们来看Client 程序的变更：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.common2;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 模拟电梯的动作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILift lift = <span class="keyword">new</span> Lift();</span><br><span class="line">        <span class="comment">//电梯的初始条件应该是停止状态</span></span><br><span class="line">        lift.setState(ILift.STOPPING_STATE);</span><br><span class="line">        <span class="comment">//首先是电梯门开启，人进去</span></span><br><span class="line">        lift.open();</span><br><span class="line">        <span class="comment">//然后电梯门关闭</span></span><br><span class="line">        lift.close();</span><br><span class="line">        <span class="comment">//再然后，电梯跑起来，向上或者向下</span></span><br><span class="line">        lift.run();</span><br><span class="line">        <span class="comment">//最后到达目的地，电梯挺下来</span></span><br><span class="line">        lift.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    业务调用的方法中增加了电梯状态判断，电梯要开门不是随时都可以开的，必须满足了一定条件你才能开门，人才能走进去，我们设置电梯的起始是停止状态，看运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电梯门开启...</span><br><span class="line">电梯门关闭...</span><br><span class="line">电梯上下跑起来...</span><br><span class="line">电梯停止了...</span><br></pre></td></tr></table></figure></p>
<pre><code>我们来想一下，这段程序有什么问题，首先Lift.java 这个文件有点长，长的原因是我们在程序中使用了大量的switch…case 这样的判断（if…else 也是一样），程序中只要你有这样的判断就避免不了加长程序，同步的在业务比较复杂的情况下，程序体会更长，这个就不是一个很好的习惯了，较长的方法或者类的维护性比较差，毕竟程序是给人来阅读的；其次，扩展性非常的不好，大家来想想，电梯还有两个状态没有加，是什么？通电状态和断电状态，你要是在程序再增加这两个方法，你看看Open()、Close()、Run()、Stop()这四个方法都要增加判断条件，也就是说switch 判断体中还要增加case 项，也就说与开闭原则相违背了；再其次，我们来思考我们的业务，电梯在门敞开状态下就不能上下跑了吗？电梯有没有发生过只有运行没有停止状态呢（从40 层直接坠到1 层嘛）？电梯故障嘛，还有电梯在检修的时候，可以在stop状态下不开门，这也是正常的业务需求呀，你想想看，如果加上这些判断条件，上面的程序有多少需要修改？虽然这些都是电梯的业务逻辑，但是一个类有且仅有一个原因引起类的变化，单一职责原则，看看我们的类，业务上的任务一个小小增加或改动都对我们的这个电梯类产生了修改，这是在项目开发上是有很大风险的。既然我们已经发现程序上有以上问题，我们怎么来修改呢？
</code></pre><p>​    刚刚我们是从电梯的有哪些方法以及这些方法执行的条件去分析，现在我们换个角度来看问题，我们来想电梯在具有这些状态的时候，能够做什么事情，也就是说在电梯处于一个具体状态时，我们来思考这个状态是由什么动作触发而产生以及在这个状态下电梯还能做什么事情，举个例子来说，电梯在停止状态时，我们来思考两个问题：</p>
<pre><code>第一、这个停止状态时怎么来的，那当然是由于电梯执行了stop 方法而来的；
</code></pre><p>​        第二、在停止状态下，电梯还能做什么动作?继续运行？开门？那当然都可以了。</p>
<p>​    我们再来分析其他三个状态，也都是一样的结果，我们只要实现电梯在一个状态下的两个任务模型就可以了：这个状态是如何产生的以及在这个状态下还能做什么其他动作（也就是这个状态怎么过渡到其他状态），既然我们以状态为参考模型，那我们就先定义电梯的状态接口，思考过后我们来看类图：</p>
<p><img src="\image\java设计模式\状态模式-以状态作为导向的类图.png" alt="状态模式-以状态作为导向的类图"></p>
<p>​                            以状态作为导向的类图</p>
<p>​    在类图中，定义了一个LiftState 抽象类，声明了一个受保护的类型Context 变量，这个是串联我们各个状态的封装类，封装的目的很明显，就是电梯对象内部状态的变化不被调用类知晓，也就是迪米特法则了，我的类内部情节你知道越少越好，并且还定义了四个具体的实现类，承担的是状态的产生以及状态间的转换过渡，我们先来看LiftState 程序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 定义一个电梯的接口</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftState</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个环境角色，也就是封装状态的变换引起的功能变化</span></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context _context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = _context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首先电梯门开启动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯门有开启，那当然也就有关闭了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯要能上能下，跑起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//电梯还要能停下来，停不下来那就扯淡了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>  抽象类比较简单，我们来先看一个具体的实现，门敞状态的实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cbf4life.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 在电梯门开启的状态下能做什么事情</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">  <span class="comment">//开启当然可以关闭了，我就想测试一下电梯门开关功能</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//状态修改</span></span><br><span class="line">  <span class="keyword">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">  <span class="comment">//动作委托为CloseState来执行</span></span><br><span class="line">  <span class="keyword">super</span>.context.getLiftState().close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//打开电梯门</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"电梯门开启..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//门开着电梯就想跑，这电梯，吓死你！</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//do nothing;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开门还不停止？</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//do nothing;</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>​    我来解释一下这个类的几个方法，Openning 状态是由open()方法产生的，因此这个方法中有一个具体的业务逻辑，我们是用print 来代替了；在Openning 状态下，电梯能过渡到其他什么状态呢？按照现在的定义的是只能过渡到Closing 状态，因此我们在Close()中定义了状态变更，同时把Close 这个动作也委托了给CloseState 类下的Close 方法执行，这个可能不好理解，我们再看看Context 类就可能好理解一点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义出所有的电梯状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> OpenningState openningState = <span class="keyword">new</span> OpenningState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ClosingState closeingState = <span class="keyword">new</span> ClosingState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> RunningState runningState = <span class="keyword">new</span> RunningState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> StoppingState stoppingState = <span class="keyword">new</span> StoppingState();</span><br><span class="line">    <span class="comment">//定一个当前电梯状态</span></span><br><span class="line">    <span class="keyword">private</span> LiftState liftState;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiftState <span class="title">getLiftState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> liftState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLiftState</span><span class="params">(LiftState liftState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState = liftState;</span><br><span class="line">        <span class="comment">//把当前的环境通知到各个实现类中</span></span><br><span class="line">        <span class="keyword">this</span>.liftState.setContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>​    结合以上三个类，我们可以这样理解，Context 是一个环境角色，它的作用是串联各个状态的过渡，在LiftSate 抽象类中我们定义了并把这个环境角色聚合进来，并传递到了子类，也就是四个具体的实现类中自己根据环境来决定如何进行状态的过渡。我们把其他的三个具体实现类阅读完毕，下面是关闭状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 电梯门关闭以后，电梯可以做哪些事情</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯门关闭，这是关闭状态要实现的动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯门关闭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门关了再打开，逗你玩呢，那这个允许呀</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.openningState); <span class="comment">//置为门敞状态</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门关了就跑，这是再正常不过了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.runningState); <span class="comment">//设置为运行状态；</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//电梯门关着，我就不按楼层</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.stoppingState); <span class="comment">//设置为停止状态；</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>下面是电梯的运行状态：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 电梯在运行状态下能做哪些动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯门关闭？这是肯定了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//运行的时候开电梯门？你疯了！电梯不会给你开的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是在运行状态下要实现的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯上下跑..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.stoppingState); <span class="comment">//环境设置为停止状态；</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>​    下面是停止状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 在停止状态下能做什么事情</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoppingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停止状态关门？电梯门本来就是关着的！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//停止状态，开门，那是要的！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().open();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//停止状态再跑起来，正常的很</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//停止状态是怎么发生的呢？当然是停止方法执行了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"电梯停止了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>  业务逻辑都已经实现了，我们来看看Client 怎么实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gumx.advance;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> gumx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* I'm glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 模拟电梯的动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setLiftState(<span class="keyword">new</span> ClosingState());</span><br><span class="line">        context.open();</span><br><span class="line">        context.close();</span><br><span class="line">        context.run();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>​    Client 调用类太简单了，只要定义个电梯的初始状态，然后调用相关的方法，就完成了，完全不用考虑状态的变更，看运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电梯门开启...</span><br><span class="line">电梯门关闭...</span><br><span class="line">电梯上下跑起来...</span><br><span class="line">电梯停止了...</span><br></pre></td></tr></table></figure></p>
<p>​    我们再来回顾一下我们刚刚批判上一段的代码，首先我们说人家代码太长，这个问题我们解决了，通过各个子类来实现，每个子类的代码都很短，而且也取消了的switch…case 条件的判断；其次，说人家不符合开闭原则，那如果在我们这个例子中要增加两个状态怎么加？增加两个子类，一个是通电状态，一个是断电状态，同时修改其他实现类的相应方法，因为状态要过渡呀，那当然要修改原有的类，只是在原有类中的方法上增加，而不去做修改；再其次，我们说人家不符合迪米特法则，我们现在呢是各个状态是单独的一个类，只有与这个状态的有关的因素修改了这个类才修改，符合迪米特法则，非常完美!</p>
<p><strong>优缺点</strong></p>
<p>​    状态模式既然有优点，那当然有缺点了，只有一个缺点，子类会太多，也就是类膨胀，你想一个事物有七八、十来个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目自己衡量。其实有很大方式解决这个状态问题，比如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。状态模式使用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说行为是受状态约束的情况下可以使用状态模式，而且状态模式使用时对象的状态最好不要超过五个，防止你写子类写疯掉。</p>
<p><strong>拓展</strong></p>
<p>​    上面的例子可能比较复杂，请各位看官耐心的看，看完我想肯定有所收获。我翻遍了所有能找的到的资料（至少也有十几本，其中有几本原文的书还是很的很不错的，我举这个电梯的例子也是从《Design  Pattern for Dummies》这本书来激发出来的），基本（基本哦，还是有几本讲的不错）上没有一本把这个状态模式讲透彻的，我不敢说我就讲的透彻，大家都只讲了一个状态到另一个状态过渡，状态间的过渡是固定的，举个简单的例子：</p>
<p><img src="\image\java设计模式\状态模式-状态过度固定-示意图.png" alt="状态模式-状态过度固定-示意图"></p>
<pre><code>这个状态图是很多书上都有的，状态A 只能变更到状态B，状态B 再变更到状态C，例子举的最多的就是TCP 监听的例子，TCP 有三个状态：等待，连接，断开，然后这三个状态中按照顺序循环变更，按照这个状态变更来讲解状态模式，我认为是不太合适的，为什么呢？你在项目中太少看到一个状态只能过渡到另一个状态情形，项目中遇到的大多数情况都是一个状态可以转换为几种状态，如下图：
</code></pre><p><img src="\image\java设计模式\状态模式-状态过度不固定-示意图.png" alt="状态模式-状态过度不固定-示意图"></p>
<pre><code>状态B 可以转换为状态C 也可以转换为状态D，而状态D 呢也可以转换为状态A 或状态B，这在项目分析过程中有一个叫状态图可以完整的展示这种蜘蛛网结构，举个实际例子来说，一些收费网站的用户就有很多状态，比如普通用户，普通会员，VIP 会员，白金级用户等等，这个状态的变更你不允许跳跃？！这不可能，所以我在例子中就举了一个比较复杂的应用，基本上可以实现状态间自由切换，这才是最经常用到的状态模式。然后我再提问个问题，状态间的自由切换，那会有很多种呀，你要一个一个的牢记一遍吗？比如上面那个电梯的例子，我要一个正常的电梯运行逻辑，规则是开门-&gt;关门-&gt;运行-&gt;停止；还要一个紧急状态（比如火灾）下的运行逻辑，关门-&gt;停止，紧急状态电梯当然不能用了；再要一个维修状态下的运行逻辑，这个状态任何情况都可以，开着门电梯运行？可以！门来回开关？可以！永久停止不动？可以！ 那这怎么实现呢？需要我们把已经有的几种状态按照一定的顺序再重新组装一下，那这个是什么模式？什么模式？大声点！建造者模式！对，建造模式+状态模式会起到非常好的封装作用。
</code></pre><p>​         再往深里面扯几句，应该有部分读者做过工作流开发，如果不是土制框架的话，就应该有个状态机管理（即使是土制框架也应该有），比如一个Activity（节点）有初始化状态（Initialized State）、挂起状态（Suspended State）、完成状态（Completed State）等等，流程实例也是有这么多状态，那这些状态怎么管理呢？通过状态机(State Machine)来管理，那状态机是个什么东西呢？就是我们上面提到的Context类的升级变态BOSS！</p>
<p><strong>总结</strong></p>
<p>​    状态模式主要是对对象涉及的内部状态进行封装，使得状态对象来负责与状态相关的动作和状态变化。这样，客户端就不需要再来关心状态与行为的影响，以及状态变化的细节。</p>
<p>​    在状态模式中，状态在不停的变换，行为也在不停的变化，并且状态还会影响到行为。但是，状态和行为之间的影响关系不会变化，状态对象的封装，使得状态与行为之间的影响关系固定，并且向客户端隐藏状态过渡细节。</p>
<p>参考资料： <a href="http://blog.csdn.net/SEU_Calvin/article/details/52779282" target="_blank" rel="noopener">设计模式——状态模式详解</a></p>
<p>​            <a href="http://blog.csdn.net/u012401711/article/details/52675873" target="_blank" rel="noopener">Java设计模式——状态模式（STATE PATTERN）</a></p>
<h2 id="访问者模式-Vistor"><a href="#访问者模式-Vistor" class="headerlink" title="访问者模式(Vistor)"></a>访问者模式(Vistor)</h2><p><strong>定义</strong></p>
<p>​    表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提<br>下定义作用于这些元素的新操作。</p>
<p>​    可以对定义这么理解：有这么一个操作，它是作用于一些元素之上的，而这些元素属于某一个对象结构。同时这个操作是在不改变各元素类的前提下，在这个前提下定义新操作是访问者模式精髓中的精髓。 </p>
<p><strong>问题</strong></p>
<p>​    在一些数据结构上，会频繁的执行一些操作，并且这个操作是变化的，可能会增加新的操作。</p>
<p><strong>方案</strong></p>
<p>​    将操作与数据结构进行分离，将操作封装成独立的对象。这样，及时操作改变了，或者增加新的操作时，都不会影响到数据结构。</p>
<p><strong>使用场景</strong></p>
<p>​    （1）数据结构稳定，作用于数据结构的操作经常变化的时候。</p>
<p>​    （2）需要对一个对象结构中的对象进行很多不同的且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</p>
<p>​     （3）有时在对数据结构上的元素进行操作的时候，需要区分具体的类型，这时使用访问者模式可以针对不同的类型，在访问者类中定义不同的操作，从而去除掉类型判断。</p>
<p><strong>结构</strong></p>
<p>​    访问者模式的结构示意图为：</p>
<p><img src="\image\java设计模式\访问者模式结构示意图.png" alt="访问者模式结构示意图"></p>
<p>​    结构图补充：在ElementA和ElementB中的accept(Vistor)    方法中会调用vistor的方法对元素进行访问。</p>
<p>​    访问者模式涉及的角色：</p>
<p>​    （1）Visitor：接口或者抽象类，它定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法数理论上来讲与元素个数是一样的，因此，访问者模式要求元素的类族要稳定，如果经常添加、移除元素类，必然会导致频繁地修改Visitor接口，如果这样则不适合使用访问者模式。</p>
<p>​    （2）ConcreteVisitor1、ConcreteVisitor2：具体的访问类，它需要给出对每一个元素类访问时所产生的具体行为。</p>
<p>​    （3）Element：元素接口或者抽象类，它定义了一个接受访问者的方法（Accept），其意义是指每一个元素都要可以被访问者访问。</p>
<p>​    （4）ConcreteElementA、ConcreteElementB：具体的元素类，它提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</p>
<p>​    （5）ObjectStructure：定义当中所说的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素供访问者访问。</p>
<p><strong>实际例子</strong></p>
<p>​    我们都知道财务都是有账本的，这个账本就可以作为一个对象结构，而它其中的元素有两种，收入和支出，这满足我们访问者模式的要求，即元素的个数是稳定的，因为账本中的元素只能是收入和支出。</p>
<p>​    而查看账本的人可能有这样几种，比如老板，会计事务所的注会，财务主管，等等。而这些人在看账本的时候显然目的和行为是不同的。</p>
<p>​    首先我们给出单子的接口，它只有一个方法accept。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个单子的接口（相当于Element）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bill</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer viewer)</span></span>;<span class="comment">//相当于接受一个访问者</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    其中的方法参数AccountBookViewer是一个账本访问者接口，接下来也就是实现类，收入单子和消费单子，或者说收入和支出类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费的单子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeBill</span> <span class="keyword">implements</span> <span class="title">Bill</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumeBill</span><span class="params">(<span class="keyword">double</span> amount, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer viewer)</span> </span>&#123;</span><br><span class="line">        viewer.view(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收入单子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncomeBill</span> <span class="keyword">implements</span> <span class="title">Bill</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncomeBill</span><span class="params">(<span class="keyword">double</span> amount, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(AccountBookViewer viewer)</span> </span>&#123;</span><br><span class="line">        viewer.view(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上面最关键的还是里面的accept方法，它直接让访问者访问自己，这相当于一次静态分派（文章最后进行解释），当然我们也可以不使用重载而直接给方法不同的名称。</p>
<p>​    接下来是账本访问者接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//账单查看者接口（相当于Visitor）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountBookViewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看消费的单子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill bill)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看收入的单子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill bill)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个方法是重载方法，就是在上面的元素类当中用到的，当然你也可以按照访问者模式类图当中的方式去做，将两个方法分别命名为viewConsumeBill和viewIncomeBill，而一般建议按照类图上来做的</p>
<p>访问者的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老板类，查看账本的类之一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">AccountBookViewer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalIncome;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalConsume;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//老板只关注一共花了多少钱以及一共收入多少钱，其余并不关心</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill bill)</span> </span>&#123;</span><br><span class="line">        totalConsume += bill.getAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill bill)</span> </span>&#123;</span><br><span class="line">        totalIncome += bill.getAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalIncome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老板查看一共收入多少，数目是："</span> + totalIncome);</span><br><span class="line">        <span class="keyword">return</span> totalIncome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalConsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老板查看一共花费多少，数目是："</span> + totalConsume);</span><br><span class="line">        <span class="keyword">return</span> totalConsume;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册会计师类，查看账本的类之一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPA</span> <span class="keyword">implements</span> <span class="title">AccountBookViewer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注会在看账本时，如果是支出，则如果支出是工资，则需要看应该交的税交了没</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(ConsumeBill bill)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bill.getItem().equals(<span class="string">"工资"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"注会查看工资是否交个人所得税。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是收入，则所有的收入都要交税</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">(IncomeBill bill)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"注会查看收入交税了没。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    老板只关心收入和支出的总额，而注会只关注该交税的是否交税</p>
<p>​    接下来是账本类，它是当前访问者模式例子中的对象结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//账本类（相当于ObjectStruture）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountBook</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单子列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Bill&gt; billList = <span class="keyword">new</span> ArrayList&lt;Bill&gt;();</span><br><span class="line">    <span class="comment">//添加单子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBill</span><span class="params">(Bill bill)</span></span>&#123;</span><br><span class="line">        billList.add(bill);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//供账本的查看者查看账本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(AccountBookViewer viewer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Bill bill : billList) &#123;</span><br><span class="line">            bill.accept(viewer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    账本类当中有一个列表，这个列表是元素（Bill）的集合，这便是对象结构的通常表示，它一般会是一堆元素的集合，不过这个集合不一定是列表，也可能是树，链表等等任何数据结构，甚至是若干个数据结构。其中show方法，就是账本类的精髓，它会枚举每一个元素，让访问者访问。</p>
<p>​    测试客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AccountBook accountBook = <span class="keyword">new</span> AccountBook();</span><br><span class="line">        <span class="comment">//添加两条收入</span></span><br><span class="line">        accountBook.addBill(<span class="keyword">new</span> IncomeBill(<span class="number">10000</span>, <span class="string">"卖商品"</span>));</span><br><span class="line">        accountBook.addBill(<span class="keyword">new</span> IncomeBill(<span class="number">12000</span>, <span class="string">"卖广告位"</span>));</span><br><span class="line">        <span class="comment">//添加两条支出</span></span><br><span class="line">        accountBook.addBill(<span class="keyword">new</span> ConsumeBill(<span class="number">1000</span>, <span class="string">"工资"</span>));</span><br><span class="line">        accountBook.addBill(<span class="keyword">new</span> ConsumeBill(<span class="number">2000</span>, <span class="string">"材料费"</span>));</span><br><span class="line">    </span><br><span class="line">        AccountBookViewer boss = <span class="keyword">new</span> Boss();</span><br><span class="line">        AccountBookViewer cpa = <span class="keyword">new</span> CPA();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//两个访问者分别访问账本</span></span><br><span class="line">        accountBook.show(cpa);</span><br><span class="line">        accountBook.show(boss);</span><br><span class="line">    </span><br><span class="line">        ((Boss) boss).getTotalConsume();</span><br><span class="line">        ((Boss) boss).getTotalIncome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    上面的代码中，可以这么理解，账本以及账本中的元素是非常稳定的，这些几乎不可能改变，而最容易改变的就是访问者这部分。</p>
<p>​    访问者模式最大的优点就是增加访问者非常容易，我们从代码上来看，如果要增加一个访问者，你只需要做一件事即可，那就是写一个类，实现AccountBookViewer接口，然后就可以直接调用AccountBook的show方法去访问账本了。</p>
<p>​    如果没使用访问者模式，一定会增加许多if else，而且每增加一个访问者，你都需要改你的if else，代码会显得非常臃肿，而且非常难以扩展和维护。</p>
<p><strong>静态分派以及动态分派</strong></p>
<p>​    变量被声明时的类型叫做变量的静态类型(Static Type)，有些人又把静态类型叫做明显类型(Apparent Type)；而变量所引用的对象的真实类型又叫做变量的实际类型(Actual Type)。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">null</span>;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure></p>
<p>​    声明了一个变量list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。静态分派(Static Dispatch)发生在编译时期，分派根据静态类型信息发生。</p>
<p><strong>静态分派</strong> </p>
<p>​    静态分派就是按照变量的静态类型进行分派，从而确定方法的执行版本，静态分派在编译时期就可以确定方法的版本。而静态分派最典型的应用就是方法重载.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"string"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Integer integer)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"integer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">"1"</span>;</span><br><span class="line">        Integer integer = <span class="number">1</span>;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.test(integer);</span><br><span class="line">        main.test(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    在静态分派判断的时候，我们根据多个判断依据（即参数类型和个数）判断出了方法的版本，那么这个就是多分派的概念，因为我们有一个以上的考量标准，也可以称为宗量。所以JAVA是静态多分派的语言。</p>
<p><strong>动态分派</strong><br>​    对于动态分派，与静态相反，它不是在编译期确定的方法版本，而是在运行时才能确定。而动态分派最典型的应用就是多态的特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"男人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"女人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person man = <span class="keyword">new</span> Man();</span><br><span class="line">        Person woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.test();</span><br><span class="line">        woman.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    这段程序输出结果为依次打印男人和女人，然而这里的test方法版本，就无法根据man和woman的静态类型去判断了，他们的静态类型都是Person接口，根本无从判断。</p>
<p>​    显然，产生的输出结果，就是因为test方法的版本是在运行时判断的，这就是动态分派。</p>
<p>​    动态分派判断的方法是在运行时获取到man和woman的实际引用类型，再确定方法的版本，而由于此时判断的依据只是实际引用类型，只有一个判断依据，所以这就是单分派的概念，这时我们的考量标准只有一个宗量，即变量的实际引用类型。相应的，这说明JAVA是动态单分派的语言。</p>
<p><strong>访问者模式中的伪动态双分派</strong></p>
<p>​    访问者模式中使用的是伪动态双分派，所谓的动态双分派就是在运行时依据两个实际类型去判断一个方法的运行行为，而访问者模式实现的手段是进行了两次动态单分派来达到这个效果。</p>
<p>​    回到上面例子当中账本类中的accept方法</p>
<p>​    for (Bill bill : billList) {<br>​            bill.accept(viewer);<br>​        }</p>
<p>​    这里就是依据biil和viewer两个实际类型决定了view方法的版本，从而决定了accept方法的动作。</p>
<p>​    分析accept方法的调用过程<br>​    1.当调用accept方法时，根据bill的实际类型决定是调用ConsumeBill还是IncomeBill的accept方法。</p>
<p>​    2.这时accept方法的版本已经确定，假如是ConsumeBill，它的accept方法是调用下面这行代码。</p>
<p>public void accept(AccountBookViewer viewer) {<br>​        viewer.view(this);<br> }</p>
<p>​    此时的this是ConsumeBill类型，所以对应于AccountBookViewer接口的view(ConsumeBill bill)方法，此时需要再根据viewer的实际类型确定view方法的版本，如此一来，就完成了动态双分派的过程。</p>
<p>​    以上的过程就是通过两次动态双分派，第一次对accept方法进行动态分派，第二次对view（类图中的visit方法）方法进行动态分派，从而达到了根据两个实际类型确定一个方法的行为的效果。</p>
<p>​    而原本我们的做法，通常是传入一个接口，直接使用该接口的方法，此为动态单分派，就像策略模式一样。在这里，show方法传入的viewer接口并不是直接调用自己的view方法，而是通过bill的实际类型先动态分派一次，然后在分派后确定的方法版本里再进行自己的动态分派。</p>
<p>​    注意：这里确定view(ConsumeBill bill)方法是静态分派决定的，所以这个并不在此次动态双分派的范畴内，而且静态分派是在编译期就完成的，所以view(ConsumeBill bill)方法的静态分派与访问者模式的动态双分派并没有任何关系。动态双分派说到底还是动态分派，是在运行时发生的，它与静态分派有着本质上的区别，不可以说一次动态分派加一次静态分派就是动态双分派，而且访问者模式的双分派本身也是另有所指。</p>
<p>​    这里的this的类型不是动态确定的，你写在哪个类当中，它的静态类型就是哪个类，这是在编译期就确定的，不确定的是它的实际类型，请各位区分开这一点。</p>
<p><strong>优缺点</strong></p>
<p>​    优点：</p>
<p>​    1、使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。</p>
<p>​    2、添加新的操作或者说访问者会非常容易。</p>
<p>​    3、将对各个元素的一组操作集中在一个访问者类当中。</p>
<p>​    缺点：</p>
<p>​    1、增加新的元素会非常困难。</p>
<p>​    2、实现起来比较复杂，会增加系统的复杂性。</p>
<p>​    3、破坏封装，如果将访问行为放在各个元素中，则可以不暴露元素的内部结构和状态，但使用访问者模式的时候，为了让访问者能获取到所关心的信息，元素类不得不暴露出一些内部的状态和结构，就像收入和支出类必须提供访问金额和单子的项目的方法一样。点：</p>
<p><strong>总结</strong></p>
<p>​    访问者模式，主要是在数据结构不变的情况下，方便访问数据的操作改变或者增加。其实就是将稳定不变的数据结构与变化的数据访问操作分离开来，并将数据访问操作进行抽象和封装，使得可以很容易的增加数据访问操作。</p>
<p>参考资料：<a href="http://blog.csdn.net/u012124438/article/details/70537203" target="_blank" rel="noopener">设计模式学习之访问者模式</a></p>
<p>​           <a href="http://blog.csdn.net/sidihuo/article/details/54892215" target="_blank" rel="noopener">java设计模式-访问者模式visit</a></p>
<p>​           <a href="http://blog.csdn.net/jason0539/article/details/45146271" target="_blank" rel="noopener">Java设计模式之访问者模式</a></p>
<h2 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式(Mediator)"></a>中介者模式(Mediator)</h2><p><strong>定义</strong></p>
<p>​    用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 </p>
<p>​    ①中介者模式主要<strong>用来将同事类之间网状结构变为星状结构</strong>，使同事类之间的关系变的清晰一些。</p>
<p>　　②所有对象只跟中介者对象进行通信，相互之间不再有联系，这样也能够<strong>集中控制这些对象的交互关系</strong>。</p>
<p><strong>问题背景</strong></p>
<pre><code>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。
</code></pre><p><img src="\image\java设计模式\中介者模式-问题背景1.jpg" alt="中介者模式-问题背景1"></p>
<p><img src="\image\java设计模式\中介者模式-问题背景2.jpg" alt="中介者模式-问题背景2"></p>
<p>​    如果引入中介者模式，那么同事类之间的关系将变为星型结构，从图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p>
<p><img src="\image\java设计模式\中介者模式-问题背景3.jpg" alt="中介者模式-问题背景3"></p>
<p><strong>结构</strong></p>
<p>​    中介者模式的结构如下所示：</p>
<p><img src="\image\java设计模式\中介者模式的结构.png" alt="中介者模式的结构"></p>
<p>​    ①Mediator： 中介者接口。在里面<strong>定义各个同事之间交互需要的方法</strong>，可以是公共的通信方法，比如<strong>changed方法</strong>，大家都可以用（一般会传入同事类的this指针），也可以是小范围的交互方法。</p>
<p>　　②ConcreteMediator：具体中介者实现对象。这需要<strong>了解并维扩各个同事对象</strong>，并负具体的协调各同事对象的交互关系。</p>
<p>　　③Colleague：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。同事类的定义，通常实现为抽象类，主要负责约束同事对象的类型，并能实现一些具体同事类之间的公共功能。同时，<strong>一般会持有中介者的引用</strong>。在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。在中介者模式中，同事类之间必须通过中介者才能进行消息传递</p>
<p>　　④ConcreteColleague：具体的同事类，实现自己的业务，在需要与其他同事通信的时候，就与持有的中介者通信，中介者会负责与其他的同事交互。</p>
<p><strong>实际例子</strong></p>
<pre><code>我们使用一个例子来说明一下什么是同事类：有两个类A和B，类中各有一个数字，并且要保证类B中的数字永远是类A中数字的100倍。也就是说，当修改类A的数时，将这个数字乘以100赋给类B，而修改类B时，要将数除以100赋给类A。类A类B互相影响，就称为同事类。代码如下：
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractColleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//抽象方法，修改数字时同时修改关联对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">		coll.setNumber(number*<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueB</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line">​	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractColleague coll)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">		coll.setNumber(number/<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		AbstractColleague collA = <span class="keyword">new</span> ColleagueA();</span><br><span class="line">		AbstractColleague collB = <span class="keyword">new</span> ColleagueB();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"==========设置A影响B=========="</span>);</span><br><span class="line">		collA.setNumber(<span class="number">1288</span>, collB);</span><br><span class="line">		System.out.println(<span class="string">"collA的number值："</span>+collA.getNumber());</span><br><span class="line">		System.out.println(<span class="string">"collB的number值："</span>+collB.getNumber());</span><br><span class="line">	</span><br><span class="line">		System.out.println(<span class="string">"==========设置B影响A=========="</span>);</span><br><span class="line">		collB.setNumber(<span class="number">87635</span>, collA);</span><br><span class="line">		System.out.println(<span class="string">"collB的number值："</span>+collB.getNumber());</span><br><span class="line">		System.out.println(<span class="string">"collA的number值："</span>+collA.getNumber());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上面的代码中，类A类B通过直接的关联发生关系，假如我们要使用中介者模式，类A类B之间则不可以直接关联，他们之间必须要通过一个中介者来达到关联的目的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractColleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> number;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注意这里的参数不再是同事类，而是一个中介者</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">		am.AaffectB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueB</span> <span class="keyword">extends</span> <span class="title">AbstractColleague</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number, AbstractMediator am)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">		am.BaffectA();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMediator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> AbstractColleague A;</span><br><span class="line">	<span class="keyword">protected</span> AbstractColleague B;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractMediator</span><span class="params">(AbstractColleague a, AbstractColleague b)</span> </span>&#123;</span><br><span class="line">		A = a;</span><br><span class="line">		B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">AaffectB</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BaffectA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> <span class="keyword">extends</span> <span class="title">AbstractMediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">(AbstractColleague a, AbstractColleague b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//处理A对B的影响</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AaffectB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = A.getNumber();</span><br><span class="line">		B.setNumber(number*<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//处理B对A的影响</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BaffectA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = B.getNumber();</span><br><span class="line">		A.setNumber(number/<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		AbstractColleague collA = <span class="keyword">new</span> ColleagueA();</span><br><span class="line">		AbstractColleague collB = <span class="keyword">new</span> ColleagueB();</span><br><span class="line">		</span><br><span class="line">		AbstractMediator am = <span class="keyword">new</span> Mediator(collA, collB);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"==========通过设置A影响B=========="</span>);</span><br><span class="line">		collA.setNumber(<span class="number">1000</span>, am);</span><br><span class="line">		System.out.println(<span class="string">"collA的number值为："</span>+collA.getNumber());</span><br><span class="line">		System.out.println(<span class="string">"collB的number值为A的10倍："</span>+collB.getNumber());</span><br><span class="line">	</span><br><span class="line">		System.out.println(<span class="string">"==========通过设置B影响A=========="</span>);</span><br><span class="line">		collB.setNumber(<span class="number">1000</span>, am);</span><br><span class="line">		System.out.println(<span class="string">"collB的number值为："</span>+collB.getNumber());</span><br><span class="line">		System.out.println(<span class="string">"collA的number值为B的0.1倍："</span>+collA.getNumber());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    虽然代码比较长，但是还是比较容易理解的，其实就是把原来处理对象关系的代码重新封装到一个中介类中，通过这个中介类来处理对象间的关系。</p>
<p><strong>优缺点</strong></p>
<p>​    中介者模式优点：   </p>
<ul>
<li>适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。</li>
<li>使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。</li>
<li>使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。</li>
</ul>
<p>​    缺点：</p>
<ul>
<li>潜在的过度集中化。如果同事对象的交互非常多，而且比较复杂。当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，难于管理和维护。</li>
<li>由于“中介“承担了较多的责任，所以一旦这个中介对象出现了问题，那么整个系统就会受到重大的影响。</li>
</ul>
<p><strong>适用场景</strong></p>
<p>​    在面向对象编程中，一个类必然会与其他的类发生依赖关系，完全独立的类是没有意义的。一个类同时依赖多个类的情况也相当普遍，既然存在这样的情况，说明，一对多的依赖关系有它的合理性，适当的使用中介者模式可以使原本凌乱的对象关系清晰，但是如果滥用，则可能会带来反的效果。一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。</p>
<p><strong>总结</strong></p>
<p>​    中介者模式可以将同事类之间的复杂交互关系抽离出来形成单独类。同事类之间如果交互过多，则一个同事类发生改变，那么将牵扯到很多的同事类。引入中介者类后，一个同事类的改变只会影响到自身和中介者。</p>
<p>参考资料：<a href="http://www.cnblogs.com/5iedu/p/5618826.html" target="_blank" rel="noopener">第19章 行为型模式—中介者模式</a></p>
<p>​           <a href="http://blog.csdn.net/zhengzhb/article/details/7430098" target="_blank" rel="noopener">23种设计模式（7）：中介者模式</a></p>
<pre><code>[Java 设计模式之中介者模式](http://blog.csdn.net/jason0539/article/details/45216585)
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag"># 设计模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/29/面向对象思想/" rel="next" title="面向对象思想">
                <i class="fa fa-chevron-left"></i> 面向对象思想
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/05/1_Java 虚拟机/" rel="prev" title="Java虚拟机学习">
                Java虚拟机学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/zhg_avatar.jpg"
                alt="zhongzhengang" />
            
              <p class="site-author-name" itemprop="name">zhongzhengang</p>
              <p class="site-description motion-element" itemprop="description">一点一滴的积累</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhongzhengang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/mu-cao-18-76/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式补充-23种设计模式"><span class="nav-number">1.</span> <span class="nav-text">设计模式补充-23种设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式补充"><span class="nav-number">1.1.</span> <span class="nav-text">设计模式补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式概括"><span class="nav-number">1.2.</span> <span class="nav-text">设计模式概括</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是设计模式？"><span class="nav-number">1.3.</span> <span class="nav-text">什么是设计模式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式的SOLID原则"><span class="nav-number">1.4.</span> <span class="nav-text">设计模式的SOLID原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interpreter-解释器-模式"><span class="nav-number">1.5.</span> <span class="nav-text">Interpreter(解释器)模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单工厂模式（Simple-Factory）"><span class="nav-number">1.6.</span> <span class="nav-text">简单工厂模式（Simple Factory）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂方法模式（Factory-Method）"><span class="nav-number">1.7.</span> <span class="nav-text">工厂方法模式（Factory Method）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象工厂模式（Abstract-Factory）"><span class="nav-number">1.8.</span> <span class="nav-text">抽象工厂模式（Abstract Factory）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-number">1.9.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建造者-builder-模式"><span class="nav-number">1.10.</span> <span class="nav-text">建造者(builder)模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型-Prototype-模式"><span class="nav-number">1.11.</span> <span class="nav-text">原型(Prototype)模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合模式（Composite）"><span class="nav-number">1.12.</span> <span class="nav-text">组合模式（Composite）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#适配器模式（Adapter）"><span class="nav-number">1.13.</span> <span class="nav-text">适配器模式（Adapter）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰者模式-Decorator-Pattern"><span class="nav-number">1.14.</span> <span class="nav-text">装饰者模式(Decorator Pattern)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理模式-Proxy-pattern"><span class="nav-number">1.15.</span> <span class="nav-text">代理模式( Proxy pattern)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#门面模式-Facade-Pattern-外观模式"><span class="nav-number">1.16.</span> <span class="nav-text">门面模式( Facade Pattern  外观模式)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桥接模式（Bridge"><span class="nav-number">1.17.</span> <span class="nav-text">桥接模式（Bridge)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#享元模式-Flyweight-Pattern"><span class="nav-number">1.18.</span> <span class="nav-text">享元模式(Flyweight Pattern)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略模式-Strategy"><span class="nav-number">1.19.</span> <span class="nav-text">策略模式( Strategy )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板方法模式-Template-Method"><span class="nav-number">1.20.</span> <span class="nav-text">模板方法模式( Template Method )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者模式（-Observer-Pattern-）"><span class="nav-number">1.21.</span> <span class="nav-text">观察者模式（ Observer Pattern ）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代子-Iterator-模式"><span class="nav-number">1.22.</span> <span class="nav-text">迭代子(Iterator)模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#责任链模式（Chain-fo-Responsibility）"><span class="nav-number">1.23.</span> <span class="nav-text">责任链模式（Chain fo Responsibility）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令模式-Command"><span class="nav-number">1.24.</span> <span class="nav-text">命令模式( Command )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#备忘录模式-Memento"><span class="nav-number">1.25.</span> <span class="nav-text">备忘录模式( Memento )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态模式-state-pattern"><span class="nav-number">1.26.</span> <span class="nav-text">状态模式( state pattern )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问者模式-Vistor"><span class="nav-number">1.27.</span> <span class="nav-text">访问者模式(Vistor)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中介者模式-Mediator"><span class="nav-number">1.28.</span> <span class="nav-text">中介者模式(Mediator)</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhongzhengang</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
