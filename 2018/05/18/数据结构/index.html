<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-zhg.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-zhg.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="容器,数据结构," />





  <link rel="alternate" href="/atom.xml" title="ZhongZhenGang's Notes" type="application/atom+xml" />






<meta name="description" content="数据结构0. 常见数据结构线性：数组，链表，队列，堆栈，hash表，双端队列，==位图(bitmap)== 树：堆（大顶堆、小顶堆），trie树（字母树or字典树），后缀树，后缀树组，二叉排序/查找树，B+/B-树，AVL树，Treap，红黑树，splay树，线段树，树状数组 图：图 其他：并查表 参考资料：数据结构与算法汇总 一、数组​    数据结构中最基本的一个结构就是线性结构，而线性结构又">
<meta name="keywords" content="容器,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://yoursite.com/2018/05/18/数据结构/index.html">
<meta property="og:site_name" content="ZhongZhenGang&#39;s Notes">
<meta property="og:description" content="数据结构0. 常见数据结构线性：数组，链表，队列，堆栈，hash表，双端队列，==位图(bitmap)== 树：堆（大顶堆、小顶堆），trie树（字母树or字典树），后缀树，后缀树组，二叉排序/查找树，B+/B-树，AVL树，Treap，红黑树，splay树，线段树，树状数组 图：图 其他：并查表 参考资料：数据结构与算法汇总 一、数组​    数据结构中最基本的一个结构就是线性结构，而线性结构又">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/image/数据结构/数组存储空间示意图.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/双向链表插入与删除节点过程.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/栈数据结构.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/树的双亲表示法.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/树的孩子表示法.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/树的孩子兄弟表示法.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉排序树的创建过程.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉排序树的创建过程-2.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉排序树-查找.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉排序树-插入.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉排序树-插入-2.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉排序树删除节点-示意图.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉树排序树-删除节点-算法1.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉树排序树-删除节点-算法2.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉树排序树-删除节点-算法2-1.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/平衡与不平衡的二叉树.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/平衡树的生成过程.png">
<meta property="og:image" content="http://yoursite.com/image/数据结构/二叉排序树的平衡旋转图例.png">
<meta property="og:image" content="http://static.blog.csdn.net/xheditor/xheditor_emot/default/crazy.gif">
<meta property="og:image" content="http://yoursite.com/image/数据结构/并查集-武林帮派举例.gif">
<meta property="og:image" content="http://static.blog.csdn.net/xheditor/xheditor_emot/default/laugh.gif">
<meta property="og:image" content="http://yoursite.com/image/数据结构/并查集-路径压缩示意.gif">
<meta property="og:updated_time" content="2018-07-05T11:41:13.796Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构">
<meta name="twitter:description" content="数据结构0. 常见数据结构线性：数组，链表，队列，堆栈，hash表，双端队列，==位图(bitmap)== 树：堆（大顶堆、小顶堆），trie树（字母树or字典树），后缀树，后缀树组，二叉排序/查找树，B+/B-树，AVL树，Treap，红黑树，splay树，线段树，树状数组 图：图 其他：并查表 参考资料：数据结构与算法汇总 一、数组​    数据结构中最基本的一个结构就是线性结构，而线性结构又">
<meta name="twitter:image" content="http://yoursite.com/image/数据结构/数组存储空间示意图.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/18/数据结构/"/>





  <title>数据结构 | ZhongZhenGang's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhongZhenGang's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhongzhengang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhg_avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhongZhenGang's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T22:01:58+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">编程基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><center>数据结构</center></h1><h2 id="0-常见数据结构"><a href="#0-常见数据结构" class="headerlink" title="0. 常见数据结构"></a>0. 常见数据结构</h2><p><strong>线性：</strong>数组，链表，队列，堆栈，hash表，双端队列，==位图(bitmap)==</p>
<p><strong>树：</strong>堆（大顶堆、小顶堆），trie树（字母树or字典树），后缀树，后缀树组，二叉排序/查找树，B+/B-树，AVL树，Treap，红黑树，splay树，线段树，树状数组</p>
<p><strong>图：</strong>图</p>
<p><strong>其他：</strong>并查表</p>
<p>参考资料：<a href="http://dongxicheng.org/structure/structure-algorithm-summary/" target="_blank" rel="noopener">数据结构与算法汇总</a></p>
<h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><p>​    数据结构中最基本的一个结构就是线性结构，而线性结构又分为连续存储结构和离散存储结构。所谓的连续存储结构其实就是数组。</p>
<p>​    在内存中，数组中的数据是以一组连续的数据集合的形式存在于内存中。当我们访问存在于内存中的数组时，我们应该找到其在内存中的地址，当我们找到数据的地址后我们就可以找到对应的数据。</p>
<p>​    数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</p>
<p>​    数组的特点是：<br>        元素类型是固定的、长度是固定的、通过下标查询，查询快，增删慢。</p>
<p><img src="\image\数据结构\数组存储空间示意图.png" alt="组存储空间示意"></p>
<h2 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h2><p>​    线性表的定义：一个线性表是n个数据元素的==有限==序列。（注意：线性表中元素的个数是有限的）。</p>
<p>​    线性表中元素的个数是n(n&gt;=0)称作线性表的长度。线性表中的元素可以是各种各样的，如数字，符号，一页书等。但同一个线性表中的元素类型必须是相同的。n=0时称线性表为空表。</p>
<p>​           在稍复杂的线性表中，一个数据元素可以由若干个数据项（item）组成，此时称数据元素为记录，含有大量记录的线性表称作文件。</p>
<h3 id="1-线性表的顺序表示和实现"><a href="#1-线性表的顺序表示和实现" class="headerlink" title="1. 线性表的顺序表示和实现"></a>1. 线性表的顺序表示和实现</h3><p>​    顺序表指的是用一组地址连续的存储单元依次存储线性表的数据元素，按照这种存储结构存储的机制称作线性表的顺序存储结构或顺序映像。</p>
<p>​    顺序表的特点、优点和缺点如下表1所示：</p>
<p>​                        表1：顺序表的特点、优点和缺点表</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">特点</td>
<td>⑴ 线性表中相邻的元素在物理上存储位置相邻。即以元素在计算机内物理位置相邻来表示线性表中数据元素之间的逻辑关系。<br>⑵ 随机存取<br>⑶ 通常对应高级程序语言中的一维数组</td>
</tr>
<tr>
<td style="text-align:center">优点</td>
<td>⑴ 不需要额外的存储空间来表示元素间的逻辑关系<br>⑵ 可随机存取</td>
</tr>
<tr>
<td style="text-align:center">缺点</td>
<td>⑴ 插入和删除元素时需要移动大量的元素<br>⑵ 必须先进行空间分配，而且还需要考虑空间的扩充</td>
</tr>
</tbody>
</table>
<h3 id="2-线性表的链式表示和实现"><a href="#2-线性表的链式表示和实现" class="headerlink" title="2. 线性表的链式表示和实现"></a>2. 线性表的链式表示和实现</h3><p>​    线性表的链式表示主要有三种：单链表、循环链表和双向链表。</p>
<p><em>2.1  单链表</em></p>
<p>​    单链表指的是用一组任意的存储单元存储线性表的数据元素。使用单链表的时候，关心的只是它所表示的线性表中数据元素之间的逻辑顺序，而不是它所表示的线性表中数据元素之间的物理顺序。</p>
<p>​    单链表的特点、优点和缺点表如下表2所示：</p>
<p>​                        表2：单链表的特点、优点和缺点表</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>特点</td>
<td>⑴ 存储单链表的存储单元地址可以连续也可以不连续。<br>⑵ 建立链表的过程就是一个动态生成链表的过程。</td>
</tr>
<tr>
<td>优点</td>
<td>(1) 在单链表中插入或删除一个节点时，仅需修改指针而不需要移动元素。<br>⑵ 根据需要申请空间，且不要求连续的存储空间。</td>
</tr>
<tr>
<td>缺点</td>
<td>⑴ 用指针指示元素之间的逻辑关系，存储空间利用率低。<br>⑵ 对表中元素只能按照顺序存取，不可随机访问。</td>
</tr>
</tbody>
</table>
<p>​    单链表中关键字解释表如表3所示：</p>
<p>​                            表3：单链表中名词解释表</p>
<table>
<thead>
<tr>
<th style="text-align:center">名词</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">结点(node)</td>
<td>单链表中存储的每个元素ai。每个节点都包括两个域，数据域和指针域。</td>
</tr>
<tr>
<td style="text-align:center">数据域</td>
<td>存储的内容是数据信息</td>
</tr>
<tr>
<td style="text-align:center">指针域</td>
<td>存储的是直接后继存储位置</td>
</tr>
<tr>
<td style="text-align:center">头指针</td>
<td>头指针指示链表中第一个结点（即第一个数据元素的存储映像）的存储位置。</td>
</tr>
<tr>
<td style="text-align:center">头结点</td>
<td>在单链表的第一个结点之前附设的结点</td>
</tr>
</tbody>
</table>
<p><em>2.2 循环链表</em></p>
<p>​    单链表中最后一个结点的指针域指向头结点。整个链表形成一个环，从表中任一点出发均可找到表中其他节点。</p>
<p><em>2.3 双向链表</em></p>
<p>​    双向链表中的节点都有两个指针域，其一指向该结点的直接前趋，另一个指针域指向该结点的直接后继结点。<br>    与单链表的循环链表类似，双向链表也可以有循环双向链表。<br>    在双向链表中插入和删除节点时，需要同时修改两个方向上的指针。</p>
<p><img src="\image\数据结构\双向链表插入与删除节点过程.png" alt="向链表插入与删除节点过"></p>
<h2 id="三、栈和队列"><a href="#三、栈和队列" class="headerlink" title="三、栈和队列"></a>三、栈和队列</h2><p>​    从数据结构角度看，栈和队列是操作受限的线性表。<br>    从数据类型角度看，栈和队列与线性表又有所不同。</p>
<h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p>​    栈是限定仅在表尾进行插入和删除操作的线性表。所以栈的最大特点是先进后出（last in first out）。<br>    栈的表示形式有两种：顺序栈和链栈。     </p>
<p>​    栈的引用举例：数制转换、括号匹配的检验、行编辑程序、迷宫求解和表达式求值。</p>
<p>​    一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作是递归函数。</p>
<p><img src="\image\数据结构\栈数据结构.png" alt="数据结"></p>
<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><p>​    队列是一种先进先出的线性表，只允许在表的一端进行插入，而在另外一端删除元素。</p>
<p>​    允许插入的一端叫做队尾（rear），允许删除的一端则叫做队头(front)。</p>
<h3 id="3-双端队列"><a href="#3-双端队列" class="headerlink" title="3. 双端队列"></a>3. 双端队列</h3><p>​    除了栈和队列之外，还有一种限定性数据结构是双端队列，尽管双端队列看起来比栈和队列更灵活，但实际上在应用程序中远不及栈和队列有用。</p>
<h3 id="4-链队列"><a href="#4-链队列" class="headerlink" title="4. 链队列"></a>4. 链队列</h3><p>​    用链表表示的队列。</p>
<h3 id="5-循环队列"><a href="#5-循环队列" class="headerlink" title="5. 循环队列"></a>5. 循环队列</h3><p>​    循环队列是用顺序表表示的队列，在非空队列中，头指针指向队列元素，而尾指针始终指向队列尾元素的下一个位置。如果用户程序中设有循环队列，则必须为它设定一个最大队列长度，若用户无法预估所用队列的最大长度，则宜采用链队列。</p>
<h2 id="四、串"><a href="#四、串" class="headerlink" title="四、串"></a>四、串</h2><p>1. 串(string)(或字符串)是由零个或多个字符组成的有限序列。</p>
<p>2. 字符串有3种机内表示方法：①定长顺序存储表示；②堆存储表示；③串的块链存储表示。</p>
<p>3. 串的模式匹配算法<br>    子串的定位操作通常称做串的模式匹配，是各种串处理系统中最重要的操作之一。</p>
<p>4. 字符串模式匹配<br>    给定字符串S(匹配串)和T(模式串)，求字符串T在S中首次出现的下标。<br>    注意：对于字符串S来说，其S[0]存放的是字符串的长度。如S=”abcd”,则S[0]=4.<br>    <strong>KMP算法：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index_KMP</span><span class="params">(String S, String T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; j &lt;=T[<span class="number">0</span>])&#123;<span class="comment">//注意：字符串的T[0]存储的是字符串长度</span></span><br><span class="line">        <span class="comment">/*如果j == 0 || S[i] == T[j]，则向后移动继续比较*/</span></span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">0</span> || S[i] == T[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则j回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    如何得到模式串T的next数组。此时T即是匹配串，也是模式串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_next</span><span class="params">(SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//注意这个地方j初始化为0</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">0</span> || S[i] == T[j])&#123;<span class="comment">//由S[i] == T[j]是否相等，来得出next[i+1]</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则j回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    如何得到模式串T的nextval数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nextval</span><span class="params">(SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//注意这个地方j初始化为0</span></span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">0</span> || S[i] == T[j])&#123;<span class="comment">//由S[i] == T[j]是否相等，来得出next[i+1]</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(T[i] == T[j])&#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则j回溯</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、树和二叉树"><a href="#四、树和二叉树" class="headerlink" title="四、树和二叉树"></a>四、树和二叉树</h2><p><strong>1.  树(Tree)</strong>是n(n&gt;=0)个结点的有限集。</p>
<p><strong>2.  森林(Forest)</strong>是m(m&gt;=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。</p>
<p><strong>3. </strong> 结点拥有的子树数称为该<strong>结点的度</strong>(Degree).</p>
<p><strong>4.  二叉树(BinaryTree)</strong>是另一种树型结构，它的特点是每个结点至多只有两颗子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<p><strong>5.  二叉树的性质</strong></p>
<p>​    ① 在二叉树的第i层上至多有2i-1个结点(i&gt;=1)；</p>
<p>​    ② 深度为k的二叉树至多有2k-1个结点；</p>
<p>​    证明：深度为k，说明是有k层，结点个数最多为2k-1个</p>
<p>​    ③ 对任何一棵二叉树T，如果终端结点数为n0，度为2的结点数为n2，则n0 = n2+1.</p>
<p>​    ④ 具有N个结点的完全二叉树的深度为log2N+1。(log2N是向下取整)</p>
<p><strong>6.  二叉树的存储结构</strong></p>
<p>​    <strong>① 顺序存储结构</strong></p>
<p>​    用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在如上定义的一维数组中下标为i-1的分量中。</p>
<p>​    <strong>② 链式存储结构</strong></p>
<p>​    二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表的节点至少包含3个域：数据域和左右指针域。</p>
<p>​    在有n个结点的二叉链表中必定存在n+1个空链域。(原因是，对于n个结点共有2n个链域，root结点不需要有指针指向，其他n-1个指针需要n-1个链域，所以还剩下2n-(n-1)=n+1)</p>
<p>​    有时为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。</p>
<p>​    利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表。</p>
<p>​    在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需要进行何种操作。</p>
<p><strong>7.  树的存储结构</strong></p>
<p>①    双亲表示法</p>
<p>​    以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置。</p>
<p>​    这种存储结构利用了每个结点(根结点除外)只有唯一的双亲的性质。可以利用O(1)的时间复杂度找到每个结点的父亲结点，但是如果要找结点的孩子结点则需要遍历整个结构。</p>
<p><img src="\image\数据结构\树的双亲表示法.png" alt="的双亲表示"></p>
<p>​           ②孩子表示法<br>      把每个结点的孩子排列起来，看成一个线性表，且以单链表作为存储结构，则n个结点有n个孩子链表。n个头指针又组成一个线性表，为了便于查找，可以采用顺序存储结构。<br>       与双亲表示法相反，孩子表示法方便找到孩子结点，但是不方便找到双亲结点。不过可以把双亲表示法和孩子表示法结合起来。                             </p>
<p><img src="\image\数据结构\树的孩子表示法.png" alt="的孩子表示"></p>
<p>③ 孩子兄弟表示法</p>
<p>​    又称二叉树表示法，或二叉链表表示法，即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点(左孩子右兄弟)，分别命名为firstchild和nextsibling域。</p>
<p>​    从firstchild域找到第一个孩子结点，然后沿着孩子结点的nextsibling域连续走i-1步，便可找到x的第i个孩子。此外，也可以为每一个结点增设一个PARENT域，则同样能方便地实现找某个结点的双亲结点。</p>
<p><img src="\image\数据结构\树的孩子兄弟表示法.png" alt="的孩子兄弟表示"></p>
<p><strong>8. 森林与二叉树的转换</strong></p>
<p>​    ==给定一棵树，可以找到唯一的一棵二叉树与之对应。==</p>
<p>​    可以把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，则同样可以导出森林与二叉树的对应关系。</p>
<p>​    先序遍历森林，相当于其对应二叉树的先序遍历，相当于依次对森林中的每棵树的先序遍历。</p>
<p>​    中序遍历森林，相当于其对应二叉树的中序遍历，相当于依次对森林中的每棵树做后续遍历。</p>
<h2 id="六、哈希表"><a href="#六、哈希表" class="headerlink" title="六、哈希表"></a>六、哈希表</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.  定义"></a>1.  定义</h3><p>​    根据设定的哈希函数H(key)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（空间）上，并以关键字在地址集中的“像”作为记录在表中存储位置。这种表则称为hash表。这个映射过程称为哈希造表或散列，所得存储位置称为哈希地址或散列地址。     </p>
<p>​    一般情况下，冲突只可能尽量少，但是不能避免。所以，在建造hash表的时候，选择好的hash构造函数和解决冲突的办法至关重要。</p>
<h3 id="2-哈希函数的构造函数。"><a href="#2-哈希函数的构造函数。" class="headerlink" title="2.  哈希函数的构造函数。"></a>2.  哈希函数的构造函数。</h3><pre><code>若对于关键字集合中的任意一个关键字，经哈希函数映像到地址集合中的任意一个位置的概率是相等的，则称此类哈希函数是均匀的。也就是说可以使任意一个关键字可被随机地映射到地址中，以便使一组关键字均匀地散列到地址集合中，以便减少冲突。
</code></pre><p>​    散列函数有一个共同性质，即函数值应按==同等概率==取其值域的每一个值。</p>
<p>​    常见的构造hash函数有：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">冲突</th>
<th>备注</th>
<th style="text-align:left">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">直接定义法</td>
<td style="text-align:left">取关键字或关键字的某个线性函数值为hash地址。H(key)=key或者H(key) = a*key+b</td>
<td style="text-align:left">不会</td>
<td>实际中使用很少。该方法关键字集合和地址集合大小相等 ，不会发生冲突。</td>
<td style="text-align:left">适合查找表较小且连续的情况。</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">数字分析法</td>
<td style="text-align:left">假设关键字是以r为基的数（如以10为基的十进制数），并且hash表中可能出现的关键字都是事先知道的，则可以取关键字的若干数位组成哈希地址</td>
<td style="text-align:left">会</td>
<td>不常用</td>
<td style="text-align:left">关键字位数比较大，就需要事先知道关键字的分布且关键字的若干位分布较均匀</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">平方取中法</td>
<td style="text-align:left">取关键字平方之后的中间几位为哈希地址。取的位数由表长决定。</td>
<td style="text-align:left">会</td>
<td>较常用</td>
<td style="text-align:left">不知道关键字的分布，而位数又不是很大的情况</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">折叠法</td>
<td style="text-align:left">将关键字分割成位数相同的几部分（最后一部分的位数可不同），然后取这几部分的叠加和（舍去最高进位）作为hash地址。  如04 4220 5864 可做04+4220+5864=0088，舍弃最高进位</td>
<td style="text-align:left">会</td>
<td>一般常用，</td>
<td style="text-align:left">事先不需要知道关键字的分布，适合关键字位数较多的情况。</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">除留余数法</td>
<td style="text-align:left">取关键字被某个不大于hash表表长m的数p除后所得余数为哈希地址。H(key)=key mod p;p&lt;=m  一般取p为小于m的质数或不包含小于20的质因数的合数。</td>
<td style="text-align:left">会</td>
<td>最简单，最常用的构造hash函数的方法。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模</td>
<td style="text-align:left">关键在于p的选择，选择较好的p则有效减少冲突。一般取p为小于m的质数或不包含小于20的质因数的合数。</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:left">随机数法</td>
<td style="text-align:left">选择一个随机函数，取关键字的随机函数值作为它的哈希地址 ，H(key)=random(key)</td>
<td style="text-align:left">会</td>
<td>通常当关键字长度不等时采用此法，构造哈希函数较恰当</td>
<td style="text-align:left">当关键字的长度不等时</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:left">相乘取整法</td>
<td style="text-align:left">首先用关键字key乘上某个常数A(0&lt;A&lt;1)，并抽取出key.A的小数部分；然后用m乘以该小数后取整</td>
<td style="text-align:left"></td>
<td></td>
</tr>
</tbody>
</table>
<p>​    实际中根据不同情况采用不同哈希方法，考虑的因素主要有：</p>
<p>​    1) 计算hash方法所需时间；2）关键字长度；3）哈希表的大小；4）关键字的分布情况；5）记录的查找频率。</p>
<p>​    总之，设计哈希构造函数的时候主要要考虑计算简单和散列地址分布均匀这两个特点。</p>
<h3 id="3-处理冲突的方法"><a href="#3-处理冲突的方法" class="headerlink" title="3.  处理冲突的方法"></a>3.  处理冲突的方法</h3><p>​           既然在构造hash表的过程中出现冲突不可避免，那么就需要有处理冲突的方法。下面介绍几种常用的处理冲突的方法。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>详细方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>开放地址法</td>
<td>线性探测再散列<br>  线性补偿探测法<br>  二次探测再散列<br>  伪随机探测再散列</td>
</tr>
<tr>
<td>再哈希法</td>
<td></td>
</tr>
<tr>
<td>链地址法（拉链法）</td>
<td></td>
</tr>
<tr>
<td>建立公共溢出区</td>
</tr>
</tbody>
</table>
<p><strong>3.1 开放地址法</strong></p>
<p>​    开放地址法主要包括线性探测再散列、线性补偿探测法、二次探测再散列和伪随机探测再散列。</p>
<p>​    Hi = (H(key)+di)%m</p>
<p>​    其中H(key)为哈希函数，m为哈希表表长，di为增量序列。</p>
<p>​    (1) di = 1,2,3..m-1称线性探测再散列；</p>
<p>​    (2) 将线性探测的步长从1 改为 Q ，即将上述算法中的 j ＝ (j ＋ 1) % m 改为： j ＝ (j ＋ Q) % m ，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。（线性补偿探测法）</p>
<p>​    (3) di = 12,-12,22,-22….k2,-k2称作二次探测再散列。</p>
<p>​    (4) di = 伪随机序列，称作伪随机探测再散列。</p>
<p>​          在处理冲突的过程中，两个hash地址不同的关键字争夺同一个后继哈希地址的现象称作是“二次聚集”，即在处理同义词的冲突过程中又添加了非同义词的冲突。</p>
<p>​       对于线性探测再查找，在哈希表未填满的状态下总能找到一个不发生冲突的地址。对于二次探测再散列，只有哈希表的长度m为形如$4*j+3$($j$是整数)的素数时，才可以保证哈希表未满情况下总能找到一个不发生冲突的地址。随机探测再散列，则取决于伪随机数列。</p>
<p><strong>3.2 再哈希法</strong></p>
<p>​        $$ Hi = RH_i (key)    i=1,2,3…k $$</p>
<p>​    $RH_i$均是不同的hash函数，即在同义词产生冲突时计算另一个哈希函数地址，直到不产生冲突为止。该方法虽然不容易产生聚集，但是会增加计算的时间。</p>
<p><strong>3.3 链地址法（拉链法）</strong></p>
<p>​       将关键字为同义词的记录存储在同一线性表中，在链表的插入为可以在表头或表尾，也可以在中间，以保持同义词在同一线性链表中按关键字有序。</p>
<p><strong>3.4 建立公共溢出区</strong></p>
<p>​       所有关键字和哈希表中已有的记录发生冲突的，就把这个关键字填入到溢出表中。（溢出表是另建立的一张新表，专门放那些在确定其hash地址的时候产生冲突的记录）</p>
<p><strong>3.5 拉链法和开放地址法比较</strong></p>
<p><strong>与开放定址法相比，拉链法有如下几个优点：</strong></p>
<p>① 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p>
<p>② 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</p>
<p>③ 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p>
<p>④ 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</p>
<p><strong>拉链法的缺点</strong><br>    　==拉链法的缺点是：指针需要额外的空间==。故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p>
<h3 id="4-哈希表的查找及分析"><a href="#4-哈希表的查找及分析" class="headerlink" title="4.  哈希表的查找及分析"></a>4.  哈希表的查找及分析</h3><p>​    哈希表的查找过程与哈希表的构造过程一致，给定k值，根据哈希函数计算得到哈希地址，若此位置上为空，则查找不成功；否则与关键字进行比较，若相等，则查找成功，否则根据处理冲突的方法查找下一个槽位上的记录。直到找到查找成功或者哈希表中某个位置为空。</p>
<p>​       哈希表的平均查找长度与哈希表的装载因子有关，与关键字集合包含元素个数无关 。因此，不管n多大，我们总可以选择一个合适的装载因子，以便将平均查找长度限定在一个范围内。</p>
<h3 id="5-哈希表的适用"><a href="#5-哈希表的适用" class="headerlink" title="5.  哈希表的适用"></a>5.  哈希表的适用</h3><p>​       散列技术既是一种存储方法，也是一种查找方法。<strong>散列技术最适合的求解问题是查找与给定值相等的记录。</strong></p>
<p>​    <strong>散列表不适合范围查找；散列表也不能获得表中记录的顺序，如获得表中最大值和最小值是不可行的。</strong></p>
<h2 id="七、图"><a href="#七、图" class="headerlink" title="七、图"></a>七、图</h2><h3 id="1-图的深度遍历DFS"><a href="#1-图的深度遍历DFS" class="headerlink" title="1.  图的深度遍历DFS"></a>1.  图的深度遍历DFS</h3><p>可采用递归和循环两种方式实现。</p>
<p>​    <strong>方法一：</strong>采用递归的方式。<br>    定义一个标志数组表示某个结点是否已经被访问过。以邻接矩阵的形式表示图。依次对深度遍历图中的每个未被遍历过的结点，然后针对该结点未被遍历过的邻接点再进行深度遍历，每个结点被遍历后加入到结果中，并且设定该结点已经被访问过。</p>
<p>​    <strong>方法二：</strong>不采用递归的方式而是采用栈保存已经遍历过并且还有其孩子结点可能还没有遍历过的结点。与递归方式中一样，也是定义一个标志数组表示某个结点是否已经被访问过。始化栈内存放第一个结点。判断栈顶元素的第一个还未被访问邻接点，把它压入到栈中，每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。循环直到栈空。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 方法一：采用递归的方式。</span></span><br><span class="line"><span class="comment">	 * 定义一个标志数组表示某个结点是否已经被访问过。</span></span><br><span class="line"><span class="comment">	 * 以邻接矩阵的形式表示图。</span></span><br><span class="line"><span class="comment">	 * 依次对深度遍历图中的每个未被遍历过的结点，针对该结点未被遍历过的邻接点再进行深度遍历，每个结点被遍历后加入到结果中，并且设定该结点已经被访问过。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS_Graph1</span><span class="params">(<span class="keyword">int</span> graph[][])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;<span class="comment">//求得结点的个数</span></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">    <span class="comment">/*Step1：依次遍历树中还未被遍历的结点*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="keyword">false</span>)&#123;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            list.add(i);</span><br><span class="line">            <span class="comment">/*Step2:深度遍历以结点i为开始的路径上的结点*/</span>				          DFS(graph,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 深度递归遍历以图中node结点为起点的结点。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> graph[][],<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">        <span class="comment">/*这个当前结点可达且未被访问的结点j才可以*/</span></span><br><span class="line">        <span class="keyword">if</span>(graph[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="keyword">false</span>)&#123;</span><br><span class="line">            visited[j] = <span class="keyword">true</span>;</span><br><span class="line">            list.add(j);</span><br><span class="line">            DFS(graph,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 方法二：不采用递归的方式而是采用栈保存已经遍历过并且还有其孩子结点可能还没有遍历过的结点。</span></span><br><span class="line"><span class="comment">	 * 与递归方式中一样，也是定义一个标志数组表示某个结点是否已经被访问过。</span></span><br><span class="line"><span class="comment">	 * 初始化栈内存放第一个结点。</span></span><br><span class="line"><span class="comment">	 * 判断栈顶元素的第一个还未被访问邻接点，把它压入到栈中，每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。</span></span><br><span class="line"><span class="comment">	 * 如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。</span></span><br><span class="line"><span class="comment">	 * 一直循环直到栈空。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS_Graph2</span><span class="params">(<span class="keyword">int</span> graph[][])</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">    <span class="comment">/*Step1:把初始第一个结点放到栈内*/</span></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*	</span></span><br><span class="line"><span class="comment">		 * Step2:找栈顶元素的第一个还未被访问邻接点，把它压入到栈中，</span></span><br><span class="line"><span class="comment">		 * 每个结点入栈的时候，把其对应的标志数组元素设为true同时把该结点放到结果中。 </span></span><br><span class="line"><span class="comment">		 * 如果栈顶元素没有了未被访问的邻接点，则将该元素弹栈。</span></span><br><span class="line"><span class="comment">		 * 循环结束的条件是栈为空。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> i = stack.peek();<span class="comment">//读栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*找栈顶元素的第一个未被访问的邻接点*/</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;size;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="keyword">false</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;size)&#123;<span class="comment">//说明找到了</span></span><br><span class="line">            visited[j] = <span class="keyword">true</span>;</span><br><span class="line">            list.add(j);</span><br><span class="line">            stack.push(j);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//只有当前栈顶元素不存在未被访问的邻接点时才弹出栈顶元素</span></span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-图的广度优先遍历BFS"><a href="#2-图的广度优先遍历BFS" class="headerlink" title="2.  图的广度优先遍历BFS"></a>2.  图的广度优先遍历BFS</h3><p>​    借助队列实现，同时设置一个包含结点个数的visited数组表示某个结点是否已经被遍历过。<br>    初始化时把第一个结点加入到结果list中，并且把visited[0]设置为true。<br>    循环开始时队列中存储的是图中的第一个结点，循环结束的条件是队列变成空。<br>    循环体内取出队列的第一个元素，并且把这个元素的所有未被访问过的邻接点都加入到队列中、加入到结果list中、设置其对应的状态为已访问。</p>
<p>​    类似于树的层次遍历.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 图的广度优先遍历。</span></span><br><span class="line"><span class="comment">	 * 借助队列实现，同时设置一个包含结点个数的visited数组表示某个结点是否已经被遍历过。</span></span><br><span class="line"><span class="comment">	 * 初始化时把第一个结点加入到结果list中，并且把visited[0]设置为true。</span></span><br><span class="line"><span class="comment">	 * 循环开始时队列中存储的是图中的第一个结点，循环结束的条件是队列变成空。</span></span><br><span class="line"><span class="comment">	 * 循环体内取出队列的第一个元素，并且把这个元素的所有未被访问过的邻接点都加入到队列中、加入到结果list中、设置其对应的状态为已访问。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BFS_Graph</span><span class="params">(<span class="keyword">int</span> graph[][])</span></span>&#123;</span><br><span class="line">		Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">int</span> size = graph.length;</span><br><span class="line">		visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">		<span class="comment">/*Step1:把初始第一个结点放到栈内。*/</span></span><br><span class="line">		queue.add(<span class="number">0</span>);</span><br><span class="line">		visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">		list.add(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> i ;</span><br><span class="line">		<span class="comment">/*Step2:循环队列中的元素直到队列为空。*/</span></span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">			i = queue.poll();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;size;j++)&#123;<span class="comment">//找刚刚被弹出队列的队头元素可达的点</span></span><br><span class="line">				<span class="keyword">if</span>(graph[i][j] ==<span class="number">1</span> &amp;&amp; visited[j] == <span class="keyword">false</span>)&#123;</span><br><span class="line">					visited[j] = <span class="keyword">true</span>;</span><br><span class="line">					list.add(j);</span><br><span class="line">					queue.add(j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="八、海量数据处理"><a href="#八、海量数据处理" class="headerlink" title="八、海量数据处理"></a>八、海量数据处理</h2><p>​    通过对海量数据的挖掘能有效地揭示用户的行为模式，加深对用户需求的理解，提取用户的集体智慧，从而为研发人员决策提供依据，提升产品用户体验，进而占领市场。</p>
<p>​    海量处理的基本方法：</p>
<p><strong>1.  Hash法</strong><br>    构造hash表和处理冲突的方法和上面介绍的一样。<br>    在处理海量数据的过程中，使用Hash方法一般可以快速存取、统计某些数据，将大量数据进行分类，例如提取某日访问网站次数最多的ip。</p>
<p><strong>2.  BitMap法</strong><br>    BitMap(位图)法的基本原理是使用数组来表示某些元素是否存在。<br>    BitMap(位图)法的时间复杂度为O(n)，比一般的排序都快，但它是以空间换时间，而且又一些限制，即数据状态不是很多，例如排序前集合大小最好已知，而且集合中元素的最大重复次数必须已知。</p>
<p><strong>3.  Bloom Filter 法（适用于对低错误率可以容忍的场合）</strong><br>    Bloom Filter是一种空间效率和时间效率都很高的随机数据结构，可用来检测一个元素是否属于一个集合。其基本原理是位数组与Hash函数的联合使用。首先，Bloom Filter是一个包含m位的位数组，数组的每一位都初始化为0；其次定义k个不同的hash函数，每个函数都可以将集合中的元素映射到位数组中的某一位，这样k个hash函数就将某个元素映射到了位数组中的k个位。查询的时候，根据k个hash函数可以得到数组中的k个位，判断这个k个位是否全为1，若是则说明该元素可不存在。插入的时候，把k个hash函数就将某个元素映射到了位数组中的k个位全部置为1。<br>    Bloom Filter的难点是如何根据输入元素个数n确定m和hash函数。<br>    <strong>特点：</strong>确定不存在的元素一定不存在，确定存在的数据不一定存在。Bloom Filter只能插入不能删除元素。<br>    <strong>优点：</strong>具有很好的空间效率和时间效率，它的插入和查询时间都是常数，另外它不保存元素本身，具有良好的安全性。<br>    <strong>缺点：</strong>牺牲了正确率，当它判断一个元素已存在于集合中时可能不正确。因为可能该元素对应的k个1位可能是被其他多个元素导致的。</p>
<p><strong>4.  数据库优化法</strong><br>    互联网上的数据一般都是被存储到数据库中，如何从数据库中存储的海量信息中提取对自己有用的信息就涉及到了数据的查询技术等相关内容。<br>    常见的数据库优化方法有数据分区、索引、缓存机制、分批处理、优化查询语句、使用采样数据进行数据挖掘等。</p>
<p><strong>5.  倒排索引法</strong><br>    倒排索引是目前搜索引擎公司对搜索引擎最常用的存储方式，也是搜索引擎的核心内容。按照关键字建立索引，关键字指向了包含它的文档。优点是在处理复杂的多关键字时，可在倒排表中完成查询的并、交等逻辑运算，得到结果后再对结果进行存取，这样把记录的查询转换为地址集合的运算，不必对每个记录随机存取，从而提高查找速度。</p>
<p><strong>6.  外排序法</strong><br>    外排序是相对于内部排序而言的，它是大文件的排序，由于内存限制，不能一下子把所有的待排内容都读到内存中进行排序，需要在内存和外部存储器之间进行多次数据交换才能达到对整个文件进行排序的目的。<br>    一般采用归并排序等方式进行外部排序，首先生成若干个子文件，分别对这些子文件进行排序，然后对这些子文件进行多次归并，使得有序的归并段主键扩大，最后在外存上形成整个文件的单一归并段。<br>    外排序适用于大数据的排序以及去重，但外排序的缺陷是会消耗大量的IO，效率不高。</p>
<p><strong>7.  Trie树</strong><br>    Trie树是一种用于快速字符串检索的多叉树结果 ，原理是利用字符串的公共前缀来减少空间开销。经常被搜索引擎系统用于文件词频统计。优点是：最大限度地减少无谓的字符串比较，查询效率比散列表高。适合用于数据量大，重复多，但是数据种类小可以放入内存的情况。<br>    但是当系统中存在大量字符串且字符串基本没有公共前缀，则相应的Trie树会非常消耗内存。</p>
<p><strong>8.  堆</strong></p>
<table>
<thead>
<tr>
<th>堆类别</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大堆</td>
<td>求前k小</td>
</tr>
<tr>
<td>最小堆</td>
<td>求前k大</td>
</tr>
<tr>
<td>双堆</td>
<td>中位数</td>
</tr>
</tbody>
</table>
<p>​    比如用最小堆求前k个最大的元素：<br>    先从待找的n个数字中找出前k个建成小顶堆，然后依次读后面的元素并与小顶堆的堆顶进行比较，如果当前元素小或相等（这个相等是自己加的，需要进一步验证，应该是正确的，因为此时的堆顶元素是前k个里面最小的。如果遇到相等的即使该元素在最后前k个里面，也可以不要那个元素因为之前的已经够k个了，不需要再进行替换了），则继续读后面的元素；如果当前的元素大，则用当前元素替换堆顶元素，然后调整小顶堆。</p>
<p><strong>9.  双层桶法</strong><br>    双层桶不是一种数据结构 ，而是一种算法思想，类似于分治思想。因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。<br>    桶排序一般适用于寻找第k个大的数，寻找中位数、寻找不重复或重复的数字。<br>    如：1）在一个文件中有10G个整数，乱序排列，要求找出中位数，内存限制是2GB；<br>    2）现在有一个0~30000的随机数生成器。请根据这个随机数生成器，设计一个抽奖范围是0~350000彩票中奖号码列表，其中要包含20000个中奖号码</p>
<p><strong>10.  MapReduce法</strong></p>
<p>​    MapReduce是云计算的核心技术之一，是一种简化并行计算的分布式编程模型，主要目的是为了大型集群的系统能在大数据集上进行并行工作，并用于大规模数据的并行运算。<br>    海量数据处理的最大难题在于数据规模巨大，使得传统处理方式面临计算能力不和存储能力不足的瓶颈问题，而基于Hadoop可以非常轻松和方便完成处理海量数据的分布式并行程序，并运行在大规模集群上。</p>
<h2 id="九、红黑树"><a href="#九、红黑树" class="headerlink" title="九、红黑树"></a>九、红黑树</h2><p><strong>1.  性质</strong><br>    红黑树是一棵二叉搜索树，它在每个结点上增加了一个存储位来表示结点的颜色，是黑色还是红色。<br>    通过任何一条从根到叶子的简单路径上各个结点的颜色进行约束，==红黑树确保没有一条路径会比其他路径长出两倍==，因此也是近似于平衡的。<br>一棵红黑树是确保满足下面红黑性质的<strong>二叉搜索树</strong>。<br>    ① 每个节点要么是红色的要么是黑色的；<br>    ② 根节点是黑色的；<br>    ③ 每个叶节点(NIL)是黑色的；<br>    ④ 若一个结点是红色的，则它的两个孩子结点都是黑色的；<br>    ⑤ 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。</p>
<p><strong>2.  黑高</strong><br>    从某个结点x(不包含该结点)出发到达一个叶结点的任意一条简单路径的黑色结点个数称为该结点的黑高(black-height)，记为bh(x)。<br>    定义红黑树的黑高为其根结点的黑高。<br>    对于给定的黑色高度为n的红黑树，从根到叶结点的简单路径的最短长度为(n-1)，从根到叶结点的简单路径的最大长度为2(n-1).</p>
<p><strong>3.  定理</strong><br>一个有n个内部结点的红黑树的高度至多为2lg(n+1).</p>
<p><strong>4.  操作</strong><br>    默认插入的节点颜色都是红色，因为插入黑色节点会破坏根路径上的黑色节点总数，但即使如此，也会出现连续红色节点的情况。因此在一般的插入操作之后，出现红黑树约束条件不满足的情况（称为失去平衡）时，就必须要根据当前的红黑树的情况做相应的调整其他。</p>
<p><strong>5.  其他</strong><br>    红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求。降低了对旋转的要求，从而提高了性能。<br>    红黑树能够以O(lgn)的时间复杂度进行搜索，插入和删除操作，此外，由于红黑树的设计，任何不平衡都会要求在三次旋转之间解决。<br>    红黑树并不应用所有应用树的领域。如果数据基本上是静态的，那么让数据待在能够插入，并且不影响平衡的地方具有更好的性能。如果数据是完全静态的，例如，做一个hash表，性能可能会更好一点。<br>    在实际的系统中，需要使用动态规划的防火墙系统，使用红黑树而不是散列表，被实践证明具有更好的伸缩性。</p>
<p>参考资料：<a href="http://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">最容易懂得红黑树</a></p>
<p><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md</a></p>
<h2 id="十、数据结构——位图（bitmap）"><a href="#十、数据结构——位图（bitmap）" class="headerlink" title="十、数据结构——位图（bitmap）"></a>十、数据结构——位图（bitmap）</h2><p><strong>定义</strong></p>
<p>​    位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。</p>
<p><strong>先了解一下位运算的基础知识：</strong></p>
<p>​    所有比特的编号方法是：从低字节的低位比特位开始，第一个bit为0，最后一个bit为 n-1。</p>
<p>​    比如，给出一个数组：int[] array = new int[4]。那么：</p>
<p>​        a[0] – a[4] 的比特位分别为：0–31,32–63,64–95,96–127</p>
<p>​    下面我们依据一个程序探究数组比特位的编号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = array[i] &gt;&gt; <span class="number">4</span>;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    结果是输出了4个1，也就是说刚开始比特位编排为：0000 0000 0001 0000，使用位运算，使其右移了4位，变为：0000 0000 0000 0001.</p>
<p><strong>利用位运算&amp; 进行取模</strong></p>
<p>​    位运算跟取模运算之间联系微妙，具体可从下面的例子中看出来：</p>
<p>​    100%32；100&amp;31</p>
<p>​    上述公式的结果是一样的，让我们探究一下他们的原理：</p>
<p>​    100%32 的取余运算，将取到一百减去3个32之后的余数为4。 100&amp;31是进行按位与运算，31=0001 1111；100=0110 0100，当他们进行按位与时，大于等于32的那部分将给消去，留下的便是余数。</p>
<p>​    当然上述运算成立的条件便是做取模运算的后一个数字必须是2的N次幂，也就是32对应位置的数必须是2的N次幂。</p>
<p><strong>特定位的设置与清除</strong></p>
<p>​    假如现在 int a = 0; 现在a的编码全部为0，现在要将其从右往左第5个位置设置为1，然后再清除上述操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    a |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);     <span class="comment">// | 按位或操作 ,双目运算符 a = a|(1&lt;&lt;5);</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">    a &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);    <span class="comment">// &amp; 按位与操作，双目运算符， ~ 按位非操作，单目运算符</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    上述运算的结果分别为32 0.</p>
<p><strong>字节位置与位位置</strong></p>
<pre><code>一个int是4个字节，每个字节有32bit，我们可以将数据存储在这些位内。比如我们要存储100这个数，我们只需在位置100存储一个1。将第100位置为1，也就是说最少需要有100个位置，每个位置1bit，100个位置需要12.5字节，因为一个int型是4字节，所以我们需要定义一个数组 int[4]。
</code></pre><p>​    现在我们要对这个数组的100位进行操作，首先要知道100在这个数组中的第几个元素，每个数组元素都是32位，那么100所在的位置就是100/32，也就是 100&gt;&gt;5。然后在元素中的位置也就是：100%32，也就是100&amp;31，也就是100&amp;0x1F。</p>
<p><strong>给一个例子：</strong></p>
<p>​    给40亿个不重复的unsigned int的整数，没有排过序，然后再给一个数，如果快速判断这个数是否在那40亿个数当中。</p>
<p>​    因为unsigned int数据的最大范围在在40亿左右（需要40亿bit），40<em>10^8/1024</em>1024*8=476，因此只需申请512M的内存空间，每个bit位表示一个unsigned int。读入40亿个数，并设置相应的bit位为1.然后读取要查询的数，查看该bit是否为1，是1则存在，否则不存在。</p>
<p><strong>优缺点</strong></p>
<p>(1) 可读性差</p>
<p>(2) 位图存储的元素个数虽然比一般做法多，但是存储的元素大小受限于存储空间的大小。位图存储性质：存储的元素个数等于元素的最大值。比如， 1K 字节内存，能存储 8K 个值大小上限为 8K 的元素。（元素值上限为 8K ，这个局限性很大！）比如，要存储值为 65535 的数，就必须要 65535/8=8K 字节的内存。要就导致了位图法根本不适合存 unsigned int 类型的数（大约需要 2^32/8=5 亿字节的内存）。</p>
<p>(3 )位图对有符号类型数据的存储，需要 2 位来表示一个有符号元素。这会让位图能存储的元素个数，元素值大小上限减半。 比如 8K 字节内存空间存储 short 类型数据只能存 8K*4=32K 个，元素值大小范围为 -32K~32K 。</p>
<p><strong>总结</strong></p>
<p>​    Bitmap是一种非常简洁快速的数据结构，他能同使证存储空间和速度最优化（而不必空间换时间）。</p>
<p>参考资料：<a href="http://blog.csdn.net/lx18792732127/article/details/70545028" target="_blank" rel="noopener">【数据结构】中的位图详解</a></p>
<p>​            <a href="http://www.cnblogs.com/tf-Y/p/5284560.html" target="_blank" rel="noopener">数据结构–位图</a></p>
<p>​                    <a href="http://blog.163.com/xb_stone_yinyang/blog/static/2118160372013625112558579/" target="_blank" rel="noopener">编程珠玑——位图数据结构</a></p>
<h2 id="十二、二叉排序-查找树"><a href="#十二、二叉排序-查找树" class="headerlink" title="十二、二叉排序/查找树"></a>十二、二叉排序/查找树</h2><p><strong>定义</strong>:</p>
<p>​    二叉排序树（Binary Sort Tree）又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树：<br>    若它的左子树不为空，则左子树上所有结点的值均小于它的根结构的值；<br>    若它的右子树不为空，则右子树上所有结点的值均大于它的根结构的值；<br>    它的左、右子树也分别为二叉排序树（递归）。</p>
<p>​    zhg 口诀： 左小右大</p>
<p>​    说的直白一点，就是具有左子树上的值&lt;根节点的值&lt;右子树上的值的二叉树，我们称之为二叉排序树。</p>
<p>​    基于二叉排序树的特点，又结合着中序遍历的特点（中序遍历是先遍历左子树，再遍历根节点，然后遍历右子树），我们不难发现，<strong>二叉排序树的中序遍历的结果是从小到大有序的</strong>。下方我们会先给出二叉排序树的创建，然后给出二叉排序树的节点删除的代码。</p>
<h3 id="1-二叉排序树的创建"><a href="#1-二叉排序树的创建" class="headerlink" title="1. 二叉排序树的创建"></a>1. 二叉排序树的创建</h3><p>​    上面也简单的提了一下，二叉排序树的创建无非就是不断查找和插入的过程，当我们查找某个值没有找到时，我们就会将该值插入到二叉排序树中。因为再查找的过程中可以确定该结点要插入的合适位置，所以插入就显得比较简单了。</p>
<p><strong>(1) 二叉排序树的查找与插入的示意图</strong></p>
<p>​    我们要将集合{62, 88, 58, 47, 35, 73, 51, 99, 37, 93}中的元素放入到我们的二叉排序树中去存储，如果对我们创建好的二叉排序树进行中序搜索的话，输出的结果就是上面集合的有序序列。下方就是我们二叉排序树从无到有的完整创建过程。</p>
<p>​    （1）、在初始化状态下我们二叉排序树的根节点为空，我们依次将集合中的元素通过搜索插入到二叉排序树中合适的位置。</p>
<p>​    （2）、首先在二叉排序中进行搜索62的位置，树为空，所以将62存入到二叉排序树的根节点中，及root=(62)。</p>
<p>​    （3）、从集合中取出88，然后查找我们的二叉排序树，发现88大于我们的根节点62，所以将88插入到62节点的右子树中，即(62)-&gt;rightChild=(88)。</p>
<p>​    （4）、从集合中取出58，然后从根节点开始查找我们现有的二叉排序树，发现55\&lt;62，将55作为62的左结点，即(62)-&gt;leftChild=(55)。</p>
<p>​    （5）、从集合中取出47，然后对二叉排序树进行搜索，发现47\&lt;55, 所以(55)-&gt;leftChild=(47)。</p>
<p>​    （6）、从集合中取出35，再次对二叉排序树进行搜索，发现35又小于47，所以(47)-&gt;leftChild=(35)</p>
<p>​    （7）、从集合中取出73，再次对二叉排序树进行搜索，发现62\&lt;73\&lt;88, 所以有(88)-&gt;leftChild=(73)。</p>
<p>​    以此类推，要做的事情就是不断从集合中取值，然后对二叉排序树进行查找，找到合适的插入点，然后将相应的节点进行插入，具体步骤就不做过多赘述了。</p>
<p><img src="\image\数据结构\二叉排序树的创建过程.png" alt="叉排序树的创建过"></p>
<p><img src="\image\数据结构\二叉排序树的创建过程-2.png" alt="叉排序树的创建过程-"></p>
<p><strong>(2) 二叉排序树的查找</strong></p>
<p>​    查找过程中要保存当前节点的父节点，如果查找失败，即在二叉排序树中没有查找到给定的元素，那么就要返回插入的位置。要注意父节点为空的情况，那表明现在二叉排序树为空树。插入的时候在和父节点的数据比较一下大小，给定元素小，那么就插入到左孩子，否则就插入到右孩子。<img src="\image\数据结构\二叉排序树-查找.png" alt="叉排序树-查"></p>
<p><strong>(3) 二叉排序树的插入</strong></p>
<p>​    插入操作比较简单，只要通过查找操作找到元素的插入位置，那么就可以根据插入位置进行插入操作了。</p>
<p><img src="\image\数据结构\二叉排序树-插入.png" alt="叉排序树-插"></p>
<p><img src="\image\数据结构\二叉排序树-插入-2.png" alt="叉排序树-插入-"></p>
<h3 id="2-二叉排序树结点的删除"><a href="#2-二叉排序树结点的删除" class="headerlink" title="2. 二叉排序树结点的删除"></a>2. 二叉排序树结点的删除</h3><p>​    二叉排序树的结点删除要比二叉排序树结点的插入要复杂一些，不过也并不难，要分为几种情况进行讨论。二叉排序树结点的插入与删除都是在查找的基础上来做的。</p>
<p>​    下面分为3种情况进行讨论：</p>
<p>​    (1) 若*p结点为叶子节点，即$P_L$和$P_R$均为空树。由于删除叶子节点不会破坏整棵树的结构，则只需要修改其双亲节点的指针即可。</p>
<p>​    (2) 若<em>P结点只有左子树$P_L$或者只有右子树$P_R$，此时只要令$P_L$或$P_R$直接成为双亲节点\</em>f的左子树即可。显然，做此修改也不破坏二叉排序树的特性。</p>
<p>​    (3) 若<em>p结点的左子树和右子树均不为空。显然此时不能像上面一样简单处理。因为二叉排序树的中序遍历是从小到大有序的，所以我们只需要让\</em>P的前驱或者后继来替代*P就可以了。</p>
<p><img src="\image\数据结构\二叉排序树删除节点-示意图.png" alt="叉排序树删除节点-示意"></p>
<p><img src="\image\数据结构\二叉树排序树-删除节点-算法1.png" alt="叉树排序树-删除节点-算法"></p>
<p><img src="\image\数据结构\二叉树排序树-删除节点-算法2.png" alt="叉树排序树-删除节点-算法"></p>
<p><img src="\image\数据结构\二叉树排序树-删除节点-算法2-1.png" alt="叉树排序树-删除节点-算法2-"></p>
<p>​    在随机的情况下，二叉排序树的平均查找长度和$\log_2 n$是等数量级的。然而，在某些情况下（有人研究证明，这种情况出现的概率约为46.5%），尚需要在构成二叉排序树的过程中进行“平衡化”处理，成为二叉平衡树。</p>
<p>​    参考资料：<a href="http://blog.fishc.com/3077.html" target="_blank" rel="noopener">二叉排序树（二叉查找树）- 数据结构和算法73</a></p>
<p>​                <a href="http://www.cnblogs.com/ludashi/p/6004024.html" target="_blank" rel="noopener">算法与数据结构(十) 二叉排序树的查找、插入与删除(Swift版)</a></p>
<h2 id="十三、平衡二叉树-AVL"><a href="#十三、平衡二叉树-AVL" class="headerlink" title="十三、平衡二叉树(AVL)"></a>十三、平衡二叉树(AVL)</h2><p>​    在平衡树上进行查找的时间复杂度为$O(\log n)$。  </p>
<p>​    <strong>平衡二叉树</strong>（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。若将二叉树上节点的平衡因子BF（Balance Factor）定义为该结点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。如图9.11(a)所示为两颗平衡二叉树，而图9.11（b）所示为两颗不平衡的二叉树，结点中的值为该结点的平衡因子。</p>
<p><img src="\image\数据结构\平衡与不平衡的二叉树.png" alt="衡与不平衡的二叉"></p>
<p>​    对于序列（13，24, 37，90，53 ）插入过程如下图所示：</p>
<p><img src="\image\数据结构\平衡树的生成过程.png" alt="衡树的生成过"></p>
<p>​                        </p>
<p>​    一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指 针为a(即a是离插入结点最近，且平衡因子绝对值超过1的祖先结点），则失去平衡后进 行调整的规律可归纳为下列4种情况：</p>
<p>​    (1)    单向右旋平衡处理：由于在<em> a的左子树根结点的左子树上插入结点，</em> a的平 衡因子由1增至2，致使以* a为根的子树失去平衡，则需进行一次向右的顺时针旋转操 作，如图9. 13(a)所示。</p>
<p>​    (2)    单向左旋平衡处理：由于在<em> a的右子树根结点的右子树上插入结点，</em> a的平 衡因子由-1变为-2,致使以*a为根结点的子树失去平衡，则需进行一次向左的逆时针旋转操作。如图9. 13(c)所示。</p>
<p>​    (3)    双向旋转（先左后右）平衡处理：由于在<em> a的左子树根结点的右子树上插入结点，</em> a的平衡因子由1增至2，致使以*a为根结点的子树失去平衡，则需进行两次旋转(先左旋后右旋)操作。如图9. 13(b)所示。</p>
<p>​    (4)    双向旋转（先右后左）平衡处理：由于在<em> a的右子树根结点的左子树上插人结点，</em> a的平衡因子由-1变为-2，致使以* a为根结点的子树失去平衡，则需进行两次 旋转（先右旋后左旋)操作。如图9. 13(d)所示。</p>
<p><img src="\image\数据结构\二叉排序树的平衡旋转图例.png" alt="叉排序树的平衡旋转图">    </p>
<p>​                图9.13  二叉排序树的平衡旋转图例</p>
<p>​            (a) LL型；     (b) LR型；     (c) RR型 ；    (d) RL型；    </p>
<p>​    上述4种情况中，（1）和（2）对称，（3)和（4）对称。旋转操作的正确性容易由“保持二叉排序树的特性：中序遍历所得关键字序列自小至大有序”证明之。同时，从图9. 13可 见，无论哪一种情况，在经过平衡旋转处理之后，以*b或*C为根的新子树为平衡二叉 树，而且它的深度和插人之前以* a为根的子树相同。因此，当平衡的二叉排序树因插人结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。因为经过旋转处理之后的子树深度和插入之前相同，因而不影响插人路径上所有祖先结点的平衡度。     </p>
<p>参考资料：<u>数据结构-C语言版（P233  平衡二叉树）</u>  </p>
<h2 id="十四、并查集-Disjoint-Set-Union-DSU-data-structure"><a href="#十四、并查集-Disjoint-Set-Union-DSU-data-structure" class="headerlink" title="十四、并查集 (Disjoint Set Union (DSU) data structure)"></a>十四、并查集 (Disjoint Set Union (DSU) data structure)</h2><p> <strong>Disjoint Set Union (DSU) data structure    </strong></p>
<p>​    这个是摘自LeetCode上684题的题解，对于并查集描述的很清晰。</p>
<p>A DSU data structure can be used to maintain knowledge of the connected components of a graph, and query for them quickly.  In particular, we would like to support two operations:</p>
<ul>
<li><code>dsu.find(node x)</code>, which outputs a unique id so that two nodes have the same id if and only if they are in the same connected component, and:</li>
<li><code>dsu.union(node x, node y)</code>, which draws an edge <code>(x, y)</code> in the graph, connecting the components with id <code>find(x)</code> and <code>find(y)</code> together.</li>
</ul>
<p>To achieve this, we keep track of <code>parent</code>, which remembers the <code>id</code> of a smaller node in the same connected component.  If the node is it’s own parent, we call this the <em>leader</em> of that connected component.</p>
<p>A naive implementation of a DSU structure would look something like this:</p>
<p><em>Psuedocode</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent initialized as (x -&gt; x)</span></span><br><span class="line">function find(x):</span><br><span class="line">    <span class="keyword">while</span> parent[x] != x: <span class="comment">#While x isn't the leader</span></span><br><span class="line">        x = parent[x]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">function union(x, y):</span><br><span class="line">    parent[find(x)] = find(y)</span><br></pre></td></tr></table></figure></p>
<p>We use two techniques to improve the run-time complexity: <em>path compression</em>, and <em>union-by-rank</em>.</p>
<ul>
<li>Path compression involves changing the <code>x = parent[x]</code> in the <code>find</code> function to <code>parent[x] = find(parent[x])</code>.  Basically, as we compute the correct leader for x, we should remember our calculation.</li>
<li>Union-by-rank involves distributing the workload of <code>find</code> across leaders evenly.  Whenever we <code>dsu.union(x, y)</code>, we have two leaders <code>xr, yr</code> and we have to choose whether we want <code>parent[x] = yr</code> or <code>parent[y] = xr</code>.  We choose the leader that has a higher following to pick up a new follower.<br>Specifically, the meaning of <code>rank</code> is that there are less than <code>2 ^ rank[x]</code> followers of <code>x</code>.  This strategy can be shown to give us better bounds for how long the recursive loop in <code>dsu.find</code> could run for.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = range(<span class="number">1001</span>)</span><br><span class="line">        self.rnk = [<span class="number">0</span>] * <span class="number">1001</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        xr, yr = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> xr == yr:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> self.rnk[xr] &lt; self.rnk[yr]:</span><br><span class="line">            self.par[xr] = yr</span><br><span class="line">        <span class="keyword">elif</span> self.rnk[xr] &gt; self.rnk[yr]:</span><br><span class="line">            self.par[yr] = xr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.par[yr] = xr</span><br><span class="line">            self.rnk[xr] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>   <span class="comment">#求解的题目是leetCode的684题</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span><span class="params">(self, edges)</span>:</span></span><br><span class="line">        dsu = DSU()</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dsu.union(*edge):</span><br><span class="line">                <span class="keyword">return</span> edge</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>Alternate Implementation of DSU without Union-By-Rank</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = range(<span class="number">1001</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.par[x] != x:</span><br><span class="line">            self.par[x] = self.find(self.par[x])</span><br><span class="line">        <span class="keyword">return</span> self.par[x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.par[self.find(x)] = self.find(y)</span><br></pre></td></tr></table></figure></p>
<p>Java语言实现的求解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MAX_EDGE_VAL = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        DSU dsu = <span class="keyword">new</span> DSU(MAX_EDGE_VAL + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dsu.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DSU</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) parent[i] = i;</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xr = find(x), yr = find(y);</span><br><span class="line">        <span class="keyword">if</span> (xr == yr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[xr] &lt; rank[yr]) &#123;</span><br><span class="line">            parent[xr] = yr;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[xr] &gt; rank[yr]) &#123;</span><br><span class="line">            parent[yr] = xr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[yr] = xr;</span><br><span class="line">            rank[xr]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time Complexity:  $O(Nα(N))≈O(N)$, where $N$ is the number of vertices (and also the number of edges) in the graph, and α\alphaα is the <em>Inverse-Ackermann</em> function.  We make up to $N$ queries of <code>dsu.union</code>, which takes (amortized) $O(\alpha(N))$ time.  Outside the scope of this article, it can be shown why <code>dsu.union</code> has $O(\alpha(N))$ complexity, what the Inverse-Ackermann function is, and why $O(\alpha(N))$ is approximately $O(1)$.</li>
<li>Space Complexity:  $O(N)$.  The current construction of the graph (embedded in our <code>dsu</code> structure) has at most $N$ nodes.</li>
</ul>
<p><strong>一个生动的例子讲解</strong></p>
<p>例子就是杭电上的畅通工程：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1232</a></p>
<p>​    首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。</p>
<p>​    如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……</p>
<p>​    以下面这组数据输入数据来说明</p>
<p>​    4 2 1 3 4 3</p>
<p>​    第一行告诉你，一共有4个点，2条路。下面两行告诉你，1、3之间有条路，4、3之间有条路。那么整幅图就被分成了1-3-4和2两部分。只要再加一条路，把2和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。 这可如何是好？</p>
<p>​    我以前也不会呀，自从用了并查集之后，嗨，效果还真好！我们全家都用它！</p>
<p>​    并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1010</span>]; <span class="comment">//存放第i个元素的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span> <span class="comment">//查找根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> son, tmp;</span><br><span class="line">	son = root;</span><br><span class="line">	<span class="keyword">while</span>(root != pre[root]) <span class="comment">//寻找根结点</span></span><br><span class="line">		root = pre[root];</span><br><span class="line">	<span class="keyword">while</span>(son != root) <span class="comment">//路径压缩</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp = pre[son];</span><br><span class="line">		pre[son] = root;</span><br><span class="line">		son = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1, <span class="keyword">int</span> root2)</span> <span class="comment">//判断是否连通，不连通就合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	x = unionsearch(root1);</span><br><span class="line">	y = unionsearch(root2);</span><br><span class="line">	<span class="keyword">if</span>(x != y) <span class="comment">//如果不连通，就把它们所在的连通分支合并</span></span><br><span class="line">		pre[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    为了解释并查集的原理，我将举一个更有爱的例子。</p>
<pre><code>话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？
</code></pre><p>​    我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p>
<p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/crazy.gif" alt="抓狂">要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p>
<p><img src="\image\数据结构\并查集-武林帮派举例.gif" alt="查集-武林帮派举"></p>
<p>​    下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 </p>
<p>​    find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span> <span class="comment">//查找根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> son, tmp;</span><br><span class="line">	son = root;</span><br><span class="line">	<span class="keyword">while</span>(root != pre[root]) <span class="comment">//我的上级不是掌门</span></span><br><span class="line">		root = pre[root];</span><br><span class="line">	<span class="keyword">while</span>(son != root) <span class="comment">//我就找他的上级，直到掌门出现</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp = pre[son];</span><br><span class="line">		pre[son] = root;</span><br><span class="line">		son = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root; <span class="comment">//掌门驾到~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/laugh.gif" alt="大笑">反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> root1, <span class="keyword">int</span> root2)</span> <span class="comment">//虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	x = unionsearch(root1);<span class="comment">//我老大是玄慈</span></span><br><span class="line">	y = unionsearch(root2);<span class="comment">//我老大是灭绝</span></span><br><span class="line">	<span class="keyword">if</span>(x != y) </span><br><span class="line">		pre[x] = y; <span class="comment">//打一仗，谁赢就当对方老大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>​    再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。</p>
<pre><code>设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低，以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。
</code></pre><p><img src="\image\数据结构\并查集-路径压缩示意.gif" alt="查集-路径压缩示"></p>
<p>​    于是，问题圆满解决。。。。。。。。。</p>
<p>​    代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">1010</span>]; <span class="comment">//里面全是掌门</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unionsearch</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> son, tmp;</span><br><span class="line">	son = root;</span><br><span class="line">	<span class="keyword">while</span>(root != pre[root]) <span class="comment">//寻找掌门ing……</span></span><br><span class="line">		root = pre[root];</span><br><span class="line">	<span class="keyword">while</span>(son != root) <span class="comment">//路径压缩</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp = pre[son];</span><br><span class="line">		pre[son] = root;</span><br><span class="line">		son = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root; <span class="comment">//掌门驾到~</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num, road, total, i, start, end, root1, root2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;num, &amp;road) &amp;&amp; num)</span><br><span class="line">	&#123;</span><br><span class="line">		total = num - <span class="number">1</span>; <span class="comment">//共num-1个门派</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= num; ++i) <span class="comment">//每条路都是掌门</span></span><br><span class="line">			pre[i] = i;</span><br><span class="line">		<span class="keyword">while</span>(road--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;start, &amp;end); <span class="comment">//他俩要结拜</span></span><br><span class="line">			root1 = unionsearch(start);</span><br><span class="line">			root2 = unionsearch(end);</span><br><span class="line">			<span class="keyword">if</span>(root1 != root2) <span class="comment">//掌门不同？踢馆！~</span></span><br><span class="line">			&#123;</span><br><span class="line">				pre[root1] = root2;</span><br><span class="line">				total--; <span class="comment">//门派少一个，敌人（要建的路）就少一个</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, total);<span class="comment">//天下局势：还剩几个门派</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考资料：<a href="http://blog.csdn.net/niushuai666/article/details/6662911" target="_blank" rel="noopener">超有爱的并查集~</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/容器/" rel="tag"># 容器</a>
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/16/2_Bash Shell学习/" rel="next" title="Bash Shell学习">
                <i class="fa fa-chevron-left"></i> Bash Shell学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/23/1_Java多线程/" rel="prev" title="java多线程">
                java多线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/zhg_avatar.jpg"
                alt="zhongzhengang" />
            
              <p class="site-author-name" itemprop="name">zhongzhengang</p>
              <p class="site-description motion-element" itemprop="description">一点一滴的积累</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhongzhengang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/mucaoyx" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/mu-cao-18-76/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-常见数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">0. 常见数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、数组"><span class="nav-number">1.2.</span> <span class="nav-text">一、数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、线性表"><span class="nav-number">1.3.</span> <span class="nav-text">二、线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-线性表的顺序表示和实现"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 线性表的顺序表示和实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线性表的链式表示和实现"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 线性表的链式表示和实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、栈和队列"><span class="nav-number">1.4.</span> <span class="nav-text">三、栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-栈"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-队列"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-双端队列"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 双端队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-链队列"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. 链队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-循环队列"><span class="nav-number">1.4.5.</span> <span class="nav-text">5. 循环队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、串"><span class="nav-number">1.5.</span> <span class="nav-text">四、串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、树和二叉树"><span class="nav-number">1.6.</span> <span class="nav-text">四、树和二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、哈希表"><span class="nav-number">1.7.</span> <span class="nav-text">六、哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-定义"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.  定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-哈希函数的构造函数。"><span class="nav-number">1.7.2.</span> <span class="nav-text">2.  哈希函数的构造函数。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-处理冲突的方法"><span class="nav-number">1.7.3.</span> <span class="nav-text">3.  处理冲突的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-哈希表的查找及分析"><span class="nav-number">1.7.4.</span> <span class="nav-text">4.  哈希表的查找及分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-哈希表的适用"><span class="nav-number">1.7.5.</span> <span class="nav-text">5.  哈希表的适用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、图"><span class="nav-number">1.8.</span> <span class="nav-text">七、图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-图的深度遍历DFS"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.  图的深度遍历DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-图的广度优先遍历BFS"><span class="nav-number">1.8.2.</span> <span class="nav-text">2.  图的广度优先遍历BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、海量数据处理"><span class="nav-number">1.9.</span> <span class="nav-text">八、海量数据处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、红黑树"><span class="nav-number">1.10.</span> <span class="nav-text">九、红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、数据结构——位图（bitmap）"><span class="nav-number">1.11.</span> <span class="nav-text">十、数据结构——位图（bitmap）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二、二叉排序-查找树"><span class="nav-number">1.12.</span> <span class="nav-text">十二、二叉排序/查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-二叉排序树的创建"><span class="nav-number">1.12.1.</span> <span class="nav-text">1. 二叉排序树的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-二叉排序树结点的删除"><span class="nav-number">1.12.2.</span> <span class="nav-text">2. 二叉排序树结点的删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三、平衡二叉树-AVL"><span class="nav-number">1.13.</span> <span class="nav-text">十三、平衡二叉树(AVL)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十四、并查集-Disjoint-Set-Union-DSU-data-structure"><span class="nav-number">1.14.</span> <span class="nav-text">十四、并查集 (Disjoint Set Union (DSU) data structure)</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhongzhengang</span>

  
</div>










        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
